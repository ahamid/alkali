{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///index.js","webpack:///webpack/bootstrap 076066ee1778f30dc35b","webpack:///./index.js","webpack:///./Element.js","webpack:///./Variable.js","webpack:///./util/lang.js","webpack:///./Renderer.js","webpack:///./react.js","webpack:///./operators.js","webpack:///./Copy.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","Element","Variable","react","Renderer","operators","Copy","main","Object","create","VMap","VArray","VPromised","all","assign","target","nodeType","HTMLElement","apply","arguments","spawn","func","valueOf","undefined","lang","isGenerator","constructor","displayName","name","Context","subject","booleanStyle","options","element","value","key","style","defaultStyle","directStyle","layoutChildren","parent","children","container","prepend","fragment","length","doc","createDocumentFragment","i","l","childNode","child","currentParent","appendChild","isContentNode","contentNode","Array","notifies","variableAsContent","Error","createTextNode","insertBefore","firstChild","content","text","error","stack","textNode","enterRenderer","TextRenderer","variable","bidirectionalHandler","InputPropertyRenderer","inputs","tagName","bindChanges","prototype","renderSelectValueUpdate","renderUpdate","noop","applyAttribute","AttributeRenderer","setAttribute","applySubProperties","renderer","SubPropertyRenderer","compose","PropertyRenderer","subKey","subValue","assignProperties","properties","styleDefinition","styleDefinitions","propertyHandlers","StyleRenderer","slice","addEventListener","buildContent","each","ItemClass","itemAs","Item","hasOwn","itemVariable","_item","collection","ListRenderer","forEach","item","childElement","buildInputContent","conversion","nextTurn","inputEvents","event","result","put","deny","type","parseFloat","inputType","inputProperty","date","datetime","time","applyToClass","applyOnCreate","_applyOnCreate","classHandlers","TypeError","getApplySet","Class","hasOwnProperty","getForClass","parentApplySet","getPrototypeOf","keys","getOwnPropertyNames","defineProperty","toLowerCase","renderDescriptor","renderMethod","map","WeakMap","get","has","set","makeElementConstructor","selector","withProperties","forTarget","property","propertyForElement","superConstructor","selectorMatch","match","SELECTOR_REGEX","operator","className","remaining","createElement","presumptiveParentMap","setPrototypeOf","ElementApplyOnCreate","argument","created","ready","append","registerTag","registerElement","getConstructor","tags","setTag","generate","elements","elementName","ElementClass","generateInputs","HTMLInputElement","From","Target","createInstance","ownedClasses","parentNode","ownedInstances","instance","ThisElementVariable","_Variable","updaters","_properties","updater","push","cleanup","stop","needsRestart","restart","elementAttached","attached","elementDetached","detached","firstVisit","node","state","__alkaliAttached__","action","docBody","contains","knownElementProperties","newValue","definition","ClassNameRenderer","ElementRenderer","currentClassName","changingClassName","removed","replace","document","tag","INPUT","TEXTAREA","display","visibility","color","opacity","zoom","minZoom","maxZoom","fontWeight","position","textDecoration","base","proto","__proto__","classes","flag","class","for","role","render","GeneratorVariable","bind","valueAsNumber","valueAsDate","checked","dataset","attributes","elment","styleObjectHandler","radios","querySelectorAll","radio","dispatchEvent","Event","within","aliases","Anchor","Paragraph","Textarea","DList","UList","OList","ListItem","Text","TextInput","TableRow","TableCell","TableHeaderCell","TableHeader","TableBody","alias","to","refresh","moveLiveElementsEnabled","extend","ExtendedElement","descriptor","getOwnPropertyDescriptor","MutationObserver","body","lifeStates","nodes","observer","mutations","il","mutation","j","jl","nodeIteration","k","kl","baseNode","currentNode","nextNode","nextSibling","observe","childList","subtree","mergeSubject","context","nextContext","getMaterializedContextualInstance","distinctSubject","contextMap","defaultContext","when","callback","then","whenAll","promiseInvolved","registerListener","listener","listeners","propertyListenersMap","listenerId","autoObserveObjects","listeningToObject","deregisterListener","index","splice","RefreshEvent","visited","Set","PropertyChangeEvent","childEvent","AddEvent","args","DeleteEvent","arrayToModify","_willModify","cachedValue","array","updateVersion","results","cachedVersion","version","insertedAt","added","startingIndex","arrayLength","addedCount","arrayPosition","updated","modifier","removedAt","removalCount","previousIndex","oldValue","iterateMethod","method","IterativeMethod","addFlag","functionValue","objectUpdated","object","_propertyChange","Composite","keyMapping","valueArray","resultObject","createForInstance","generalizeClass","prototypeNames","getGeneralizedDescriptor","generalizeMethod","instanceForContext","defaultInstance","noChange","RequestChange","RequestSet","nextId","freeze","propertyName","contextFromCache","VariablePrototype","gotValue","getValue","previousNotifyingValue","notifyingValue","ownObject","dependents","stopNotifies","isMap","Map","propertyVariable","Property","instanceMap","ContextualizedVariable","distinctFor","contextualizedVariable","onPropertyChange","eachKey","Call","forDependencies","init","dependency","handles","remove","computedVariable","getVersion","Math","max","getSubject","selectVariable","getUpdates","since","updates","nextUpdateMap","updateEvent","by","add","contextualInstance","lastUpdate","dependent","e","console","fixed","invalidate","unsubscribe","subscribe","updateQueued","next","handle","initialValue","setValue","_changeValue","undefine","proxy","proxiedVariable","thisVariable","complete","onValue","callbackOrItemClass","callbackOrContext","collectionVariable","transformFunction","reverse","forward","schema","validate","valid","isValid","validation","Validating","getId","observeObject","observerCount","events","el","addKey","done","deliverChanges","unshift","pop","shift","Symbol","iterator","Caching","withComputedValue","computedValue","watchedContext","newVersion","gotValueAndListen","parentUpdated","parentSchemaProperties","arg","resolved","functionVariable","invoke","argsVersion","execute","originalValue","observeArguments","handlesVariables","handlesPromises","input","setReverse","Source","source","propagatedEvent","filterUpdated","indexOf","matches","filter","mapUpdated","generator","resuming","lastValue","generatorIterator","isThrowing","stepReturn","nextVariable","description","generalize","Function","ExtendedVariable","Base","_defaultInstance","sourceVariable","sourceProperties","targetVariable","feature","hasFeatures","diff","previous","current","queued","toJSONHidden","queuedListeners","requestAnimationFrame","promise","Promise","keyFlag","currentValue","targetAncestor","previousSet","previousGet","enumerable","timerStarted","setInterval","watchedObjects","watchedCopies","copy","unobserve","Hidden","toJSON","processAnimationFrame","toRender","setTimeout","resolve","reject","resolution","finished","errorResolution","isResolved","queue","errback","newError","values","mapProperty","intermediary","errorHandler","onResolve","onError","onEach","readyInputs","lastPromiseResult","previousPromiseResult","div","alkaliRenderers","update","updateRendering","shouldRender","alwaysUpdate","updateOnStart","ContentRenderer","onElementRemoval","renderers","invalidatedElements","invalidated","contextMatches","invalidateElement","invalidatedParts","queueTask","processQueue","updateElement","always","renderersOnShow","addElement","omitValueOf","started","renderLoading","isNaN","eventualValue","innerHTML","replaceChild","childNodes","nodeValue","eachItem","nextChild","thisElement","childElements","builtList","removeChild","onShowElement","shownElement","getElementsByClassName","includingTop","onlyChildren","getElementsByTagName","from","prop","directPropertyValue","cond","test","consequent","alternate","choose","fcall","mcall","getOperatingFunction","expression","operatingFunctions","precedence","reverseA","reverseB","addFlags","operatorHandler","infix","output","a","b","deepCopy","derivativeMap","copiedFrom","isDirty","derivative","thisValue","getCopyOf","save","original","newCopiedFrom","onSave","revert"],"mappings":"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A,QACA,WACA,WACA,QACA,QACA,QACA,KACA,QACA,MACA,WACA,KACA,KACA,UACA,QACA,OACA,SACA,SACA,SACA,QACA,WACA,MACA,UACA,QACA,IACA,SACA,SACA,WACA,SACA,KACA,MACA,MACA,QACA,OACA,OACA,MACA,OACA,SACA,QACA,KACA,SACA,QACA,QACA,SACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,WACA,QACA,OACA,OACA,QACA,UACA,QACA,SACA,SACA,aACA,SACA,OACA,OACA,WACA,MACA,UACA,UACA,MACA,MACA,SACA,UACA,WACA,KACA,SACA,SACA,OACA,KACA,OACA,MAEAI,GACA,WACA,WACA,SACA,QACA,QACA,OACA,WACA,QACA,QACA,SACA,QACA,SACA,MACA,OACA,MACA,QAEA,IAAAN,OA0CAmF,IACAC,OAAA,IACAC,UAAA,IACAC,SAAA,WACAC,MAAA,KACAC,MAAA,KACAC,MAAA,KACAC,SAAA,KACAC,KAAA,QACAC,UAAA,QACAC,SAAA,KACAC,UAAA,KACAC,gBAAA,KACAC,YAAA,QACAC,UAAA,QAEA,QAAAC,MAAAf,KACA,SAAAe,EAAAC,GACAvQ,OAAAmI,eAAA1I,GAAA6Q,GACA7H,IAAA,WACA,MAAA7J,MAAA2R,OAGGD,GAAAf,GAAAe,IAGH7Q,IAAAuK,SACAvK,GAAA0C,UACA1C,GAAA+Q,QAAA5Q,EAAA4Q,OACA/Q,IAAA+B,SACAiP,yBAAA,EAEAhR,IAAA8D,QAAA,SAAA9B,GAEA,OACAqB,eAAA,EACA7C,OAAAwB,EAAAxB,OAAAwO,KAAAhN,KAIAhC,GAAAiR,OAAA,SAAA9I,EAAAzC,GACA,QAAAwL,KACA,MAAA/I,GAAAlH,MAAA9B,KAAA+B,WAEAgJ,GAAAgH,EAAA/I,EACA,IAAAxD,GAAAuM,EAAAvM,UAAApE,OAAAC,OAAA2H,EAAAxD,UAUA,OATAA,GAAAlD,YAAAyP,EACA3Q,OAAAkI,oBAAA/C,GAAAiB,QAAA,SAAAzE,GACA,GAAAiP,GAAA5Q,OAAA6Q,yBAAA1L,EAAAxD,EACA8F,IAAA9F,GAC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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"alkali\"] = factory();\n\telse\n\t\troot[\"alkali\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"alkali\"] = factory();\n\telse\n\t\troot[\"alkali\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/// <reference path=\"./typing.d.ts\" />\r\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1), __webpack_require__(2), __webpack_require__(5), __webpack_require__(4), __webpack_require__(6), __webpack_require__(7)], __WEBPACK_AMD_DEFINE_RESULT__ = function(Element, Variable, react, Renderer, operators, Copy) {\r\n\t\tvar main = Object.create(Element)\r\n\t\tmain.Copy = Copy\r\n\t\tmain.Element = Element\r\n\t\tmain.Variable = Variable\r\n\t\tmain.VMap = Variable.VMap\r\n\t\tmain.VArray = Variable.VArray\r\n\t\tmain.VPromised = Variable.VPromised\r\n\t\tmain.all = Variable.all\r\n\t\tmain.assign = function(target) {\r\n\t\t\t// generic assign that decides based on target\r\n\t\t\tif (target.nodeType && target instanceof HTMLElement) {\r\n\t\t\t\treturn Element.assign.apply(this, arguments)\r\n\t\t\t} else {\r\n\t\t\t\treturn Variable.assign.apply(this, arguments)\r\n\t\t\t}\r\n\t\t}\r\n\t\tmain.react = react\r\n\t\tmain.spawn = function(func) {\r\n\t\t\treturn react(func).valueOf()\r\n\t\t}\r\n\t\tmain.Renderer = Renderer\r\n\t\tObject.assign(main, Renderer)\r\n\t\tObject.assign(main, operators)\r\n\t\treturn main\r\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(4), __webpack_require__(3)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Variable, Renderer, lang) {\r\n\t\tvar knownElementProperties = {};\r\n\t\t['textContent', 'innerHTML', 'title', 'href', 'value', 'valueAsNumber', 'role', 'render'].forEach(function(property) {\r\n\t\t\tknownElementProperties[property] = true\r\n\t\t})\r\n\t\r\n\t\tvar SELECTOR_REGEX = /(\\.|#)([-\\w]+)(.+)?/\r\n\t\tfunction isGenerator(func) {\r\n\t\t\tif (typeof func === 'function') {\r\n\t\t\t\tvar constructor = func.constructor\r\n\t\t\t\treturn (constructor.displayName || constructor.name) === 'GeneratorFunction'\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction Context(subject){\r\n\t\t\tthis.subject = subject\r\n\t\t}\r\n\t\r\n\t\tvar PropertyRenderer = Renderer.PropertyRenderer\r\n\t\tvar InputPropertyRenderer = Renderer.InputPropertyRenderer\r\n\t\tvar AttributeRenderer = Renderer.AttributeRenderer\r\n\t\tvar StyleRenderer = lang.compose(Renderer.StyleRenderer, function StyleRenderer() {\r\n\t\t\tRenderer.StyleRenderer.apply(this, arguments)\r\n\t\t}, {\r\n\t\t\trenderUpdate: function(newValue, element) {\r\n\t\t\t\tvar definition = styleDefinitions[this.name]\r\n\t\t\t\tif (definition) {\r\n\t\t\t\t\tdefinition(element, newValue, this.name)\r\n\t\t\t\t} else {\r\n\t\t\t\t\telement.style[this.name] = newValue\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\tvar ClassNameRenderer = lang.compose(Renderer.ElementRenderer, function ClassNameRenderer(options) {\r\n\t\t\tthis.className = options.className\r\n\t\t\tRenderer.apply(this, arguments)\r\n\t\t}, {\r\n\t\t\trenderUpdate: function(newValue, element) {\r\n\t\t\t\tvar currentClassName = element.className\r\n\t\t\t\tvar changingClassName = this.className\r\n\t\t\t\t// remove the className (needed for addition or removal)\r\n\t\t\t\t// see http://jsperf.com/remove-class-name-algorithm/2 for some tests on this\r\n\t\t\t\tvar removed = currentClassName && (' ' + currentClassName + ' ').replace(' ' + changingClassName + ' ', ' ')\r\n\t\t\t\tif (newValue) {\r\n\t\t\t\t\t// addition, add the className\r\n\t\t\t\t\tchangingClassName = currentClassName ? (removed + changingClassName).slice(1) : changingClassName;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// we already have removed the class, just need to trim\r\n\t\t\t\t\tchangingClassName = removed.slice(1, removed.length - 1)\r\n\t\t\t\t}\r\n\t\t\t\t// only assign if it changed, this can save a lot of time\r\n\t\t\t\tif (changingClassName != currentClassName) {\r\n\t\t\t\t\telement.className = changingClassName\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\t// TODO: check for renderContent with text updater\r\n\t\tvar TextRenderer = Renderer.TextRenderer\r\n\t\tvar ListRenderer = Renderer.ListRenderer\r\n\t\t\r\n\t\tvar toAddToElementPrototypes = []\r\n\t\tvar createdBaseElements = []\r\n\t\tvar doc = typeof document !== 'undefined' ? document : {\r\n\t\t\tcreateElement: function(tag) {\r\n\t\t\t\treturn {}\r\n\t\t\t},\r\n\t\t\taddEventListener: function() {\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tvar testStyle = doc.createElement('div').style\r\n\t\tvar childTagForParent = {\r\n\t\t\tTABLE: ['tr','td'],\r\n\t\t\tTBODY: ['tr','td'],\r\n\t\t\tTR: 'td',\r\n\t\t\tUL: 'li',\r\n\t\t\tOL: 'li',\r\n\t\t\tSELECT: 'option'\r\n\t\t}\r\n\t\tvar inputs = {\r\n\t\t\tINPUT: 1,\r\n\t\t\tTEXTAREA: 1\r\n\t\t\t// SELECT: 1, we exclude this, so the default \"content\" of the element can be the options\r\n\t\t}\r\n\t\r\n\t\tfunction booleanStyle(options) {\r\n\t\t\treturn function(element, value, key) {\r\n\t\t\t\tif (typeof value === 'boolean') {\r\n\t\t\t\t\t// has a boolean conversion\r\n\t\t\t\t\tvalue = options[value ? 0 : 1]\r\n\t\t\t\t}\r\n\t\t\t\telement.style[key] = value\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction defaultStyle(element, value, key) {\r\n\t\t\tif (typeof value === 'number') {\r\n\t\t\t\tvalue = value + 'px'\r\n\t\t\t}\r\n\t\t\telement.style[key] = value\r\n\t\t}\r\n\t\tfunction directStyle(element, value, key) {\r\n\t\t\telement.style[key] = value\r\n\t\t}\r\n\t\r\n\t\tvar styleDefinitions = {\r\n\t\t\tdisplay: booleanStyle(['initial', 'none']),\r\n\t\t\tvisibility: booleanStyle(['visible', 'hidden']),\r\n\t\t\tcolor: directStyle,\r\n\t\t\topacity: directStyle,\r\n\t\t\tzoom: directStyle,\r\n\t\t\tminZoom: directStyle,\r\n\t\t\tmaxZoom: directStyle,\r\n\t\t\tfontWeight: directStyle,\r\n\t\t\tposition: booleanStyle(['absolute', '']),\r\n\t\t\ttextDecoration: booleanStyle(['underline', '']),\r\n\t\t\tfontWeight: booleanStyle(['bold', 'normal'])\r\n\t\t}\r\n\t\t;[\"alignContent\",\"alignItems\",\"alignSelf\",\"animation\",\"animationDelay\",\"animationDirection\",\"animationDuration\",\"animationFillMode\",\"animationIterationCount\",\"animationName\",\"animationPlayState\",\"animationTimingFunction\",\"backfaceVisibility\",\"background\",\"backgroundAttachment\",\"backgroundBlendMode\",\"backgroundClip\",\"backgroundColor\",\"backgroundImage\",\"backgroundOrigin\",\"backgroundPosition\",\"backgroundPositionX\",\"backgroundPositionY\",\"backgroundRepeat\",\"backgroundRepeatX\",\"backgroundRepeatY\",\"backgroundSize\",\"baselineShift\",\"border\",\"borderBottom\",\"borderBottomColor\",\"borderBottomLeftRadius\",\"borderBottomRightRadius\",\"borderBottomStyle\",\"borderBottomWidth\",\"borderCollapse\",\"borderColor\",\"borderImage\",\"borderImageOutset\",\"borderImageRepeat\",\"borderImageSlice\",\"borderImageSource\",\"borderImageWidth\",\"borderLeft\",\"borderLeftColor\",\"borderLeftStyle\",\"borderLeftWidth\",\"borderRadius\",\"borderRight\",\"borderRightColor\",\"borderRightStyle\",\"borderRightWidth\",\"borderSpacing\",\"borderStyle\",\"borderTop\",\"borderTopColor\",\"borderTopLeftRadius\",\"borderTopRightRadius\",\"borderTopStyle\",\"borderTopWidth\",\"borderWidth\",\"bottom\",\"boxShadow\",\"boxSizing\",\"bufferedRendering\",\"captionSide\",\"clear\",\"clip\",\"clipPath\",\"clipRule\",\"color\",\"colorInterpolation\",\"colorInterpolationFilters\",\"colorRendering\",\"counterIncrement\",\"counterReset\",\"cursor\",\"direction\",\"display\",\"emptyCells\",\"fill\",\"fillOpacity\",\"fillRule\",\"filter\",\"flex\",\"flexBasis\",\"flexDirection\",\"flexFlow\",\"flexGrow\",\"flexShrink\",\"flexWrap\",\"float\",\"floodColor\",\"floodOpacity\",\"font\",\"fontFamily\",\"fontFeatureSettings\",\"fontKerning\",\"fontSize\",\"fontStretch\",\"fontStyle\",\"fontVariant\",\"fontVariantLigatures\",\"fontWeight\",\"height\",\"imageRendering\",\"isolation\",\"justifyContent\",\"left\",\"letterSpacing\",\"lightingColor\",\"lineHeight\",\"listStyle\",\"listStyleImage\",\"listStylePosition\",\"listStyleType\",\"margin\",\"marginBottom\",\"marginLeft\",\"marginRight\",\"marginTop\",\"marker\",\"markerEnd\",\"markerMid\",\"markerStart\",\"mask\",\"maskType\",\"maxHeight\",\"maxWidth\",\"maxZoom\",\"minHeight\",\"minWidth\",\"minZoom\",\"mixBlendMode\",\"motion\",\"motionOffset\",\"motionPath\",\"motionRotation\",\"objectFit\",\"objectPosition\",\"opacity\",\"order\",\"orientation\",\"orphans\",\"outline\",\"outlineColor\",\"outlineOffset\",\"outlineStyle\",\"outlineWidth\",\"overflow\",\"overflowWrap\",\"overflowX\",\"overflowY\",\"padding\",\"paddingBottom\",\"paddingLeft\",\"paddingRight\",\"paddingTop\",\"page\",\"pageBreakAfter\",\"pageBreakBefore\",\"pageBreakInside\",\"paintOrder\",\"perspective\",\"perspectiveOrigin\",\"pointerEvents\",\"position\",\"quotes\",\"resize\",\"right\",\"shapeImageThreshold\",\"shapeMargin\",\"shapeOutside\",\"shapeRendering\",\"size\",\"speak\",\"src\",\"stopColor\",\"stopOpacity\",\"stroke\",\"strokeDasharray\",\"strokeDashoffset\",\"strokeLinecap\",\"strokeLinejoin\",\"strokeMiterlimit\",\"strokeOpacity\",\"strokeWidth\",\"tabSize\",\"tableLayout\",\"textAlign\",\"textAlignLast\",\"textAnchor\",\"textCombineUpright\",\"textDecoration\",\"textIndent\",\"textOrientation\",\"textOverflow\",\"textRendering\",\"textShadow\",\"textTransform\",\"top\",\"touchAction\",\"transform\",\"transformOrigin\",\"transformStyle\",\"transition\",\"transitionDelay\",\"transitionDuration\",\"transitionProperty\",\"transitionTimingFunction\",\"unicodeBidi\",\"unicodeRange\",\"userZoom\",\"vectorEffect\",\"verticalAlign\",\"visibility\",\"whiteSpace\",\"widows\",\"width\",\"willChange\",\"wordBreak\",\"wordSpacing\",\"wordWrap\",\"writingMode\",\"zIndex\",\"zoom\"].forEach(function(property) {\r\n\t\t\tstyleDefinitions[property] = styleDefinitions[property] || defaultStyle\r\n\t\t})\r\n\t\tvar styleSheet\r\n\t\tvar presumptiveParentMap = new WeakMap()\r\n\t\r\n\t\tvar setPrototypeOf = Object.setPrototypeOf || (function(base, proto) { base.__proto__ = proto})\r\n\t\tvar getPrototypeOf = Object.getPrototypeOf || (function(base) { return base.__proto__ })\r\n\t\tfunction createCssRule(selector) {\r\n\t\t\tif (!styleSheet) {\r\n\t\t\t\tvar styleSheetElement = doc.createElement(\"style\")\r\n\t\t\t\tstyleSheetElement.setAttribute(\"type\", \"text/css\")\r\n\t//\t\t\tstyleSheet.appendChild(doc.createTextNode(css))\r\n\t\t\t\tdoc.head.insertBefore(styleSheetElement, doc.head.firstChild)\r\n\t\t\t\tstyleSheet = styleSheetElement.sheet\r\n\t\t\t}\r\n\t\t\tvar cssRules = styleSheet.cssRules || styleSheet.rules\r\n\t\t\treturn cssRules[styleSheet.addRule(selector, ' ', cssRules.length)]\r\n\t\t}\r\n\t\tvar invalidatedElements = new WeakMap(null, 'invalidated')\r\n\t\tvar queued\r\n\t\r\n\t\tvar toRender = []\r\n\t\tfunction flatten(target, part) {\r\n\t\t\tvar base = target.base\r\n\t\t\tif (base) {\r\n\t\t\t\tvar basePart = base[part]\r\n\t\t\t\tif (basePart) {\r\n\t\t\t\t\ttarget[part] || target[part]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction layoutChildren(parent, children, container, prepend) {\r\n\t\t\tvar fragment = (children.length > 3 || prepend) ? doc.createDocumentFragment() : parent\r\n\t\t\tfor(var i = 0, l = children.length; i < l; i++) {\r\n\t\t\t\tvar child = children[i]\r\n\t\t\t\tvar childNode\r\n\t\t\t\tif (child && child.create) {\r\n\t\t\t\t\t// an element constructor\r\n\t\t\t\t\tcurrentParent = parent\r\n\t\t\t\t\tchildNode = child.create()\r\n\t\t\t\t\tfragment.appendChild(childNode)\r\n\t\t\t\t\tif (child.isContentNode) {\r\n\t\t\t\t\t\tcontainer.contentNode = childNode\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (typeof child == 'function') {\r\n\t\t\t\t\t// TODO: reenable this\r\n\t//\t\t\t\tif (child.for) {\r\n\t\t\t\t\t\t// a variable constructor that can be contextualized\r\n\t\t//\t\t\t\tfragment.appendChild(variableAsContent(parent, child))\r\n\t\t\t//\t\t} else {\r\n\t\t\t\t\t\t// an element constructor\r\n\t\t\t\t\t\tchildNode = new child()\r\n\t\t\t\t\t\tfragment.appendChild(childNode)\r\n\t\t\t\t//\t}\r\n\t\t\t\t} else if (child && typeof child == 'object') {\r\n\t\t\t\t\tif (child instanceof Array) {\r\n\t\t\t\t\t\t// array of sub-children\r\n\t\t\t\t\t\tcontainer = container || parent\r\n\t\t\t\t\t\tchildNode = childNode || parent\r\n\t\t\t\t\t\tlayoutChildren(childNode.contentNode || childNode, child, container)\r\n\t\t\t\t\t} else if (child.notifies) {\r\n\t\t\t\t\t\t// a variable\r\n\t\t\t\t\t\tfragment.appendChild(childNode = variableAsContent(parent, child))\r\n\t\t\t\t\t} else if (child.nodeType) {\r\n\t\t\t\t\t\t// an element itself\r\n\t\t\t\t\t\tfragment.appendChild(childNode = child)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// TODO: apply properties to last child, but with binding to the parent (for events)\r\n\t\t\t\t\t\tthrow new Error('Unknown child type ' + child)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// a primitive value\r\n\t\t\t\t\tchildNode = doc.createTextNode(child)\r\n\t\t\t\t\tfragment.appendChild(childNode)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (fragment != parent) {\r\n\t\t\t\tif (prepend) {\r\n\t\t\t\t\tparent.insertBefore(fragment, parent.firstChild)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tparent.appendChild(fragment)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn childNode\r\n\t\t}\r\n\t\tfunction variableAsContent(parent, content) {\r\n\t\t\tif (content == null) {\r\n\t\t\t\treturn doc.createTextNode('')\r\n\t\t\t}\r\n\t\t\tvar text\r\n\t\t\ttry {\r\n\t\t\t\ttext = content.valueOf(new Context(parent))\r\n\t\t\t} catch (error) {\r\n\t\t\t\ttext = error.stack\r\n\t\t\t}\r\n\t\t\tvar textNode = doc.createTextNode(text)\r\n\t\t\tif (content.notifies) {\r\n\t\t\t\tenterRenderer(TextRenderer, {\r\n\t\t\t\t\telement: parent,\r\n\t\t\t\t\ttextNode: textNode,\r\n\t\t\t\t\tvariable: content\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\treturn textNode\r\n\t\t}\r\n\t\r\n\t\tfunction bidirectionalHandler(element, value, key) {\r\n\t\t\tif (value && value.notifies) {\r\n\t\t\t\tenterRenderer(InputPropertyRenderer, {\r\n\t\t\t\t\tname: key,\r\n\t\t\t\t\tvariable: value,\r\n\t\t\t\t\telement: element\r\n\t\t\t\t})\r\n\t\t\t\tif (inputs[element.tagName] || element.tagName === 'SELECT') {\r\n\t\t\t\t\tbindChanges(element, value, key)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (element.tagName === 'SELECT' && key === 'value') {\r\n\t\t\t\t\t// use the deferred <select> value assignment\r\n\t\t\t\t\tInputPropertyRenderer.prototype.renderSelectValueUpdate(value, element)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tInputPropertyRenderer.prototype.renderUpdate(value, element)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction noop() {}\r\n\t\tvar propertyHandlers = {\r\n\t\t\tcontent: noop, // content and children have special handling in create\r\n\t\t\tchildren: noop,\r\n\t\t\ttagName: noop,\r\n\t\t\teach: noop, // just used by content, doesn't need to be recorded on the element\r\n\t\t\tclasses: function(element, classes) {\r\n\t\t\t\tif (!(classes.length > -1)) {\r\n\t\t\t\t\t// index the classes, if necessary\r\n\t\t\t\t\tvar i = 0\r\n\t\t\t\t\tfor (var key in classes) {\r\n\t\t\t\t\t\tif (!classes[i]) {\r\n\t\t\t\t\t\t\tclasses[i] = key\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ti++\r\n\t\t\t\t\t}\r\n\t\t\t\t\tclasses.length = i\r\n\t\t\t\t}\r\n\t\t\t\tfor (var i = 0, l = classes.length; i < l; i++) {\r\n\t\t\t\t\t// find each class name\r\n\t\t\t\t\tvar className = classes[i]\r\n\t\t\t\t\tvar flag = classes[className]\r\n\t\t\t\t\tif (flag && flag.notifies) {\r\n\t\t\t\t\t\t// if it is a variable, we react to it\r\n\t\t\t\t\t\tenterRenderer(ClassNameRenderer, {\r\n\t\t\t\t\t\t\telement: element,\r\n\t\t\t\t\t\t\tclassName: className,\r\n\t\t\t\t\t\t\tvariable: flag\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t} else if (flag || flag === undefined) {\r\n\t\t\t\t\t\telement.className += ' ' + className\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tclass: applyAttribute,\r\n\t\t\tfor: applyAttribute,\r\n\t\t\trole: applyAttribute,\r\n\t\t\trender: function(element, value, key, properties) {\r\n\t\t\t\t// TODO: This doesn't need to be a property updater\r\n\t\t\t\t// we should also verify it is a generator\r\n\t\t\t\t// and maybe, at some point, find an optimization to eliminate the bind()\r\n\t\t\t\tenterRenderer(PropertyRenderer, {\r\n\t\t\t\t\tname: key,\r\n\t\t\t\t\tvariable: new Variable.GeneratorVariable(value.bind(element, properties)),\r\n\t\t\t\t\telement: element\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tvalue: bidirectionalHandler,\r\n\t\t\tvalueAsNumber: bidirectionalHandler,\r\n\t\t\tvalueAsDate: bidirectionalHandler,\r\n\t\t\tchecked: bidirectionalHandler,\r\n\t\t\tdataset: applySubProperties(function(newValue, element, key) {\r\n\t\t\t\telement.dataset[key || this.name] = newValue\r\n\t\t\t}),\r\n\t\t\tattributes: applySubProperties(function(newValue, element, key) {\r\n\t\t\t\telement.setAttribute(key || this.name, newValue)\r\n\t\t\t}),\r\n\t\t\tstyle: function(element, value, key) {\r\n\t\t\t\tif (typeof value === 'string') {\r\n\t\t\t\t\telement.setAttribute('style', value)\r\n\t\t\t\t} else if (value && value.notifies) {\r\n\t\t\t\t\tenterRenderer(AttributeRenderer, {\r\n\t\t\t\t\t\tname: 'style',\r\n\t\t\t\t\t\tvariable: value,\r\n\t\t\t\t\t\telment: element\r\n\t\t\t\t\t})\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstyleObjectHandler(element, value, key)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction applyAttribute(element, value, key) {\r\n\t\t\tif (value && value.notifies) {\r\n\t\t\t\tenterRenderer(AttributeRenderer, {\r\n\t\t\t\t\tname: key,\r\n\t\t\t\t\tvariable: value,\r\n\t\t\t\t\telement: element\r\n\t\t\t\t})\r\n\t\t\t} else {\r\n\t\t\t\telement.setAttribute(key, value)\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tvar styleObjectHandler = applySubProperties(function(newValue, element, key) {\r\n\t\t\telement.style[key || this.name] = newValue\r\n\t\t})\r\n\t\r\n\t\tfunction applySubProperties(renderer) {\r\n\t\t\tvar SubPropertyRenderer = lang.compose(PropertyRenderer, function SubPropertyRenderer(options) {\r\n\t\t\t\tPropertyRenderer.apply(this, arguments)\r\n\t\t\t}, {\r\n\t\t\t\trenderUpdate: renderer\r\n\t\t\t})\t\r\n\t\t\treturn function(element, value, key) {\r\n\t\t\t\tvar target = element[key]\r\n\t\t\t\tfor (var subKey in value) {\r\n\t\t\t\t\tvar subValue = value[subKey]\r\n\t\t\t\t\tif (subValue && subValue.notifies) {\r\n\t\t\t\t\t\tenterRenderer(SubPropertyRenderer, {\r\n\t\t\t\t\t\t\tname: subKey,\r\n\t\t\t\t\t\t\tvariable: subValue,\r\n\t\t\t\t\t\t\telement: element\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\trenderer(subValue, element, subKey)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction assignProperties(element, properties) {\r\n\t\t\tfor (var key in properties) {\r\n\t\t\t\tvar value = properties[key]\r\n\t\t\t\tvar styleDefinition = styleDefinitions[key]\r\n\t\t\t\tif (propertyHandlers[key]) {\r\n\t\t\t\t\tpropertyHandlers[key](element, value, key, properties)\r\n\t\t\t\t} else if ((styleDefinition = styleDefinitions[key]) && element[key] === undefined) {\r\n\t\t\t\t\tif (value && value.notifies) {\r\n\t\t\t\t\t\tenterRenderer(StyleRenderer, {\r\n\t\t\t\t\t\t\tname: key,\r\n\t\t\t\t\t\t\tvariable: value,\r\n\t\t\t\t\t\t\telement: element\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tstyleDefinition(element, value, key)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (value && value.notifies) {\r\n\t\t\t\t\tenterRenderer(PropertyRenderer, {\r\n\t\t\t\t\t\tname: key,\r\n\t\t\t\t\t\tvariable: value,\r\n\t\t\t\t\t\telement: element\r\n\t\t\t\t\t})\r\n\t\t\t\t} else if (typeof value === 'function' && key.slice(0, 2) === 'on') {\r\n\t\t\t\t\telement.addEventListener(key.slice(2), value)\r\n\t\t\t\t} else {\r\n\t\t\t\t\telement[key] = value\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction applySelector(element, selector) {\r\n\t\t\tselector.replace(/(\\.|#)?(\\w+)/g, function(t, operator, name) {\r\n\t\t\t\tif (operator == '.') {\r\n\t\t\t\t\telement._class = (element._class ? element._class + ' ' : '') + name\r\n\t\t\t\t} else if (operator == '#') {\r\n\t\t\t\t\telement._id = name\r\n\t\t\t\t} else {\r\n\t\t\t\t\telement._tag = name\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t}\r\n\t\r\n\t\tfunction buildContent(element, content, key, properties) {\r\n\t\t\tvar each = element.each || properties.each\r\n\t\t\tif (each && content) {\r\n\t\t\t\t// render as list\r\n\t\t\t\tif (each.create) {\r\n\t\t\t\t\tvar ItemClass = element.itemAs || Item\r\n\t\t\t\t\thasOwn(each, ItemClass, function (element) {\r\n\t\t\t\t\t\tvar itemVariable = ItemClass.for(element._item)\r\n\t\t\t\t\t\titemVariable.collection = content\r\n\t\t\t\t\t\treturn itemVariable\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t\tif (content.notifies) {\r\n\t\t\t\t\tenterRenderer(ListRenderer, {\r\n\t\t\t\t\t\teach: each,\r\n\t\t\t\t\t\tvariable: content,\r\n\t\t\t\t\t\telement: element\r\n\t\t\t\t\t})\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar fragment = doc.createDocumentFragment()\r\n\t\t\t\t\tcontent.forEach(function(item) {\r\n\t\t\t\t\t\tif (each.create) {\r\n\t\t\t\t\t\t\tchildElement = each.create({parent: element, _item: item}) // TODO: make a faster object here potentially\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tchildElement = each(item, element)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfragment.appendChild(childElement)\r\n\t\t\t\t\t})\r\n\t\t\t\t\telement.appendChild(fragment)\r\n\t\t\t\t}\r\n\t\t\t} else if (inputs[element.tagName]) {\r\n\t\t\t\t// render into input\r\n\t\t\t\tbuildInputContent(element, content)\r\n\t\t\t} else if (content instanceof Array) {\r\n\t\t\t\t// treat array as children (potentially of the content node)\r\n\t\t\t\telement = element.contentNode || element\r\n\t\t\t\tlayoutChildren(element, content, element)\r\n\t\t\t} else {\r\n\t\t\t\t// render as string\r\n\t\t\t\telement.appendChild(variableAsContent(element, content))\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction bindChanges(element, variable, key, conversion) {\r\n\t\t\tlang.nextTurn(function() { // wait for next turn in case inputChanges isn't set yet\r\n\t\t\t\tvar inputEvents = element.inputEvents || ['change', 'alkali-change']\r\n\t\t\t\tfor (var i = 0, l = inputEvents.length; i < l; i++) {\r\n\t\t\t\t\telement.addEventListener(inputEvents[i], function (event) {\r\n\t\t\t\t\t\tvar value = element[key]\r\n\t\t\t\t\t\tvar result = variable.put(conversion ? conversion(value, element) : value, new Context(element))\r\n\t\t\t\t\t\tif (result === Variable.deny) {\r\n\t\t\t\t\t\t\tthrow new Error('Variable change denied')\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t}\r\n\t\r\n\t\tdoc.addEventListener('click', function(event) {\r\n\t\t\tvar target = event.target\r\n\t\t\tif (target.type === 'radio') {\r\n\t\t\t\tvar radios = doc.querySelectorAll('input[type=radio]')\r\n\t\t\t\tfor (var i = 0, l = radios.length; i < l; i++) {\r\n\t\t\t\t\tvar radio = radios[i]\r\n\t\t\t\t\tif (radio.name === target.name && radio !== target) {\r\n\t\t\t\t\t\tradio.dispatchEvent(new Event('alkali-change', {}))\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\tfunction conversion(value, element) {\r\n\t\t\tif (element.type == 'number') {\r\n\t\t\t\treturn parseFloat(value)\r\n\t\t\t}\r\n\t\t\treturn value\r\n\t\t}\r\n\t\r\n\t\tfunction buildInputContent(element, content) {\r\n\t\t\tvar inputType = element.type\r\n\t\t\tvar inputProperty = inputType in {date: 1, datetime: 1, time: 1} ?\r\n\t\t\t\t\t'valueAsDate' : (inputType === 'checkbox' || inputType === 'radio') ?\r\n\t\t\t\t\t\t'checked' : 'value'\r\n\t\r\n\t\t\tif (content && content.notifies) {\r\n\t\t\t\t// a variable, respond to changes\r\n\t\t\t\tenterRenderer(InputPropertyRenderer, {\r\n\t\t\t\t\tvariable: content,\r\n\t\t\t\t\tname: inputProperty,\r\n\t\t\t\t\telement: element\r\n\t\t\t\t})\r\n\t\t\t\t// and bind the other way as well, updating the variable in response to input changes\r\n\t\t\t\tbindChanges(element, content, inputProperty, conversion)\r\n\t\t\t} else {\r\n\t\t\t\t// primitive\r\n\t\t\t\telement[inputProperty] = content\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar classHandlers = {\r\n\t\t\thasOwn: function(Element, value) {\r\n\t\t\t\thasOwn(Element, value)\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction applyToClass(value, Element) {\r\n\t\t\tvar applyOnCreate = Element._applyOnCreate\r\n\t\t\tvar prototype = Element.prototype\r\n\t\t\tif (value && typeof value === 'object') {\r\n\t\t\t\tif (value instanceof Array || value.notifies) {\r\n\t\t\t\t\tapplyOnCreate.content = value\r\n\t\t\t\t} else {\r\n\t\t\t\t\tfor (var key in value) {\r\n\t\t\t\t\t// TODO: eventually we want to be able to set these as rules statically per element\r\n\t\t\t\t\t/*if (styleDefinitions[key]) {\r\n\t\t\t\t\t\tvar styles = Element.styles || (Element.styles = [])\r\n\t\t\t\t\t\tstyles.push(key)\r\n\t\t\t\t\t\tstyles[key] = descriptor.value\r\n\t\t\t\t\t} else {*/\r\n\t\t\t\t\t\tif (classHandlers[key]) {\r\n\t\t\t\t\t\t\thasOwn(Element, value[key])\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// TODO: do deep merging of styles and classes, but not variables\r\n\t\t\t\t\t\t\tapplyOnCreate[key] = value[key]\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else if (typeof value === 'function' && !value.for) {\r\n\t\t\t\tthrow new TypeError('Function as argument not supported')\r\n\t\t\t} else {\r\n\t\t\t\tapplyOnCreate.content = value\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction getApplySet(Class) {\r\n\t\t\tif (Class.hasOwnProperty('_applyOnCreate')) {\r\n\t\t\t\treturn Class._applyOnCreate\r\n\t\t\t}\r\n\t\t\t// this means we didn't extend and evaluate the prototype yet\r\n\t\t\tif (Class.getForClass) {\r\n\t\t\t\t// we are extending an alkali constructor\r\n\t\t\t\t// if this class is inheriting from an alkali constructor, work our way up the chain\r\n\t\t\t\tapplyOnCreate = Class._applyOnCreate = {}\r\n\t\t\t\tvar parentApplySet = getApplySet(getPrototypeOf(Class))\r\n\t\t\t\tfor (var key in parentApplySet) {\r\n\t\t\t\t\tapplyOnCreate[key] = parentApplySet[key]\r\n\t\t\t\t}\r\n\t\t\t\t// we need to check the prototype for event handlers\r\n\t\t\t\tvar prototype = Class.prototype\r\n\t\t\t\tvar keys = Object.getOwnPropertyNames(prototype)\r\n\t\t\t\tfor (var i = 0, l = keys.length; i < l; i++) {\r\n\t\t\t\t\tvar key = keys[i]\r\n\t\t\t\t\tif (key.slice(0, 2) === 'on' || (key === 'render' && isGenerator(prototype[key]))) {\r\n\t\t\t\t\t\tapplyOnCreate[key] = prototype[key]\r\n\t\t\t\t\t} else if (key.slice(0, 6) === 'render') {\r\n\t\t\t\t\t\tObject.defineProperty(prototype, key[6].toLowerCase() + key.slice(7), renderDescriptor(key))\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn applyOnCreate\r\n\t\t\t}\r\n\t\t\treturn null\r\n\t\t}\r\n\t\r\n\t\tfunction renderDescriptor(renderMethod) {\r\n\t\t\tvar map = new WeakMap()\r\n\t\t\treturn {\r\n\t\t\t\tget: function() {\r\n\t\t\t\t\treturn map.has(this) ? map.get(this) : null\r\n\t\t\t\t},\r\n\t\t\t\tset: function(value) {\r\n\t\t\t\t\tmap.set(this, value)\r\n\t\t\t\t\tthis[renderMethod](value)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction makeElementConstructor() {\r\n\t\t\tfunction Element(selector, properties) {\r\n\t\t\t\tif (this instanceof Element){\r\n\t\t\t\t\t// create DOM element\r\n\t\t\t\t\t// Need to detect if we have registered the element and `this` is actually already the correct instance\r\n\t\t\t\t\treturn create.apply(Element.prototype === getPrototypeOf(this) ? Element :// this means it is from this constructor\r\n\t\t\t\t\t\tthis.constructor, // this means it was constructed from a subclass\r\n\t\t\t\t\t\targuments)\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// extend to create new class\r\n\t\t\t\t\treturn withProperties.apply(Element, arguments)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tElement.create = create\r\n\t\t\tElement.with = withProperties\r\n\t\t\tElement.for = forTarget\r\n\t\t\tElement.property = propertyForElement\r\n\t\t\tElement.getForClass = getForClass\r\n\t\t\treturn Element\r\n\t\t}\r\n\t\r\n\t\tfunction withProperties(selector, properties) {\r\n\t\t\tvar Element = makeElementConstructor()\r\n\t\t\tElement.superConstructor = this\r\n\t\t\tElement.tagName = this.tagName\r\n\t\t\tif (this.children) {\r\n\t\t\t\t// just copy this property\r\n\t\t\t\tElement.children = this.children\r\n\t\t\t}\r\n\t\t\tvar prototype = Element.prototype = this.prototype\r\n\t\r\n\t\t\tvar hasOwnApplySet\r\n\t\t\tvar applyOnCreate = Element._applyOnCreate = {}\r\n\t\t\tvar parentApplySet = getApplySet(this)\r\n\t\t\t// copy parent properties\r\n\t\t\tfor (var key in parentApplySet) {\r\n\t\t\t\tapplyOnCreate[key] = parentApplySet[key]\r\n\t\t\t}\r\n\t\r\n\t\t\tvar i = 0 // for arguments\r\n\t\t\tif (typeof selector === 'string') {\r\n\t\t\t\tvar selectorMatch = selector.match(SELECTOR_REGEX)\r\n\t\t\t\tif (selectorMatch) {\r\n\t\t\t\t\tdo {\r\n\t\t\t\t\t\tvar operator = selectorMatch[1]\r\n\t\t\t\t\t\tvar name = selectorMatch[2]\r\n\t\t\t\t\t\tif (operator == '.') {\r\n\t\t\t\t\t\t\tif (applyOnCreate.className) {\r\n\t\t\t\t\t\t\t\tapplyOnCreate.className += ' ' + name\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tapplyOnCreate.className = name\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tapplyOnCreate.id = name\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar remaining = selectorMatch[3]\r\n\t\t\t\t\t\tselectorMatch = remaining && remaining.match(SELECTOR_REGEX)\r\n\t\t\t\t\t} while (selectorMatch)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tapplyOnCreate.content = selector\r\n\t\t\t\t}\r\n\t\t\t\ti++ // skip the first argument\r\n\t\t\t}\r\n\t\r\n\t\t\tfor (var l = arguments.length; i < l; i++) {\r\n\t\t\t\tapplyToClass(arguments[i], Element)\r\n\t\t\t}\r\n\t\t\treturn Element\r\n\t\t}\r\n\t\tvar currentParent\r\n\t\tfunction create(selector, properties) {\r\n\t\t\t// TODO: make this a symbol\r\n\t\t\tvar applyOnCreate = getApplySet(this)\r\n\t\t\tif (currentParent) {\r\n\t\t\t\tvar parent = currentParent\r\n\t\t\t\tcurrentParent = null\r\n\t\t\t}\r\n\t/*\t\tif (this._initialized != this) {\r\n\t\t\t\tthis._initialized = this\r\n\t\t\t\tthis.initialize && this.initialize()\r\n\t\t\t\tvar styles = this.styles\r\n\t\t\t\tif (styles) {\r\n\t\t\t\t\tvar rule = createCssRule(getUniqueSelector(this))\r\n\t\t\t\t\tfor (var i = 0, l = styles.length; i < l; i++) {\r\n\t\t\t\t\t\tvar key = styles[i]\r\n\t\t\t\t\t\tvar value = styles[key]\r\n\t\t\t\t\t\t// TODO: if it is a contextualized variable, do this on the element\r\n\t\t\t\t\t\tvar styleDefinition = styleDefinitions[key]\r\n\t\t\t\t\t\tif (styleDefinition) {\r\n\t\t\t\t\t\t\tstyleDefinition(rule, value, key)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (!this.hasOwnProperty('_applyOnCreate')) {\r\n\t\t\t\t\tapplyOnCreate = getApplySet(this)\r\n\t\t\t\t}\r\n\t\t\t}*/\r\n\t\t\tvar element = doc.createElement(this.tagName)\r\n\t\t\tif (selector && selector.parent) {\r\n\t\t\t\tparent = selector.parent\r\n\t\t\t}\r\n\t\t\tif (parent) {\r\n\t\t\t\tpresumptiveParentMap.set(element, parent)\r\n\t\t\t}\r\n\t\t\tif (!(element instanceof this)) {\r\n\t\t\t\t// ideally we want to avoid this call, as it is expensive, but for classes that\r\n\t\t\t\t// don't register a tag name, we have to make sure the prototype chain is correct\r\n\t\t\t\tsetPrototypeOf(element, this.prototype)\r\n\t\t\t}\r\n\t\t\tif (element.constructor != this) {\r\n\t\t\t\telement.constructor = this // need to do this for hasOwn contextualization to work\r\n\t\t\t}\r\n\t\t\tif (arguments.length > 0) {\r\n\t\t\t\t// copy applyOnCreate when we have arguments\r\n\t\t\t\tvar ElementApplyOnCreate = applyOnCreate\r\n\t\t\t\tapplyOnCreate = {}\r\n\t\t\t\tfor (var key in ElementApplyOnCreate) {\r\n\t\t\t\t\tapplyOnCreate[key] = ElementApplyOnCreate[key]\r\n\t\t\t\t}\r\n\t\t\t\tvar i = 0\r\n\t\t\t\tif (typeof selector == 'string') {\r\n\t\t\t\t\ti++\r\n\t\t\t\t\tvar selectorMatch = selector.match(SELECTOR_REGEX)\r\n\t\t\t\t\tif (selectorMatch) {\r\n\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\tvar operator = selectorMatch[1]\r\n\t\t\t\t\t\t\tvar name = selectorMatch[2]\r\n\t\t\t\t\t\t\tif (operator == '.') {\r\n\t\t\t\t\t\t\t\tif (applyOnCreate.className) {\r\n\t\t\t\t\t\t\t\t\tapplyOnCreate.className += ' ' + name\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tif (element.className) {\r\n\t\t\t\t\t\t\t\t\t    element.className += ' ' + name\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t    element.className = name\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tif (applyOnCreate.id) {\r\n\t\t\t\t\t\t\t\t\tapplyOnCreate.id = name\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t// just skip right to the element\r\n\t\t\t\t\t\t\t\t\telement.id = name\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tvar remaining = selectorMatch[3]\r\n\t\t\t\t\t\t\tselectorMatch = remaining && remaining.match(SELECTOR_REGEX)\r\n\t\t\t\t\t\t} while (selectorMatch)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tapplyOnCreate.content = selector\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (selector && selector._item) {\r\n\t\t\t\t\t// this is kind of hack, to get the Item available before the properties, eventually we may want to\r\n\t\t\t\t\t// order static properties before variable binding applications, but for now.\r\n\t\t\t\t\telement._item = selector._item\r\n\t\t\t\t}\r\n\t\t\t\tfor (var l = arguments.length; i < l; i++) {\r\n\t\t\t\t\tvar argument = arguments[i]\r\n\t\t\t\t\tif (argument && typeof argument === 'object') {\r\n\t\t\t\t\t\tif (argument instanceof Array || argument.notifies) {\r\n\t\t\t\t\t\t\tapplyOnCreate.content = argument\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tfor (var key in argument) {\r\n\t\t\t\t\t\t\t\t// TODO: do deep merging of styles and classes, but not variables\r\n\t\t\t\t\t\t\t\tapplyOnCreate[key] = argument[key]\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (typeof argument === 'function' && argument.for) {\r\n\t\t\t\t\t\tapplyOnCreate.content = argument.for(element)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tapplyOnCreate.content = argument\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (element.created) {\r\n\t\t\t\tapplyOnCreate = element.created(applyOnCreate) || applyOnCreate\r\n\t\t\t}\r\n\t\t\t// TODO: inline this for better performance, possibly\r\n\t\t\tassignProperties(element, applyOnCreate)\r\n\t\t\tif (this.children) {\r\n\t\t\t\tlayoutChildren(element, this.children, element)\r\n\t\t\t}\r\n\t\t\t// always do this last, so it can be properly inserted inside the children\r\n\t\t\tif (applyOnCreate.content) {\r\n\t\t\t\tbuildContent(element, applyOnCreate.content, 'content', applyOnCreate)\r\n\t\t\t}\r\n\t\t\telement.ready && element.ready(applyOnCreate)\r\n\t\t\treturn element\r\n\t\t}\r\n\t\r\n\t\tvar slice = [].slice\r\n\t\tfunction append(parent){\r\n\t\t\treturn this.nodeType ?\r\n\t\t\t\tlayoutChildren(this, arguments, this) : // called as a method\r\n\t\t\t\tlayoutChildren(parent, slice.call(arguments, 1), parent) // called as a function\r\n\t\t}\r\n\t\r\n\t\tfunction prepend(parent){\r\n\t\t\treturn this.nodeType ?\r\n\t\t\t\tlayoutChildren(this, arguments, this, true) : // called as a method\r\n\t\t\t\tlayoutChildren(parent, slice.call(arguments, 1), parent, true) // called as a function\r\n\t\t}\r\n\t\r\n\t\tfunction registerTag(tagName) {\r\n\t\t\tthis.tagName = tagName\r\n\t\t\tif (doc.registerElement && this.prototype.constructor === this) {\r\n\t\t\t\tdoc.registerElement(tagName, this)\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tvar Element = withProperties.call(typeof HTMLElement !== 'undefined' ? HTMLElement : function() {})\r\n\t\r\n\t\tElement.registerTag = registerTag\r\n\t\tElement.assign = assignProperties\r\n\t\r\n\t\tElement.within = function(element){\r\n\t\t\t// find closest child\r\n\t\t}\r\n\t\r\n\t\tgenerate([\r\n\t\t\t'Video',\r\n\t\t\t'Source',\r\n\t\t\t'Media',\r\n\t\t\t'Audio',\r\n\t\t\t'UL',\r\n\t\t\t'Track',\r\n\t\t\t'Title',\r\n\t\t\t'TextArea',\r\n\t\t\t'Template',\r\n\t\t\t'TBody',\r\n\t\t\t'THead',\r\n\t\t\t'TFoot',\r\n\t\t\t'TR',\r\n\t\t\t'Table',\r\n\t\t\t'Col',\r\n\t\t\t'ColGroup',\r\n\t\t\t'TH',\r\n\t\t\t'TD',\r\n\t\t\t'Caption',\r\n\t\t\t'Style',\r\n\t\t\t'Span',\r\n\t\t\t'Shadow',\r\n\t\t\t'Select',\r\n\t\t\t'Script',\r\n\t\t\t'Quote',\r\n\t\t\t'Progress',\r\n\t\t\t'Pre',\r\n\t\t\t'Picture',\r\n\t\t\t'Param',\r\n\t\t\t'P',\r\n\t\t\t'Output',\r\n\t\t\t'Option',\r\n\t\t\t'Optgroup',\r\n\t\t\t'Object',\r\n\t\t\t'OL',\r\n\t\t\t'Ins',\r\n\t\t\t'Del',\r\n\t\t\t'Meter',\r\n\t\t\t'Meta',\r\n\t\t\t'Menu',\r\n\t\t\t'Map',\r\n\t\t\t'Link',\r\n\t\t\t'Legend',\r\n\t\t\t'Label',\r\n\t\t\t'LI',\r\n\t\t\t'KeyGen',\r\n\t\t\t'Input',\r\n\t\t\t'Image',\r\n\t\t\t'IFrame',\r\n\t\t\t'H1',\r\n\t\t\t'H2',\r\n\t\t\t'H3',\r\n\t\t\t'H4',\r\n\t\t\t'H5',\r\n\t\t\t'H6',\r\n\t\t\t'Hr',\r\n\t\t\t'FrameSet',\r\n\t\t\t'Frame',\r\n\t\t\t'Form',\r\n\t\t\t'Font',\r\n\t\t\t'Embed',\r\n\t\t\t'Article',\r\n\t\t\t'Aside',\r\n\t\t\t'Footer',\r\n\t\t\t'Figure',\r\n\t\t\t'FigCaption',\r\n\t\t\t'Header',\r\n\t\t\t'Main',\r\n\t\t\t'Mark',\r\n\t\t\t'MenuItem',\r\n\t\t\t'Nav',\r\n\t\t\t'Section',\r\n\t\t\t'Summary',\r\n\t\t\t'WBr',\r\n\t\t\t'Div',\r\n\t\t\t'Dialog',\r\n\t\t\t'Details',\r\n\t\t\t'DataList',\r\n\t\t\t'DL',\r\n\t\t\t'Canvas',\r\n\t\t\t'Button',\r\n\t\t\t'Base',\r\n\t\t\t'Br',\r\n\t\t\t'Area',\r\n\t\t\t'A'\r\n\t\t])\r\n\t\tgenerateInputs([\r\n\t\t\t'Checkbox',\r\n\t\t\t'Password',\r\n\t\t\t'Submit',\r\n\t\t\t'Radio',\r\n\t\t\t'Color',\r\n\t\t\t'Date',\r\n\t\t\t'DateTime',\r\n\t\t\t'Email',\r\n\t\t\t'Month',\r\n\t\t\t'Number',\r\n\t\t\t'Range',\r\n\t\t\t'Search',\r\n\t\t\t'Tel',\r\n\t\t\t'Time',\r\n\t\t\t'Url',\r\n\t\t\t'Week'])\r\n\t\r\n\t\tvar tags = {}\r\n\t\tfunction getConstructor(tagName) {\r\n\t\t\ttagName = tagName.toLowerCase()\r\n\t\t\treturn tags[tagName] ||\r\n\t\t\t\t(tags[tagName] =\r\n\t\t\t\t\tsetTag(withProperties.call(doc.createElement(tagName).constructor), tagName))\r\n\t\t}\r\n\t\r\n\t\tfunction setTag(Element, tagName) {\r\n\t\t\tElement.tagName = tagName\r\n\t\t\treturn Element\r\n\t\t}\r\n\t\tfunction generate(elements) {\r\n\t\t\telements.forEach(function(elementName) {\r\n\t\t\t\tvar ElementClass\r\n\t\t\t\tObject.defineProperty(Element, elementName, {\r\n\t\t\t\t\tget: function() {\r\n\t\t\t\t\t\treturn ElementClass || (ElementClass = getConstructor(elementName))\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t})\r\n\t\t}\r\n\t\tfunction generateInputs(elements) {\r\n\t\t\telements.forEach(function(inputType) {\r\n\t\t\t\tvar ElementClass\r\n\t\t\t\tObject.defineProperty(Element, inputType, {\r\n\t\t\t\t\tget: function() {\r\n\t\t\t\t\t\t// TODO: make all inputs extend from input generated from generate\r\n\t\t\t\t\t\treturn ElementClass || (ElementClass = setTag(withProperties.call(HTMLInputElement, {\r\n\t\t\t\t\t\t\ttype: inputType.toLowerCase()\r\n\t\t\t\t\t\t}), 'input'))\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t\t// alias all the inputs with an Input suffix\r\n\t\t\t\tObject.defineProperty(Element, inputType + 'Input', {\r\n\t\t\t\t\tget: function() {\r\n\t\t\t\t\t\treturn this[inputType]\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t})\r\n\t\t}\r\n\t\r\n\t\tvar aliases = {\r\n\t\t\tAnchor: 'A',\r\n\t\t\tParagraph: 'P',\r\n\t\t\tTextarea: 'TextArea',\r\n\t\t\tDList: 'DL',\r\n\t\t\tUList: 'UL',\r\n\t\t\tOList: 'OL',\r\n\t\t\tListItem: 'LI',\r\n\t\t\tText: 'Input',\r\n\t\t\tTextInput: 'Input',\r\n\t\t\tTableRow: 'TR',\r\n\t\t\tTableCell: 'TD',\r\n\t\t\tTableHeaderCell: 'TH',\r\n\t\t\tTableHeader: 'THead',\r\n\t\t\tTableBody: 'TBody'\r\n\t\t}\r\n\t\tfor (var alias in aliases) {\r\n\t\t\t(function(alias, to) {\r\n\t\t\t\tObject.defineProperty(Element, alias, {\r\n\t\t\t\t\tget: function() {\r\n\t\t\t\t\t\treturn this[to]\r\n\t\t\t\t\t}\r\n\t\t\t\t})\t\t\t\r\n\t\t\t})(alias, aliases[alias])\r\n\t\t}\r\n\t\r\n\t\tElement.append = append\r\n\t\tElement.prepend = prepend\r\n\t\tElement.refresh = Renderer.refresh\r\n\t\tvar options = Element.options = {\r\n\t\t\tmoveLiveElementsEnabled: true,\r\n\t\t}\r\n\t\tElement.content = function(element){\r\n\t\t\t// container marker\r\n\t\t\treturn {\r\n\t\t\t\tisContentNode: true,\r\n\t\t\t\tcreate: element.create.bind(element)\r\n\t\t\t}\r\n\t\t}\r\n\t\t// TODO: unify this in lang\r\n\t\tElement.extend = function(Class, properties) {\r\n\t\t\tfunction ExtendedElement() {\r\n\t\t\t\treturn Class.apply(this, arguments)\r\n\t\t\t}\r\n\t\t\tsetPrototypeOf(ExtendedElement, Class)\r\n\t\t\tvar prototype = ExtendedElement.prototype = Object.create(Class.prototype)\r\n\t\t\tprototype.constructor = ExtendedElement\r\n\t\t\tObject.getOwnPropertyNames(properties).forEach(function(key) {\r\n\t\t\t\tvar descriptor = Object.getOwnPropertyDescriptor(properties, key)\r\n\t\t\t\tif (classHandlers[key]) {\r\n\t\t\t\t\tclassHandlers[key](ExtendedElement, descriptor.value)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tObject.defineProperty(prototype, key, descriptor)\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\treturn ExtendedElement\r\n\t\t}\r\n\t\r\n\t\tfunction forTarget(target) {\r\n\t\t\treturn target.constructor.getForClass(target, this)\r\n\t\t}\r\n\t\r\n\t\tfunction hasOwn(From, Target, createInstance) {\r\n\t\t\tif (typeof Target === 'object' && Target.Class) {\r\n\t\t\t\treturn hasOwn(From, Target.Class, Target.createInstance)\r\n\t\t\t}\r\n\t\t\tif (Target instanceof Array) {\r\n\t\t\t\treturn Target.forEach(function(Target) {\r\n\t\t\t\t\thasOwn(From, Target)\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tvar ownedClasses = From.ownedClasses || (From.ownedClasses = new WeakMap())\r\n\t\t\t// TODO: assign to super classes\r\n\t\t\townedClasses.set(Target, createInstance || function() {\r\n\t\t\t\treturn new Target()\r\n\t\t\t})\r\n\t\t\treturn From\r\n\t\t}\r\n\t\r\n\t\tvar globalInstances = {}\r\n\t\tfunction getForClass(element, Target) {\r\n\t\t\tvar createInstance\r\n\t\t\twhile (element && !(createInstance = element.constructor.ownedClasses && element.constructor.ownedClasses.get(Target))) {\r\n\t\t\t\telement = element.parentNode || presumptiveParentMap.get(element)\r\n\t\t\t}\r\n\t\t\tif (createInstance) {\r\n\t\t\t\tvar ownedInstances = element.ownedInstances || (element.ownedInstances = new WeakMap())\r\n\t\t\t\tvar instance = ownedInstances.get(Target)\r\n\t\t\t\tif (instance === undefined) {\r\n\t\t\t\t\townedInstances.set(Target, instance = createInstance(element))\r\n\t\t\t\t\tinstance.subject = element\r\n\t\t\t\t}\r\n\t\t\t\treturn instance\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction propertyForElement(key) {\r\n\t\t\t// we just need to establish one Variable class for each element, so we cache it\r\n\t\t\tThisElementVariable = this._Variable\r\n\t\t\tif (!ThisElementVariable) {\r\n\t\t\t\t// need our own branded variable class for this element class\r\n\t\t\t\tThisElementVariable = this._Variable = Variable()\r\n\t\r\n\t\t\t\thasOwn(this, ThisElementVariable, function(element) {\r\n\t\t\t\t\t// TODO: we might want to do this in init instead\r\n\t\t\t\t\tvar instance = new ThisElementVariable(element)\r\n\t\t\t\t\t// we are not observing, because you can't delegate getters and setters in safari\r\n\t\t\t\t\t// instance.observeObject()\r\n\t\t\t\t\tif (element.updaters) {\r\n\t\t\t\t\t\tinstance._properties = {}\r\n\t\t\t\t\t\t// so find any variables and install them in the created instance\r\n\t\t\t\t\t\tfor (var i = 0; i < element.updaters.length; i++){\r\n\t\t\t\t\t\t\tvar updater = element.updaters[i]\r\n\t\t\t\t\t\t\tif (updater.name) {\r\n\t\t\t\t\t\t\t\tinstance._properties[updater.name] = updater.variable\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn instance\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\t// now actually get the property class\r\n\t\t\treturn ThisElementVariable.property(key)\r\n\t\t}\r\n\t\r\n\t\tvar Item = Element.Item = Variable.Item\r\n\t\r\n\t\tfunction enterRenderer(Renderer, options/*, target*/) {\r\n\t\t\t// this will be used for optimized class-level variables\r\n\t\t\t/*if (target.started) { // TODO: Might want to pass in started as a parameter\r\n\t\t\t\t// this means that the updater has already been created, so we just need to add this instance\r\n\t\t\t\tRenderer.prototype.renderUpdate.call(options, element)\r\n\t\t\t} else {*/\r\n\t\t\tvar target = options.element\r\n\t\t\tvar updaters = target.updaters || (target.updaters = [])\r\n\t\t\tupdaters.push(new Renderer(options))\r\n\t\t\t//}\r\n\t\t}\r\n\t\r\n\t\tfunction cleanup(target) {\r\n\t\t\tvar updaters = target.updaters\r\n\t\t\tif (updaters) {\r\n\t\t\t\tfor (var i = 0, l = updaters.length; i < l; i++) {\r\n\t\t\t\t\tupdaters[i].stop()\r\n\t\t\t\t}\r\n\t\t\t\ttarget.needsRestart = true\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction restart(target) {\r\n\t\t\tvar updaters = target.updaters\r\n\t\t\tif (updaters) {\r\n\t\t\t\tfor (var i = 0, l = updaters.length; i < l; i++) {\r\n\t//\t\t\t\tupdaters[i].start()\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t// setup the mutation observer so we can be notified of attachments and removals\r\n\t\tfunction elementAttached(element) {\r\n\t\t\tvar Class = element.constructor\r\n\t\t\tif (Class.create) {\r\n\t/*\t\t\tif (Class.attachedInstances) {\r\n\t\t\t\t\tClass.attachedInstances.push(element)\r\n\t\t\t\t\tif (Class.attachedInstances.length === 1 && Class.needsRestart) {\r\n\t\t\t\t\t\trestart(Class)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tClass.attachedInstances = [element]\r\n\t\t\t\t}*/\r\n\t\t\t\tif (element.attached) {\r\n\t\t\t\t\telement.attached()\r\n\t\t\t\t}\r\n\t\t\t\tif (element.needsRestart) {\r\n\t\t\t\t\trestart(element)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction elementDetached(element) {\r\n\t\t\t/*var attachedInstances = element.constructor.attachedInstances\r\n\t\t\tif (attachedInstances) {\r\n\t\t\t\tvar index = attachedInstances.indexOf(element)\r\n\t\t\t\tif (index > -1) {\r\n\t\t\t\t\tattachedInstances.splice(index, 1)\r\n\t\t\t\t\tif (attachedInstances.length === 0) {\r\n\t\t\t\t\t\tcleanup(Class)\r\n\t\t\t\t\t}\r\n\t\t\t\t}*/\r\n\t\t\t\tif (element.detached) {\r\n\t\t\t\t\telement.detached()\r\n\t\t\t\t}\r\n\t\t\t\tcleanup(element)\r\n\t\t\t//}\r\n\t\t}\r\n\t\tif (typeof MutationObserver === 'function') {\r\n\t\t\tvar docBody = doc.body\r\n\t\t\tvar lifeStates = [{\r\n\t\t\t\tname: 'detached',\r\n\t\t\t\tnodes: 'removedNodes',\r\n\t\t\t\taction: elementDetached\r\n\t\t\t}, {\r\n\t\t\t\tname: 'attached',\r\n\t\t\t\tnodes: 'addedNodes',\r\n\t\t\t\taction: elementAttached\r\n\t\t\t}]\r\n\t\t\tfunction firstVisit(node, state) {\r\n\t\t\t\tif (state.name === 'attached') {\r\n\t\t\t\t\tif (node.__alkaliAttached__) {\r\n\t\t\t\t\t\treturn false\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tnode.__alkaliAttached__ = true\r\n\t\t\t\t\t\tstate.action(node)\r\n\t\t\t\t\t\treturn true\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (node.__alkaliAttached__) {\r\n\t\t\t\t\tif (docBody.contains(node)) {\r\n\t\t\t\t\t\t// detached event, but it is actually still attached (will get attached in a later mutation record)\r\n\t\t\t\t\t\t// so don't get through the detached/attached lifecycle\r\n\t\t\t\t\t\treturn false\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnode.__alkaliAttached__ = false\r\n\t\t\t\t\tstate.action(node)\r\n\t\t\t\t}\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\t\t\tvar observer = new MutationObserver(function(mutations) {\r\n\t\t\t\tfor (var i = 0, il = mutations.length; i < il; i++) {\r\n\t\t\t\t\tvar mutation = mutations[i]\r\n\t\t\t\t\t// invoke action on element if we haven't already\r\n\t\t\t\t\tactionIteration:\r\n\t\t\t\t\tfor (var j = 0, jl = lifeStates.length; j < jl; j++) { // two steps, removed nodes and added nodes\r\n\t\t\t\t\t\tvar state = lifeStates[j]\r\n\t\t\t\t\t\tvar nodes = mutation[state.nodes]\r\n\t\t\t\t\t\t// iterate over node list\r\n\t\t\t\t\t\tnodeIteration:\r\n\t\t\t\t\t\tfor (var k = 0, kl = nodes.length; k < kl; k++) {\r\n\t\t\t\t\t\t\tvar baseNode = nodes[k]\r\n\t\t\t\t\t\t\tif (firstVisit(baseNode, state)) {\r\n\t\t\t\t\t\t\t\t// start traversal with child, if it exists\r\n\t\t\t\t\t\t\t\tvar currentNode = baseNode.firstChild\r\n\t\t\t\t\t\t\t\tif (currentNode) {\r\n\t\t\t\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\t\t\t\tvar nextNode\r\n\t\t\t\t\t\t\t\t\t\tif (currentNode.nodeType === 1 && firstVisit(currentNode, state)) {\r\n\t\t\t\t\t\t\t\t\t\t\t// depth-first search\r\n\t\t\t\t\t\t\t\t\t\t\tnextNode = currentNode.firstChild\r\n\t\t\t\t\t\t\t\t\t\t\tif (!nextNode) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tnextNode = currentNode.nextSibling\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\tnextNode = currentNode.nextSibling\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tif (!nextNode) {\r\n\t\t\t\t\t\t\t\t\t\t\t// come back out to parents\r\n\t\t\t\t\t\t\t\t\t\t\t// TODO: try keeping a stack to make this faster\r\n\t\t\t\t\t\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentNode = currentNode.parentNode\r\n\t\t\t\t\t\t\t\t\t\t\t\tif (currentNode === baseNode) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tcontinue nodeIteration\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t} while (!(nextNode = currentNode.nextSibling))\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tcurrentNode = nextNode\r\n\t\t\t\t\t\t\t\t\t} while (true)\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// if (options.moveLiveElementsEnabled) {\r\n\t\t\t\t\t\t\t// TODO: any options that we can really do here?\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\tobserver.observe(docBody, {\r\n\t\t\t\tchildList: true,\r\n\t\t\t\tsubtree: true\r\n\t\t\t})\r\n\t\t}\r\n\t\r\n\t\treturn Element\r\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\r\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(3)], __WEBPACK_AMD_DEFINE_RESULT__ = function (lang) {\r\n\t\tvar deny = {}\r\n\t\tvar noChange = {}\r\n\t\tvar WeakMap = lang.WeakMap\r\n\t\tvar setPrototypeOf = Object.setPrototypeOf || (function(base, proto) { base.__proto__ = proto})\r\n\t\tvar getPrototypeOf = Object.getPrototypeOf || (function(base) { return base.__proto__ })\r\n\t\t// update types\r\n\t\tvar ToParent = 2\r\n\t\tvar RequestChange = 3\r\n\t\tvar RequestSet = 4\r\n\t\t\r\n\t\tvar ToChild = Object.freeze({\r\n\t\t\ttype: 'refresh'\r\n\t\t})\r\n\t\tvar nextId = 1\r\n\t\tvar propertyListenersMap = new WeakMap(null, 'propertyListenersMap')\r\n\t\r\n\t\tvar CacheEntry = lang.compose(WeakMap, function() {\r\n\t\t},{\r\n\t\t\t_propertyChange: function(propertyName) {\r\n\t\t\t\tthis.variable._propertyChange(propertyName, contextFromCache(this))\r\n\t\t\t}\r\n\t\t})\r\n\t\tvar listenerId = 1\r\n\t\r\n\t\tfunction mergeSubject(context) {\r\n\t\t\tfor (var i = 1, l = arguments.length; i < l; i++) {\r\n\t\t\t\tvar nextContext = arguments[i]\r\n\t\t\t\tif (nextContext !== context && (!context || nextContext && context.contains && context.contains(nextContext))) {\r\n\t\t\t\t\tcontext = nextContext\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn context\r\n\t\t}\r\n\t\r\n\t\tfunction getMaterializedContextualInstance(variable, context) {\r\n\t\t\tvar subject = context && (context.distinctSubject || context.subject)\r\n\t\t\tif (typeof variable === 'function') {\r\n\t\t\t\treturn variable.for(subject)\r\n\t\t\t}\r\n\t\t\tvar contextMap = variable.contextMap\r\n\t\t\tif (context && contextMap) {\r\n\t\t\t\twhile(subject && !contextMap.has(subject)) {\r\n\t\t\t\t\tsubject = subject.parentNode\r\n\t\t\t\t}\r\n\t\t\t\tif (!subject) {\r\n\t\t\t\t\tsubject = defaultContext\r\n\t\t\t\t}\r\n\t\t\t\treturn contextMap.get(subject)\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction when(value, callback) {\r\n\t\t\tif (value && value.then) {\r\n\t\t\t\treturn value.then(callback)\r\n\t\t\t}\r\n\t\t\treturn callback(value)\r\n\t\t}\r\n\t\r\n\t\tfunction Context(subject){\r\n\t\t\tthis.subject = subject\r\n\t\t}\r\n\t\tfunction whenAll(inputs, callback){\r\n\t\t\tvar promiseInvolved\r\n\t\t\tvar needsContext\r\n\t\t\tfor (var i = 0, l = inputs.length; i < l; i++) {\r\n\t\t\t\tif (inputs[i] && inputs[i].then) {\r\n\t\t\t\t\tpromiseInvolved = true\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (promiseInvolved) {\r\n\t\t\t\treturn lang.whenAll(inputs, callback)\r\n\t\t\t}\r\n\t\t\treturn callback(inputs)\r\n\t\t}\r\n\t\r\n\t\tfunction registerListener(value, listener) {\r\n\t\t\tvar listeners = propertyListenersMap.get(value)\r\n\t\t\tvar id = listener.listenerId || (listener.listenerId = ('-' + listenerId++))\r\n\t\t\tif (listeners) {\r\n\t\t\t\tif (listeners[id] === undefined) {\r\n\t\t\t\t\tlisteners[id] = listeners.push(listener) - 1\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\tpropertyListenersMap.set(value, listeners = [listener])\r\n\t\t\t\tlisteners[id] = 0\r\n\t\t\t\tif (Variable.autoObserveObjects) {\r\n\t\t\t\t\tobserve(value)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tlistener.listeningToObject = value\r\n\t\t}\r\n\t\tfunction deregisterListener(listener) {\r\n\t\t\tif (listener.listeningToObject) {\r\n\t\t\t\tvar value = listener.listeningToObject\r\n\t\t\t\tlistener.listeningToObject = null\r\n\t\t\t\tvar listeners = propertyListenersMap.get(value)\r\n\t\t\t\tif (listeners) {\r\n\t\t\t\t\tvar index = listeners[listener.listenerId]\r\n\t\t\t\t\tif (index > -1) {\r\n\t\t\t\t\t\tlisteners.splice(index, 1)\r\n\t\t\t\t\t\tdelete listeners[listener.listenerId]\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction RefreshEvent() {\r\n\t\t\tthis.visited = new Set()\r\n\t\t}\r\n\t\tRefreshEvent.prototype.type = 'refresh'\r\n\t\r\n\t\tfunction PropertyChangeEvent(key, childEvent, parent) {\r\n\t\t\tthis.key = key\r\n\t\t\tthis.childEvent = childEvent\r\n\t\t\tthis.parent = parent\r\n\t\t\tthis.visited = childEvent.visited\r\n\t\t}\r\n\t\tPropertyChangeEvent.prototype.type = 'update'\r\n\t\r\n\t\tfunction AddEvent(args) {\r\n\t\t\tthis.visited = new Set()\r\n\t\t\tfor (var key in args) {\r\n\t\t\t\tthis[key] = args[key]\r\n\t\t\t}\r\n\t\t}\r\n\t\tAddEvent.prototype.type = 'add'\r\n\t\tfunction DeleteEvent(args) {\r\n\t\t\tthis.visited = new Set()\r\n\t\t\tfor (var key in args) {\r\n\t\t\t\tthis[key] = args[key]\r\n\t\t\t}\r\n\t\t}\r\n\t\tDeleteEvent.prototype.type = 'delete'\r\n\t\r\n\t\r\n\t\tfunction Variable(value) {\r\n\t\t\tif (this instanceof Variable) {\r\n\t\t\t\t// new call, may eventually use new.target\r\n\t\t\t\tthis.value = typeof value === 'undefined' ? this.default : value\r\n\t\t\t} else {\r\n\t\t\t\treturn Variable.extend(value)\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar VariablePrototype = Variable.prototype = {\r\n\t\t\tconstructor: Variable,\r\n\t\t\tvalueOf: function(context) {\r\n\t\t\t\tif (this.subject) {\r\n\t\t\t\t\tvar variable = this\r\n\t\t\t\t\tcontext = new Context(this.subject)\r\n\t\t\t\t}\r\n\t\t\t\treturn this.gotValue(this.getValue(context), context)\r\n\t\t\t},\r\n\t\t\tgetValue: function() {\r\n\t\t\t\treturn this.value\r\n\t\t\t},\r\n\t\t\tgotValue: function(value, context) {\r\n\t\t\t\tvar previousNotifyingValue = this.notifyingValue\r\n\t\t\t\tvar variable = this\r\n\t\t\t\tif (value && value.then) {\r\n\t\t\t\t\treturn when(value, function(value) {\r\n\t\t\t\t\t\treturn Variable.prototype.gotValue.call(variable, value, context)\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t\tif (previousNotifyingValue) {\r\n\t\t\t\t\tif (value === previousNotifyingValue) {\r\n\t\t\t\t\t\t// nothing changed, immediately return valueOf (or ownObject if we have it)\r\n\t\t\t\t\t\treturn variable.ownObject || value.valueOf(context)\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// if there was a another value that we were dependent on before, stop listening to it\r\n\t\t\t\t\t// TODO: we may want to consider doing cleanup after the next rendering turn\r\n\t\t\t\t\tif (variable.dependents) {\r\n\t\t\t\t\t\tpreviousNotifyingValue.stopNotifies(variable)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvariable.notifyingValue = null\r\n\t\t\t\t}\r\n\t\t\t\tif (value && value.notifies) {\r\n\t\t\t\t\tif (variable.dependents) {\r\n\t\t\t\t\t\t\t// the value is another variable, start receiving notifications\r\n\t\t\t\t\t\tvalue.notifies(variable)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvariable.notifyingValue = value\r\n\t\t\t\t\tvalue = value.valueOf(context)\r\n\t\t\t\t\tif (variable.ownObject) {\r\n\t\t\t\t\t\tif (getPrototypeOf(variable.ownObject) !== value) {\r\n\t\t\t\t\t\t\tsetPrototypeOf(variable.ownObject, value)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvalue = variable.ownObject\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (value === undefined) {\r\n\t\t\t\t\tvalue = variable.default\r\n\t\t\t\t}\r\n\t\t\t\treturn value\r\n\t\t\t},\r\n\t\t\tisMap: function() {\r\n\t\t\t\treturn this.value instanceof Map\r\n\t\t\t},\r\n\t\t\tproperty: function(key) {\r\n\t\t\t\tvar isMap = this.isMap()\r\n\t\t\t\tvar properties = this._properties || (this._properties = isMap ? new Map() : {})\r\n\t\t\t\tvar propertyVariable = isMap ? properties.get(key) : properties[key]\r\n\t\t\t\tif (!propertyVariable) {\r\n\t\t\t\t\t// create the property variable\r\n\t\t\t\t\tpropertyVariable = new Property(this, key)\r\n\t\t\t\t\tif (isMap) {\r\n\t\t\t\t\t\tproperties.set(key, propertyVariable)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tproperties[key] = propertyVariable\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn propertyVariable\r\n\t\t\t},\r\n\t\t\tfor: function(subject) {\r\n\t\t\t\tif (subject && subject.target && !subject.constructor.getForClass) {\r\n\t\t\t\t\t// makes HTML events work\r\n\t\t\t\t\tsubject = subject.target\r\n\t\t\t\t}\r\n\t\t\t\tif (typeof this === 'function') {\r\n\t\t\t\t\t// this is a class, the subject should hopefully have an entry\r\n\t\t\t\t\tif (subject !== undefined) {\r\n\t\t\t\t\t\tvar instance\r\n\t\t\t\t\t\tif (subject.constructor.getForClass) {\r\n\t\t\t\t\t\t\t// if the subject has it is own means of retrieving an instance\r\n\t\t\t\t\t\t\tinstance = subject.constructor.getForClass(subject, this)\r\n\t\t\t\t\t\t\tif (instance && !instance.subject) {\r\n\t\t\t\t\t\t\t\tinstance.subject = subject\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tif (subject && typeof subject === 'object') {\r\n\t\t\t\t\t\t\t\t// a plain object, we use our own map to retrieve the instance (or create one)\r\n\t\t\t\t\t\t\t\tvar instanceMap = this.instanceMap || (this.instanceMap = new WeakMap())\r\n\t\t\t\t\t\t\t\tinstance = instanceMap.get(subject)\r\n\t\t\t\t\t\t\t\tif (!instance) {\r\n\t\t\t\t\t\t\t\t\tinstanceMap.set(subject, instance = new this(subject))\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// a primitive, just unconditionally create a new variable for it\r\n\t\t\t\t\t\t\t\tinstance = new this(subject)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// TODO: Do we have a global context that we set on defaultInstance?\r\n\t\t\t\t\t\treturn instance || this.defaultInstance\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn this.defaultInstance\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn new ContextualizedVariable(this, subject || defaultContext)\r\n\t\t\t},\r\n\t\t\tdistinctFor: function(subject) {\r\n\t\t\t\tif (typeof this === 'function') {\r\n\t\t\t\t\treturn this.for(subject)\r\n\t\t\t\t}\r\n\t\t\t\tvar map = this.contextMap || (this.contextMap = new WeakMap())\r\n\t\t\t\tif (map.has(subject)) {\r\n\t\t\t\t\treturn map.get(subject)\r\n\t\t\t\t}\r\n\t\t\t\tvar contextualizedVariable\r\n\t\t\t\tmap.set(subject, contextualizedVariable = new ContextualizedVariable(this, subject))\r\n\t\t\t\treturn contextualizedVariable\r\n\t\t\t},\r\n\t\t\t_propertyChange: function(propertyName, object, context, type) {\r\n\t\t\t\tif (this.onPropertyChange) {\r\n\t\t\t\t\tthis.onPropertyChange(propertyName, object, context)\r\n\t\t\t\t}\r\n\t\t\t\tthis.updated(new PropertyChangeEvent(propertyName, new RefreshEvent(), this), null, context)\r\n\t\t\t},\r\n\t\t\teachKey: function(callback) {\r\n\t\t\t\tfor (var i in this._properties) {\r\n\t\t\t\t\tcallback(i)\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tapply: function(instance, args) {\r\n\t\t\t\treturn new Call(this, args)\r\n\t\t\t},\r\n\t\t\tcall: function(instance) {\r\n\t\t\t\treturn this.apply(instance, Array.prototype.slice.call(arguments, 1))\r\n\t\t\t},\r\n\t\t\tforDependencies: function(callback) {\r\n\t\t\t\tif (this.notifyingValue) {\r\n\t\t\t\t\tcallback(this.notifyingValue)\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tinit: function() {\r\n\t\t\t\tif (this.subject) {\r\n\t\t\t\t\tthis.constructor.notifies(this)\r\n\t\t\t\t}\r\n\t\t\t\tvar variable = this\r\n\t\t\t\tthis.forDependencies(function(dependency) {\r\n\t\t\t\t\tdependency.notifies(variable)\r\n\t\t\t\t})\r\n\t\t\t\tif (this.listeningToObject === null) {\r\n\t\t\t\t\t// we were previously listening to an object, but it needs to be restored\r\n\t\t\t\t\t// calling valueOf will cause the listening object to be restored\r\n\t\t\t\t\tthis.valueOf()\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tcleanup: function() {\r\n\t\t\t\tvar handles = this.handles\r\n\t\t\t\tif (handles) {\r\n\t\t\t\t\tfor (var i = 0; i < handles.length; i++) {\r\n\t\t\t\t\t\thandles[i].remove()\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tthis.handles = null\r\n\t\t\t\tvar notifyingValue = this.notifyingValue\r\n\t\t\t\tif (notifyingValue) {\r\n\t\t\t\t\t// TODO: move this into the caching class\r\n\t\t\t\t\tthis.computedVariable = null\r\n\t\t\t\t}\r\n\t\t\t\tvar variable = this\r\n\t\t\t\tthis.forDependencies(function(dependency) {\r\n\t\t\t\t\tdependency.stopNotifies(variable)\r\n\t\t\t\t})\r\n\t\t\t\tif (this.context) {\r\n\t\t\t\t\tthis.constructor.stopNotifies(this)\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\r\n\t\t\tupdateVersion: function(version) {\r\n\t\t\t\tthis.version = nextId++\r\n\t\t\t},\r\n\t\r\n\t\t\tgetVersion: function(context) {\r\n\t\t\t\treturn Math.max(this.version || 0, this.notifyingValue && this.notifyingValue.getVersion ? this.notifyingValue.getVersion(context) : 0)\r\n\t\t\t},\r\n\t\r\n\t\t\tgetSubject: function(selectVariable) {\r\n\t\t\t\treturn this.subject\r\n\t\t\t},\r\n\t\r\n\t\t\tgetUpdates: function(since) {\r\n\t\t\t\tvar updates = []\r\n\t\t\t\tvar nextUpdateMap = this.nextUpdateMap\r\n\t\t\t\tif (nextUpdateMap && since) {\r\n\t\t\t\t\twhile ((since = nextUpdateMap.get(since))) {\r\n\t\t\t\t\t\tif (since.type === 'refresh') {\r\n\t\t\t\t\t\t\t// if it was refresh, we can clear any prior entries\r\n\t\t\t\t\t\t\tupdates = []\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tupdates.push(since)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn updates\r\n\t\t\t},\r\n\t\r\n\t\t\tupdated: function(updateEvent, by, context) {\r\n\t\t\t\tif (!updateEvent) {\r\n\t\t\t\t\tupdateEvent = new RefreshEvent()\r\n\t\t\t\t}\r\n\t\t\t\tif (updateEvent.visited.has(this)){\r\n\t\t\t\t\t// if this event has already visited this variable, skip it\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t\tupdateEvent.visited.add(this)\r\n\t\t\t\tif (this.subject) {\r\n\t\t\t\t\tif (by === this.constructor) {\r\n\t\t\t\t\t\t// if we receive an update from the constructor, filter it\r\n\t\t\t\t\t\tif (!(!context || (context.distinctSubject || context.subject) === this.subject || (context.subject.contains && this.subject.nodeType && context.subject.contains(this.subject)))) {\r\n\t\t\t\t\t\t\treturn\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// if we receive an outside update, send it to the constructor\r\n\t\t\t\t\t\treturn this.constructor.updated(updateEvent, this, new Context(this.subject))\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tvar contextualInstance = getMaterializedContextualInstance(this, context)\r\n\t\t\t\tif (contextualInstance) {\r\n\t\t\t\t\tcontextualInstance.updated(updateEvent, this, context)\r\n\t\t\t\t}\r\n\t\t\t\tif (this.lastUpdate) {\r\n\t\t\t\t\tvar nextUpdateMap = this.nextUpdateMap\r\n\t\t\t\t\tif (!nextUpdateMap) {\r\n\t\t\t\t\t\tnextUpdateMap = this.nextUpdateMap = new WeakMap()\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnextUpdateMap.set(this.lastUpdate, updateEvent)\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.lastUpdate = updateEvent\r\n\t\t\t\tthis.updateVersion()\r\n\t\t\t\tvar value = this.value\r\n\t\r\n\t\t\t\tvar dependents = this.dependents\r\n\t\t\t\tif (dependents) {\r\n\t\t\t\t\t// make a copy, in case they change\r\n\t\t\t\t\tdependents = dependents.slice(0)\r\n\t\t\t\t\tfor (var i = 0, l = dependents.length; i < l; i++) {\r\n\t\t\t\t\t\ttry{\r\n\t\t\t\t\t\t\tvar dependent = dependents[i]\r\n\t\t\t\t\t\t\tif ((updateEvent instanceof PropertyChangeEvent) &&\r\n\t\t\t\t\t\t\t\t\t(dependent instanceof Property)) {\r\n\t\t\t\t\t\t\t\tif (dependent.key === updateEvent.key) {\r\n\t\t\t\t\t\t\t\t\tdependent.updated(updateEvent.childEvent, this, context)\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tdependent.updated(updateEvent, this, context)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}catch(e) {\r\n\t\t\t\t\t\t\tconsole.error(e, e.stack, 'updating a variable')\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (updateEvent instanceof PropertyChangeEvent) {\r\n\t\t\t\t\tif (this.notifyingValue && this.fixed) {\r\n\t\t\t\t\t\tthis.notifyingValue.updated(updateEvent, this, context)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (this.collection) {\r\n\t\t\t\t\t\tthis.collection.updated(updateEvent, this, context)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn updateEvent\r\n\t\t\t},\r\n\t\r\n\t\t\tinvalidate: function() {\r\n\t\t\t\t// for back-compatibility for now\r\n\t\t\t\tthis.updated()\r\n\t\t\t},\r\n\t\r\n\t\t\tnotifies: function(target) {\r\n\t\t\t\tvar dependents = this.dependents\r\n\t\t\t\tif (!dependents || !this.hasOwnProperty('dependents')) {\r\n\t\t\t\t\tthis.dependents = dependents = []\r\n\t\t\t\t\tthis.init()\r\n\t\t\t\t}\r\n\t\t\t\tdependents.push(target)\r\n\t\t\t\tvar variable = this\r\n\t\t\t\treturn {\r\n\t\t\t\t\tunsubscribe: function() {\r\n\t\t\t\t\t\tvariable.stopNotifies(target)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tsubscribe: function(listener) {\r\n\t\t\t\t// ES7 Observable (and baconjs) compatible API\r\n\t\t\t\tvar updated\r\n\t\t\t\tvar updateQueued\r\n\t\t\t\tvar variable = this\r\n\t\t\t\t// it is important to make sure you register for notifications before getting the value\r\n\t\t\t\tif (typeof listener === 'function') {\r\n\t\t\t\t\t// BaconJS compatible API\r\n\t\t\t\t\tvar variable = this\r\n\t\t\t\t\tvar event = {\r\n\t\t\t\t\t\tvalue: function() {\r\n\t\t\t\t\t\t\treturn variable.valueOf()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tupdated = function() {\r\n\t\t\t\t\t\tupdateQueued = false\r\n\t\t\t\t\t\tlistener(event)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\telse if (listener.next) {\r\n\t\t\t\t\t// Assuming ES7 Observable API. It is actually a streaming API, this pretty much violates all principles of reactivity, but we will support it\r\n\t\t\t\t\tupdated = function() {\r\n\t\t\t\t\t\tupdateQueued = false\r\n\t\t\t\t\t\tlistener.next(variable.valueOf())\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow new Error('Subscribing to an invalid listener, the listener must be a function, or have an update or next method')\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar handle = this.notifies({\r\n\t\t\t\t\tupdated: function() {\r\n\t\t\t\t\t\tif (updateQueued) {\r\n\t\t\t\t\t\t\treturn\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tupdateQueued = true\r\n\t\t\t\t\t\tlang.nextTurn(updated)\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t\tvar initialValue = this.valueOf()\r\n\t\t\t\tif (initialValue !== undefined) {\r\n\t\t\t\t\tupdated()\r\n\t\t\t\t}\r\n\t\t\t\treturn handle\r\n\t\t\t},\r\n\t\t\tstopNotifies: function(dependent) {\r\n\t\t\t\tvar dependents = this.dependents\r\n\t\t\t\tif (dependents) {\r\n\t\t\t\t\tfor (var i = 0; i < dependents.length; i++) {\r\n\t\t\t\t\t\tif (dependents[i] === dependent) {\r\n\t\t\t\t\t\t\tdependents.splice(i--, 1)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (dependents.length === 0) {\r\n\t\t\t\t\t\t// clear the dependents so it will be reinitialized if it has\r\n\t\t\t\t\t\t// dependents again\r\n\t\t\t\t\t\tthis.dependents = dependents = false\r\n\t\t\t\t\t\tthis.cleanup()\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tput: function(value, context) {\r\n\t\t\t\tvar variable = this\r\n\t\t\t\tif (this.ownObject) {\r\n\t\t\t\t\tthis.ownObject = false\r\n\t\t\t\t}\t\t\t\r\n\t\t\t\treturn when(this.getValue(context), function(oldValue) {\r\n\t\t\t\t\tif (oldValue === value) {\r\n\t\t\t\t\t\treturn noChange\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (variable.fixed &&\r\n\t\t\t\t\t\t\t// if it is set to fixed, we see we can put in the current variable\r\n\t\t\t\t\t\t\toldValue && oldValue.put) {\r\n\t\t\t\t\t\treturn oldValue.put(value)\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn when(variable.setValue(value, context), function(value) {\r\n\t\t\t\t\t\tvariable.updated(new RefreshEvent(), variable, context)\r\n\t\t\t\t\t})\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tget: function(key) {\r\n\t\t\t\tif (this._properties && this._properties[key]) {\r\n\t\t\t\t\treturn this.property(key).valueOf()\r\n\t\t\t\t}\r\n\t\t\t\treturn when(this.valueOf(), function(object) {\r\n\t\t\t\t\tvar value = object && (typeof object.get === 'function' ? object.get(key) : object[key])\r\n\t\t\t\t\tif (value && value.notifies) {\r\n\t\t\t\t\t\t// nested variable situation, get underlying value\r\n\t\t\t\t\t\treturn value.valueOf()\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn value\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tset: function(key, value) {\r\n\t\t\t\t// TODO: create an optimized route when the property doesn't exist yet\r\n\t\t\t\tthis.property(key)._changeValue(null, RequestSet, value)\r\n\t\t\t},\r\n\t\t\tundefine: function(key, context) {\r\n\t\t\t\tthis.set(key, undefined, context)\r\n\t\t\t},\r\n\t\t\tproxy: function(proxiedVariable) {\r\n\t\t\t\tvar thisVariable = this\r\n\t\t\t\tthis.fixed = true\r\n\t\t\t\treturn when(this.setValue(proxiedVariable), function(value) {\r\n\t\t\t\t\tthisVariable.updated(new RefreshEvent(), thisVariable)\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tnext: function(value) {\r\n\t\t\t\t// for ES7 observable compatibility\r\n\t\t\t\tthis.put(value)\r\n\t\t\t},\r\n\t\t\terror: function(error) {\r\n\t\t\t\t// for ES7 observable compatibility\r\n\t\t\t\tvar dependents = this.dependents\r\n\t\t\t\tif (dependents) {\r\n\t\t\t\t\t// make a copy, in case they change\r\n\t\t\t\t\tdependents = dependents.slice(0)\r\n\t\t\t\t\tfor (var i = 0, l = dependents.length; i < l; i++) {\r\n\t\t\t\t\t\ttry{\r\n\t\t\t\t\t\t\tvar dependent = dependents[i]\r\n\t\t\t\t\t\t\t// skip notifying property dependents if we are headed up the parent chain\r\n\t\t\t\t\t\t\tdependent.error(error)\r\n\t\t\t\t\t\t}catch(e) {\r\n\t\t\t\t\t\t\tconsole.error(e, 'sending an error')\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tcomplete: function(value) {\r\n\t\t\t\t// for ES7 observable compatibility\r\n\t\t\t\tthis.put(value)\r\n\t\t\t},\r\n\t\t\tsetValue: function(value) {\r\n\t\t\t\tthis.value = value\r\n\t\t\t},\r\n\t\t\tonValue: function(listener) {\r\n\t\t\t\treturn this.subscribe(function(event) {\r\n\t\t\t\t\tlang.when(event.value(), function(value) {\r\n\t\t\t\t\t\tlistener(value)\r\n\t\t\t\t\t})\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tforEach: function(callbackOrItemClass, callbackOrContext, context) {\r\n\t\t\t\t// iterate through current value of variable\r\n\t\t\t\tif (callbackOrItemClass.notifies) {\r\n\t\t\t\t\tvar collectionVariable = this\r\n\t\t\t\t\tthis.forEach(function(item) {\r\n\t\t\t\t\t\tvar itemVariable = callbackOrItemClass.for(item)\r\n\t\t\t\t\t\titemVariable.collection = collectionVariable\r\n\t\t\t\t\t\tcallbackOrContext.call(this, itemVariable)\r\n\t\t\t\t\t}, context)\r\n\t\t\t\t}\r\n\t\t\t\treturn when(this.valueOf(callbackOrContext), function(value) {\r\n\t\t\t\t\tif (value && value.forEach) {\r\n\t\t\t\t\t\tvalue.forEach(callbackOrItemClass)\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tfor (var i in value) {\r\n\t\t\t\t\t\t\tcallbackOrItemClass.call(value, value[i], i)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\r\n\t\t\tto: function (transformFunction, reverse) {\r\n\t\t\t\tif (typeof transformFunction !== 'function') {\r\n\t\t\t\t\tif (typeof transformFunction === 'object') {\r\n\t\t\t\t\t\tthis.to(transformFunction.forward, transformFunction.reverse)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthrow new Error('No function provided to transform')\r\n\t\t\t\t}\r\n\t\t\t\tif (reverse) {\r\n\t\t\t\t\ttransformFunction.reverse = function(value, args, context) {\r\n\t\t\t\t\t\t// for direct to, we can just use the first argument\r\n\t\t\t\t\t\treverse.call(this, args[0], context)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn new Call(transformFunction, [this])\r\n\t\t\t},\r\n\t\t\tget schema() {\r\n\t\t\t\t// default schema is the constructor\r\n\t\t\t\treturn this.notifyingValue ? this.notifyingValue.schema : this.constructor\r\n\t\t\t},\r\n\t\t\tset schema(schema) {\r\n\t\t\t\t// but allow it to be overriden\r\n\t\t\t\tObject.defineProperty(this, 'schema', {\r\n\t\t\t\t\tvalue: schema\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tvalidate: function(target, schema) {\r\n\t\t\t\tif (this.notifyingValue) {\r\n\t\t\t\t\treturn this.notifyingValue.validate(target, schema)\r\n\t\t\t\t}\r\n\t\t\t\tif (schema.type && (schema.type !== typeof target)) {\r\n\t\t\t\t\treturn ['Target type of ' + typeof target + ' does not match schema type of ' + schema.type]\r\n\t\t\t\t}\r\n\t\t\t\tvar valid = []\r\n\t\t\t\tvalid.isValid = true\r\n\t\t\t\treturn valid\r\n\t\t\t},\r\n\t\r\n\t\t\tget validation() {\r\n\t\t\t\tvar validation = new Validating(this)\r\n\t\t\t\tObject.defineProperty(this, 'validation', {\r\n\t\t\t\t\tvalue: validation\r\n\t\t\t\t})\r\n\t\t\t\treturn validation\r\n\t\t\t},\r\n\t\t\tset validation(validation) {\r\n\t\t\t\t// but allow it to be overriden\r\n\t\t\t\tObject.defineProperty(this, 'validation', {\r\n\t\t\t\t\tvalue: validation\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tgetId: function() {\r\n\t\t\t\treturn this.id || (this.id = nextId++)\r\n\t\t\t},\r\n\t\t\tobserveObject: function() {\r\n\t\t\t\tvar variable = this\r\n\t\t\t\treturn when(this.valueOf(), function(object) {\r\n\t\t\t\t\tvar listeners = propertyListenersMap.get(object)\r\n\t\t\t\t\tif (!listeners) {\r\n\t\t\t\t\t\tpropertyListenersMap.set(object, listeners = [])\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (listeners.observerCount) {\r\n\t\t\t\t\t\tlisteners.observerCount++\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tlisteners.observerCount = 1\r\n\t\t\t\t\t\tvar observer = listeners.observer = lang.observe(object, function(events) {\r\n\t\t\t\t\t\t\tfor (var i = 0, l = listeners.length; i < l; i++) {\r\n\t\t\t\t\t\t\t\tvar listener = listeners[i]\r\n\t\t\t\t\t\t\t\tfor (var j = 0, el = events.length; j < el; j++) {\r\n\t\t\t\t\t\t\t\t\tvar event = events[j]\r\n\t\t\t\t\t\t\t\t\tlistener._propertyChange(event.name, object)\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t\tif (observer.addKey) {\r\n\t\t\t\t\t\t\tfor (var i = 0, l = listeners.length; i < l; i++) {\r\n\t\t\t\t\t\t\t\tvar listener = listeners[i]\r\n\t\t\t\t\t\t\t\tlistener.eachKey(function(key) {\r\n\t\t\t\t\t\t\t\t\tobserver.addKey(key)\r\n\t\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tregisterListener(object, variable)\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tremove: function() {\r\n\t\t\t\t\t\t\tderegisterListener(object, variable)\r\n\t\t\t\t\t\t\tif (!(--listeners.observerCount)) {\r\n\t\t\t\t\t\t\t\tlisteners.observer.remove()\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tdone: function() {\r\n\t\t\t\t\t\t\t// deliver changes\r\n\t\t\t\t\t\t\tlang.deliverChanges(observer)\r\n\t\t\t\t\t\t\tthis.remove()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\t_willModify: function(context) {\r\n\t\t\t\t// an intent to modify, so we need to make sure we have our own copy\r\n\t\t\t\t// of an object when necessary\r\n\t\t\t\tif (this.fixed) {\r\n\t\t\t\t\tif (this.value && this.value._willModify) {\r\n\t\t\t\t\t\treturn this.value._willModify(context)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (!this.ownObject && this.value && this.value.notifies) {\r\n\t\t\t\t\tvar variable = this\r\n\t\t\t\t\treturn when(this.valueOf(context), function(value) {\r\n\t\t\t\t\t\tif (value && typeof value === 'object') {\r\n\t\t\t\t\t\t\tif (value instanceof Array) {\r\n\t\t\t\t\t\t\t\tvariable.ownObject = value.slice(0)\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tvariable.ownObject = Object.create(value)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tsplice: function(startingIndex, removalCount) {\r\n\t\t\t\tvar args = arguments\r\n\t\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\t\tvar results = array.splice.apply(array, args)\r\n\t\t\t\t\tremovedAt(this, results, startingIndex, removalCount, array.length)\r\n\t\t\t\t\tinsertedAt(this, [].slice.call(args, 2), startingIndex, array.length)\r\n\t\t\t\t\treturn results\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tpush: function() {\r\n\t\t\t\tvar args = arguments\r\n\t\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\t\tvar results = array.push.apply(array, args)\r\n\t\t\t\t\tinsertedAt(this, args, array.length - args.length, array.length)\r\n\t\t\t\t\treturn results\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tunshift: function() {\r\n\t\t\t\tvar args = arguments\r\n\t\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\t\tvar results = array.unshift.apply(array, args)\r\n\t\t\t\t\tinsertedAt(this, args, 0, array.length)\r\n\t\t\t\t\treturn results\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tpop: function() {\r\n\t\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\t\tvar results = array.pop()\r\n\t\t\t\t\tremovedAt(this, [results], array.length, 1)\r\n\t\t\t\t\treturn results\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tshift: function() {\r\n\t\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\t\tvar results = array.shift()\r\n\t\t\t\t\tremovedAt(this, [results], 0, 1, array.length)\r\n\t\t\t\t\treturn results\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction arrayToModify(variable, callback) {\r\n\t\t\tvariable._willModify()\r\n\t\t\t// TODO: switch this to allow promises\r\n\t\t\twhen(variable.cachedValue || variable.valueOf(), function(array) {\r\n\t\t\t\tif (!array) {\r\n\t\t\t\t\tvariable.put(array = [])\r\n\t\t\t\t}\r\n\t\t\t\tvariable.updateVersion()\r\n\t\t\t\tvar results = callback.call(variable, array)\r\n\t\t\t\tvariable.cachedVersion = variable.version // update the cached version so it doesn't need to be recomputed\r\n\t\t\t\treturn results\r\n\t\t\t})\r\n\t\t}\r\n\t\r\n\t\tfunction insertedAt(variable, added, startingIndex, arrayLength) {\r\n\t\t\tvar addedCount = added.length\r\n\t\t\t// adjust the key positions of any index properties after splice\r\n\t\t\tif (addedCount > 0) {\r\n\t\t\t\tif (variable._properties) {\r\n\t\t\t\t\tvar arrayPosition\r\n\t\t\t\t\tfor (var i = arrayLength - addedCount; i > startingIndex;) {\r\n\t\t\t\t\t\tvar arrayPosition = variable._properties[--i]\r\n\t\t\t\t\t\tif (arrayPosition) {\r\n\t\t\t\t\t\t\tvariable._properties[i] = undefined\r\n\t\t\t\t\t\t\tarrayPosition.key += addedCount\r\n\t\t\t\t\t\t\tvariable._properties[arrayPosition.key] = arrayPosition\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// send out updates\r\n\t\t\t\tfor (var i = 0, l = added.length; i < l; i++) {\r\n\t\t\t\t\tvariable.updated(new AddEvent({\r\n\t\t\t\t\t\tvalue: added[i],\r\n\t\t\t\t\t\tindex: i + startingIndex,\r\n\t\t\t\t\t\tmodifier: variable\r\n\t\t\t\t\t}), variable)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction removedAt(variable, removed, startingIndex, removalCount, arrayLength) {\r\n\t\t\t// adjust the properties\r\n\t\t\tvar i = startingIndex + removalCount\r\n\t\t\tvar arrayPosition\r\n\t\t\tif (removalCount > 0) {\r\n\t\t\t\tif (variable._properties) {\r\n\t\t\t\t\tfor (var i = startingIndex + removalCount; i < arrayLength + removalCount; i++) {\r\n\t\t\t\t\t\tvar arrayPosition = variable._properties[i]\r\n\t\t\t\t\t\tif (arrayPosition) {\r\n\t\t\t\t\t\t\tvariable._properties[i] = undefined\r\n\t\t\t\t\t\t\tarrayPosition.key -= removalCount\r\n\t\t\t\t\t\t\tvariable._properties[arrayPosition.key] = arrayPosition\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// send out updates\r\n\t\t\t\tfor (var i = 0; i < removalCount; i++) {\r\n\t\t\t\t\tvariable.updated(new DeleteEvent({\r\n\t\t\t\t\t\tpreviousIndex: startingIndex,\r\n\t\t\t\t\t\toldValue: removed[i],\r\n\t\t\t\t\t\tmodifier: variable\r\n\t\t\t\t\t}), variable)\r\n\t\t\t\t}\r\n\t\t\t\tvariable.cachedVersion = variable.version // update the cached version so it doesn't need to be recomputed\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tif (typeof Symbol !== 'undefined') {\r\n\t\t\tVariable.prototype[Symbol.iterator] = function() {\r\n\t\t\t\treturn this.valueOf()[Symbol.iterator]()\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tVariable.VMap = lang.compose(Variable, function(value){\r\n\t\t\tthis.value = typeof value === 'undefined' ? this.default : value\r\n\t\t}, {\r\n\t\t\t// TODO: Move all the get and set functionality for maps out of Variable\r\n\t\t\tproperty: function(key) {\r\n\t\t\t\tvar properties = this._properties || (this._properties = new Map())\r\n\t\t\t\tvar propertyVariable = properties.get(key)\r\n\t\t\t\tif (!propertyVariable) {\r\n\t\t\t\t\t// create the property variable\r\n\t\t\t\t\tpropertyVariable = new Property(this, key)\r\n\t\t\t\t\tproperties.set(key, propertyVariable)\r\n\t\t\t\t}\r\n\t\t\t\treturn propertyVariable\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\tvar cacheNotFound = {}\r\n\t\tvar Caching = Variable.Caching = lang.compose(Variable, function(getValue, setValue) {\r\n\t\t\tif (getValue) {\r\n\t\t\t\tthis.getValue = getValue\r\n\t\t\t}\r\n\t\t\tif (setValue) {\r\n\t\t\t\tthis.setValue = setValue\r\n\t\t\t}\r\n\t\t}, {\r\n\t\t\tvalueOf: function(context) {\r\n\t\t\t\t// first check to see if we have the variable already computed\r\n\t\t\t\tif (this.cachedVersion === this.getVersion()) {\r\n\t\t\t\t\tif (this.contextMap) {\r\n\t\t\t\t\t\tvar contextualizedVariable = getMaterializedContextualInstance(this, context)\r\n\t\t\t\t\t\tif (contextualizedVariable) {\r\n\t\t\t\t\t\t\treturn contextualizedVariable.cachedValue\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn this.cachedValue\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tvar variable = this\r\n\t\r\n\t\t\t\tfunction withComputedValue(computedValue) {\r\n\t\t\t\t\tif (computedValue && computedValue.notifies && variable.dependents) {\r\n\t\t\t\t\t\tvariable.computedVariable = computedValue\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcomputedValue = variable.gotValue(computedValue, watchedContext)\r\n\t\t\t\t\tvar contextualizedVariable\r\n\t\t\t\t\tif (watchedContext && watchedContext.distinctSubject) {\r\n\t\t\t\t\t\t(variable.contextMap || (variable.contextMap = new WeakMap()))\r\n\t\t\t\t\t\t\t.set(watchedContext.distinctSubject,\r\n\t\t\t\t\t\t\t\tcontextualizedVariable = new ContextualizedVariable(variable, watchedContext.distinctSubject))\r\n\t\t\t\t\t\tcontext.distinctSubject = mergeSubject(context.distinctSubject, watchedContext.distinctSubject)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tcontextualizedVariable = variable\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcontextualizedVariable.cachedVersion = newVersion\r\n\t\t\t\t\tcontextualizedVariable.cachedValue = computedValue\r\n\t\t\t\t\treturn computedValue\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar watchedContext\r\n\t\t\t\tif (context) {\r\n\t\t\t\t\twatchedContext = new Context(context.subject)\r\n\t\t\t\t}\r\n\t\t\t\tvar newVersion = this.getVersion()\r\n\t\t\t\tvar computedValue = this.getValue(watchedContext)\r\n\t\t\t\tif (computedValue && computedValue.then) {\r\n\t\t\t\t\treturn computedValue.then(withComputedValue)\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn withComputedValue(computedValue)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\tfunction GetCache() {\r\n\t\t}\r\n\t\r\n\t\tvar Property = lang.compose(Variable, function Property(parent, key) {\r\n\t\t\tthis.parent = parent\r\n\t\t\tthis.key = key\r\n\t\t},\r\n\t\t{\r\n\t\t\tforDependencies: function(callback) {\r\n\t\t\t\tVariable.prototype.forDependencies.call(this, callback)\r\n\t\t\t\tcallback(this.parent)\r\n\t\t\t},\r\n\t\t\tvalueOf: function(context) {\r\n\t\t\t\tif (this.value) {\r\n\t\t\t\t\treturn Variable.prototype.valueOf.call(this, context)\r\n\t\t\t\t}\r\n\t\t\t\tvar key = this.key\r\n\t\t\t\tvar property = this\r\n\t\t\t\tvar object = this.parent.valueOf(context)\r\n\t\t\t\tfunction gotValueAndListen(object) {\r\n\t\t\t\t\tif (property.dependents) {\r\n\t\t\t\t\t\tvar listeners = propertyListenersMap.get(object)\r\n\t\t\t\t\t\tif (listeners && listeners.observer && listeners.observer.addKey) {\r\n\t\t\t\t\t\t\tlisteners.observer.addKey(key)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar value = property.gotValue(object == null ? undefined : typeof object.get === 'function' ? object.get(key) : object[key])\r\n\t\t\t\t\treturn value\r\n\t\t\t\t}\r\n\t\t\t\tif (object && object.then) {\r\n\t\t\t\t\treturn when(object, gotValueAndListen)\r\n\t\t\t\t}\r\n\t\t\t\treturn gotValueAndListen(object)\r\n\t\t\t},\r\n\t\t\tput: function(value, context) {\r\n\t\t\t\treturn this._changeValue(context, RequestChange, value)\r\n\t\t\t},\r\n\t\t\tparentUpdated: function(updateEvent, context) {\r\n\t\t\t\treturn Variable.prototype.updated.call(this, updateEvent, this.parent, context)\r\n\t\t\t},\r\n\t\t\tupdated: function(updateEvent, by, context) {\r\n\t\t\t\tif (updateEvent = Variable.prototype.updated.call(this, updateEvent, by, context)) {\r\n\t\t\t\t\tthis.parent.updated(new PropertyChangeEvent(this.key, updateEvent, this.parent), this, context)\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\t_changeValue: function(context, type, newValue) {\r\n\t\t\t\tvar key = this.key\r\n\t\t\t\tvar parent = this.parent\r\n\t\t\t\tvar variable = this\r\n\t\t\t\tif (this.value) {\r\n\t\t\t\t\tif (type === RequestChange) {\r\n\t\t\t\t\t\t// put() go into the existing variable, if it has one\r\n\t\t\t\t\t\tthis.value.put(newValue)\r\n\t\t\t\t\t\treturn\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.value = null\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tparent._willModify(context)\r\n\t\t\t\treturn when(parent.valueOf(context), function(object) {\r\n\t\t\t\t\tif (object == null) {\r\n\t\t\t\t\t\t// nothing there yet, create an object to hold the new property\r\n\t\t\t\t\t\tvar response = parent.put(object = typeof key == 'number' ? [] : {}, context)\r\n\t\t\t\t\t} else if (typeof object != 'object') {\r\n\t\t\t\t\t\t// if the parent is not an object, we can't set anything (that will be retained)\r\n\t\t\t\t\t\treturn deny\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (newValue && newValue.put) {\r\n\t\t\t\t\t\tvariable.value = newValue\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar oldValue = typeof object.get === 'function' ? object.get(key) : object[key]\r\n\t\t\t\t\t/*if (oldValue === newValue) {\r\n\t\t\t\t\t\t// no actual change to make\r\n\t\t\t\t\t\treturn noChange\r\n\t\t\t\t\t}*/\r\n\t\t\t\t\tif (typeof object.set === 'function') {\r\n\t\t\t\t\t\tobject.set(key, newValue)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (type == RequestChange && oldValue && oldValue.put) {\r\n\t\t\t\t\t\t\t// if a put and the property value is a variable, assign it to that.\r\n\t\t\t\t\t\t\toldValue.put(newValue)\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tobject[key] = newValue && newValue.valueOf(context)\r\n\t\t\t\t\t\t\t// or set the setter/getter\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvariable.updated(null, variable, context)\r\n\t\r\n\t\t\t\t\t// now notify any object listeners\r\n\t\t\t\t\tvar listeners = propertyListenersMap.get(object)\r\n\t\t\t\t\t// we need to do it before the other listeners, so we can update it before\r\n\t\t\t\t\t// we trigger a full clobbering of the object\r\n\t\t\t\t\tif (listeners) {\r\n\t\t\t\t\t\tlisteners = listeners.slice(0)\r\n\t\t\t\t\t\tfor (var i = 0, l = listeners.length; i < l; i++) {\r\n\t\t\t\t\t\t\tvar listener = listeners[i]\r\n\t\t\t\t\t\t\tif (listener !== parent) {\r\n\t\t\t\t\t\t\t\t// now go ahead and actually trigger the other listeners (but make sure we don't do the parent again)\r\n\t\t\t\t\t\t\t\tlistener._propertyChange(key, object, context, type)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\t_willModify: function() {\r\n\t\t\t\tthis.parent._willModify()\r\n\t\t\t\treturn Variable.prototype._willModify.call(this)\r\n\t\t\t},\r\n\t\t\tvalidate: function(target, schema) {\r\n\t\t\t\treturn this.parent.validate(target.valueOf(), schema)\r\n\t\t\t}\r\n\t\t})\r\n\t\tObject.defineProperty(Property.prototype, 'schema', {\r\n\t\t\tget: function() {\r\n\t\t\t\tvar parentSchemaProperties = this.parent.schema.properties\r\n\t\t\t\treturn parentSchemaProperties && parentSchemaProperties[this.key]\r\n\t\t\t},\r\n\t\t\tset: function(schema) {\r\n\t\t\t\t// have to repeat the override\r\n\t\t\t\tObject.defineProperty(this, 'schema', {\r\n\t\t\t\t\tvalue: schema\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t})\r\n\t\tVariable.Property = Property\r\n\t\r\n\t\tvar Item = Variable.Item = lang.compose(Variable, function Item(value, content) {\r\n\t\t\tthis.value = value\r\n\t\t\tthis.collection = content\r\n\t\t}, {})\r\n\t\r\n\t\tvar Composite = Variable.Composite = lang.compose(Caching, function Composite(args) {\r\n\t\t\tthis.args = args\r\n\t\t}, {\r\n\t\t\tforDependencies: function(callback) {\r\n\t\t\t\t// depend on the args\r\n\t\t\t\tCaching.prototype.forDependencies.call(this, callback)\r\n\t\t\t\tvar args = this.args\r\n\t\t\t\tfor (var i = 0, l = args.length; i < l; i++) {\r\n\t\t\t\t\tvar arg = args[i]\r\n\t\t\t\t\tif (arg && arg.notifies) {\r\n\t\t\t\t\t\tcallback(arg)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\r\n\t\t\tupdated: function(updateEvent, by, context) {\r\n\t\t\t\tvar args = this.args\r\n\t\t\t\tif (by !== this.notifyingValue && updateEvent && updateEvent.type !== 'refresh') {\r\n\t\t\t\t\t// using a painful search instead of indexOf, because args may be an arguments object\r\n\t\t\t\t\tfor (var i = 0, l = args.length; i < l; i++) {\r\n\t\t\t\t\t\tvar arg = args[i]\r\n\t\t\t\t\t\tif (arg === by) {\r\n\t\t\t\t\t\t\t// if one of the args was updated, we need to do a full refresh (we can't compute differential events without knowledge of how the mapping function works)\r\n\t\t\t\t\t\t\tupdateEvent = new RefreshEvent()\r\n\t\t\t\t\t\t\tcontinue\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn Caching.prototype.updated.call(this, updateEvent, by, context)\r\n\t\t\t},\r\n\t\r\n\t\t\tgetUpdates: function(since) {\r\n\t\t\t\t// this always issues updates, nothing incremental can flow through it\r\n\t\t\t\tif (!since || since.version < getVersion()) {\r\n\t\t\t\t\treturn [new RefreshEvent()]\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\r\n\t\t\tgetVersion: function(context) {\r\n\t\t\t\tvar args = this.args\r\n\t\t\t\tvar version = Variable.prototype.getVersion.call(this, context)\r\n\t\t\t\tfor (var i = 0, l = args.length; i < l; i++) {\r\n\t\t\t\t\tvar arg = args[i]\r\n\t\t\t\t\tif (arg && arg.getVersion) {\r\n\t\t\t\t\t\tversion = Math.max(version, arg.getVersion(context))\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn version\r\n\t\t\t},\r\n\t\r\n\t\t\tgetValue: function(context) {\r\n\t\t\t\tvar results = []\r\n\t\t\t\tvar args = this.args\r\n\t\t\t\tfor (var i = 0, l = args.length; i < l; i++) {\r\n\t\t\t\t\tvar arg = args[i]\r\n\t\t\t\t\tresults[i] = arg && arg.valueOf(context)\r\n\t\t\t\t}\r\n\t\t\t\treturn whenAll(results, function(resolved) {\r\n\t\t\t\t\treturn resolved\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\t// a call variable is the result of a call\r\n\t\tvar Call = lang.compose(Composite, function Call(functionVariable, args) {\r\n\t\t\tthis.functionVariable = functionVariable\r\n\t\t\tthis.args = args\r\n\t\t}, {\r\n\t\t\tfixed: true,\r\n\t\t\tforDependencies: function(callback) {\r\n\t\t\t\t// depend on the args\r\n\t\t\t\tComposite.prototype.forDependencies.call(this, callback)\r\n\t\t\t\tif (this.functionVariable.notifies) {\r\n\t\t\t\t\tcallback(this.functionVariable)\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\r\n\t\t\tgetValue: function(context) {\r\n\t\t\t\tvar functionValue = this.functionVariable.valueOf(context)\r\n\t\t\t\tif (functionValue.then) {\r\n\t\t\t\t\tvar call = this\r\n\t\t\t\t\treturn functionValue.then(function(functionValue) {\r\n\t\t\t\t\t\treturn call.invoke(functionValue, call.args, context)\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t\treturn this.invoke(functionValue, this.args, context)\r\n\t\t\t},\r\n\t\r\n\t\t\tgetVersion: function(context) {\r\n\t\t\t\t// TODO: shortcut if we are live and since equals this.lastUpdate\r\n\t\t\t\tvar argsVersion = Composite.prototype.getVersion.call(this, context)\r\n\t\t\t\tif (this.functionVariable.getVersion) {\r\n\t\t\t\t\treturn Math.max(argsVersion, this.functionVariable.getVersion(context))\r\n\t\t\t\t}\r\n\t\t\t\treturn argsVersion\r\n\t\t\t},\r\n\t\r\n\t\t\texecute: function(context) {\r\n\t\t\t\tvar call = this\r\n\t\t\t\treturn when(this.functionVariable.valueOf(context), function(functionValue) {\r\n\t\t\t\t\treturn call.invoke(functionValue, call.args, context, true)\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\r\n\t\t\tput: function(value, context) {\r\n\t\t\t\tvar call = this\r\n\t\t\t\treturn when(this.valueOf(context), function(originalValue) {\r\n\t\t\t\t\tif (originalValue === value) {\r\n\t\t\t\t\t\treturn noChange\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn when(call.functionVariable.valueOf(context), function(functionValue) {\r\n\t\t\t\t\t\treturn call.invoke(function() {\r\n\t\t\t\t\t\t\tif (functionValue.reverse) {\r\n\t\t\t\t\t\t\t\tfunctionValue.reverse.call(call, value, call.args, context)\r\n\t\t\t\t\t\t\t\treturn Variable.prototype.put.call(call, value, context)\r\n\t\t\t\t\t\t\t} else if (originalValue && originalValue.put) {\r\n\t\t\t\t\t\t\t\treturn originalValue.put(value)\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\treturn deny\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}, call.args, context)\r\n\t\t\t\t\t});\t\t\t\t\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tinvoke: function(functionValue, args, context, observeArguments) {\r\n\t\t\t\tvar instance = this.functionVariable.parent\r\n\t\t\t\tif (functionValue.handlesVariables || functionValue.property) {\r\n\t\t\t\t\treturn functionValue.apply(instance, args, context)\r\n\t\t\t\t}else{\r\n\t\t\t\t\tvar results = []\r\n\t\t\t\t\tfor (var i = 0, l = args.length; i < l; i++) {\r\n\t\t\t\t\t\tvar arg = args[i]\r\n\t\t\t\t\t\tresults[i] = arg && arg.valueOf(context)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tinstance = instance && instance.valueOf(context)\r\n\t\t\t\t\tif (functionValue.handlesPromises) {\r\n\t\t\t\t\t\treturn functionValue.apply(instance, results, context)\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\t// include the instance in whenAll\r\n\t\t\t\t\t\tresults.push(instance)\r\n\t\t\t\t\t\t// wait for the values to be received\r\n\t\t\t\t\t\treturn whenAll(results, function(inputs) {\r\n\t\t\t\t\t\t\tif (observeArguments) {\r\n\t\t\t\t\t\t\t\tvar handles = []\r\n\t\t\t\t\t\t\t\tfor (var i = 0, l = inputs.length; i < l; i++) {\r\n\t\t\t\t\t\t\t\t\tvar input = inputs[i]\r\n\t\t\t\t\t\t\t\t\tif (input && typeof input === 'object') {\r\n\t\t\t\t\t\t\t\t\t\thandles.push(observe(input))\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tvar instance = inputs.pop()\r\n\t\t\t\t\t\t\t\ttry{\r\n\t\t\t\t\t\t\t\t\tvar result = functionValue.apply(instance, inputs, context)\r\n\t\t\t\t\t\t\t\t}finally{\r\n\t\t\t\t\t\t\t\t\twhen(result, function() {\r\n\t\t\t\t\t\t\t\t\t\tfor (var i = 0; i < l; i++) {\r\n\t\t\t\t\t\t\t\t\t\t\thandles[i].done()\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\treturn result\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tvar instance = inputs.pop()\r\n\t\t\t\t\t\t\treturn functionValue.apply(instance, inputs, context)\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tsetReverse: function(reverse) {\r\n\t\t\t\tthis.functionVariable.valueOf().reverse = reverse\r\n\t\t\t\treturn this\r\n\t\t\t}\r\n\t\t})\r\n\t\tVariable.Call = Call\r\n\t\r\n\t\tvar ContextualizedVariable = lang.compose(Variable, function ContextualizedVariable(Source, subject) {\r\n\t\t\tthis.constructor = Source\r\n\t\t\tthis.subject = subject\r\n\t\t}, {\r\n\t\t\tvalueOf: function() {\r\n\t\t\t\treturn this.constructor.valueOf(new Context(this.subject))\r\n\t\t\t},\r\n\t\r\n\t\t\tput: function(value) {\r\n\t\t\t\treturn this.constructor.put(value, new Context(this.subject))\r\n\t\t\t},\r\n\t\t\tparentUpdated: function(event, context) {\r\n\t\t\t\t// if we receive an outside update, send it to the constructor\r\n\t\t\t\tthis.constructor.updated(event, this.parent, this.context)\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\r\n\t\tfunction iterateMethod(method) {\r\n\t\t\tVariable.prototype[method] = function() {\r\n\t\t\t\treturn new IterativeMethod(this, method, arguments)\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\titerateMethod('filter')\r\n\t\titerateMethod('map')\r\n\t\titerateMethod('reduce')\r\n\t\titerateMethod('reduceRight')\r\n\t\titerateMethod('some')\r\n\t\titerateMethod('every')\r\n\t\titerateMethod('slice')\r\n\t\t\r\n\t\tvar IterativeMethod = lang.compose(Composite, function(source, method, args) {\r\n\t\t\tthis.source = source\r\n\t\t\t// source.interestWithin = true\r\n\t\t\tthis.method = method\r\n\t\t\tthis.args = args\r\n\t\t}, {\r\n\t\t\tgetValue: function(context) {\r\n\t\t\t\tvar method = this.method\r\n\t\t\t\tvar args = this.args\r\n\t\t\t\tvar variable = this\r\n\t\t\t\treturn when(this.source.valueOf(context), function(array) {\r\n\t\t\t\t\tif (array && array.forEach) {\r\n\t\t\t\t\t\tif (variable.dependents) {\r\n\t\t\t\t\t\t\tvar contextualizedVariable\r\n\t\t\t\t\t\t\tif (context) {\r\n\t\t\t\t\t\t\t\tvar contextMap = variable.contextMap || (variable.contextMap = new WeakMap())\r\n\t\t\t\t\t\t\t\tif (contextMap.has(context.distinctSubject)) {\r\n\t\t\t\t\t\t\t\t\tcontextualizedVariable = contextMap.get(context.distinctSubject)\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tcontextMap.set(context.distinctSubject, contextualizedVariable = new ContextualizedVariable(variable, context.distinctSubject))\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tcontextualizedVariable = variable\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (method === 'map'){\r\n\t\t\t\t\t\t\t// fast path, and special behavior for map\r\n\t\t\t\t\t\t\treturn args[0](array)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// if not an array convert to an array\r\n\t\t\t\t\t\tarray = [array]\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// apply method\r\n\t\t\t\t\treturn array[method].apply(array, args)\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tupdated: function(event, by, context) {\r\n\t\t\t\tif (!event || event.modifier === this || (event.modifier && event.modifier.constructor === this)) {\r\n\t\t\t\t\treturn Composite.prototype.updated.call(this, event, by, context)\r\n\t\t\t\t}\r\n\t\t\t\tvar propagatedEvent = event.type === 'refresh' ? event : // always propagate refreshes\r\n\t\t\t\t\tthis[this.method + 'Updated'] ? this[this.method + 'Updated'](event, context) : // if we have an updated handler, use it\r\n\t\t\t\t\tnew RefreshEvent() // else recompute the array method\r\n\t\t\t\t// TODO: make sure we normalize the event structure\r\n\t\t\t\tif (propagatedEvent) {\r\n\t\t\t\t\tComposite.prototype.updated.call(this, propagatedEvent, by, context)\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tfilterUpdated: function(event, context) {\r\n\t\t\t\tvar contextualizedVariable = getMaterializedContextualInstance(this, context) || this\r\n\t\t\t\tif (event.type === 'delete') {\r\n\t\t\t\t\tvar index = contextualizedVariable.cachedValue.indexOf(event.oldValue)\r\n\t\t\t\t\tif (index > -1) {\r\n\t\t\t\t\t\tcontextualizedVariable.splice(index, 1)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (event.type === 'add') {\r\n\t\t\t\t\tif ([event.value].filter(this.args[0]).length > 0) {\r\n\t\t\t\t\t\tcontextualizedVariable.push(event.value)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (event.type === 'update') {\r\n\t\t\t\t\tvar object = event.parent.valueOf(context)\r\n\t\t\t\t\tvar index = contextualizedVariable.cachedValue.indexOf(object)\r\n\t\t\t\t\tvar matches = [object].filter(this.args[0]).length > 0\r\n\t\t\t\t\tif (index > -1) {\r\n\t\t\t\t\t\tif (matches) {\r\n\t\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\t\ttype: 'updated',\r\n\t\t\t\t\t\t\t\tobject: object,\r\n\t\t\t\t\t\t\t\tindex: index\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tcontextualizedVariable.splice(index, 1)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\telse {\r\n\t\t\t\t\t\tif (matches) {\r\n\t\t\t\t\t\t\tcontextualizedVariable.push(object)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// else nothing mactches\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn event\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tmapUpdated: function(event, context) {\r\n\t\t\t\tvar contextualizedVariable = getMaterializedContextualInstance(this, context) || this\r\n\t\t\t\tif (event.type === 'delete') {\r\n\t\t\t\t\tcontextualizedVariable.splice(event.previousIndex, 1)\r\n\t\t\t\t} else if (event.type === 'add') {\r\n\t\t\t\t\tcontextualizedVariable.push(this.args[0].call(this.args[1], event.value))\r\n\t\t\t\t} else if (event.type === 'update') {\r\n\t\t\t\t\tvar object = event.parent.valueOf(context)\r\n\t\t\t\t\tvar array = contextualizedVariable.cachedValue\r\n\t\t\t\t\tif (array && array.map) {\r\n\t\t\t\t\t\tvar index = array.indexOf(object)\r\n\t\t\t\t\t\tvar matches = [object].filter(this.args[0]).length > 0\r\n\t\t\t\t\t\tcontextualizedVariable.splice(index, 1, this.args[0].call(this.args[1], event.value))\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn event\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn event\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\t// TODO: Create specialized updated handlers for faster recomputation of other array derivatives\r\n\t\t\tforDependencies: function(callback) {\r\n\t\t\t\t// depend on the args\r\n\t\t\t\tComposite.prototype.forDependencies.call(this, callback)\r\n\t\t\t\tcallback(this.source)\r\n\t\t\t},\r\n\t\t\tgetVersion: function(context) {\r\n\t\t\t\treturn Math.max(Composite.prototype.getVersion.call(this, context), this.source.getVersion(context))\r\n\t\t\t}\t\t\r\n\t\t})\r\n\t\r\n\t\r\n\t\tvar getValue\r\n\t\tvar GeneratorVariable = Variable.GeneratorVariable = lang.compose(Variable.Composite, function ReactiveGenerator(generator){\r\n\t\t\tthis.generator = generator\r\n\t\t\tthis.args = []\r\n\t\t}, {\r\n\t\t\tgetValue: getValue = function(context, resuming) {\r\n\t\t\t\tvar lastValue\r\n\t\t\t\tvar i\r\n\t\t\t\tvar generatorIterator\r\n\t\t\t\tvar isThrowing\r\n\t\t\t\tif (resuming) {\r\n\t\t\t\t\t// resuming from a promise\r\n\t\t\t\t\tgeneratorIterator = resuming.iterator\r\n\t\t\t\t\ti = resuming.i\r\n\t\t\t\t\tlastValue = resuming.value\r\n\t\t\t\t\tisThrowing = resuming.isThrowing\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// a fresh start\r\n\t\t\t\t\ti = 0\r\n\t\t\t\t\tgeneratorIterator = this.generator()\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tvar args = this.args\r\n\t\t\t\tdo {\r\n\t\t\t\t\tvar stepReturn = generatorIterator[isThrowing ? 'throw' : 'next'](lastValue)\r\n\t\t\t\t\tif (stepReturn.done) {\r\n\t\t\t\t\t\treturn stepReturn.value\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar nextVariable = stepReturn.value\r\n\t\t\t\t\t// compare with the arguments from the last\r\n\t\t\t\t\t// execution to see if they are the same\r\n\t\t\t\t\tif (args[i] !== nextVariable) {\r\n\t\t\t\t\t\tif (args[i]) {\r\n\t\t\t\t\t\t\targs[i].stopNotifies(this)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// subscribe if it is a variable\r\n\t\t\t\t\t\tif (nextVariable && nextVariable.notifies) {\r\n\t\t\t\t\t\t\tnextVariable.notifies(this)\r\n\t\t\t\t\t\t\tthis.args[i] = nextVariable\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthis.args[i] = null\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\ti++\r\n\t\t\t\t\tlastValue = nextVariable && nextVariable.valueOf(context)\r\n\t\t\t\t\tif (lastValue && lastValue.then) {\r\n\t\t\t\t\t\t// if it is a promise, we will wait on it\r\n\t\t\t\t\t\tvar variable = this\r\n\t\t\t\t\t\t// and return the promise so that the getValue caller can wait on this\r\n\t\t\t\t\t\treturn lastValue.then(function(value) {\r\n\t\t\t\t\t\t\treturn getValue.call(variable, context, {\r\n\t\t\t\t\t\t\t\ti: i,\r\n\t\t\t\t\t\t\t\titerator: generatorIterator,\r\n\t\t\t\t\t\t\t\tvalue: value\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t}, function(error) {\r\n\t\t\t\t\t\t\treturn getValue.call(variable, context, {\r\n\t\t\t\t\t\t\t\ti: i,\r\n\t\t\t\t\t\t\t\titerator: generatorIterator,\r\n\t\t\t\t\t\t\t\tvalue: error,\r\n\t\t\t\t\t\t\t\tisThrowing: true\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}\r\n\t\t\t\t} while(true)\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\tvar Validating = lang.compose(Caching, function(target) {\r\n\t\t\tthis.target = target\r\n\t\t}, {\r\n\t\t\tforDependencies: function(callback) {\r\n\t\t\t\tCaching.prototype.forDependencies.call(this, callback)\r\n\t\t\t\tcallback(this.target)\r\n\t\t\t},\r\n\t\t\tgetVersion: function(context) {\r\n\t\t\t\treturn Math.max(Variable.prototype.getVersion.call(this, context), this.target.getVersion(context))\r\n\t\t\t},\r\n\t\t\tgetValue: function(context) {\r\n\t\t\t\tvar target = this.target\r\n\t\t\t\treturn target.validate(target, target.schema)\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\tfunction validate(target) {\r\n\t\t\tvar schemaForObject = schema(target)\r\n\t\t\treturn new Validating(target, schemaForObject)\r\n\t\t}\r\n\t\tVariable.VArray = Variable\r\n\t\tVariable.VPromised = Variable\r\n\t\tVariable.deny = deny\r\n\t\tVariable.noChange = noChange\r\n\t\tfunction addFlag(name) {\r\n\t\t\tVariable[name] = function(functionValue) {\r\n\t\t\t\tfunctionValue[name] = true\r\n\t\t\t}\r\n\t\t}\r\n\t\taddFlag(Variable, 'handlesContext')\r\n\t\taddFlag(Variable, 'handlesPromises')\r\n\t\r\n\t\tfunction objectUpdated(object) {\r\n\t\t\t// simply notifies any subscribers to an object, that it has changed\r\n\t\t\tvar listeners = propertyListenersMap.get(object)\r\n\t\t\tif (listeners) {\r\n\t\t\t\tfor (var i = 0, l = listeners.length; i < l; i++) {\r\n\t\t\t\t\tlisteners[i]._propertyChange(null, object)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction all(array) {\r\n\t\t\t// This is intended to mirror Promise.all. It actually takes\r\n\t\t\t// an iterable, but for now we are just looking for array-like\r\n\t\t\tif (array.length > -1) {\r\n\t\t\t\treturn new Composite(array)\r\n\t\t\t}\r\n\t\t\tif (arguments.length > 1) {\r\n\t\t\t\t// support multiple arguments as an array\r\n\t\t\t\treturn new Composite(arguments)\r\n\t\t\t}\r\n\t\t\tif (typeof array === 'object') {\r\n\t\t\t\t// allow an object as a hash to be mapped\r\n\t\t\t\tvar keyMapping = []\r\n\t\t\t\tvar valueArray = []\r\n\t\t\t\tfor (var key in array) {\r\n\t\t\t\t\tkeyMapping.push(key)\r\n\t\t\t\t\tvalueArray.push(array[key])\r\n\t\t\t\t}\r\n\t\t\t\treturn new Variable(function(results) {\r\n\t\t\t\t\tvar resultObject = {}\r\n\t\t\t\t\tfor (var i = 0; i < results.length; i++) {\r\n\t\t\t\t\t\tresultObject[keyMapping[i]] = results[i]\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn resultObject\r\n\t\t\t\t}).apply(null, valueArray)\r\n\t\t\t}\r\n\t\t\tthrow new TypeError('Variable.all requires an array')\r\n\t\t}\r\n\t\r\n\t\tfunction hasOwn(Target, createForInstance) {\r\n\t\t\tvar ownedClasses = this.ownedClasses || (this.ownedClasses = new WeakMap())\r\n\t\t\t// TODO: assign to super classes\r\n\t\t\tvar Class = this\r\n\t\t\townedClasses.set(Target, createForInstance || function() { return new Target() })\r\n\t\t\treturn this\r\n\t\t}\r\n\t\tfunction getForClass(subject, Target) {\r\n\t\t\tvar createInstance = subject.constructor.ownedClasses && subject.constructor.ownedClasses.get(Target)\r\n\t\t\tif (createInstance) {\r\n\t\t\t\tvar ownedInstances = subject.ownedInstances || (subject.ownedInstances = new WeakMap())\r\n\t\t\t\tvar instance = ownedInstances.get(Target)\r\n\t\t\t\tif (!instance) {\r\n\t\t\t\t\townedInstances.set(Target, instance = createInstance(subject))\r\n\t\t\t\t\tinstance.subject = subject\r\n\t\t\t\t}\r\n\t\t\t\treturn instance\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction generalizeClass() {\r\n\t\t\tvar prototype = this.prototype\r\n\t\t\tvar prototypeNames = Object.getOwnPropertyNames(prototype)\r\n\t\t\tfor(var i = 0, l = prototypeNames.length; i < l; i++) {\r\n\t\t\t\tvar name = prototypeNames[i]\r\n\t\t\t\tObject.defineProperty(this, name, getGeneralizedDescriptor(Object.getOwnPropertyDescriptor(prototype, name), name, this))\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction getGeneralizedDescriptor(descriptor, name, Class) {\r\n\t\t\tif (typeof descriptor.value === 'function') {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tvalue: generalizeMethod(Class, name)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\treturn descriptor\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction generalizeMethod(Class, name) {\r\n\t\t\t// I think we can just rely on `this`, but we could use the argument:\r\n\t\t\t// function(possibleEvent) {\r\n\t\t\t// \tvar target = possibleEvent && possibleEvent.target\r\n\t\t\tvar method = Class[name] = function() {\r\n\t\t\t\tvar instance = Class.for(this)\r\n\t\t\t\treturn instance[name].apply(instance, arguments)\r\n\t\t\t}\r\n\t\t\tmethod.for = function(context) {\r\n\t\t\t\tvar instance = Class.for(context)\r\n\t\t\t\treturn function() {\r\n\t\t\t\t\treturn instance[name].apply(instance, arguments)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn method\r\n\t\t}\r\n\t\r\n\t\tvar defaultContext = {\r\n\t\t\tname: 'Default context',\r\n\t\t\tdescription: 'This object is the default context for classes, corresponding to a singleton instance of that class',\r\n\t\t\tconstructor: {\r\n\t\t\t\tgetForClass: function(subject, Class) {\r\n\t\t\t\t\treturn Class.defaultInstance\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tcontains: function() {\r\n\t\t\t\treturn true // contains everything\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction instanceForContext(Class, context) {\r\n\t\t\tif (!context) {\r\n\t\t\t\tthrow new TypeError('Accessing a generalized class without context to resolve to an instance, call for(context) (where context is an element or related variable instance) on your variable first')\r\n\t\t\t}\r\n\t\t\tvar instance = context.subject.constructor.getForClass && context.subject.constructor.getForClass(context.subject, Class) || Class.defaultInstance\r\n\t\t\tcontext.distinctSubject = mergeSubject(context.distinctSubject, instance.subject)\r\n\t\t\treturn instance\r\n\t\t}\r\n\t\t// a variable inheritance change goes through its own prototype, so classes/constructor\r\n\t\t// can be used as variables as well\r\n\t\tfor (var key in VariablePrototype) {\r\n\t\t\tObject.defineProperty(Variable, key, Object.getOwnPropertyDescriptor(VariablePrototype, key))\r\n\t\t}\r\n\t\tVariable.valueOf = function(context) {\r\n\t\t\t// contextualized getValue\r\n\t\t\treturn instanceForContext(this, context).valueOf()\r\n\t\t}\r\n\t\tVariable.setValue = function(value, context) {\r\n\t\t\t// contextualized setValue\r\n\t\t\treturn instanceForContext(this, context).put(value)\r\n\t\t}\r\n\t\tVariable.getForClass = getForClass\r\n\t\tVariable.generalize = generalizeClass\r\n\t\tVariable.call = Function.prototype.call // restore these\r\n\t\tVariable.apply = Function.prototype.apply\r\n\t\tVariable.extend = function(properties) {\r\n\t\t\t// TODO: handle arguments\r\n\t\t\tvar Base = this\r\n\t\t\tfunction ExtendedVariable() {\r\n\t\t\t\tif (this instanceof ExtendedVariable) {\r\n\t\t\t\t\treturn Base.apply(this, arguments)\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn ExtendedVariable.extend(properties)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tvar prototype = ExtendedVariable.prototype = Object.create(this.prototype)\r\n\t\t\tExtendedVariable.prototype.constructor = ExtendedVariable\r\n\t\t\tsetPrototypeOf(ExtendedVariable, this)\r\n\t\t\tfor (var key in properties) {\r\n\t\t\t\tvar descriptor = Object.getOwnPropertyDescriptor(properties, key)\r\n\t\t\t\tObject.defineProperty(prototype, key, descriptor)\r\n\t\t\t\tObject.defineProperty(ExtendedVariable, key, getGeneralizedDescriptor(descriptor, key, ExtendedVariable))\r\n\t\t\t}\r\n\t\t\tif (properties && properties.hasOwn) {\r\n\t\t\t\thasOwn.call(ExtendedVariable, properties.hasOwn)\r\n\t\t\t}\r\n\t\t\treturn ExtendedVariable\r\n\t\t}\r\n\t\tObject.defineProperty(Variable, 'defaultInstance', {\r\n\t\t\tget: function() {\r\n\t\t\t\treturn this.hasOwnProperty('_defaultInstance') ?\r\n\t\t\t\t\tthis._defaultInstance : (\r\n\t\t\t\t\t\tthis._defaultInstance = new this(),\r\n\t\t\t\t\t\tthis._defaultInstance.subject = defaultContext,\r\n\t\t\t\t\t\tthis._defaultInstance)\r\n\t\t\t}\r\n\t\t})\r\n\t\tVariable.hasOwn = hasOwn\r\n\t\tVariable.all = all\r\n\t\tVariable.objectUpdated = objectUpdated\r\n\t\tVariable.assign = function(target) {\r\n\t\t\t// copy properties, using variable sources\r\n\t\t\tfor (var i = 1; i < arguments.length; i++) {\r\n\t\t\t\tvar source = arguments[i]\r\n\t\t\t\tvar sourceVariable\r\n\t\t\t\tif (source && source.notifies) {\r\n\t\t\t\t\tsourceVariable = source\r\n\t\t\t\t\tsource = null\r\n\t\t\t\t} else {\r\n\t\t\t\t\tsourceVariable = Variable.instanceMap && Variable.instanceMap.get(source)\r\n\t\t\t\t}\r\n\t\t\t\tvar sourceProperties = sourceVariable && sourceVariable._properties\r\n\t\t\t\tif (sourceProperties) {\r\n\t\t\t\t\tfor (var key in sourceProperties) {\r\n\t\t\t\t\t\tvar property = sourceProperties[key]\r\n\t\t\t\t\t\tif (property && property.value) {\r\n\t\t\t\t\t\t\tvar targetVariable = targetVariable || Variable.for(target)\r\n\t\t\t\t\t\t\ttargetVariable.property(key).put(property)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tfor (var key in source) {\r\n\t\t\t\t\tif (!(sourceVariable && sourceVariable._properties && sourceVariable._properties[key])) {\r\n\t\t\t\t\t\ttarget[key] = source[key]\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn target\r\n\t\t}\r\n\t\tVariable.assign.handlesVariables = true\r\n\t\r\n\t\treturn Variable\r\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\r\n\t\tvar getPrototypeOf = Object.getPrototypeOf || (function(base) { return base.__proto__ })\r\n\t\tvar setPrototypeOf = Object.setPrototypeOf || (function(base, proto) { base.__proto__ = proto})\r\n\t\tvar hasFeatures = {\r\n\t\t\trequestAnimationFrame: typeof requestAnimationFrame != 'undefined',\r\n\t\t\tdefineProperty: Object.defineProperty && (function() {\r\n\t\t\t\ttry{\r\n\t\t\t\t\tObject.defineProperty({}, 't', {})\r\n\t\t\t\t\treturn true\r\n\t\t\t\t}catch(e) {\r\n\t\t\t\t}\r\n\t\t\t})(),\r\n\t\t\tpromise: typeof Promise !== 'undefined',\r\n\t\t\tMutationObserver: typeof MutationObserver !== 'undefined',\r\n\t\t\t'WeakMap': typeof WeakMap === 'function'\r\n\t\t}\r\n\t\tfunction has(feature) {\r\n\t\t\treturn hasFeatures[feature]\r\n\t\t}\r\n\t\t// This is an polyfill for Object.observe with just enough functionality\r\n\t\t// for what Variables need\r\n\t\t// An observe function, with polyfile\r\n\t\tvar observe =\r\n\t\t\thas('defineProperty') ? \r\n\t\t\tfunction observe(target, listener) {\r\n\t\t\t\t/*for(var i in target) {\r\n\t\t\t\t\taddKey(i)\r\n\t\t\t\t}*/\r\n\t\t\t\tlistener.addKey = addKey\r\n\t\t\t\tlistener.remove = function() {\r\n\t\t\t\t\tlistener = null\r\n\t\t\t\t}\r\n\t\t\t\treturn listener\r\n\t\t\t\tfunction addKey(key) {\r\n\t\t\t\t\tvar keyFlag = 'key' + key\r\n\t\t\t\t\tif(this[keyFlag]) {\r\n\t\t\t\t\t\treturn\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tthis[keyFlag] = true\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar currentValue = target[key]\r\n\t\t\t\t\tvar targetAncestor = target\r\n\t\t\t\t\tvar descriptor\r\n\t\t\t\t\tdo {\r\n\t\t\t\t\t\tdescriptor = Object.getOwnPropertyDescriptor(targetAncestor, key)\r\n\t\t\t\t\t} while(!descriptor && (targetAncestor = getPrototypeOf(targetAncestor)))\r\n\t\r\n\t\t\t\t\tif(descriptor && descriptor.set) {\r\n\t\t\t\t\t\tvar previousSet = descriptor.set\r\n\t\t\t\t\t\tvar previousGet = descriptor.get\r\n\t\t\t\t\t\tObject.defineProperty(target, key, {\r\n\t\t\t\t\t\t\tget: function() {\r\n\t\t\t\t\t\t\t\treturn (currentValue = previousGet.call(this))\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\tset: function(value) {\r\n\t\t\t\t\t\t\t\tpreviousSet.call(this, value)\r\n\t\t\t\t\t\t\t\tif(currentValue !== value) {\r\n\t\t\t\t\t\t\t\t\tcurrentValue = value\r\n\t\t\t\t\t\t\t\t\tif(listener) {\r\n\t\t\t\t\t\t\t\t\t\tlistener([{target: this, name: key}])\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\tenumerable: descriptor.enumerable\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tObject.defineProperty(target, key, {\r\n\t\t\t\t\t\t\tget: function() {\r\n\t\t\t\t\t\t\t\treturn currentValue\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\tset: function(value) {\r\n\t\t\t\t\t\t\t\tif(currentValue !== value) {\r\n\t\t\t\t\t\t\t\t\tcurrentValue = value\r\n\t\t\t\t\t\t\t\t\tif(listener) {\r\n\t\t\t\t\t\t\t\t\t\tlistener([{target: this, name: key}])\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\tenumerable: !descriptor || descriptor.enumerable\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} :\r\n\t\t\t// and finally a polling-based solution, for the really old browsers\r\n\t\t\tfunction(target, listener) {\r\n\t\t\t\tif(!timerStarted) {\r\n\t\t\t\t\ttimerStarted = true\r\n\t\t\t\t\tsetInterval(function() {\r\n\t\t\t\t\t\tfor(var i = 0, l = watchedObjects.length; i < l; i++) {\r\n\t\t\t\t\t\t\tdiff(watchedCopies[i], watchedObjects[i], listeners[i])\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}, 20)\r\n\t\t\t\t}\r\n\t\t\t\tvar copy = {}\r\n\t\t\t\tfor(var i in target) {\r\n\t\t\t\t\tif(target.hasOwnProperty(i)) {\r\n\t\t\t\t\t\tcopy[i] = target[i]\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\twatchedObjects.push(target)\r\n\t\t\t\twatchedCopies.push(copy)\r\n\t\t\t\tlisteners.push(listener)\r\n\t\t\t}\r\n\t\tvar queuedListeners\r\n\t\tfunction queue(listener, object, name) {\r\n\t\t\tif(queuedListeners) {\r\n\t\t\t\tif(queuedListeners.indexOf(listener) === -1) {\r\n\t\t\t\t\tqueuedListeners.push(listener)\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\tqueuedListeners = [listener]\r\n\t\t\t\tlang.nextTurn(function() {\r\n\t\t\t\t\tqueuedListeners.forEach(function(listener) {\r\n\t\t\t\t\t\tvar events = []\r\n\t\t\t\t\t\tlistener.properties.forEach(function(property) {\r\n\t\t\t\t\t\t\tevents.push({target: listener.object, name: property})\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t\tlistener(events)\r\n\t\t\t\t\t\tlistener.object = null\r\n\t\t\t\t\t\tlistener.properties = null\r\n\t\t\t\t\t})\r\n\t\t\t\t\tqueuedListeners = null\r\n\t\t\t\t}, 0)\r\n\t\t\t}\r\n\t\t\tlistener.object = object\r\n\t\t\tvar properties = listener.properties || (listener.properties = [])\r\n\t\t\tif(properties.indexOf(name) === -1) {\r\n\t\t\t\tproperties.push(name)\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar unobserve = has('observe') ? Object.unobserve :\r\n\t\t\tfunction(target, listener) {\r\n\t\t\t\tif(listener.remove) {\r\n\t\t\t\t\tlistener.remove()\r\n\t\t\t\t}\r\n\t\t\t\tfor(var i = 0, l = watchedObjects.length; i < l; i++) {\r\n\t\t\t\t\tif(watchedObjects[i] === target && listeners[i] === listener) {\r\n\t\t\t\t\t\twatchedObjects.splice(i, 1)\r\n\t\t\t\t\t\twatchedCopies.splice(i, 1)\r\n\t\t\t\t\t\tlisteners.splice(i, 1)\r\n\t\t\t\t\t\treturn\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\tvar watchedObjects = []\r\n\t\tvar watchedCopies = []\r\n\t\tvar listeners = []\r\n\t\tvar timerStarted = false\r\n\t\tfunction diff(previous, current, callback) {\r\n\t\t\t// TODO: keep an array of properties for each watch for faster iteration\r\n\t\t\tvar queued\r\n\t\t\tfor(var i in previous) {\r\n\t\t\t\tif(previous.hasOwnProperty(i) && previous[i] !== current[i]) {\r\n\t\t\t\t\t// a property has changed\r\n\t\t\t\t\tprevious[i] = current[i]\r\n\t\t\t\t\t(queued || (queued = [])).push({name: i})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor(var i in current) {\r\n\t\t\t\tif(current.hasOwnProperty(i) && !previous.hasOwnProperty(i)) {\r\n\t\t\t\t\t// a property has been added\r\n\t\t\t\t\tprevious[i] = current[i]\r\n\t\t\t\t\t(queued || (queued = [])).push({name: i})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(queued) {\r\n\t\t\t\tcallback(queued)\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tvar id = 1\r\n\t\t// a function that returns a function, to stop JSON serialization of an\r\n\t\t// object\r\n\t\tfunction toJSONHidden() {\r\n\t\t\treturn toJSONHidden\r\n\t\t}\r\n\t\t// An object that will be hidden from JSON serialization\r\n\t\tvar Hidden = function () {\r\n\t\t}\r\n\t\tHidden.prototype.toJSON = toJSONHidden\r\n\t\r\n\t\tvar lang = {\r\n\t\t\trequestAnimationFrame: has('requestAnimationFrame') ? requestAnimationFrame :\r\n\t\t\t\t(function() {\r\n\t\t\t\t\tvar toRender = []\r\n\t\t\t\t\tvar queued = false\r\n\t\t\t\t\tfunction processAnimationFrame() {\r\n\t\t\t\t\t\tfor (var i = 0; i < toRender.length; i++) {\r\n\t\t\t\t\t\t\ttoRender[i]()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttoRender = []\r\n\t\t\t\t\t\tqueued = false\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfunction requestAnimationFrame(renderer) {\r\n\t\t\t\t\t \tif (!queued) {\r\n\t\t\t\t\t\t\tsetTimeout(processAnimationFrame)\r\n\t\t\t\t\t\t\tqueued = true\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttoRender.push(renderer)\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn requestAnimationFrame\r\n\t\t\t\t})(),\r\n\t\t\tPromise: has('promise') ? Promise : (function() {\r\n\t\t\t\tfunction Promise(execute) {\r\n\t\t\t\t\tvar isResolved, resolution, errorResolution\r\n\t\t\t\t\tvar queue = 0\r\n\t\t\t\t\tfunction resolve(value) {\r\n\t\t\t\t\t\t// resolve function\r\n\t\t\t\t\t\tif(value && value.then) {\r\n\t\t\t\t\t\t\t// received a promise, wait for it\r\n\t\t\t\t\t\t\tvalue.then(resolve, reject)\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\tresolution = value\r\n\t\t\t\t\t\t\tfinished()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfunction reject(error) {\r\n\t\t\t\t\t\t// reject function\r\n\t\t\t\t\t\terrorResolution = error\r\n\t\t\t\t\t\tfinished()\r\n\t\t\t\t\t}\r\n\t\t\t\t\texecute(resolve, reject)\r\n\t\t\t\t\tfunction finished() {\r\n\t\t\t\t\t\tisResolved = true\r\n\t\t\t\t\t\tfor(var i = 0, l = queue.length; i < l; i++) {\r\n\t\t\t\t\t\t\tqueue[i]()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// clean out the memory\r\n\t\t\t\t\t\tqueue = 0\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tthen: function(callback, errback) {\r\n\t\t\t\t\t\t\treturn new Promise(function(resolve, reject) {\r\n\t\t\t\t\t\t\t\tfunction handle() {\r\n\t\t\t\t\t\t\t\t\t// promise fulfilled, call the appropriate callback\r\n\t\t\t\t\t\t\t\t\ttry{\r\n\t\t\t\t\t\t\t\t\t\tif(errorResolution && !errback) {\r\n\t\t\t\t\t\t\t\t\t\t\t// errors without a handler flow through\r\n\t\t\t\t\t\t\t\t\t\t\treject(errorResolution)\r\n\t\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t\t// resolve to the callback's result\r\n\t\t\t\t\t\t\t\t\t\t\tresolve(errorResolution ?\r\n\t\t\t\t\t\t\t\t\t\t\t\terrback(errorResolution) :\r\n\t\t\t\t\t\t\t\t\t\t\t\tcallback ?\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tcallback(resolution) : resolution)\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}catch(newError) {\r\n\t\t\t\t\t\t\t\t\t\t// caught an error, reject the returned promise\r\n\t\t\t\t\t\t\t\t\t\treject(newError)\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif(isResolved) {\r\n\t\t\t\t\t\t\t\t\t// already resolved, immediately handle\r\n\t\t\t\t\t\t\t\t\thandle()\r\n\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t(queue || (queue = [])).push(handle)\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn Promise\r\n\t\t\t}()),\r\n\t\r\n\t\t\tWeakMap: has('WeakMap') ? WeakMap :\r\n\t\t \tfunction (values, name) {\r\n\t\t \t\tvar mapProperty = '__' + (name || '') + id++\r\n\t\t \t\treturn has('defineProperty') ?\r\n\t\t \t\t{\r\n\t\t \t\t\tget: function (key) {\r\n\t\t \t\t\t\treturn key[mapProperty]\r\n\t\t \t\t\t},\r\n\t\t \t\t\tset: function (key, value) {\r\n\t\t \t\t\t\tObject.defineProperty(key, mapProperty, {\r\n\t\t \t\t\t\t\tvalue: value,\r\n\t\t \t\t\t\t\tenumerable: false\r\n\t\t \t\t\t\t})\r\n\t\t \t\t\t}\r\n\t\t \t\t} :\r\n\t\t \t\t{\r\n\t\t \t\t\tget: function (key) {\r\n\t\t \t\t\t\tvar intermediary = key[mapProperty]\r\n\t\t \t\t\t\treturn intermediary && intermediary.value\r\n\t\t \t\t\t},\r\n\t\t \t\t\tset: function (key, value) {\r\n\t\t \t\t\t\t// we use an intermediary that is hidden from JSON serialization, at least\r\n\t\t \t\t\t\tvar intermediary = key[mapProperty] || (key[mapProperty] = new Hidden())\r\n\t\t \t\t\t\tintermediary.value = value\r\n\t\t \t\t\t}\r\n\t\t \t\t}\r\n\t\t \t},\r\n\t\r\n\t\t\tobserve: observe,\r\n\t\t\tunobserve: unobserve,\r\n\t\t\twhen: function(value, callback, errorHandler) {\r\n\t\t\t\treturn value && value.then ?\r\n\t\t\t\t\t(value.then(callback, errorHandler) || value) : callback(value)\r\n\t\t\t},\r\n\t\t\twhenAll: function(inputs, callback) {\r\n\t\t\t\tvar promiseInvolved\r\n\t\t\t\tfor(var i = 0, l = inputs.length; i < l; i++) {\r\n\t\t\t\t\tif(inputs[i] && inputs[i].then) {\r\n\t\t\t\t\t\tpromiseInvolved = true\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif(promiseInvolved) {\r\n\t\t\t\t\t// we have asynch inputs, do lazy loading\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tthen: function(onResolve, onError) {\r\n\t\t\t\t\t\t\tvar remaining = 1\r\n\t\t\t\t\t\t\tvar result\r\n\t\t\t\t\t\t\tvar readyInputs = []\r\n\t\t\t\t\t\t\tvar lastPromiseResult\r\n\t\t\t\t\t\t\tfor(var i = 0; i < inputs.length; i++) {\r\n\t\t\t\t\t\t\t\tvar input = inputs[i]\r\n\t\t\t\t\t\t\t\tremaining++\r\n\t\t\t\t\t\t\t\tif(input && input.then) {\r\n\t\t\t\t\t\t\t\t\t(function(i, previousPromiseResult) {\r\n\t\t\t\t\t\t\t\t\t\tlastPromiseResult = input.then(function(value) {\r\n\t\t\t\t\t\t\t\t\t\t\treadyInputs[i] = value\r\n\t\t\t\t\t\t\t\t\t\t\tonEach()\r\n\t\t\t\t\t\t\t\t\t\t\tif(!remaining) {\r\n\t\t\t\t\t\t\t\t\t\t\t\treturn result\r\n\t\t\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t\t\treturn previousPromiseResult\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}, onError)\r\n\t\t\t\t\t\t\t\t\t})(i, lastPromiseResult)\r\n\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\treadyInputs[i] = input\r\n\t\t\t\t\t\t\t\t\tonEach()\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tonEach()\r\n\t\t\t\t\t\t\tfunction onEach() {\r\n\t\t\t\t\t\t\t\tremaining--\r\n\t\t\t\t\t\t\t\tif(!remaining) {\r\n\t\t\t\t\t\t\t\t\tresult = onResolve(callback(readyInputs))\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn lastPromiseResult\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tinputs: inputs\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// just sync inputs\r\n\t\t\t\treturn callback(inputs)\r\n\t\r\n\t\t\t},\r\n\t\t\tcompose: function(Base, constructor, properties) {\r\n\t\t\t\tvar prototype = constructor.prototype = Object.create(Base.prototype)\r\n\t\t\t\tsetPrototypeOf(constructor, Base)\r\n\t\t\t\tfor(var i in properties) {\r\n\t\t\t\t\tprototype[i] = properties[i]\r\n\t\t\t\t}\r\n\t\t\t\tprototype.constructor = constructor\r\n\t\t\t\treturn constructor\r\n\t\t\t},\r\n\t\t\tnextTurn: has('MutationObserver') ?\r\n\t\t\t\tfunction (callback) {\r\n\t\t\t\t\t// promises don't resolve consistently on the next micro turn (Edge doesn't do it right),\r\n\t\t\t\t\t// so use mutation observer\r\n\t\t\t\t\t// TODO: make a faster mode that doesn't recreate each time\r\n\t\t\t\t\tvar div = document.createElement('div')\r\n\t\t\t\t\tvar observer = new MutationObserver(callback)\r\n\t\t\t\t\tobserver.observe(div, {\r\n\t\t\t\t\t\tattributes: true\r\n\t\t\t\t\t})\r\n\t\t\t\t\tdiv.setAttribute('a', id++)\r\n\t\t\t\t} :\r\n\t\t\t\tfunction (callback) {\r\n\t\t\t\t\t// TODO: we can do better for other, older browsers\r\n\t\t\t\t\tsetTimeout(callback, 0)\r\n\t\t\t\t},\r\n\t\t\tcopy: Object.assign || function(target, source) {\r\n\t\t\t\tfor(var i in source) {\r\n\t\t\t\t\ttarget[i] = source[i]\r\n\t\t\t\t}\r\n\t\t\t\treturn target\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn lang\r\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(3)], __WEBPACK_AMD_DEFINE_RESULT__ = function (lang, Variable) {\r\n\t\tvar doc = typeof document !== 'undefined' && document\r\n\t\tvar invalidatedElements\r\n\t\tvar queued\r\n\t\tvar toRender = []\r\n\t\tvar nextId = 1\r\n\t\tvar requestAnimationFrame = lang.requestAnimationFrame\r\n\t\r\n\t\tfunction Context(subject){\r\n\t\t\tthis.subject = subject\r\n\t\t}\r\n\t\r\n\t\tfunction Renderer(options) {\r\n\t\t\tvar variable = options.variable\r\n\t\r\n\t\t\tthis.variable = variable\r\n\t\t\tthis.elements = []\r\n\t\t\tif (options) {\r\n\t\t\t\tif (options.selector) {\r\n\t\t\t\t\tthis.selector = options.selector\r\n\t\t\t\t}\r\n\t\t\t\tif (options.elements) {\r\n\t\t\t\t\tthis.elements = options.elements\r\n\t\t\t\t\tthis.element = this.elements[0]\r\n\t\t\t\t}\r\n\t\t\t\tif (options.element) {\r\n\t\t\t\t\tthis.element = options.element\r\n\t\t\t\t\tthis.elements.push(options.element)\r\n\t\t\t\t}\r\n\t\t\t\tfor(var i = 0, l = this.elements.length; i < l; i++) {\r\n\t\t\t\t\t(this.elements[i].alkaliRenderers || (this.elements[i].alkaliRenderers = [])).push(this)\r\n\t\t\t\t}\r\n\t\t\t\tif (options.update) {\r\n\t\t\t\t\tthis.updateRendering = options.update\r\n\t\t\t\t}\r\n\t\t\t\tif (options.shouldRender) {\r\n\t\t\t\t\tthis.shouldRender = options.shouldRender\r\n\t\t\t\t}\r\n\t\t\t\tif (options.renderUpdate) {\r\n\t\t\t\t\tthis.renderUpdate = options.renderUpdate\r\n\t\t\t\t}\r\n\t\t\t\tif (options.alwaysUpdate) {\r\n\t\t\t\t\tthis.alwaysUpdate = options.alwaysUpdate\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (variable.updated) {\r\n\t\t\t\t// if it has update, we don't need to instantiate a closure\r\n\t\t\t\tvariable.notifies(this)\r\n\t\t\t} else {\r\n\t\t\t\t// baconjs-esqe API\r\n\t\t\t\tvar renderer = this\r\n\t\t\t\tvariable.subscribe(function (event) {\r\n\t\t\t\t\t// replace the variable with an object\r\n\t\t\t\t\t// that returns the value from the event\r\n\t\t\t\t\trenderer.variable = {\r\n\t\t\t\t\t\tvalueOf: function () {\r\n\t\t\t\t\t\t\treturn event.value()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\trenderer.updated()\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tif(options && options.updateOnStart !== false){\r\n\t\t\t\tthis.updateRendering(true)\r\n\t\t\t}\r\n\t\t}\r\n\t\tRenderer.prototype = {\r\n\t\t\tconstructor: Renderer,\r\n\t\t\tupdateRendering: function () {\r\n\t\t\t\tthrow new Error ('updateRendering must be implemented by sub class of Renderer')\r\n\t\t\t},\r\n\t\t\tupdated: function (updateEvent, by, context) {\r\n\t\t\t\tif (!this.invalidated) {\r\n\t\t\t\t\tif (!context || this.contextMatches(context)) {\r\n\t\t\t\t\t\t// do this only once, until we render again\r\n\t\t\t\t\t\tthis.invalidated = true\r\n\t\t\t\t\t\tvar renderer = this\r\n\t\t\t\t\t\trequestAnimationFrame(function(){\r\n\t\t\t\t\t\t\tinvalidatedElements = null\r\n\t\t\t\t\t\t\trenderer.updateRendering(renderer.alwaysUpdate)\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tcontextMatches: function(context) {\r\n\t\t\t\treturn true\r\n\t\t\t\treturn context == this.elements ||\r\n\t\t\t\t\t// if context is any element in this.elements - perhaps return only the specific matching elements?\r\n\t\t\t\t\t(this.elements.indexOf(context) != -1) ||\r\n\t\t\t\t  // (context is an array and any/all elements are contained in this.elements) ||\r\n\t\t\t\t\t// context contains() any of this.elements\r\n\t\t\t\t\t(function(elements) {\r\n\t\t\t\t\t\tfor(var i = 0, l = elements.length; i < l; i++) {\r\n\t\t\t\t\t\t\tif (context.contains(elements[i])) return true\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn false\r\n\t\t\t\t\t})(this.elements)\r\n\t\t\t},\r\n\t\t\tinvalidateElement: function(element) {\r\n\t\t\t\tif(!invalidatedElements){\r\n\t\t\t\t\tinvalidatedElements = new WeakMap(null, 'invalidated')\r\n\t\t\t\t\t// TODO: if this is not a real weak map, we don't want to GC it, or it will leak\r\n\t\t\t\t}\r\n\t\t\t\tvar invalidatedParts = invalidatedElements.get(element)\r\n\t\t\t\tinvalidatedElements.set(element, invalidatedParts = {})\r\n\t\t\t\tif (!invalidatedParts[id]) {\r\n\t\t\t\t\tinvalidatedParts[id] = true\r\n\t\t\t\t}\r\n\t\t\t\tif (!queued) {\r\n\t\t\t\t\tlang.queueTask(processQueue)\r\n\t\t\t\t\tqueued = true\r\n\t\t\t\t}\r\n\t\t\t\tvar renderer = this\r\n\t\t\t\ttoRender.push(function(){\r\n\t\t\t\t\trenderer.invalidated = false\r\n\t\t\t\t\trenderer.updateElement(element)\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tgetId: function(){\r\n\t\t\t\treturn this.id || (this.id = nextId++)\r\n\t\t\t},\r\n\t\t\tstop: function() {\r\n\t\t\t\tthis.variable.stopNotifies(this)\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction ElementRenderer(options) {\r\n\t\t\tRenderer.call(this, options)\r\n\t\t}\r\n\t\tElementRenderer.prototype = Object.create(Renderer.prototype)\r\n\t\tElementRenderer.prototype.shouldRender = function (element) {\r\n\t\t\treturn document.body.contains(element)\r\n\t\t}\r\n\t\tElementRenderer.prototype.getSubject = function () {\r\n\t\t\treturn this.element || this.elements[0]\r\n\t\t}\r\n\t\tElementRenderer.prototype.updateRendering = function (always, element) {\r\n\t\t\tvar elements = this.elements || (element && [element]) || []\r\n\t\t\tif(!elements.length){\r\n\t\t\t\tif(this.selector){\r\n\t\t\t\t\telements = document.querySelectorAll(this.selector)\r\n\t\t\t\t}else{\r\n\t\t\t\t\tthrow new Error('No element or selector was provided to the Renderer')\r\n\t\t\t\t}\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tfor(var i = 0, l = elements.length; i < l; i++){\r\n\t\t\t\tif(always || this.shouldRender(elements[i])){\r\n\t\t\t\t\t// it is connected\r\n\t\t\t\t\tthis.updateElement(elements[i])\r\n\t\t\t\t}else{\r\n\t\t\t\t\tvar id = this.getId()\r\n\t\t\t\t\tvar renderers = elements[i].renderersOnShow\r\n\t\t\t\t\tif(!renderers){\r\n\t\t\t\t\t\trenderers = elements[i].renderersOnShow = []\r\n\t\t\t\t\t\telements[i].className += ' needs-rerendering'\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!renderers[id]) {\r\n\t\t\t\t\t\trenderers[id] = this\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tElementRenderer.prototype.addElement = function (element) {\r\n\t\t\tif (this.selector) {\r\n\t\t\t\telement.renderersOnShow = [this]\r\n\t\t\t} else {\r\n\t\t\t\tthis.elements.push(element)\r\n\t\t\t}\r\n\t\t\t// and immediately do an update\r\n\t\t\tthis.updateElement(element)\r\n\t\t}\r\n\t\tElementRenderer.prototype.updateElement = function(element) {\r\n\t\t\tthis.invalidated = false\r\n\t\t\ttry {\r\n\t\t\t\t// TODO: might make something cheaper than for(element) for setting context?\r\n\t\t\t\tvar value = !this.omitValueOf && this.variable.valueOf(new Context(element))\r\n\t\t\t} catch (error) {\r\n\t\t\t\telement.appendChild(document.createTextNode(error))\r\n\t\t\t}\r\n\t\t\tif(value !== undefined || this.started){\r\n\t\t\t\tthis.started = true\r\n\t\t\t\tif(value && value.then){\r\n\t\t\t\t\tif(this.renderLoading){\r\n\t\t\t\t\t\tthis.renderLoading(value, element)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar renderer = this\r\n\t\t\t\t\tvalue.then(function (value) {\r\n\t\t\t\t\t\trenderer.renderUpdate(value, element)\r\n\t\t\t\t\t})\r\n\t\t\t\t}else{\r\n\t\t\t\t\tthis.renderUpdate(value, element)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tElementRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\t\tthrow new Error('renderUpdate(newValue) must be implemented')\r\n\t\t}\r\n\t\tRenderer.Renderer = Renderer\r\n\t\tRenderer.ElementRenderer = ElementRenderer\r\n\t\r\n\t\tfunction AttributeRenderer(options) {\r\n\t\t\tif(options.name){\r\n\t\t\t\tthis.name = options.name\r\n\t\t\t}\r\n\t\t\tElementRenderer.apply(this, arguments)\r\n\t\t}\r\n\t\tAttributeRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\t\tAttributeRenderer.prototype.type = 'AttributeRenderer'\r\n\t\tAttributeRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\t\telement.setAttribute(this.name, newValue)\r\n\t\t}\r\n\t\tRenderer.AttributeRenderer = AttributeRenderer\r\n\t\r\n\t\tfunction PropertyRenderer(options) {\r\n\t\t\tif (options.name) {\r\n\t\t\t\tthis.name = options.name\r\n\t\t\t}\r\n\t\t\tElementRenderer.apply(this, arguments)\r\n\t\t}\r\n\t\tPropertyRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\t\tPropertyRenderer.prototype.type = 'PropertyRenderer'\r\n\t\tPropertyRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\t\telement[this.name] = newValue\r\n\t\t}\r\n\t\tRenderer.PropertyRenderer = PropertyRenderer\r\n\t\r\n\t\tfunction InputPropertyRenderer(options) {\r\n\t\t\tif (options.element && options.element.tagName === 'SELECT' && options.name === 'value') {\r\n\t\t\t\t// use the deferred value assignment for <select>\r\n\t\t\t\tthis.renderUpdate = this.renderSelectValueUpdate\r\n\t\t\t}\r\n\t\t\tPropertyRenderer.apply(this, arguments)\r\n\t\t}\r\n\t\tInputPropertyRenderer.prototype = Object.create(PropertyRenderer.prototype)\r\n\t\tInputPropertyRenderer.prototype.type = 'InputPropertyRenderer'\r\n\t\tInputPropertyRenderer.prototype.renderUpdate = function(newValue, element) {\r\n\t\t\tif (element.type === 'number') {\r\n\t\t\t\tif (isNaN(newValue)) {\r\n\t\t\t\t\tnewValue = ''\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telement[this.name] = newValue\r\n\t\t}\r\n\t\tInputPropertyRenderer.prototype.renderSelectValueUpdate = function (newValue, element) {\r\n\t\t\telement.value = newValue\r\n\t\t\tif (element.value != newValue && !element.value) {\r\n\t\t\t\t// if we didn't successfully set the value of a <select>, we may need to wait until the children are constructed\r\n\t\t\t\telement.eventualValue = newValue\r\n\t\t\t\tlang.nextTurn(function() {\r\n\t\t\t\t\tif (element.eventualValue) {\r\n\t\t\t\t\t\telement.value = element.eventualValue\r\n\t\t\t\t\t\telement.eventualValue = undefined\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t} else {\r\n\t\t\t\telement.eventualValue = undefined\r\n\t\t\t}\r\n\t\t}\r\n\t\tRenderer.InputPropertyRenderer = InputPropertyRenderer\r\n\t\r\n\t\tfunction StyleRenderer(options) {\r\n\t\t\tif(options.name){\r\n\t\t\t\tthis.name = options.name\r\n\t\t\t}\r\n\t\t\tElementRenderer.apply(this, arguments)\r\n\t\t}\r\n\t\tStyleRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\t\tStyleRenderer.prototype.type = 'StyleRenderer'\r\n\t\tStyleRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\t\telement.style[this.name] = newValue\r\n\t\t}\r\n\t\tRenderer.StyleRenderer = StyleRenderer\r\n\t\r\n\t\tfunction ContentRenderer(options) {\r\n\t\t\tElementRenderer.apply(this, arguments)\r\n\t\t}\r\n\t\tContentRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\t\tContentRenderer.prototype.type = 'ContentRenderer'\r\n\t\tContentRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\t\telement.innerHTML = ''\r\n\t\t\tif (newValue === undefined){\r\n\t\t\t\tnewValue = ''\r\n\t\t\t}\r\n\t\t\telement.appendChild(document.createTextNode(newValue))\r\n\t\t}\r\n\t\tRenderer.ContentRenderer = ContentRenderer\r\n\t\r\n\t\tfunction TextRenderer(options) {\r\n\t\t\tthis.position = options.position\r\n\t\t\tthis.textNode = options.textNode\r\n\t\t\tElementRenderer.apply(this, arguments)\r\n\t\t}\r\n\t\tTextRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\t\tTextRenderer.prototype.type = 'TextRenderer'\r\n\t\tTextRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\t\tif (newValue == null){\r\n\t\t\t\tnewValue = ''\r\n\t\t\t} else if (newValue.nodeType) {\r\n\t\t\t\tif (this.textNode && this.textNode.parentNode == element) {\r\n\t\t\t\t\t// text node is attached, we can replace it with the node\r\n\t\t\t\t\telement.replaceChild(newValue, this.textNode)\r\n\t\t\t\t} else {\r\n\t\t\t\t\telement.appendChild(newValue)\r\n\t\t\t\t}\r\n\t\t\t\tthis.textNode = newValue\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\t(this.textNode || element.childNodes[this.position]).nodeValue = newValue\r\n\t\t}\r\n\t\tRenderer.TextRenderer = TextRenderer\r\n\t\r\n\t\tfunction ListRenderer(options) {\r\n\t\t\tif (options.each) {\r\n\t\t\t\tthis.each = options.each\r\n\t\t\t}\r\n\t\t\tElementRenderer.apply(this, arguments)\r\n\t\t}\r\n\t\tListRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\t\tListRenderer.prototype.updated = function (updateEvent, context) {\r\n\t\t\t(this.updates || (this.updates = [])).push(updateEvent)\r\n\t\t\tElementRenderer.prototype.updated.call(this, updateEvent, context)\r\n\t\t}\r\n\t\tListRenderer.prototype.type = 'ListRenderer'\r\n\t\tListRenderer.prototype.omitValueOf = true\r\n\t\tListRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\t\tvar container\r\n\t\t\tvar each = this.each\r\n\t\t\tvar thisElement = this.elements[0]\r\n\t\t\tvar renderer = this\r\n\t\t\tif (!this.builtList) {\r\n\t\t\t\tthis.builtList = true\r\n\t\t\t\tcontainer = document.createDocumentFragment()\r\n\t\t\t\tvar childElements = this.childElements = []\r\n\t\t\t\tthis.variable.for(thisElement).forEach(function(item) {\r\n\t\t\t\t\teachItem(item)\r\n\t\t\t\t})\r\n\t\t\t\tthis.element.appendChild(container)\r\n\t\t\t} else {\r\n\t\t\t\tvar childElements = this.childElements\r\n\t\t\t\tvar updates = this.updates\r\n\t\t\t\tcontainer = this.element\r\n\t\t\t\tupdates.forEach(function(update) {\r\n\t\t\t\t\tif (update.type === 'refresh') {\r\n\t\t\t\t\t\trenderer.builtList = false\r\n\t\t\t\t\t\tfor (var i = 0, l = childElements.length; i < l; i++) {\r\n\t\t\t\t\t\t\tthisElement.removeChild(childElements[i])\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\trenderer.renderUpdate()\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (update.previousIndex > -1) {\r\n\t\t\t\t\t\t\tthisElement.removeChild(childElements[update.previousIndex])\r\n\t\t\t\t\t\t\tchildElements.splice(update.previousIndex, 1)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (update.index > -1) {\r\n\t\t\t\t\t\t\tvar nextChild = childElements[update.index] || null\r\n\t\t\t\t\t\t\teachItem(update.value, update.index, nextChild)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t\tthis.updates = [] // clear the updates\r\n\t\t\t}\r\n\t\t\tfunction eachItem(item, index, nextChild) {\r\n\t\t\t\tvar childElement\r\n\t\t\t\tif (each.create) {\r\n\t\t\t\t\tchildElement = each.create({parent: thisElement, _item: item}) // TODO: make a faster object here potentially\r\n\t\t\t\t} else {\r\n\t\t\t\t\tchildElement = each(item, thisElement)\r\n\t\t\t\t}\r\n\t\t\t\tif (nextChild) {\r\n\t\t\t\t\tcontainer.insertBefore(childElement, nextChild)\r\n\t\t\t\t\tchildElements.splice(index, 0, childElement)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcontainer.appendChild(childElement)\r\n\t\t\t\t\tchildElements.push(childElement)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tRenderer.ListRenderer = ListRenderer\r\n\t\r\n\t\tRenderer.onShowElement = function(shownElement){\r\n\t\t\trequestAnimationFrame(function(){\r\n\t\t\t\tinvalidatedElements = null\r\n\t\t\t\tvar elements = [].slice.call(shownElement.getElementsByClassName('needs-rerendering'))\r\n\t\t\t\tif (shownElement.className.indexOf('needs-rerendering') > 0){\r\n\t\t\t\t\tvar includingTop = [shownElement]\r\n\t\t\t\t\tincludingTop.push.apply(includingTop, elements)\r\n\t\t\t\t\telements = includingTop\r\n\t\t\t\t}\r\n\t\t\t\tfor (var i = 0, l = elements.length; i < l; i++){\r\n\t\t\t\t\tvar element = elements[i]\r\n\t\t\t\t\tvar renderers = element.renderersOnShow\r\n\t\t\t\t\tif(renderers){\r\n\t\t\t\t\t\telement.renderersOnShow = null\r\n\t\t\t\t\t\t// remove needs-rerendering class\r\n\t\t\t\t\t\telement.className = element.className.replace(/\\s?needs\\-rerendering\\s?/g, '')\r\n\t\t\t\t\t\tfor (var id in renderers) {\r\n\t\t\t\t\t\t\tvar renderer = renderers[id]\r\n\t\t\t\t\t\t\trenderer.updateElement(element)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t}\r\n\t\r\n\t\tfunction onElementRemoval(element){\r\n\t\t\t// cleanup element renderers\r\n\t\t\tif(element.alkaliRenderers){\r\n\t\t\t\tvar renderers = element.alkaliRenderers\r\n\t\t\t\tfor(var i = 0; i < renderers.length; i++){\r\n\t\t\t\t\tvar renderer = renderers[i]\r\n\t\t\t\t\trenderer.variable.stopNotifies(renderer)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tRenderer.onElementRemoval = function(element, onlyChildren){\r\n\t\t\tif(!onlyChildren){\r\n\t\t\t\tonElementRemoval(element)\r\n\t\t\t}\r\n\t\t\tvar children = element.getElementsByTagName('*')\r\n\t\t\tfor(var i = 0, l = children.length; i < l; i++){\r\n\t\t\t\tvar child = children[i]\r\n\t\t\t\tif(child.alkaliRenderers){\r\n\t\t\t\t\tonElementRemoval(child)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn Renderer\r\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(3), __webpack_require__(2), __webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = function (lang, Variable, operators) {\r\n\t\r\n\t\tfunction react(generator, options) {\r\n\t    if (typeof generator !== 'function') {\r\n\t      throw new Error('react() must be called with a generator. You need to use the babel-plugin-transform-alkali plugin if you want to use reactive expressions')\r\n\t    }\r\n\t\t\tif (options && options.reverse) {\r\n\t\t\t\tgenerator.reverse = options.reverse\r\n\t\t\t}\r\n\t\t\treturn new Variable.GeneratorVariable(generator)\r\n\t\t}\r\n\t  Object.assign(react, operators)\r\n\t  react.from = function(value) {\r\n\t    if (value && value.notifies) {\r\n\t      return value\r\n\t    }\r\n\t    return Variable.for(value)\r\n\t  }\r\n\t  react.prop = function(object, property) {\r\n\t    if (object) {\r\n\t      if (object.property) {\r\n\t        // it is a variable already\r\n\t        var directPropertyValue = object[property]\r\n\t        return directPropertyValue !== undefined ? directPropertyValue : object.property(property)\r\n\t      } else if (typeof object === 'object') {\r\n\t        // get the mapped variable for the object\r\n\t        return Variable.for(object).property(property)\r\n\t      }\r\n\t      // not an object\r\n\t      return object[property]\r\n\t    }\r\n\t    // not even truthy\r\n\t    return object\r\n\t  }\r\n\t  react.cond = function(test, consequent, alternate) {\r\n\t    return operators.if(test, operators.choose(consequent, alternate))\r\n\t  }\r\n\t  react.fcall = function(target, args) {\r\n\t    return new Variable.Call(target, args)\r\n\t  }\r\n\t  react.mcall = function(target, key, args) {\r\n\t    return new Variable.Call(target[key].bind(target), args)\r\n\t  }\r\n\t\treturn react\r\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Variable) {\r\n\t\tvar deny = Variable.deny;\r\n\t\tvar operatingFunctions = {};\r\n\t\tvar operators = {};\r\n\t\tfunction getOperatingFunction(expression){\r\n\t\t\t// jshint evil: true\r\n\t\t\treturn operatingFunctions[expression] ||\r\n\t\t\t\t(operatingFunctions[expression] =\r\n\t\t\t\t\tnew Function('a', 'b', 'deny', 'return ' + expression));\r\n\t\t}\r\n\t\tfunction operator(operator, name, precedence, forward, reverseA, reverseB){\r\n\t\t\t// defines the standard operators\r\n\t\t\tvar reverse = function(output, inputs){\r\n\t\t\t\tvar a = inputs[0],\r\n\t\t\t\t\tb = inputs[1];\r\n\t\t\t\tif(a && a.put){\r\n\t\t\t\t\tvar result = reverseA(output, b && b.valueOf());\r\n\t\t\t\t\tif(result !== deny){\r\n\t\t\t\t\t\ta.put(result);\r\n\t\t\t\t\t}\r\n\t\t\t\t}else if(b && b.put){\r\n\t\t\t\t\tb.put(reverseB(output, a && a.valueOf()));\r\n\t\t\t\t}else{\r\n\t\t\t\t\treturn deny;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\t// define a function that can lazily ensure the operating function\r\n\t\t\t// is available\r\n\t\t\tvar operatorHandler = {\r\n\t\t\t\tapply: function(instance, args){\r\n\t\t\t\t\tforward = getOperatingFunction(forward);\r\n\t\t\t\t\treverseA = reverseA && getOperatingFunction(reverseA);\r\n\t\t\t\t\treverseB = reverseB && getOperatingFunction(reverseB);\r\n\t\t\t\t\tforward.reverse = reverse;\r\n\t\t\t\t\toperators[operator] = operatorHandler = new Variable(forward);\r\n\t\r\n\t\t\t\t\taddFlags(operatorHandler);\r\n\t\t\t\t\targs = Array.prototype.slice.call(args);\r\n\t\t\t\t\targs.push(deny)\r\n\t\t\t\t\treturn operatorHandler.apply(instance, args);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\tfunction addFlags(operatorHandler){\r\n\t\t\t\toperatorHandler.precedence = precedence;\r\n\t\t\t\toperatorHandler.infix = reverseB !== false;\r\n\t\t\t}\r\n\t\t\taddFlags(operatorHandler);\r\n\t\t\toperators[operator] = operatorHandler;\r\n\t\t\toperators[name] = function() {\r\n\t\t\t\treturn operatorHandler.apply(null, arguments)\r\n\t\t\t}\r\n\t\t}\r\n\t\t// using order precedence from:\r\n\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence\r\n\t\toperator('+', 'add', 6, 'a+b', 'a-b', 'a-b');\r\n\t\toperator('-', 'subtract', 6, 'a-b', 'a+b', 'b-a');\r\n\t\toperator('*', 'multiply', 5, 'a*b', 'a/b', 'a/b');\r\n\t\toperator('/', 'divide', 5, 'a/b', 'a*b', 'b/a');\r\n\t//\toperator('^', 7, 'a^b', 'a^(-b)', 'Math.log(a)/Math.log(b)');\r\n\t\toperator('?', 'if', 16, 'b[a?0:1]', 'a===b[0]||(a===b[1]?false:deny)', '[a,b]');\r\n\t\toperator(':', 'choose', 15, '[a,b]', 'a[0]?a[1]:deny', 'a[1]');\r\n\t\toperator('!', 'not', 4, '!a', '!a', false);\r\n\t\toperator('%', 'remainder', 5, 'a%b');\r\n\t\toperator('>', 'greater', 8, 'a>b');\r\n\t\toperator('>=', 'greaterOrEqual', 8, 'a>=b');\r\n\t\toperator('<', 'less', 8, 'a<b');\r\n\t\toperator('<=', 'lessOrEqual', 8, 'a<=b');\r\n\t\toperator('===', 'looseEqual', 9, 'a===b');\r\n\t\toperator('==', 'equal', 9, 'a==b');\r\n\t\toperator('&', 'and', 8, 'a&&b');\r\n\t\toperator('|', 'or', 8, 'a||b');\r\n\t\toperator('round', 'round', 8, 'Math.round(a*Math.pow(10,b||1))/Math.pow(10,b||1)', 'a', 'a');\r\n\t\treturn operators;\r\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(3), __webpack_require__(2)], __WEBPACK_AMD_DEFINE_RESULT__ = function (lang, Variable) {\r\n\t\r\n\t\tfunction deepCopy(source, target, derivativeMap) {\r\n\t\t\tif (source && typeof source == 'object') {\r\n\t\t\t\tif (source instanceof Array) {\r\n\t\t\t\t\ttarget = [] // always create a new array for array targets\r\n\t\t\t\t\tfor(var i = 0, l = source.length; i < l; i++) {\r\n\t\t\t\t\t\ttarget[i] = deepCopy(source[i], null, derivativeMap)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (!target || typeof target !== 'object') {\r\n\t\t\t\t\t\ttarget = derivativeMap && derivativeMap.get(source)\r\n\t\t\t\t\t\tif (!target) {\r\n\t\t\t\t\t\t\ttarget = {}\r\n\t\t\t\t\t\t\tderivativeMap && derivativeMap.set(source, target)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfor (var i in source) {\r\n\t\t\t\t\t\ttarget[i] = deepCopy(source[i], target[i], derivativeMap)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn target\r\n\t\t\t}\r\n\t\t\treturn source\r\n\t\t}\r\n\t\r\n\t\tvar Copy = lang.compose(Variable, function(copiedFrom) {\r\n\t\t\t// this is the variable that we derive from\r\n\t\t\tthis.copiedFrom = copiedFrom\r\n\t\t\tthis.derivativeMap = new lang.WeakMap(null, 'derivative')\r\n\t\t\tthis.isDirty = new Variable(false)\r\n\t\t}, {\r\n\t\t\tvalueOf: function(context) {\r\n\t\t\t\tif(this.state) {\r\n\t\t\t\t\tthis.state = null\r\n\t\t\t\t}\r\n\t\t\t\tvar value = this.copiedFrom.valueOf(context)\r\n\t\t\t\tif(value && typeof value == 'object') {\r\n\t\t\t\t\tvar derivative = this.derivativeMap.get(value)\r\n\t\t\t\t\tif (derivative == null) {\r\n\t\t\t\t\t\tthis.derivativeMap.set(value, derivative = deepCopy(value, undefined, this.derivativeMap))\r\n\t\t\t\t\t\tthis.setValue(derivative, context)\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn derivative\r\n\t\t\t\t}\r\n\t\t\t\tvar thisValue = this.getValue(context)\r\n\t\t\t\tif(thisValue === undefined) {\r\n\t\t\t\t\treturn value\r\n\t\t\t\t}\r\n\t\t\t\treturn thisValue\r\n\t\t\t},\r\n\t\t\tgetCopyOf: function(value) {\r\n\t\t\t\tvar derivative = this.derivativeMap.get(value)\r\n\t\t\t\tif (derivative == null) {\r\n\t\t\t\t\tthis.derivativeMap.set(value, derivative = deepCopy(value, undefined, this.derivativeMap))\r\n\t\t\t\t}\r\n\t\t\t\treturn derivative\r\n\t\t\t},\r\n\t\t\tsave: function() {\r\n\t\t\t\t// copy back to the original object\r\n\t\t\t\tvar original = this.copiedFrom.valueOf()\r\n\t\t\t\tvar newCopiedFrom = deepCopy(this.valueOf(), original)\r\n\t\t\t\tif (original !== newCopiedFrom) {\r\n\t\t\t\t\t// if we have replaced it with a new object/value, put it\r\n\t\t\t\t\tthis.copiedFrom.put && this.copiedFrom.put(newCopiedFrom)\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// else we have modified an existing object, but we still need to notify\r\n\t\t\t\t\tif (this.copiedFrom.notifies && this.copiedFrom.updated) { // copiedFrom doesn't have to be a variable, it can be a plain object\r\n\t\t\t\t\t\tthis.copiedFrom.updated()\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tthis.isDirty.put(false)\r\n\t\t\t\tthis.onSave && this.onSave()\r\n\t\t\t},\r\n\t\t\trevert: function() {\r\n\t\t\t\tvar original = this.copiedFrom.valueOf()\r\n\t\t\t\tthis.put(deepCopy(original, this.derivativeMap.get(original), this.derivativeMap))\r\n\t\t\t\tthis.isDirty.put(false)\r\n\t\t\t},\r\n\t\t\tupdated: function() {\r\n\t\t\t\tthis.isDirty.put(true)\r\n\t\t\t\treturn Variable.prototype.updated.apply(this, arguments)\r\n\t\t\t}\r\n\t\t})\r\n\t\treturn Copy\r\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** index.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 076066ee1778f30dc35b\n **/","/// <reference path=\"./typing.d.ts\" />\r\ndefine(['./Element', './Variable', './react', './Renderer', './operators', './Copy'], function(Element, Variable, react, Renderer, operators, Copy) {\r\n\tvar main = Object.create(Element)\r\n\tmain.Copy = Copy\r\n\tmain.Element = Element\r\n\tmain.Variable = Variable\r\n\tmain.VMap = Variable.VMap\r\n\tmain.VArray = Variable.VArray\r\n\tmain.VPromised = Variable.VPromised\r\n\tmain.all = Variable.all\r\n\tmain.assign = function(target) {\r\n\t\t// generic assign that decides based on target\r\n\t\tif (target.nodeType && target instanceof HTMLElement) {\r\n\t\t\treturn Element.assign.apply(this, arguments)\r\n\t\t} else {\r\n\t\t\treturn Variable.assign.apply(this, arguments)\r\n\t\t}\r\n\t}\r\n\tmain.react = react\r\n\tmain.spawn = function(func) {\r\n\t\treturn react(func).valueOf()\r\n\t}\r\n\tmain.Renderer = Renderer\r\n\tObject.assign(main, Renderer)\r\n\tObject.assign(main, operators)\r\n\treturn main\r\n})\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./index.js\n ** module id = 0\n ** module chunks = 0\n **/","define(['./Variable', './Renderer', './util/lang'], function (Variable, Renderer, lang) {\r\n\tvar knownElementProperties = {};\r\n\t['textContent', 'innerHTML', 'title', 'href', 'value', 'valueAsNumber', 'role', 'render'].forEach(function(property) {\r\n\t\tknownElementProperties[property] = true\r\n\t})\r\n\r\n\tvar SELECTOR_REGEX = /(\\.|#)([-\\w]+)(.+)?/\r\n\tfunction isGenerator(func) {\r\n\t\tif (typeof func === 'function') {\r\n\t\t\tvar constructor = func.constructor\r\n\t\t\treturn (constructor.displayName || constructor.name) === 'GeneratorFunction'\r\n\t\t}\r\n\t}\r\n\tfunction Context(subject){\r\n\t\tthis.subject = subject\r\n\t}\r\n\r\n\tvar PropertyRenderer = Renderer.PropertyRenderer\r\n\tvar InputPropertyRenderer = Renderer.InputPropertyRenderer\r\n\tvar AttributeRenderer = Renderer.AttributeRenderer\r\n\tvar StyleRenderer = lang.compose(Renderer.StyleRenderer, function StyleRenderer() {\r\n\t\tRenderer.StyleRenderer.apply(this, arguments)\r\n\t}, {\r\n\t\trenderUpdate: function(newValue, element) {\r\n\t\t\tvar definition = styleDefinitions[this.name]\r\n\t\t\tif (definition) {\r\n\t\t\t\tdefinition(element, newValue, this.name)\r\n\t\t\t} else {\r\n\t\t\t\telement.style[this.name] = newValue\r\n\t\t\t}\r\n\t\t}\r\n\t})\r\n\r\n\tvar ClassNameRenderer = lang.compose(Renderer.ElementRenderer, function ClassNameRenderer(options) {\r\n\t\tthis.className = options.className\r\n\t\tRenderer.apply(this, arguments)\r\n\t}, {\r\n\t\trenderUpdate: function(newValue, element) {\r\n\t\t\tvar currentClassName = element.className\r\n\t\t\tvar changingClassName = this.className\r\n\t\t\t// remove the className (needed for addition or removal)\r\n\t\t\t// see http://jsperf.com/remove-class-name-algorithm/2 for some tests on this\r\n\t\t\tvar removed = currentClassName && (' ' + currentClassName + ' ').replace(' ' + changingClassName + ' ', ' ')\r\n\t\t\tif (newValue) {\r\n\t\t\t\t// addition, add the className\r\n\t\t\t\tchangingClassName = currentClassName ? (removed + changingClassName).slice(1) : changingClassName;\r\n\t\t\t} else {\r\n\t\t\t\t// we already have removed the class, just need to trim\r\n\t\t\t\tchangingClassName = removed.slice(1, removed.length - 1)\r\n\t\t\t}\r\n\t\t\t// only assign if it changed, this can save a lot of time\r\n\t\t\tif (changingClassName != currentClassName) {\r\n\t\t\t\telement.className = changingClassName\r\n\t\t\t}\r\n\t\t}\r\n\t})\r\n\r\n\t// TODO: check for renderContent with text updater\r\n\tvar TextRenderer = Renderer.TextRenderer\r\n\tvar ListRenderer = Renderer.ListRenderer\r\n\t\r\n\tvar toAddToElementPrototypes = []\r\n\tvar createdBaseElements = []\r\n\tvar doc = typeof document !== 'undefined' ? document : {\r\n\t\tcreateElement: function(tag) {\r\n\t\t\treturn {}\r\n\t\t},\r\n\t\taddEventListener: function() {\r\n\t\t}\r\n\t}\r\n\r\n\tvar testStyle = doc.createElement('div').style\r\n\tvar childTagForParent = {\r\n\t\tTABLE: ['tr','td'],\r\n\t\tTBODY: ['tr','td'],\r\n\t\tTR: 'td',\r\n\t\tUL: 'li',\r\n\t\tOL: 'li',\r\n\t\tSELECT: 'option'\r\n\t}\r\n\tvar inputs = {\r\n\t\tINPUT: 1,\r\n\t\tTEXTAREA: 1\r\n\t\t// SELECT: 1, we exclude this, so the default \"content\" of the element can be the options\r\n\t}\r\n\r\n\tfunction booleanStyle(options) {\r\n\t\treturn function(element, value, key) {\r\n\t\t\tif (typeof value === 'boolean') {\r\n\t\t\t\t// has a boolean conversion\r\n\t\t\t\tvalue = options[value ? 0 : 1]\r\n\t\t\t}\r\n\t\t\telement.style[key] = value\r\n\t\t}\r\n\t}\r\n\r\n\tfunction defaultStyle(element, value, key) {\r\n\t\tif (typeof value === 'number') {\r\n\t\t\tvalue = value + 'px'\r\n\t\t}\r\n\t\telement.style[key] = value\r\n\t}\r\n\tfunction directStyle(element, value, key) {\r\n\t\telement.style[key] = value\r\n\t}\r\n\r\n\tvar styleDefinitions = {\r\n\t\tdisplay: booleanStyle(['initial', 'none']),\r\n\t\tvisibility: booleanStyle(['visible', 'hidden']),\r\n\t\tcolor: directStyle,\r\n\t\topacity: directStyle,\r\n\t\tzoom: directStyle,\r\n\t\tminZoom: directStyle,\r\n\t\tmaxZoom: directStyle,\r\n\t\tfontWeight: directStyle,\r\n\t\tposition: booleanStyle(['absolute', '']),\r\n\t\ttextDecoration: booleanStyle(['underline', '']),\r\n\t\tfontWeight: booleanStyle(['bold', 'normal'])\r\n\t}\r\n\t;[\"alignContent\",\"alignItems\",\"alignSelf\",\"animation\",\"animationDelay\",\"animationDirection\",\"animationDuration\",\"animationFillMode\",\"animationIterationCount\",\"animationName\",\"animationPlayState\",\"animationTimingFunction\",\"backfaceVisibility\",\"background\",\"backgroundAttachment\",\"backgroundBlendMode\",\"backgroundClip\",\"backgroundColor\",\"backgroundImage\",\"backgroundOrigin\",\"backgroundPosition\",\"backgroundPositionX\",\"backgroundPositionY\",\"backgroundRepeat\",\"backgroundRepeatX\",\"backgroundRepeatY\",\"backgroundSize\",\"baselineShift\",\"border\",\"borderBottom\",\"borderBottomColor\",\"borderBottomLeftRadius\",\"borderBottomRightRadius\",\"borderBottomStyle\",\"borderBottomWidth\",\"borderCollapse\",\"borderColor\",\"borderImage\",\"borderImageOutset\",\"borderImageRepeat\",\"borderImageSlice\",\"borderImageSource\",\"borderImageWidth\",\"borderLeft\",\"borderLeftColor\",\"borderLeftStyle\",\"borderLeftWidth\",\"borderRadius\",\"borderRight\",\"borderRightColor\",\"borderRightStyle\",\"borderRightWidth\",\"borderSpacing\",\"borderStyle\",\"borderTop\",\"borderTopColor\",\"borderTopLeftRadius\",\"borderTopRightRadius\",\"borderTopStyle\",\"borderTopWidth\",\"borderWidth\",\"bottom\",\"boxShadow\",\"boxSizing\",\"bufferedRendering\",\"captionSide\",\"clear\",\"clip\",\"clipPath\",\"clipRule\",\"color\",\"colorInterpolation\",\"colorInterpolationFilters\",\"colorRendering\",\"counterIncrement\",\"counterReset\",\"cursor\",\"direction\",\"display\",\"emptyCells\",\"fill\",\"fillOpacity\",\"fillRule\",\"filter\",\"flex\",\"flexBasis\",\"flexDirection\",\"flexFlow\",\"flexGrow\",\"flexShrink\",\"flexWrap\",\"float\",\"floodColor\",\"floodOpacity\",\"font\",\"fontFamily\",\"fontFeatureSettings\",\"fontKerning\",\"fontSize\",\"fontStretch\",\"fontStyle\",\"fontVariant\",\"fontVariantLigatures\",\"fontWeight\",\"height\",\"imageRendering\",\"isolation\",\"justifyContent\",\"left\",\"letterSpacing\",\"lightingColor\",\"lineHeight\",\"listStyle\",\"listStyleImage\",\"listStylePosition\",\"listStyleType\",\"margin\",\"marginBottom\",\"marginLeft\",\"marginRight\",\"marginTop\",\"marker\",\"markerEnd\",\"markerMid\",\"markerStart\",\"mask\",\"maskType\",\"maxHeight\",\"maxWidth\",\"maxZoom\",\"minHeight\",\"minWidth\",\"minZoom\",\"mixBlendMode\",\"motion\",\"motionOffset\",\"motionPath\",\"motionRotation\",\"objectFit\",\"objectPosition\",\"opacity\",\"order\",\"orientation\",\"orphans\",\"outline\",\"outlineColor\",\"outlineOffset\",\"outlineStyle\",\"outlineWidth\",\"overflow\",\"overflowWrap\",\"overflowX\",\"overflowY\",\"padding\",\"paddingBottom\",\"paddingLeft\",\"paddingRight\",\"paddingTop\",\"page\",\"pageBreakAfter\",\"pageBreakBefore\",\"pageBreakInside\",\"paintOrder\",\"perspective\",\"perspectiveOrigin\",\"pointerEvents\",\"position\",\"quotes\",\"resize\",\"right\",\"shapeImageThreshold\",\"shapeMargin\",\"shapeOutside\",\"shapeRendering\",\"size\",\"speak\",\"src\",\"stopColor\",\"stopOpacity\",\"stroke\",\"strokeDasharray\",\"strokeDashoffset\",\"strokeLinecap\",\"strokeLinejoin\",\"strokeMiterlimit\",\"strokeOpacity\",\"strokeWidth\",\"tabSize\",\"tableLayout\",\"textAlign\",\"textAlignLast\",\"textAnchor\",\"textCombineUpright\",\"textDecoration\",\"textIndent\",\"textOrientation\",\"textOverflow\",\"textRendering\",\"textShadow\",\"textTransform\",\"top\",\"touchAction\",\"transform\",\"transformOrigin\",\"transformStyle\",\"transition\",\"transitionDelay\",\"transitionDuration\",\"transitionProperty\",\"transitionTimingFunction\",\"unicodeBidi\",\"unicodeRange\",\"userZoom\",\"vectorEffect\",\"verticalAlign\",\"visibility\",\"whiteSpace\",\"widows\",\"width\",\"willChange\",\"wordBreak\",\"wordSpacing\",\"wordWrap\",\"writingMode\",\"zIndex\",\"zoom\"].forEach(function(property) {\r\n\t\tstyleDefinitions[property] = styleDefinitions[property] || defaultStyle\r\n\t})\r\n\tvar styleSheet\r\n\tvar presumptiveParentMap = new WeakMap()\r\n\r\n\tvar setPrototypeOf = Object.setPrototypeOf || (function(base, proto) { base.__proto__ = proto})\r\n\tvar getPrototypeOf = Object.getPrototypeOf || (function(base) { return base.__proto__ })\r\n\tfunction createCssRule(selector) {\r\n\t\tif (!styleSheet) {\r\n\t\t\tvar styleSheetElement = doc.createElement(\"style\")\r\n\t\t\tstyleSheetElement.setAttribute(\"type\", \"text/css\")\r\n//\t\t\tstyleSheet.appendChild(doc.createTextNode(css))\r\n\t\t\tdoc.head.insertBefore(styleSheetElement, doc.head.firstChild)\r\n\t\t\tstyleSheet = styleSheetElement.sheet\r\n\t\t}\r\n\t\tvar cssRules = styleSheet.cssRules || styleSheet.rules\r\n\t\treturn cssRules[styleSheet.addRule(selector, ' ', cssRules.length)]\r\n\t}\r\n\tvar invalidatedElements = new WeakMap(null, 'invalidated')\r\n\tvar queued\r\n\r\n\tvar toRender = []\r\n\tfunction flatten(target, part) {\r\n\t\tvar base = target.base\r\n\t\tif (base) {\r\n\t\t\tvar basePart = base[part]\r\n\t\t\tif (basePart) {\r\n\t\t\t\ttarget[part] || target[part]\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction layoutChildren(parent, children, container, prepend) {\r\n\t\tvar fragment = (children.length > 3 || prepend) ? doc.createDocumentFragment() : parent\r\n\t\tfor(var i = 0, l = children.length; i < l; i++) {\r\n\t\t\tvar child = children[i]\r\n\t\t\tvar childNode\r\n\t\t\tif (child && child.create) {\r\n\t\t\t\t// an element constructor\r\n\t\t\t\tcurrentParent = parent\r\n\t\t\t\tchildNode = child.create()\r\n\t\t\t\tfragment.appendChild(childNode)\r\n\t\t\t\tif (child.isContentNode) {\r\n\t\t\t\t\tcontainer.contentNode = childNode\r\n\t\t\t\t}\r\n\t\t\t} else if (typeof child == 'function') {\r\n\t\t\t\t// TODO: reenable this\r\n//\t\t\t\tif (child.for) {\r\n\t\t\t\t\t// a variable constructor that can be contextualized\r\n\t//\t\t\t\tfragment.appendChild(variableAsContent(parent, child))\r\n\t\t//\t\t} else {\r\n\t\t\t\t\t// an element constructor\r\n\t\t\t\t\tchildNode = new child()\r\n\t\t\t\t\tfragment.appendChild(childNode)\r\n\t\t\t//\t}\r\n\t\t\t} else if (child && typeof child == 'object') {\r\n\t\t\t\tif (child instanceof Array) {\r\n\t\t\t\t\t// array of sub-children\r\n\t\t\t\t\tcontainer = container || parent\r\n\t\t\t\t\tchildNode = childNode || parent\r\n\t\t\t\t\tlayoutChildren(childNode.contentNode || childNode, child, container)\r\n\t\t\t\t} else if (child.notifies) {\r\n\t\t\t\t\t// a variable\r\n\t\t\t\t\tfragment.appendChild(childNode = variableAsContent(parent, child))\r\n\t\t\t\t} else if (child.nodeType) {\r\n\t\t\t\t\t// an element itself\r\n\t\t\t\t\tfragment.appendChild(childNode = child)\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// TODO: apply properties to last child, but with binding to the parent (for events)\r\n\t\t\t\t\tthrow new Error('Unknown child type ' + child)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t// a primitive value\r\n\t\t\t\tchildNode = doc.createTextNode(child)\r\n\t\t\t\tfragment.appendChild(childNode)\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (fragment != parent) {\r\n\t\t\tif (prepend) {\r\n\t\t\t\tparent.insertBefore(fragment, parent.firstChild)\r\n\t\t\t} else {\r\n\t\t\t\tparent.appendChild(fragment)\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn childNode\r\n\t}\r\n\tfunction variableAsContent(parent, content) {\r\n\t\tif (content == null) {\r\n\t\t\treturn doc.createTextNode('')\r\n\t\t}\r\n\t\tvar text\r\n\t\ttry {\r\n\t\t\ttext = content.valueOf(new Context(parent))\r\n\t\t} catch (error) {\r\n\t\t\ttext = error.stack\r\n\t\t}\r\n\t\tvar textNode = doc.createTextNode(text)\r\n\t\tif (content.notifies) {\r\n\t\t\tenterRenderer(TextRenderer, {\r\n\t\t\t\telement: parent,\r\n\t\t\t\ttextNode: textNode,\r\n\t\t\t\tvariable: content\r\n\t\t\t})\r\n\t\t}\r\n\t\treturn textNode\r\n\t}\r\n\r\n\tfunction bidirectionalHandler(element, value, key) {\r\n\t\tif (value && value.notifies) {\r\n\t\t\tenterRenderer(InputPropertyRenderer, {\r\n\t\t\t\tname: key,\r\n\t\t\t\tvariable: value,\r\n\t\t\t\telement: element\r\n\t\t\t})\r\n\t\t\tif (inputs[element.tagName] || element.tagName === 'SELECT') {\r\n\t\t\t\tbindChanges(element, value, key)\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (element.tagName === 'SELECT' && key === 'value') {\r\n\t\t\t\t// use the deferred <select> value assignment\r\n\t\t\t\tInputPropertyRenderer.prototype.renderSelectValueUpdate(value, element)\r\n\t\t\t} else {\r\n\t\t\t\tInputPropertyRenderer.prototype.renderUpdate(value, element)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction noop() {}\r\n\tvar propertyHandlers = {\r\n\t\tcontent: noop, // content and children have special handling in create\r\n\t\tchildren: noop,\r\n\t\ttagName: noop,\r\n\t\teach: noop, // just used by content, doesn't need to be recorded on the element\r\n\t\tclasses: function(element, classes) {\r\n\t\t\tif (!(classes.length > -1)) {\r\n\t\t\t\t// index the classes, if necessary\r\n\t\t\t\tvar i = 0\r\n\t\t\t\tfor (var key in classes) {\r\n\t\t\t\t\tif (!classes[i]) {\r\n\t\t\t\t\t\tclasses[i] = key\r\n\t\t\t\t\t}\r\n\t\t\t\t\ti++\r\n\t\t\t\t}\r\n\t\t\t\tclasses.length = i\r\n\t\t\t}\r\n\t\t\tfor (var i = 0, l = classes.length; i < l; i++) {\r\n\t\t\t\t// find each class name\r\n\t\t\t\tvar className = classes[i]\r\n\t\t\t\tvar flag = classes[className]\r\n\t\t\t\tif (flag && flag.notifies) {\r\n\t\t\t\t\t// if it is a variable, we react to it\r\n\t\t\t\t\tenterRenderer(ClassNameRenderer, {\r\n\t\t\t\t\t\telement: element,\r\n\t\t\t\t\t\tclassName: className,\r\n\t\t\t\t\t\tvariable: flag\r\n\t\t\t\t\t})\r\n\t\t\t\t} else if (flag || flag === undefined) {\r\n\t\t\t\t\telement.className += ' ' + className\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tclass: applyAttribute,\r\n\t\tfor: applyAttribute,\r\n\t\trole: applyAttribute,\r\n\t\trender: function(element, value, key, properties) {\r\n\t\t\t// TODO: This doesn't need to be a property updater\r\n\t\t\t// we should also verify it is a generator\r\n\t\t\t// and maybe, at some point, find an optimization to eliminate the bind()\r\n\t\t\tenterRenderer(PropertyRenderer, {\r\n\t\t\t\tname: key,\r\n\t\t\t\tvariable: new Variable.GeneratorVariable(value.bind(element, properties)),\r\n\t\t\t\telement: element\r\n\t\t\t})\r\n\t\t},\r\n\t\tvalue: bidirectionalHandler,\r\n\t\tvalueAsNumber: bidirectionalHandler,\r\n\t\tvalueAsDate: bidirectionalHandler,\r\n\t\tchecked: bidirectionalHandler,\r\n\t\tdataset: applySubProperties(function(newValue, element, key) {\r\n\t\t\telement.dataset[key || this.name] = newValue\r\n\t\t}),\r\n\t\tattributes: applySubProperties(function(newValue, element, key) {\r\n\t\t\telement.setAttribute(key || this.name, newValue)\r\n\t\t}),\r\n\t\tstyle: function(element, value, key) {\r\n\t\t\tif (typeof value === 'string') {\r\n\t\t\t\telement.setAttribute('style', value)\r\n\t\t\t} else if (value && value.notifies) {\r\n\t\t\t\tenterRenderer(AttributeRenderer, {\r\n\t\t\t\t\tname: 'style',\r\n\t\t\t\t\tvariable: value,\r\n\t\t\t\t\telment: element\r\n\t\t\t\t})\r\n\t\t\t} else {\r\n\t\t\t\tstyleObjectHandler(element, value, key)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfunction applyAttribute(element, value, key) {\r\n\t\tif (value && value.notifies) {\r\n\t\t\tenterRenderer(AttributeRenderer, {\r\n\t\t\t\tname: key,\r\n\t\t\t\tvariable: value,\r\n\t\t\t\telement: element\r\n\t\t\t})\r\n\t\t} else {\r\n\t\t\telement.setAttribute(key, value)\r\n\t\t}\r\n\t}\r\n\r\n\tvar styleObjectHandler = applySubProperties(function(newValue, element, key) {\r\n\t\telement.style[key || this.name] = newValue\r\n\t})\r\n\r\n\tfunction applySubProperties(renderer) {\r\n\t\tvar SubPropertyRenderer = lang.compose(PropertyRenderer, function SubPropertyRenderer(options) {\r\n\t\t\tPropertyRenderer.apply(this, arguments)\r\n\t\t}, {\r\n\t\t\trenderUpdate: renderer\r\n\t\t})\t\r\n\t\treturn function(element, value, key) {\r\n\t\t\tvar target = element[key]\r\n\t\t\tfor (var subKey in value) {\r\n\t\t\t\tvar subValue = value[subKey]\r\n\t\t\t\tif (subValue && subValue.notifies) {\r\n\t\t\t\t\tenterRenderer(SubPropertyRenderer, {\r\n\t\t\t\t\t\tname: subKey,\r\n\t\t\t\t\t\tvariable: subValue,\r\n\t\t\t\t\t\telement: element\r\n\t\t\t\t\t})\r\n\t\t\t\t} else {\r\n\t\t\t\t\trenderer(subValue, element, subKey)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction assignProperties(element, properties) {\r\n\t\tfor (var key in properties) {\r\n\t\t\tvar value = properties[key]\r\n\t\t\tvar styleDefinition = styleDefinitions[key]\r\n\t\t\tif (propertyHandlers[key]) {\r\n\t\t\t\tpropertyHandlers[key](element, value, key, properties)\r\n\t\t\t} else if ((styleDefinition = styleDefinitions[key]) && element[key] === undefined) {\r\n\t\t\t\tif (value && value.notifies) {\r\n\t\t\t\t\tenterRenderer(StyleRenderer, {\r\n\t\t\t\t\t\tname: key,\r\n\t\t\t\t\t\tvariable: value,\r\n\t\t\t\t\t\telement: element\r\n\t\t\t\t\t})\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstyleDefinition(element, value, key)\r\n\t\t\t\t}\r\n\t\t\t} else if (value && value.notifies) {\r\n\t\t\t\tenterRenderer(PropertyRenderer, {\r\n\t\t\t\t\tname: key,\r\n\t\t\t\t\tvariable: value,\r\n\t\t\t\t\telement: element\r\n\t\t\t\t})\r\n\t\t\t} else if (typeof value === 'function' && key.slice(0, 2) === 'on') {\r\n\t\t\t\telement.addEventListener(key.slice(2), value)\r\n\t\t\t} else {\r\n\t\t\t\telement[key] = value\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction applySelector(element, selector) {\r\n\t\tselector.replace(/(\\.|#)?(\\w+)/g, function(t, operator, name) {\r\n\t\t\tif (operator == '.') {\r\n\t\t\t\telement._class = (element._class ? element._class + ' ' : '') + name\r\n\t\t\t} else if (operator == '#') {\r\n\t\t\t\telement._id = name\r\n\t\t\t} else {\r\n\t\t\t\telement._tag = name\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n\r\n\tfunction buildContent(element, content, key, properties) {\r\n\t\tvar each = element.each || properties.each\r\n\t\tif (each && content) {\r\n\t\t\t// render as list\r\n\t\t\tif (each.create) {\r\n\t\t\t\tvar ItemClass = element.itemAs || Item\r\n\t\t\t\thasOwn(each, ItemClass, function (element) {\r\n\t\t\t\t\tvar itemVariable = ItemClass.for(element._item)\r\n\t\t\t\t\titemVariable.collection = content\r\n\t\t\t\t\treturn itemVariable\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tif (content.notifies) {\r\n\t\t\t\tenterRenderer(ListRenderer, {\r\n\t\t\t\t\teach: each,\r\n\t\t\t\t\tvariable: content,\r\n\t\t\t\t\telement: element\r\n\t\t\t\t})\r\n\t\t\t} else {\r\n\t\t\t\tvar fragment = doc.createDocumentFragment()\r\n\t\t\t\tcontent.forEach(function(item) {\r\n\t\t\t\t\tif (each.create) {\r\n\t\t\t\t\t\tchildElement = each.create({parent: element, _item: item}) // TODO: make a faster object here potentially\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tchildElement = each(item, element)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfragment.appendChild(childElement)\r\n\t\t\t\t})\r\n\t\t\t\telement.appendChild(fragment)\r\n\t\t\t}\r\n\t\t} else if (inputs[element.tagName]) {\r\n\t\t\t// render into input\r\n\t\t\tbuildInputContent(element, content)\r\n\t\t} else if (content instanceof Array) {\r\n\t\t\t// treat array as children (potentially of the content node)\r\n\t\t\telement = element.contentNode || element\r\n\t\t\tlayoutChildren(element, content, element)\r\n\t\t} else {\r\n\t\t\t// render as string\r\n\t\t\telement.appendChild(variableAsContent(element, content))\r\n\t\t}\r\n\t}\r\n\r\n\tfunction bindChanges(element, variable, key, conversion) {\r\n\t\tlang.nextTurn(function() { // wait for next turn in case inputChanges isn't set yet\r\n\t\t\tvar inputEvents = element.inputEvents || ['change', 'alkali-change']\r\n\t\t\tfor (var i = 0, l = inputEvents.length; i < l; i++) {\r\n\t\t\t\telement.addEventListener(inputEvents[i], function (event) {\r\n\t\t\t\t\tvar value = element[key]\r\n\t\t\t\t\tvar result = variable.put(conversion ? conversion(value, element) : value, new Context(element))\r\n\t\t\t\t\tif (result === Variable.deny) {\r\n\t\t\t\t\t\tthrow new Error('Variable change denied')\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n\r\n\tdoc.addEventListener('click', function(event) {\r\n\t\tvar target = event.target\r\n\t\tif (target.type === 'radio') {\r\n\t\t\tvar radios = doc.querySelectorAll('input[type=radio]')\r\n\t\t\tfor (var i = 0, l = radios.length; i < l; i++) {\r\n\t\t\t\tvar radio = radios[i]\r\n\t\t\t\tif (radio.name === target.name && radio !== target) {\r\n\t\t\t\t\tradio.dispatchEvent(new Event('alkali-change', {}))\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t})\r\n\r\n\tfunction conversion(value, element) {\r\n\t\tif (element.type == 'number') {\r\n\t\t\treturn parseFloat(value)\r\n\t\t}\r\n\t\treturn value\r\n\t}\r\n\r\n\tfunction buildInputContent(element, content) {\r\n\t\tvar inputType = element.type\r\n\t\tvar inputProperty = inputType in {date: 1, datetime: 1, time: 1} ?\r\n\t\t\t\t'valueAsDate' : (inputType === 'checkbox' || inputType === 'radio') ?\r\n\t\t\t\t\t'checked' : 'value'\r\n\r\n\t\tif (content && content.notifies) {\r\n\t\t\t// a variable, respond to changes\r\n\t\t\tenterRenderer(InputPropertyRenderer, {\r\n\t\t\t\tvariable: content,\r\n\t\t\t\tname: inputProperty,\r\n\t\t\t\telement: element\r\n\t\t\t})\r\n\t\t\t// and bind the other way as well, updating the variable in response to input changes\r\n\t\t\tbindChanges(element, content, inputProperty, conversion)\r\n\t\t} else {\r\n\t\t\t// primitive\r\n\t\t\telement[inputProperty] = content\r\n\t\t}\r\n\t}\r\n\tvar classHandlers = {\r\n\t\thasOwn: function(Element, value) {\r\n\t\t\thasOwn(Element, value)\r\n\t\t}\r\n\t}\r\n\r\n\tfunction applyToClass(value, Element) {\r\n\t\tvar applyOnCreate = Element._applyOnCreate\r\n\t\tvar prototype = Element.prototype\r\n\t\tif (value && typeof value === 'object') {\r\n\t\t\tif (value instanceof Array || value.notifies) {\r\n\t\t\t\tapplyOnCreate.content = value\r\n\t\t\t} else {\r\n\t\t\t\tfor (var key in value) {\r\n\t\t\t\t// TODO: eventually we want to be able to set these as rules statically per element\r\n\t\t\t\t/*if (styleDefinitions[key]) {\r\n\t\t\t\t\tvar styles = Element.styles || (Element.styles = [])\r\n\t\t\t\t\tstyles.push(key)\r\n\t\t\t\t\tstyles[key] = descriptor.value\r\n\t\t\t\t} else {*/\r\n\t\t\t\t\tif (classHandlers[key]) {\r\n\t\t\t\t\t\thasOwn(Element, value[key])\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// TODO: do deep merging of styles and classes, but not variables\r\n\t\t\t\t\t\tapplyOnCreate[key] = value[key]\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (typeof value === 'function' && !value.for) {\r\n\t\t\tthrow new TypeError('Function as argument not supported')\r\n\t\t} else {\r\n\t\t\tapplyOnCreate.content = value\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getApplySet(Class) {\r\n\t\tif (Class.hasOwnProperty('_applyOnCreate')) {\r\n\t\t\treturn Class._applyOnCreate\r\n\t\t}\r\n\t\t// this means we didn't extend and evaluate the prototype yet\r\n\t\tif (Class.getForClass) {\r\n\t\t\t// we are extending an alkali constructor\r\n\t\t\t// if this class is inheriting from an alkali constructor, work our way up the chain\r\n\t\t\tapplyOnCreate = Class._applyOnCreate = {}\r\n\t\t\tvar parentApplySet = getApplySet(getPrototypeOf(Class))\r\n\t\t\tfor (var key in parentApplySet) {\r\n\t\t\t\tapplyOnCreate[key] = parentApplySet[key]\r\n\t\t\t}\r\n\t\t\t// we need to check the prototype for event handlers\r\n\t\t\tvar prototype = Class.prototype\r\n\t\t\tvar keys = Object.getOwnPropertyNames(prototype)\r\n\t\t\tfor (var i = 0, l = keys.length; i < l; i++) {\r\n\t\t\t\tvar key = keys[i]\r\n\t\t\t\tif (key.slice(0, 2) === 'on' || (key === 'render' && isGenerator(prototype[key]))) {\r\n\t\t\t\t\tapplyOnCreate[key] = prototype[key]\r\n\t\t\t\t} else if (key.slice(0, 6) === 'render') {\r\n\t\t\t\t\tObject.defineProperty(prototype, key[6].toLowerCase() + key.slice(7), renderDescriptor(key))\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn applyOnCreate\r\n\t\t}\r\n\t\treturn null\r\n\t}\r\n\r\n\tfunction renderDescriptor(renderMethod) {\r\n\t\tvar map = new WeakMap()\r\n\t\treturn {\r\n\t\t\tget: function() {\r\n\t\t\t\treturn map.has(this) ? map.get(this) : null\r\n\t\t\t},\r\n\t\t\tset: function(value) {\r\n\t\t\t\tmap.set(this, value)\r\n\t\t\t\tthis[renderMethod](value)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction makeElementConstructor() {\r\n\t\tfunction Element(selector, properties) {\r\n\t\t\tif (this instanceof Element){\r\n\t\t\t\t// create DOM element\r\n\t\t\t\t// Need to detect if we have registered the element and `this` is actually already the correct instance\r\n\t\t\t\treturn create.apply(Element.prototype === getPrototypeOf(this) ? Element :// this means it is from this constructor\r\n\t\t\t\t\tthis.constructor, // this means it was constructed from a subclass\r\n\t\t\t\t\targuments)\r\n\t\t\t} else {\r\n\t\t\t\t// extend to create new class\r\n\t\t\t\treturn withProperties.apply(Element, arguments)\r\n\t\t\t}\r\n\t\t}\r\n\t\tElement.create = create\r\n\t\tElement.with = withProperties\r\n\t\tElement.for = forTarget\r\n\t\tElement.property = propertyForElement\r\n\t\tElement.getForClass = getForClass\r\n\t\treturn Element\r\n\t}\r\n\r\n\tfunction withProperties(selector, properties) {\r\n\t\tvar Element = makeElementConstructor()\r\n\t\tElement.superConstructor = this\r\n\t\tElement.tagName = this.tagName\r\n\t\tif (this.children) {\r\n\t\t\t// just copy this property\r\n\t\t\tElement.children = this.children\r\n\t\t}\r\n\t\tvar prototype = Element.prototype = this.prototype\r\n\r\n\t\tvar hasOwnApplySet\r\n\t\tvar applyOnCreate = Element._applyOnCreate = {}\r\n\t\tvar parentApplySet = getApplySet(this)\r\n\t\t// copy parent properties\r\n\t\tfor (var key in parentApplySet) {\r\n\t\t\tapplyOnCreate[key] = parentApplySet[key]\r\n\t\t}\r\n\r\n\t\tvar i = 0 // for arguments\r\n\t\tif (typeof selector === 'string') {\r\n\t\t\tvar selectorMatch = selector.match(SELECTOR_REGEX)\r\n\t\t\tif (selectorMatch) {\r\n\t\t\t\tdo {\r\n\t\t\t\t\tvar operator = selectorMatch[1]\r\n\t\t\t\t\tvar name = selectorMatch[2]\r\n\t\t\t\t\tif (operator == '.') {\r\n\t\t\t\t\t\tif (applyOnCreate.className) {\r\n\t\t\t\t\t\t\tapplyOnCreate.className += ' ' + name\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tapplyOnCreate.className = name\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tapplyOnCreate.id = name\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar remaining = selectorMatch[3]\r\n\t\t\t\t\tselectorMatch = remaining && remaining.match(SELECTOR_REGEX)\r\n\t\t\t\t} while (selectorMatch)\r\n\t\t\t} else {\r\n\t\t\t\tapplyOnCreate.content = selector\r\n\t\t\t}\r\n\t\t\ti++ // skip the first argument\r\n\t\t}\r\n\r\n\t\tfor (var l = arguments.length; i < l; i++) {\r\n\t\t\tapplyToClass(arguments[i], Element)\r\n\t\t}\r\n\t\treturn Element\r\n\t}\r\n\tvar currentParent\r\n\tfunction create(selector, properties) {\r\n\t\t// TODO: make this a symbol\r\n\t\tvar applyOnCreate = getApplySet(this)\r\n\t\tif (currentParent) {\r\n\t\t\tvar parent = currentParent\r\n\t\t\tcurrentParent = null\r\n\t\t}\r\n/*\t\tif (this._initialized != this) {\r\n\t\t\tthis._initialized = this\r\n\t\t\tthis.initialize && this.initialize()\r\n\t\t\tvar styles = this.styles\r\n\t\t\tif (styles) {\r\n\t\t\t\tvar rule = createCssRule(getUniqueSelector(this))\r\n\t\t\t\tfor (var i = 0, l = styles.length; i < l; i++) {\r\n\t\t\t\t\tvar key = styles[i]\r\n\t\t\t\t\tvar value = styles[key]\r\n\t\t\t\t\t// TODO: if it is a contextualized variable, do this on the element\r\n\t\t\t\t\tvar styleDefinition = styleDefinitions[key]\r\n\t\t\t\t\tif (styleDefinition) {\r\n\t\t\t\t\t\tstyleDefinition(rule, value, key)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!this.hasOwnProperty('_applyOnCreate')) {\r\n\t\t\t\tapplyOnCreate = getApplySet(this)\r\n\t\t\t}\r\n\t\t}*/\r\n\t\tvar element = doc.createElement(this.tagName)\r\n\t\tif (selector && selector.parent) {\r\n\t\t\tparent = selector.parent\r\n\t\t}\r\n\t\tif (parent) {\r\n\t\t\tpresumptiveParentMap.set(element, parent)\r\n\t\t}\r\n\t\tif (!(element instanceof this)) {\r\n\t\t\t// ideally we want to avoid this call, as it is expensive, but for classes that\r\n\t\t\t// don't register a tag name, we have to make sure the prototype chain is correct\r\n\t\t\tsetPrototypeOf(element, this.prototype)\r\n\t\t}\r\n\t\tif (element.constructor != this) {\r\n\t\t\telement.constructor = this // need to do this for hasOwn contextualization to work\r\n\t\t}\r\n\t\tif (arguments.length > 0) {\r\n\t\t\t// copy applyOnCreate when we have arguments\r\n\t\t\tvar ElementApplyOnCreate = applyOnCreate\r\n\t\t\tapplyOnCreate = {}\r\n\t\t\tfor (var key in ElementApplyOnCreate) {\r\n\t\t\t\tapplyOnCreate[key] = ElementApplyOnCreate[key]\r\n\t\t\t}\r\n\t\t\tvar i = 0\r\n\t\t\tif (typeof selector == 'string') {\r\n\t\t\t\ti++\r\n\t\t\t\tvar selectorMatch = selector.match(SELECTOR_REGEX)\r\n\t\t\t\tif (selectorMatch) {\r\n\t\t\t\t\tdo {\r\n\t\t\t\t\t\tvar operator = selectorMatch[1]\r\n\t\t\t\t\t\tvar name = selectorMatch[2]\r\n\t\t\t\t\t\tif (operator == '.') {\r\n\t\t\t\t\t\t\tif (applyOnCreate.className) {\r\n\t\t\t\t\t\t\t\tapplyOnCreate.className += ' ' + name\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tif (element.className) {\r\n\t\t\t\t\t\t\t\t    element.className += ' ' + name\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t    element.className = name\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tif (applyOnCreate.id) {\r\n\t\t\t\t\t\t\t\tapplyOnCreate.id = name\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// just skip right to the element\r\n\t\t\t\t\t\t\t\telement.id = name\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar remaining = selectorMatch[3]\r\n\t\t\t\t\t\tselectorMatch = remaining && remaining.match(SELECTOR_REGEX)\r\n\t\t\t\t\t} while (selectorMatch)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tapplyOnCreate.content = selector\r\n\t\t\t\t}\r\n\t\t\t} else if (selector && selector._item) {\r\n\t\t\t\t// this is kind of hack, to get the Item available before the properties, eventually we may want to\r\n\t\t\t\t// order static properties before variable binding applications, but for now.\r\n\t\t\t\telement._item = selector._item\r\n\t\t\t}\r\n\t\t\tfor (var l = arguments.length; i < l; i++) {\r\n\t\t\t\tvar argument = arguments[i]\r\n\t\t\t\tif (argument && typeof argument === 'object') {\r\n\t\t\t\t\tif (argument instanceof Array || argument.notifies) {\r\n\t\t\t\t\t\tapplyOnCreate.content = argument\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tfor (var key in argument) {\r\n\t\t\t\t\t\t\t// TODO: do deep merging of styles and classes, but not variables\r\n\t\t\t\t\t\t\tapplyOnCreate[key] = argument[key]\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (typeof argument === 'function' && argument.for) {\r\n\t\t\t\t\tapplyOnCreate.content = argument.for(element)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tapplyOnCreate.content = argument\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (element.created) {\r\n\t\t\tapplyOnCreate = element.created(applyOnCreate) || applyOnCreate\r\n\t\t}\r\n\t\t// TODO: inline this for better performance, possibly\r\n\t\tassignProperties(element, applyOnCreate)\r\n\t\tif (this.children) {\r\n\t\t\tlayoutChildren(element, this.children, element)\r\n\t\t}\r\n\t\t// always do this last, so it can be properly inserted inside the children\r\n\t\tif (applyOnCreate.content) {\r\n\t\t\tbuildContent(element, applyOnCreate.content, 'content', applyOnCreate)\r\n\t\t}\r\n\t\telement.ready && element.ready(applyOnCreate)\r\n\t\treturn element\r\n\t}\r\n\r\n\tvar slice = [].slice\r\n\tfunction append(parent){\r\n\t\treturn this.nodeType ?\r\n\t\t\tlayoutChildren(this, arguments, this) : // called as a method\r\n\t\t\tlayoutChildren(parent, slice.call(arguments, 1), parent) // called as a function\r\n\t}\r\n\r\n\tfunction prepend(parent){\r\n\t\treturn this.nodeType ?\r\n\t\t\tlayoutChildren(this, arguments, this, true) : // called as a method\r\n\t\t\tlayoutChildren(parent, slice.call(arguments, 1), parent, true) // called as a function\r\n\t}\r\n\r\n\tfunction registerTag(tagName) {\r\n\t\tthis.tagName = tagName\r\n\t\tif (doc.registerElement && this.prototype.constructor === this) {\r\n\t\t\tdoc.registerElement(tagName, this)\r\n\t\t}\r\n\t}\r\n\r\n\tvar Element = withProperties.call(typeof HTMLElement !== 'undefined' ? HTMLElement : function() {})\r\n\r\n\tElement.registerTag = registerTag\r\n\tElement.assign = assignProperties\r\n\r\n\tElement.within = function(element){\r\n\t\t// find closest child\r\n\t}\r\n\r\n\tgenerate([\r\n\t\t'Video',\r\n\t\t'Source',\r\n\t\t'Media',\r\n\t\t'Audio',\r\n\t\t'UL',\r\n\t\t'Track',\r\n\t\t'Title',\r\n\t\t'TextArea',\r\n\t\t'Template',\r\n\t\t'TBody',\r\n\t\t'THead',\r\n\t\t'TFoot',\r\n\t\t'TR',\r\n\t\t'Table',\r\n\t\t'Col',\r\n\t\t'ColGroup',\r\n\t\t'TH',\r\n\t\t'TD',\r\n\t\t'Caption',\r\n\t\t'Style',\r\n\t\t'Span',\r\n\t\t'Shadow',\r\n\t\t'Select',\r\n\t\t'Script',\r\n\t\t'Quote',\r\n\t\t'Progress',\r\n\t\t'Pre',\r\n\t\t'Picture',\r\n\t\t'Param',\r\n\t\t'P',\r\n\t\t'Output',\r\n\t\t'Option',\r\n\t\t'Optgroup',\r\n\t\t'Object',\r\n\t\t'OL',\r\n\t\t'Ins',\r\n\t\t'Del',\r\n\t\t'Meter',\r\n\t\t'Meta',\r\n\t\t'Menu',\r\n\t\t'Map',\r\n\t\t'Link',\r\n\t\t'Legend',\r\n\t\t'Label',\r\n\t\t'LI',\r\n\t\t'KeyGen',\r\n\t\t'Input',\r\n\t\t'Image',\r\n\t\t'IFrame',\r\n\t\t'H1',\r\n\t\t'H2',\r\n\t\t'H3',\r\n\t\t'H4',\r\n\t\t'H5',\r\n\t\t'H6',\r\n\t\t'Hr',\r\n\t\t'FrameSet',\r\n\t\t'Frame',\r\n\t\t'Form',\r\n\t\t'Font',\r\n\t\t'Embed',\r\n\t\t'Article',\r\n\t\t'Aside',\r\n\t\t'Footer',\r\n\t\t'Figure',\r\n\t\t'FigCaption',\r\n\t\t'Header',\r\n\t\t'Main',\r\n\t\t'Mark',\r\n\t\t'MenuItem',\r\n\t\t'Nav',\r\n\t\t'Section',\r\n\t\t'Summary',\r\n\t\t'WBr',\r\n\t\t'Div',\r\n\t\t'Dialog',\r\n\t\t'Details',\r\n\t\t'DataList',\r\n\t\t'DL',\r\n\t\t'Canvas',\r\n\t\t'Button',\r\n\t\t'Base',\r\n\t\t'Br',\r\n\t\t'Area',\r\n\t\t'A'\r\n\t])\r\n\tgenerateInputs([\r\n\t\t'Checkbox',\r\n\t\t'Password',\r\n\t\t'Submit',\r\n\t\t'Radio',\r\n\t\t'Color',\r\n\t\t'Date',\r\n\t\t'DateTime',\r\n\t\t'Email',\r\n\t\t'Month',\r\n\t\t'Number',\r\n\t\t'Range',\r\n\t\t'Search',\r\n\t\t'Tel',\r\n\t\t'Time',\r\n\t\t'Url',\r\n\t\t'Week'])\r\n\r\n\tvar tags = {}\r\n\tfunction getConstructor(tagName) {\r\n\t\ttagName = tagName.toLowerCase()\r\n\t\treturn tags[tagName] ||\r\n\t\t\t(tags[tagName] =\r\n\t\t\t\tsetTag(withProperties.call(doc.createElement(tagName).constructor), tagName))\r\n\t}\r\n\r\n\tfunction setTag(Element, tagName) {\r\n\t\tElement.tagName = tagName\r\n\t\treturn Element\r\n\t}\r\n\tfunction generate(elements) {\r\n\t\telements.forEach(function(elementName) {\r\n\t\t\tvar ElementClass\r\n\t\t\tObject.defineProperty(Element, elementName, {\r\n\t\t\t\tget: function() {\r\n\t\t\t\t\treturn ElementClass || (ElementClass = getConstructor(elementName))\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t})\r\n\t}\r\n\tfunction generateInputs(elements) {\r\n\t\telements.forEach(function(inputType) {\r\n\t\t\tvar ElementClass\r\n\t\t\tObject.defineProperty(Element, inputType, {\r\n\t\t\t\tget: function() {\r\n\t\t\t\t\t// TODO: make all inputs extend from input generated from generate\r\n\t\t\t\t\treturn ElementClass || (ElementClass = setTag(withProperties.call(HTMLInputElement, {\r\n\t\t\t\t\t\ttype: inputType.toLowerCase()\r\n\t\t\t\t\t}), 'input'))\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\t// alias all the inputs with an Input suffix\r\n\t\t\tObject.defineProperty(Element, inputType + 'Input', {\r\n\t\t\t\tget: function() {\r\n\t\t\t\t\treturn this[inputType]\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t})\r\n\t}\r\n\r\n\tvar aliases = {\r\n\t\tAnchor: 'A',\r\n\t\tParagraph: 'P',\r\n\t\tTextarea: 'TextArea',\r\n\t\tDList: 'DL',\r\n\t\tUList: 'UL',\r\n\t\tOList: 'OL',\r\n\t\tListItem: 'LI',\r\n\t\tText: 'Input',\r\n\t\tTextInput: 'Input',\r\n\t\tTableRow: 'TR',\r\n\t\tTableCell: 'TD',\r\n\t\tTableHeaderCell: 'TH',\r\n\t\tTableHeader: 'THead',\r\n\t\tTableBody: 'TBody'\r\n\t}\r\n\tfor (var alias in aliases) {\r\n\t\t(function(alias, to) {\r\n\t\t\tObject.defineProperty(Element, alias, {\r\n\t\t\t\tget: function() {\r\n\t\t\t\t\treturn this[to]\r\n\t\t\t\t}\r\n\t\t\t})\t\t\t\r\n\t\t})(alias, aliases[alias])\r\n\t}\r\n\r\n\tElement.append = append\r\n\tElement.prepend = prepend\r\n\tElement.refresh = Renderer.refresh\r\n\tvar options = Element.options = {\r\n\t\tmoveLiveElementsEnabled: true,\r\n\t}\r\n\tElement.content = function(element){\r\n\t\t// container marker\r\n\t\treturn {\r\n\t\t\tisContentNode: true,\r\n\t\t\tcreate: element.create.bind(element)\r\n\t\t}\r\n\t}\r\n\t// TODO: unify this in lang\r\n\tElement.extend = function(Class, properties) {\r\n\t\tfunction ExtendedElement() {\r\n\t\t\treturn Class.apply(this, arguments)\r\n\t\t}\r\n\t\tsetPrototypeOf(ExtendedElement, Class)\r\n\t\tvar prototype = ExtendedElement.prototype = Object.create(Class.prototype)\r\n\t\tprototype.constructor = ExtendedElement\r\n\t\tObject.getOwnPropertyNames(properties).forEach(function(key) {\r\n\t\t\tvar descriptor = Object.getOwnPropertyDescriptor(properties, key)\r\n\t\t\tif (classHandlers[key]) {\r\n\t\t\t\tclassHandlers[key](ExtendedElement, descriptor.value)\r\n\t\t\t} else {\r\n\t\t\t\tObject.defineProperty(prototype, key, descriptor)\r\n\t\t\t}\r\n\t\t})\r\n\t\treturn ExtendedElement\r\n\t}\r\n\r\n\tfunction forTarget(target) {\r\n\t\treturn target.constructor.getForClass(target, this)\r\n\t}\r\n\r\n\tfunction hasOwn(From, Target, createInstance) {\r\n\t\tif (typeof Target === 'object' && Target.Class) {\r\n\t\t\treturn hasOwn(From, Target.Class, Target.createInstance)\r\n\t\t}\r\n\t\tif (Target instanceof Array) {\r\n\t\t\treturn Target.forEach(function(Target) {\r\n\t\t\t\thasOwn(From, Target)\r\n\t\t\t})\r\n\t\t}\r\n\t\tvar ownedClasses = From.ownedClasses || (From.ownedClasses = new WeakMap())\r\n\t\t// TODO: assign to super classes\r\n\t\townedClasses.set(Target, createInstance || function() {\r\n\t\t\treturn new Target()\r\n\t\t})\r\n\t\treturn From\r\n\t}\r\n\r\n\tvar globalInstances = {}\r\n\tfunction getForClass(element, Target) {\r\n\t\tvar createInstance\r\n\t\twhile (element && !(createInstance = element.constructor.ownedClasses && element.constructor.ownedClasses.get(Target))) {\r\n\t\t\telement = element.parentNode || presumptiveParentMap.get(element)\r\n\t\t}\r\n\t\tif (createInstance) {\r\n\t\t\tvar ownedInstances = element.ownedInstances || (element.ownedInstances = new WeakMap())\r\n\t\t\tvar instance = ownedInstances.get(Target)\r\n\t\t\tif (instance === undefined) {\r\n\t\t\t\townedInstances.set(Target, instance = createInstance(element))\r\n\t\t\t\tinstance.subject = element\r\n\t\t\t}\r\n\t\t\treturn instance\r\n\t\t}\r\n\t}\r\n\r\n\tfunction propertyForElement(key) {\r\n\t\t// we just need to establish one Variable class for each element, so we cache it\r\n\t\tThisElementVariable = this._Variable\r\n\t\tif (!ThisElementVariable) {\r\n\t\t\t// need our own branded variable class for this element class\r\n\t\t\tThisElementVariable = this._Variable = Variable()\r\n\r\n\t\t\thasOwn(this, ThisElementVariable, function(element) {\r\n\t\t\t\t// TODO: we might want to do this in init instead\r\n\t\t\t\tvar instance = new ThisElementVariable(element)\r\n\t\t\t\t// we are not observing, because you can't delegate getters and setters in safari\r\n\t\t\t\t// instance.observeObject()\r\n\t\t\t\tif (element.updaters) {\r\n\t\t\t\t\tinstance._properties = {}\r\n\t\t\t\t\t// so find any variables and install them in the created instance\r\n\t\t\t\t\tfor (var i = 0; i < element.updaters.length; i++){\r\n\t\t\t\t\t\tvar updater = element.updaters[i]\r\n\t\t\t\t\t\tif (updater.name) {\r\n\t\t\t\t\t\t\tinstance._properties[updater.name] = updater.variable\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn instance\r\n\t\t\t})\r\n\t\t}\r\n\t\t// now actually get the property class\r\n\t\treturn ThisElementVariable.property(key)\r\n\t}\r\n\r\n\tvar Item = Element.Item = Variable.Item\r\n\r\n\tfunction enterRenderer(Renderer, options/*, target*/) {\r\n\t\t// this will be used for optimized class-level variables\r\n\t\t/*if (target.started) { // TODO: Might want to pass in started as a parameter\r\n\t\t\t// this means that the updater has already been created, so we just need to add this instance\r\n\t\t\tRenderer.prototype.renderUpdate.call(options, element)\r\n\t\t} else {*/\r\n\t\tvar target = options.element\r\n\t\tvar updaters = target.updaters || (target.updaters = [])\r\n\t\tupdaters.push(new Renderer(options))\r\n\t\t//}\r\n\t}\r\n\r\n\tfunction cleanup(target) {\r\n\t\tvar updaters = target.updaters\r\n\t\tif (updaters) {\r\n\t\t\tfor (var i = 0, l = updaters.length; i < l; i++) {\r\n\t\t\t\tupdaters[i].stop()\r\n\t\t\t}\r\n\t\t\ttarget.needsRestart = true\r\n\t\t}\r\n\t}\r\n\tfunction restart(target) {\r\n\t\tvar updaters = target.updaters\r\n\t\tif (updaters) {\r\n\t\t\tfor (var i = 0, l = updaters.length; i < l; i++) {\r\n//\t\t\t\tupdaters[i].start()\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t// setup the mutation observer so we can be notified of attachments and removals\r\n\tfunction elementAttached(element) {\r\n\t\tvar Class = element.constructor\r\n\t\tif (Class.create) {\r\n/*\t\t\tif (Class.attachedInstances) {\r\n\t\t\t\tClass.attachedInstances.push(element)\r\n\t\t\t\tif (Class.attachedInstances.length === 1 && Class.needsRestart) {\r\n\t\t\t\t\trestart(Class)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tClass.attachedInstances = [element]\r\n\t\t\t}*/\r\n\t\t\tif (element.attached) {\r\n\t\t\t\telement.attached()\r\n\t\t\t}\r\n\t\t\tif (element.needsRestart) {\r\n\t\t\t\trestart(element)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfunction elementDetached(element) {\r\n\t\t/*var attachedInstances = element.constructor.attachedInstances\r\n\t\tif (attachedInstances) {\r\n\t\t\tvar index = attachedInstances.indexOf(element)\r\n\t\t\tif (index > -1) {\r\n\t\t\t\tattachedInstances.splice(index, 1)\r\n\t\t\t\tif (attachedInstances.length === 0) {\r\n\t\t\t\t\tcleanup(Class)\r\n\t\t\t\t}\r\n\t\t\t}*/\r\n\t\t\tif (element.detached) {\r\n\t\t\t\telement.detached()\r\n\t\t\t}\r\n\t\t\tcleanup(element)\r\n\t\t//}\r\n\t}\r\n\tif (typeof MutationObserver === 'function') {\r\n\t\tvar docBody = doc.body\r\n\t\tvar lifeStates = [{\r\n\t\t\tname: 'detached',\r\n\t\t\tnodes: 'removedNodes',\r\n\t\t\taction: elementDetached\r\n\t\t}, {\r\n\t\t\tname: 'attached',\r\n\t\t\tnodes: 'addedNodes',\r\n\t\t\taction: elementAttached\r\n\t\t}]\r\n\t\tfunction firstVisit(node, state) {\r\n\t\t\tif (state.name === 'attached') {\r\n\t\t\t\tif (node.__alkaliAttached__) {\r\n\t\t\t\t\treturn false\r\n\t\t\t\t} else {\r\n\t\t\t\t\tnode.__alkaliAttached__ = true\r\n\t\t\t\t\tstate.action(node)\r\n\t\t\t\t\treturn true\r\n\t\t\t\t}\r\n\t\t\t} else if (node.__alkaliAttached__) {\r\n\t\t\t\tif (docBody.contains(node)) {\r\n\t\t\t\t\t// detached event, but it is actually still attached (will get attached in a later mutation record)\r\n\t\t\t\t\t// so don't get through the detached/attached lifecycle\r\n\t\t\t\t\treturn false\r\n\t\t\t\t}\r\n\t\t\t\tnode.__alkaliAttached__ = false\r\n\t\t\t\tstate.action(node)\r\n\t\t\t}\r\n\t\t\treturn true\r\n\t\t}\r\n\t\tvar observer = new MutationObserver(function(mutations) {\r\n\t\t\tfor (var i = 0, il = mutations.length; i < il; i++) {\r\n\t\t\t\tvar mutation = mutations[i]\r\n\t\t\t\t// invoke action on element if we haven't already\r\n\t\t\t\tactionIteration:\r\n\t\t\t\tfor (var j = 0, jl = lifeStates.length; j < jl; j++) { // two steps, removed nodes and added nodes\r\n\t\t\t\t\tvar state = lifeStates[j]\r\n\t\t\t\t\tvar nodes = mutation[state.nodes]\r\n\t\t\t\t\t// iterate over node list\r\n\t\t\t\t\tnodeIteration:\r\n\t\t\t\t\tfor (var k = 0, kl = nodes.length; k < kl; k++) {\r\n\t\t\t\t\t\tvar baseNode = nodes[k]\r\n\t\t\t\t\t\tif (firstVisit(baseNode, state)) {\r\n\t\t\t\t\t\t\t// start traversal with child, if it exists\r\n\t\t\t\t\t\t\tvar currentNode = baseNode.firstChild\r\n\t\t\t\t\t\t\tif (currentNode) {\r\n\t\t\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\t\t\tvar nextNode\r\n\t\t\t\t\t\t\t\t\tif (currentNode.nodeType === 1 && firstVisit(currentNode, state)) {\r\n\t\t\t\t\t\t\t\t\t\t// depth-first search\r\n\t\t\t\t\t\t\t\t\t\tnextNode = currentNode.firstChild\r\n\t\t\t\t\t\t\t\t\t\tif (!nextNode) {\r\n\t\t\t\t\t\t\t\t\t\t\tnextNode = currentNode.nextSibling\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\tnextNode = currentNode.nextSibling\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tif (!nextNode) {\r\n\t\t\t\t\t\t\t\t\t\t// come back out to parents\r\n\t\t\t\t\t\t\t\t\t\t// TODO: try keeping a stack to make this faster\r\n\t\t\t\t\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\t\t\t\t\tcurrentNode = currentNode.parentNode\r\n\t\t\t\t\t\t\t\t\t\t\tif (currentNode === baseNode) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tcontinue nodeIteration\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t} while (!(nextNode = currentNode.nextSibling))\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tcurrentNode = nextNode\r\n\t\t\t\t\t\t\t\t} while (true)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// if (options.moveLiveElementsEnabled) {\r\n\t\t\t\t\t\t// TODO: any options that we can really do here?\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t\tobserver.observe(docBody, {\r\n\t\t\tchildList: true,\r\n\t\t\tsubtree: true\r\n\t\t})\r\n\t}\r\n\r\n\treturn Element\r\n})\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./Element.js\n ** module id = 1\n ** module chunks = 0\n **/","define(['./util/lang'], function (lang) {\r\n\tvar deny = {}\r\n\tvar noChange = {}\r\n\tvar WeakMap = lang.WeakMap\r\n\tvar setPrototypeOf = Object.setPrototypeOf || (function(base, proto) { base.__proto__ = proto})\r\n\tvar getPrototypeOf = Object.getPrototypeOf || (function(base) { return base.__proto__ })\r\n\t// update types\r\n\tvar ToParent = 2\r\n\tvar RequestChange = 3\r\n\tvar RequestSet = 4\r\n\t\r\n\tvar ToChild = Object.freeze({\r\n\t\ttype: 'refresh'\r\n\t})\r\n\tvar nextId = 1\r\n\tvar propertyListenersMap = new WeakMap(null, 'propertyListenersMap')\r\n\r\n\tvar CacheEntry = lang.compose(WeakMap, function() {\r\n\t},{\r\n\t\t_propertyChange: function(propertyName) {\r\n\t\t\tthis.variable._propertyChange(propertyName, contextFromCache(this))\r\n\t\t}\r\n\t})\r\n\tvar listenerId = 1\r\n\r\n\tfunction mergeSubject(context) {\r\n\t\tfor (var i = 1, l = arguments.length; i < l; i++) {\r\n\t\t\tvar nextContext = arguments[i]\r\n\t\t\tif (nextContext !== context && (!context || nextContext && context.contains && context.contains(nextContext))) {\r\n\t\t\t\tcontext = nextContext\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn context\r\n\t}\r\n\r\n\tfunction getMaterializedContextualInstance(variable, context) {\r\n\t\tvar subject = context && (context.distinctSubject || context.subject)\r\n\t\tif (typeof variable === 'function') {\r\n\t\t\treturn variable.for(subject)\r\n\t\t}\r\n\t\tvar contextMap = variable.contextMap\r\n\t\tif (context && contextMap) {\r\n\t\t\twhile(subject && !contextMap.has(subject)) {\r\n\t\t\t\tsubject = subject.parentNode\r\n\t\t\t}\r\n\t\t\tif (!subject) {\r\n\t\t\t\tsubject = defaultContext\r\n\t\t\t}\r\n\t\t\treturn contextMap.get(subject)\r\n\t\t}\r\n\t}\r\n\tfunction when(value, callback) {\r\n\t\tif (value && value.then) {\r\n\t\t\treturn value.then(callback)\r\n\t\t}\r\n\t\treturn callback(value)\r\n\t}\r\n\r\n\tfunction Context(subject){\r\n\t\tthis.subject = subject\r\n\t}\r\n\tfunction whenAll(inputs, callback){\r\n\t\tvar promiseInvolved\r\n\t\tvar needsContext\r\n\t\tfor (var i = 0, l = inputs.length; i < l; i++) {\r\n\t\t\tif (inputs[i] && inputs[i].then) {\r\n\t\t\t\tpromiseInvolved = true\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (promiseInvolved) {\r\n\t\t\treturn lang.whenAll(inputs, callback)\r\n\t\t}\r\n\t\treturn callback(inputs)\r\n\t}\r\n\r\n\tfunction registerListener(value, listener) {\r\n\t\tvar listeners = propertyListenersMap.get(value)\r\n\t\tvar id = listener.listenerId || (listener.listenerId = ('-' + listenerId++))\r\n\t\tif (listeners) {\r\n\t\t\tif (listeners[id] === undefined) {\r\n\t\t\t\tlisteners[id] = listeners.push(listener) - 1\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\tpropertyListenersMap.set(value, listeners = [listener])\r\n\t\t\tlisteners[id] = 0\r\n\t\t\tif (Variable.autoObserveObjects) {\r\n\t\t\t\tobserve(value)\r\n\t\t\t}\r\n\t\t}\r\n\t\tlistener.listeningToObject = value\r\n\t}\r\n\tfunction deregisterListener(listener) {\r\n\t\tif (listener.listeningToObject) {\r\n\t\t\tvar value = listener.listeningToObject\r\n\t\t\tlistener.listeningToObject = null\r\n\t\t\tvar listeners = propertyListenersMap.get(value)\r\n\t\t\tif (listeners) {\r\n\t\t\t\tvar index = listeners[listener.listenerId]\r\n\t\t\t\tif (index > -1) {\r\n\t\t\t\t\tlisteners.splice(index, 1)\r\n\t\t\t\t\tdelete listeners[listener.listenerId]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction RefreshEvent() {\r\n\t\tthis.visited = new Set()\r\n\t}\r\n\tRefreshEvent.prototype.type = 'refresh'\r\n\r\n\tfunction PropertyChangeEvent(key, childEvent, parent) {\r\n\t\tthis.key = key\r\n\t\tthis.childEvent = childEvent\r\n\t\tthis.parent = parent\r\n\t\tthis.visited = childEvent.visited\r\n\t}\r\n\tPropertyChangeEvent.prototype.type = 'update'\r\n\r\n\tfunction AddEvent(args) {\r\n\t\tthis.visited = new Set()\r\n\t\tfor (var key in args) {\r\n\t\t\tthis[key] = args[key]\r\n\t\t}\r\n\t}\r\n\tAddEvent.prototype.type = 'add'\r\n\tfunction DeleteEvent(args) {\r\n\t\tthis.visited = new Set()\r\n\t\tfor (var key in args) {\r\n\t\t\tthis[key] = args[key]\r\n\t\t}\r\n\t}\r\n\tDeleteEvent.prototype.type = 'delete'\r\n\r\n\r\n\tfunction Variable(value) {\r\n\t\tif (this instanceof Variable) {\r\n\t\t\t// new call, may eventually use new.target\r\n\t\t\tthis.value = typeof value === 'undefined' ? this.default : value\r\n\t\t} else {\r\n\t\t\treturn Variable.extend(value)\r\n\t\t}\r\n\t}\r\n\tvar VariablePrototype = Variable.prototype = {\r\n\t\tconstructor: Variable,\r\n\t\tvalueOf: function(context) {\r\n\t\t\tif (this.subject) {\r\n\t\t\t\tvar variable = this\r\n\t\t\t\tcontext = new Context(this.subject)\r\n\t\t\t}\r\n\t\t\treturn this.gotValue(this.getValue(context), context)\r\n\t\t},\r\n\t\tgetValue: function() {\r\n\t\t\treturn this.value\r\n\t\t},\r\n\t\tgotValue: function(value, context) {\r\n\t\t\tvar previousNotifyingValue = this.notifyingValue\r\n\t\t\tvar variable = this\r\n\t\t\tif (value && value.then) {\r\n\t\t\t\treturn when(value, function(value) {\r\n\t\t\t\t\treturn Variable.prototype.gotValue.call(variable, value, context)\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tif (previousNotifyingValue) {\r\n\t\t\t\tif (value === previousNotifyingValue) {\r\n\t\t\t\t\t// nothing changed, immediately return valueOf (or ownObject if we have it)\r\n\t\t\t\t\treturn variable.ownObject || value.valueOf(context)\r\n\t\t\t\t}\r\n\t\t\t\t// if there was a another value that we were dependent on before, stop listening to it\r\n\t\t\t\t// TODO: we may want to consider doing cleanup after the next rendering turn\r\n\t\t\t\tif (variable.dependents) {\r\n\t\t\t\t\tpreviousNotifyingValue.stopNotifies(variable)\r\n\t\t\t\t}\r\n\t\t\t\tvariable.notifyingValue = null\r\n\t\t\t}\r\n\t\t\tif (value && value.notifies) {\r\n\t\t\t\tif (variable.dependents) {\r\n\t\t\t\t\t\t// the value is another variable, start receiving notifications\r\n\t\t\t\t\tvalue.notifies(variable)\r\n\t\t\t\t}\r\n\t\t\t\tvariable.notifyingValue = value\r\n\t\t\t\tvalue = value.valueOf(context)\r\n\t\t\t\tif (variable.ownObject) {\r\n\t\t\t\t\tif (getPrototypeOf(variable.ownObject) !== value) {\r\n\t\t\t\t\t\tsetPrototypeOf(variable.ownObject, value)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvalue = variable.ownObject\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (value === undefined) {\r\n\t\t\t\tvalue = variable.default\r\n\t\t\t}\r\n\t\t\treturn value\r\n\t\t},\r\n\t\tisMap: function() {\r\n\t\t\treturn this.value instanceof Map\r\n\t\t},\r\n\t\tproperty: function(key) {\r\n\t\t\tvar isMap = this.isMap()\r\n\t\t\tvar properties = this._properties || (this._properties = isMap ? new Map() : {})\r\n\t\t\tvar propertyVariable = isMap ? properties.get(key) : properties[key]\r\n\t\t\tif (!propertyVariable) {\r\n\t\t\t\t// create the property variable\r\n\t\t\t\tpropertyVariable = new Property(this, key)\r\n\t\t\t\tif (isMap) {\r\n\t\t\t\t\tproperties.set(key, propertyVariable)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tproperties[key] = propertyVariable\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn propertyVariable\r\n\t\t},\r\n\t\tfor: function(subject) {\r\n\t\t\tif (subject && subject.target && !subject.constructor.getForClass) {\r\n\t\t\t\t// makes HTML events work\r\n\t\t\t\tsubject = subject.target\r\n\t\t\t}\r\n\t\t\tif (typeof this === 'function') {\r\n\t\t\t\t// this is a class, the subject should hopefully have an entry\r\n\t\t\t\tif (subject !== undefined) {\r\n\t\t\t\t\tvar instance\r\n\t\t\t\t\tif (subject.constructor.getForClass) {\r\n\t\t\t\t\t\t// if the subject has it is own means of retrieving an instance\r\n\t\t\t\t\t\tinstance = subject.constructor.getForClass(subject, this)\r\n\t\t\t\t\t\tif (instance && !instance.subject) {\r\n\t\t\t\t\t\t\tinstance.subject = subject\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (subject && typeof subject === 'object') {\r\n\t\t\t\t\t\t\t// a plain object, we use our own map to retrieve the instance (or create one)\r\n\t\t\t\t\t\t\tvar instanceMap = this.instanceMap || (this.instanceMap = new WeakMap())\r\n\t\t\t\t\t\t\tinstance = instanceMap.get(subject)\r\n\t\t\t\t\t\t\tif (!instance) {\r\n\t\t\t\t\t\t\t\tinstanceMap.set(subject, instance = new this(subject))\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// a primitive, just unconditionally create a new variable for it\r\n\t\t\t\t\t\t\tinstance = new this(subject)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// TODO: Do we have a global context that we set on defaultInstance?\r\n\t\t\t\t\treturn instance || this.defaultInstance\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn this.defaultInstance\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn new ContextualizedVariable(this, subject || defaultContext)\r\n\t\t},\r\n\t\tdistinctFor: function(subject) {\r\n\t\t\tif (typeof this === 'function') {\r\n\t\t\t\treturn this.for(subject)\r\n\t\t\t}\r\n\t\t\tvar map = this.contextMap || (this.contextMap = new WeakMap())\r\n\t\t\tif (map.has(subject)) {\r\n\t\t\t\treturn map.get(subject)\r\n\t\t\t}\r\n\t\t\tvar contextualizedVariable\r\n\t\t\tmap.set(subject, contextualizedVariable = new ContextualizedVariable(this, subject))\r\n\t\t\treturn contextualizedVariable\r\n\t\t},\r\n\t\t_propertyChange: function(propertyName, object, context, type) {\r\n\t\t\tif (this.onPropertyChange) {\r\n\t\t\t\tthis.onPropertyChange(propertyName, object, context)\r\n\t\t\t}\r\n\t\t\tthis.updated(new PropertyChangeEvent(propertyName, new RefreshEvent(), this), null, context)\r\n\t\t},\r\n\t\teachKey: function(callback) {\r\n\t\t\tfor (var i in this._properties) {\r\n\t\t\t\tcallback(i)\r\n\t\t\t}\r\n\t\t},\r\n\t\tapply: function(instance, args) {\r\n\t\t\treturn new Call(this, args)\r\n\t\t},\r\n\t\tcall: function(instance) {\r\n\t\t\treturn this.apply(instance, Array.prototype.slice.call(arguments, 1))\r\n\t\t},\r\n\t\tforDependencies: function(callback) {\r\n\t\t\tif (this.notifyingValue) {\r\n\t\t\t\tcallback(this.notifyingValue)\r\n\t\t\t}\r\n\t\t},\r\n\t\tinit: function() {\r\n\t\t\tif (this.subject) {\r\n\t\t\t\tthis.constructor.notifies(this)\r\n\t\t\t}\r\n\t\t\tvar variable = this\r\n\t\t\tthis.forDependencies(function(dependency) {\r\n\t\t\t\tdependency.notifies(variable)\r\n\t\t\t})\r\n\t\t\tif (this.listeningToObject === null) {\r\n\t\t\t\t// we were previously listening to an object, but it needs to be restored\r\n\t\t\t\t// calling valueOf will cause the listening object to be restored\r\n\t\t\t\tthis.valueOf()\r\n\t\t\t}\r\n\t\t},\r\n\t\tcleanup: function() {\r\n\t\t\tvar handles = this.handles\r\n\t\t\tif (handles) {\r\n\t\t\t\tfor (var i = 0; i < handles.length; i++) {\r\n\t\t\t\t\thandles[i].remove()\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.handles = null\r\n\t\t\tvar notifyingValue = this.notifyingValue\r\n\t\t\tif (notifyingValue) {\r\n\t\t\t\t// TODO: move this into the caching class\r\n\t\t\t\tthis.computedVariable = null\r\n\t\t\t}\r\n\t\t\tvar variable = this\r\n\t\t\tthis.forDependencies(function(dependency) {\r\n\t\t\t\tdependency.stopNotifies(variable)\r\n\t\t\t})\r\n\t\t\tif (this.context) {\r\n\t\t\t\tthis.constructor.stopNotifies(this)\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tupdateVersion: function(version) {\r\n\t\t\tthis.version = nextId++\r\n\t\t},\r\n\r\n\t\tgetVersion: function(context) {\r\n\t\t\treturn Math.max(this.version || 0, this.notifyingValue && this.notifyingValue.getVersion ? this.notifyingValue.getVersion(context) : 0)\r\n\t\t},\r\n\r\n\t\tgetSubject: function(selectVariable) {\r\n\t\t\treturn this.subject\r\n\t\t},\r\n\r\n\t\tgetUpdates: function(since) {\r\n\t\t\tvar updates = []\r\n\t\t\tvar nextUpdateMap = this.nextUpdateMap\r\n\t\t\tif (nextUpdateMap && since) {\r\n\t\t\t\twhile ((since = nextUpdateMap.get(since))) {\r\n\t\t\t\t\tif (since.type === 'refresh') {\r\n\t\t\t\t\t\t// if it was refresh, we can clear any prior entries\r\n\t\t\t\t\t\tupdates = []\r\n\t\t\t\t\t}\r\n\t\t\t\t\tupdates.push(since)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn updates\r\n\t\t},\r\n\r\n\t\tupdated: function(updateEvent, by, context) {\r\n\t\t\tif (!updateEvent) {\r\n\t\t\t\tupdateEvent = new RefreshEvent()\r\n\t\t\t}\r\n\t\t\tif (updateEvent.visited.has(this)){\r\n\t\t\t\t// if this event has already visited this variable, skip it\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tupdateEvent.visited.add(this)\r\n\t\t\tif (this.subject) {\r\n\t\t\t\tif (by === this.constructor) {\r\n\t\t\t\t\t// if we receive an update from the constructor, filter it\r\n\t\t\t\t\tif (!(!context || (context.distinctSubject || context.subject) === this.subject || (context.subject.contains && this.subject.nodeType && context.subject.contains(this.subject)))) {\r\n\t\t\t\t\t\treturn\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// if we receive an outside update, send it to the constructor\r\n\t\t\t\t\treturn this.constructor.updated(updateEvent, this, new Context(this.subject))\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tvar contextualInstance = getMaterializedContextualInstance(this, context)\r\n\t\t\tif (contextualInstance) {\r\n\t\t\t\tcontextualInstance.updated(updateEvent, this, context)\r\n\t\t\t}\r\n\t\t\tif (this.lastUpdate) {\r\n\t\t\t\tvar nextUpdateMap = this.nextUpdateMap\r\n\t\t\t\tif (!nextUpdateMap) {\r\n\t\t\t\t\tnextUpdateMap = this.nextUpdateMap = new WeakMap()\r\n\t\t\t\t}\r\n\t\t\t\tnextUpdateMap.set(this.lastUpdate, updateEvent)\r\n\t\t\t}\r\n\r\n\t\t\tthis.lastUpdate = updateEvent\r\n\t\t\tthis.updateVersion()\r\n\t\t\tvar value = this.value\r\n\r\n\t\t\tvar dependents = this.dependents\r\n\t\t\tif (dependents) {\r\n\t\t\t\t// make a copy, in case they change\r\n\t\t\t\tdependents = dependents.slice(0)\r\n\t\t\t\tfor (var i = 0, l = dependents.length; i < l; i++) {\r\n\t\t\t\t\ttry{\r\n\t\t\t\t\t\tvar dependent = dependents[i]\r\n\t\t\t\t\t\tif ((updateEvent instanceof PropertyChangeEvent) &&\r\n\t\t\t\t\t\t\t\t(dependent instanceof Property)) {\r\n\t\t\t\t\t\t\tif (dependent.key === updateEvent.key) {\r\n\t\t\t\t\t\t\t\tdependent.updated(updateEvent.childEvent, this, context)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tdependent.updated(updateEvent, this, context)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}catch(e) {\r\n\t\t\t\t\t\tconsole.error(e, e.stack, 'updating a variable')\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (updateEvent instanceof PropertyChangeEvent) {\r\n\t\t\t\tif (this.notifyingValue && this.fixed) {\r\n\t\t\t\t\tthis.notifyingValue.updated(updateEvent, this, context)\r\n\t\t\t\t}\r\n\t\t\t\tif (this.collection) {\r\n\t\t\t\t\tthis.collection.updated(updateEvent, this, context)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn updateEvent\r\n\t\t},\r\n\r\n\t\tinvalidate: function() {\r\n\t\t\t// for back-compatibility for now\r\n\t\t\tthis.updated()\r\n\t\t},\r\n\r\n\t\tnotifies: function(target) {\r\n\t\t\tvar dependents = this.dependents\r\n\t\t\tif (!dependents || !this.hasOwnProperty('dependents')) {\r\n\t\t\t\tthis.dependents = dependents = []\r\n\t\t\t\tthis.init()\r\n\t\t\t}\r\n\t\t\tdependents.push(target)\r\n\t\t\tvar variable = this\r\n\t\t\treturn {\r\n\t\t\t\tunsubscribe: function() {\r\n\t\t\t\t\tvariable.stopNotifies(target)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tsubscribe: function(listener) {\r\n\t\t\t// ES7 Observable (and baconjs) compatible API\r\n\t\t\tvar updated\r\n\t\t\tvar updateQueued\r\n\t\t\tvar variable = this\r\n\t\t\t// it is important to make sure you register for notifications before getting the value\r\n\t\t\tif (typeof listener === 'function') {\r\n\t\t\t\t// BaconJS compatible API\r\n\t\t\t\tvar variable = this\r\n\t\t\t\tvar event = {\r\n\t\t\t\t\tvalue: function() {\r\n\t\t\t\t\t\treturn variable.valueOf()\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tupdated = function() {\r\n\t\t\t\t\tupdateQueued = false\r\n\t\t\t\t\tlistener(event)\r\n\t\t\t\t}\r\n\t\t\t}\telse if (listener.next) {\r\n\t\t\t\t// Assuming ES7 Observable API. It is actually a streaming API, this pretty much violates all principles of reactivity, but we will support it\r\n\t\t\t\tupdated = function() {\r\n\t\t\t\t\tupdateQueued = false\r\n\t\t\t\t\tlistener.next(variable.valueOf())\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tthrow new Error('Subscribing to an invalid listener, the listener must be a function, or have an update or next method')\r\n\t\t\t}\r\n\r\n\t\t\tvar handle = this.notifies({\r\n\t\t\t\tupdated: function() {\r\n\t\t\t\t\tif (updateQueued) {\r\n\t\t\t\t\t\treturn\r\n\t\t\t\t\t}\r\n\t\t\t\t\tupdateQueued = true\r\n\t\t\t\t\tlang.nextTurn(updated)\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\tvar initialValue = this.valueOf()\r\n\t\t\tif (initialValue !== undefined) {\r\n\t\t\t\tupdated()\r\n\t\t\t}\r\n\t\t\treturn handle\r\n\t\t},\r\n\t\tstopNotifies: function(dependent) {\r\n\t\t\tvar dependents = this.dependents\r\n\t\t\tif (dependents) {\r\n\t\t\t\tfor (var i = 0; i < dependents.length; i++) {\r\n\t\t\t\t\tif (dependents[i] === dependent) {\r\n\t\t\t\t\t\tdependents.splice(i--, 1)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (dependents.length === 0) {\r\n\t\t\t\t\t// clear the dependents so it will be reinitialized if it has\r\n\t\t\t\t\t// dependents again\r\n\t\t\t\t\tthis.dependents = dependents = false\r\n\t\t\t\t\tthis.cleanup()\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tput: function(value, context) {\r\n\t\t\tvar variable = this\r\n\t\t\tif (this.ownObject) {\r\n\t\t\t\tthis.ownObject = false\r\n\t\t\t}\t\t\t\r\n\t\t\treturn when(this.getValue(context), function(oldValue) {\r\n\t\t\t\tif (oldValue === value) {\r\n\t\t\t\t\treturn noChange\r\n\t\t\t\t}\r\n\t\t\t\tif (variable.fixed &&\r\n\t\t\t\t\t\t// if it is set to fixed, we see we can put in the current variable\r\n\t\t\t\t\t\toldValue && oldValue.put) {\r\n\t\t\t\t\treturn oldValue.put(value)\r\n\t\t\t\t}\r\n\t\t\t\treturn when(variable.setValue(value, context), function(value) {\r\n\t\t\t\t\tvariable.updated(new RefreshEvent(), variable, context)\r\n\t\t\t\t})\r\n\t\t\t})\r\n\t\t},\r\n\t\tget: function(key) {\r\n\t\t\tif (this._properties && this._properties[key]) {\r\n\t\t\t\treturn this.property(key).valueOf()\r\n\t\t\t}\r\n\t\t\treturn when(this.valueOf(), function(object) {\r\n\t\t\t\tvar value = object && (typeof object.get === 'function' ? object.get(key) : object[key])\r\n\t\t\t\tif (value && value.notifies) {\r\n\t\t\t\t\t// nested variable situation, get underlying value\r\n\t\t\t\t\treturn value.valueOf()\r\n\t\t\t\t}\r\n\t\t\t\treturn value\r\n\t\t\t})\r\n\t\t},\r\n\t\tset: function(key, value) {\r\n\t\t\t// TODO: create an optimized route when the property doesn't exist yet\r\n\t\t\tthis.property(key)._changeValue(null, RequestSet, value)\r\n\t\t},\r\n\t\tundefine: function(key, context) {\r\n\t\t\tthis.set(key, undefined, context)\r\n\t\t},\r\n\t\tproxy: function(proxiedVariable) {\r\n\t\t\tvar thisVariable = this\r\n\t\t\tthis.fixed = true\r\n\t\t\treturn when(this.setValue(proxiedVariable), function(value) {\r\n\t\t\t\tthisVariable.updated(new RefreshEvent(), thisVariable)\r\n\t\t\t})\r\n\t\t},\r\n\t\tnext: function(value) {\r\n\t\t\t// for ES7 observable compatibility\r\n\t\t\tthis.put(value)\r\n\t\t},\r\n\t\terror: function(error) {\r\n\t\t\t// for ES7 observable compatibility\r\n\t\t\tvar dependents = this.dependents\r\n\t\t\tif (dependents) {\r\n\t\t\t\t// make a copy, in case they change\r\n\t\t\t\tdependents = dependents.slice(0)\r\n\t\t\t\tfor (var i = 0, l = dependents.length; i < l; i++) {\r\n\t\t\t\t\ttry{\r\n\t\t\t\t\t\tvar dependent = dependents[i]\r\n\t\t\t\t\t\t// skip notifying property dependents if we are headed up the parent chain\r\n\t\t\t\t\t\tdependent.error(error)\r\n\t\t\t\t\t}catch(e) {\r\n\t\t\t\t\t\tconsole.error(e, 'sending an error')\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tcomplete: function(value) {\r\n\t\t\t// for ES7 observable compatibility\r\n\t\t\tthis.put(value)\r\n\t\t},\r\n\t\tsetValue: function(value) {\r\n\t\t\tthis.value = value\r\n\t\t},\r\n\t\tonValue: function(listener) {\r\n\t\t\treturn this.subscribe(function(event) {\r\n\t\t\t\tlang.when(event.value(), function(value) {\r\n\t\t\t\t\tlistener(value)\r\n\t\t\t\t})\r\n\t\t\t})\r\n\t\t},\r\n\t\tforEach: function(callbackOrItemClass, callbackOrContext, context) {\r\n\t\t\t// iterate through current value of variable\r\n\t\t\tif (callbackOrItemClass.notifies) {\r\n\t\t\t\tvar collectionVariable = this\r\n\t\t\t\tthis.forEach(function(item) {\r\n\t\t\t\t\tvar itemVariable = callbackOrItemClass.for(item)\r\n\t\t\t\t\titemVariable.collection = collectionVariable\r\n\t\t\t\t\tcallbackOrContext.call(this, itemVariable)\r\n\t\t\t\t}, context)\r\n\t\t\t}\r\n\t\t\treturn when(this.valueOf(callbackOrContext), function(value) {\r\n\t\t\t\tif (value && value.forEach) {\r\n\t\t\t\t\tvalue.forEach(callbackOrItemClass)\r\n\t\t\t\t}else{\r\n\t\t\t\t\tfor (var i in value) {\r\n\t\t\t\t\t\tcallbackOrItemClass.call(value, value[i], i)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t},\r\n\r\n\t\tto: function (transformFunction, reverse) {\r\n\t\t\tif (typeof transformFunction !== 'function') {\r\n\t\t\t\tif (typeof transformFunction === 'object') {\r\n\t\t\t\t\tthis.to(transformFunction.forward, transformFunction.reverse)\r\n\t\t\t\t}\r\n\t\t\t\tthrow new Error('No function provided to transform')\r\n\t\t\t}\r\n\t\t\tif (reverse) {\r\n\t\t\t\ttransformFunction.reverse = function(value, args, context) {\r\n\t\t\t\t\t// for direct to, we can just use the first argument\r\n\t\t\t\t\treverse.call(this, args[0], context)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn new Call(transformFunction, [this])\r\n\t\t},\r\n\t\tget schema() {\r\n\t\t\t// default schema is the constructor\r\n\t\t\treturn this.notifyingValue ? this.notifyingValue.schema : this.constructor\r\n\t\t},\r\n\t\tset schema(schema) {\r\n\t\t\t// but allow it to be overriden\r\n\t\t\tObject.defineProperty(this, 'schema', {\r\n\t\t\t\tvalue: schema\r\n\t\t\t})\r\n\t\t},\r\n\t\tvalidate: function(target, schema) {\r\n\t\t\tif (this.notifyingValue) {\r\n\t\t\t\treturn this.notifyingValue.validate(target, schema)\r\n\t\t\t}\r\n\t\t\tif (schema.type && (schema.type !== typeof target)) {\r\n\t\t\t\treturn ['Target type of ' + typeof target + ' does not match schema type of ' + schema.type]\r\n\t\t\t}\r\n\t\t\tvar valid = []\r\n\t\t\tvalid.isValid = true\r\n\t\t\treturn valid\r\n\t\t},\r\n\r\n\t\tget validation() {\r\n\t\t\tvar validation = new Validating(this)\r\n\t\t\tObject.defineProperty(this, 'validation', {\r\n\t\t\t\tvalue: validation\r\n\t\t\t})\r\n\t\t\treturn validation\r\n\t\t},\r\n\t\tset validation(validation) {\r\n\t\t\t// but allow it to be overriden\r\n\t\t\tObject.defineProperty(this, 'validation', {\r\n\t\t\t\tvalue: validation\r\n\t\t\t})\r\n\t\t},\r\n\t\tgetId: function() {\r\n\t\t\treturn this.id || (this.id = nextId++)\r\n\t\t},\r\n\t\tobserveObject: function() {\r\n\t\t\tvar variable = this\r\n\t\t\treturn when(this.valueOf(), function(object) {\r\n\t\t\t\tvar listeners = propertyListenersMap.get(object)\r\n\t\t\t\tif (!listeners) {\r\n\t\t\t\t\tpropertyListenersMap.set(object, listeners = [])\r\n\t\t\t\t}\r\n\t\t\t\tif (listeners.observerCount) {\r\n\t\t\t\t\tlisteners.observerCount++\r\n\t\t\t\t}else{\r\n\t\t\t\t\tlisteners.observerCount = 1\r\n\t\t\t\t\tvar observer = listeners.observer = lang.observe(object, function(events) {\r\n\t\t\t\t\t\tfor (var i = 0, l = listeners.length; i < l; i++) {\r\n\t\t\t\t\t\t\tvar listener = listeners[i]\r\n\t\t\t\t\t\t\tfor (var j = 0, el = events.length; j < el; j++) {\r\n\t\t\t\t\t\t\t\tvar event = events[j]\r\n\t\t\t\t\t\t\t\tlistener._propertyChange(event.name, object)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t\tif (observer.addKey) {\r\n\t\t\t\t\t\tfor (var i = 0, l = listeners.length; i < l; i++) {\r\n\t\t\t\t\t\t\tvar listener = listeners[i]\r\n\t\t\t\t\t\t\tlistener.eachKey(function(key) {\r\n\t\t\t\t\t\t\t\tobserver.addKey(key)\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tregisterListener(object, variable)\r\n\t\t\t\treturn {\r\n\t\t\t\t\tremove: function() {\r\n\t\t\t\t\t\tderegisterListener(object, variable)\r\n\t\t\t\t\t\tif (!(--listeners.observerCount)) {\r\n\t\t\t\t\t\t\tlisteners.observer.remove()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t},\r\n\t\t\t\t\tdone: function() {\r\n\t\t\t\t\t\t// deliver changes\r\n\t\t\t\t\t\tlang.deliverChanges(observer)\r\n\t\t\t\t\t\tthis.remove()\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t},\r\n\t\t_willModify: function(context) {\r\n\t\t\t// an intent to modify, so we need to make sure we have our own copy\r\n\t\t\t// of an object when necessary\r\n\t\t\tif (this.fixed) {\r\n\t\t\t\tif (this.value && this.value._willModify) {\r\n\t\t\t\t\treturn this.value._willModify(context)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!this.ownObject && this.value && this.value.notifies) {\r\n\t\t\t\tvar variable = this\r\n\t\t\t\treturn when(this.valueOf(context), function(value) {\r\n\t\t\t\t\tif (value && typeof value === 'object') {\r\n\t\t\t\t\t\tif (value instanceof Array) {\r\n\t\t\t\t\t\t\tvariable.ownObject = value.slice(0)\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tvariable.ownObject = Object.create(value)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t},\r\n\t\tsplice: function(startingIndex, removalCount) {\r\n\t\t\tvar args = arguments\r\n\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\tvar results = array.splice.apply(array, args)\r\n\t\t\t\tremovedAt(this, results, startingIndex, removalCount, array.length)\r\n\t\t\t\tinsertedAt(this, [].slice.call(args, 2), startingIndex, array.length)\r\n\t\t\t\treturn results\r\n\t\t\t})\r\n\t\t},\r\n\t\tpush: function() {\r\n\t\t\tvar args = arguments\r\n\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\tvar results = array.push.apply(array, args)\r\n\t\t\t\tinsertedAt(this, args, array.length - args.length, array.length)\r\n\t\t\t\treturn results\r\n\t\t\t})\r\n\t\t},\r\n\t\tunshift: function() {\r\n\t\t\tvar args = arguments\r\n\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\tvar results = array.unshift.apply(array, args)\r\n\t\t\t\tinsertedAt(this, args, 0, array.length)\r\n\t\t\t\treturn results\r\n\t\t\t})\r\n\t\t},\r\n\t\tpop: function() {\r\n\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\tvar results = array.pop()\r\n\t\t\t\tremovedAt(this, [results], array.length, 1)\r\n\t\t\t\treturn results\r\n\t\t\t})\r\n\t\t},\r\n\t\tshift: function() {\r\n\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\tvar results = array.shift()\r\n\t\t\t\tremovedAt(this, [results], 0, 1, array.length)\r\n\t\t\t\treturn results\r\n\t\t\t})\r\n\t\t}\r\n\t}\r\n\r\n\tfunction arrayToModify(variable, callback) {\r\n\t\tvariable._willModify()\r\n\t\t// TODO: switch this to allow promises\r\n\t\twhen(variable.cachedValue || variable.valueOf(), function(array) {\r\n\t\t\tif (!array) {\r\n\t\t\t\tvariable.put(array = [])\r\n\t\t\t}\r\n\t\t\tvariable.updateVersion()\r\n\t\t\tvar results = callback.call(variable, array)\r\n\t\t\tvariable.cachedVersion = variable.version // update the cached version so it doesn't need to be recomputed\r\n\t\t\treturn results\r\n\t\t})\r\n\t}\r\n\r\n\tfunction insertedAt(variable, added, startingIndex, arrayLength) {\r\n\t\tvar addedCount = added.length\r\n\t\t// adjust the key positions of any index properties after splice\r\n\t\tif (addedCount > 0) {\r\n\t\t\tif (variable._properties) {\r\n\t\t\t\tvar arrayPosition\r\n\t\t\t\tfor (var i = arrayLength - addedCount; i > startingIndex;) {\r\n\t\t\t\t\tvar arrayPosition = variable._properties[--i]\r\n\t\t\t\t\tif (arrayPosition) {\r\n\t\t\t\t\t\tvariable._properties[i] = undefined\r\n\t\t\t\t\t\tarrayPosition.key += addedCount\r\n\t\t\t\t\t\tvariable._properties[arrayPosition.key] = arrayPosition\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// send out updates\r\n\t\t\tfor (var i = 0, l = added.length; i < l; i++) {\r\n\t\t\t\tvariable.updated(new AddEvent({\r\n\t\t\t\t\tvalue: added[i],\r\n\t\t\t\t\tindex: i + startingIndex,\r\n\t\t\t\t\tmodifier: variable\r\n\t\t\t\t}), variable)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction removedAt(variable, removed, startingIndex, removalCount, arrayLength) {\r\n\t\t// adjust the properties\r\n\t\tvar i = startingIndex + removalCount\r\n\t\tvar arrayPosition\r\n\t\tif (removalCount > 0) {\r\n\t\t\tif (variable._properties) {\r\n\t\t\t\tfor (var i = startingIndex + removalCount; i < arrayLength + removalCount; i++) {\r\n\t\t\t\t\tvar arrayPosition = variable._properties[i]\r\n\t\t\t\t\tif (arrayPosition) {\r\n\t\t\t\t\t\tvariable._properties[i] = undefined\r\n\t\t\t\t\t\tarrayPosition.key -= removalCount\r\n\t\t\t\t\t\tvariable._properties[arrayPosition.key] = arrayPosition\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// send out updates\r\n\t\t\tfor (var i = 0; i < removalCount; i++) {\r\n\t\t\t\tvariable.updated(new DeleteEvent({\r\n\t\t\t\t\tpreviousIndex: startingIndex,\r\n\t\t\t\t\toldValue: removed[i],\r\n\t\t\t\t\tmodifier: variable\r\n\t\t\t\t}), variable)\r\n\t\t\t}\r\n\t\t\tvariable.cachedVersion = variable.version // update the cached version so it doesn't need to be recomputed\r\n\t\t}\r\n\t}\r\n\r\n\tif (typeof Symbol !== 'undefined') {\r\n\t\tVariable.prototype[Symbol.iterator] = function() {\r\n\t\t\treturn this.valueOf()[Symbol.iterator]()\r\n\t\t}\r\n\t}\r\n\r\n\tVariable.VMap = lang.compose(Variable, function(value){\r\n\t\tthis.value = typeof value === 'undefined' ? this.default : value\r\n\t}, {\r\n\t\t// TODO: Move all the get and set functionality for maps out of Variable\r\n\t\tproperty: function(key) {\r\n\t\t\tvar properties = this._properties || (this._properties = new Map())\r\n\t\t\tvar propertyVariable = properties.get(key)\r\n\t\t\tif (!propertyVariable) {\r\n\t\t\t\t// create the property variable\r\n\t\t\t\tpropertyVariable = new Property(this, key)\r\n\t\t\t\tproperties.set(key, propertyVariable)\r\n\t\t\t}\r\n\t\t\treturn propertyVariable\r\n\t\t}\r\n\t})\r\n\r\n\tvar cacheNotFound = {}\r\n\tvar Caching = Variable.Caching = lang.compose(Variable, function(getValue, setValue) {\r\n\t\tif (getValue) {\r\n\t\t\tthis.getValue = getValue\r\n\t\t}\r\n\t\tif (setValue) {\r\n\t\t\tthis.setValue = setValue\r\n\t\t}\r\n\t}, {\r\n\t\tvalueOf: function(context) {\r\n\t\t\t// first check to see if we have the variable already computed\r\n\t\t\tif (this.cachedVersion === this.getVersion()) {\r\n\t\t\t\tif (this.contextMap) {\r\n\t\t\t\t\tvar contextualizedVariable = getMaterializedContextualInstance(this, context)\r\n\t\t\t\t\tif (contextualizedVariable) {\r\n\t\t\t\t\t\treturn contextualizedVariable.cachedValue\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn this.cachedValue\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar variable = this\r\n\r\n\t\t\tfunction withComputedValue(computedValue) {\r\n\t\t\t\tif (computedValue && computedValue.notifies && variable.dependents) {\r\n\t\t\t\t\tvariable.computedVariable = computedValue\r\n\t\t\t\t}\r\n\t\t\t\tcomputedValue = variable.gotValue(computedValue, watchedContext)\r\n\t\t\t\tvar contextualizedVariable\r\n\t\t\t\tif (watchedContext && watchedContext.distinctSubject) {\r\n\t\t\t\t\t(variable.contextMap || (variable.contextMap = new WeakMap()))\r\n\t\t\t\t\t\t.set(watchedContext.distinctSubject,\r\n\t\t\t\t\t\t\tcontextualizedVariable = new ContextualizedVariable(variable, watchedContext.distinctSubject))\r\n\t\t\t\t\tcontext.distinctSubject = mergeSubject(context.distinctSubject, watchedContext.distinctSubject)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcontextualizedVariable = variable\r\n\t\t\t\t}\r\n\t\t\t\tcontextualizedVariable.cachedVersion = newVersion\r\n\t\t\t\tcontextualizedVariable.cachedValue = computedValue\r\n\t\t\t\treturn computedValue\r\n\t\t\t}\r\n\r\n\t\t\tvar watchedContext\r\n\t\t\tif (context) {\r\n\t\t\t\twatchedContext = new Context(context.subject)\r\n\t\t\t}\r\n\t\t\tvar newVersion = this.getVersion()\r\n\t\t\tvar computedValue = this.getValue(watchedContext)\r\n\t\t\tif (computedValue && computedValue.then) {\r\n\t\t\t\treturn computedValue.then(withComputedValue)\r\n\t\t\t} else {\r\n\t\t\t\treturn withComputedValue(computedValue)\r\n\t\t\t}\r\n\t\t}\r\n\t})\r\n\r\n\tfunction GetCache() {\r\n\t}\r\n\r\n\tvar Property = lang.compose(Variable, function Property(parent, key) {\r\n\t\tthis.parent = parent\r\n\t\tthis.key = key\r\n\t},\r\n\t{\r\n\t\tforDependencies: function(callback) {\r\n\t\t\tVariable.prototype.forDependencies.call(this, callback)\r\n\t\t\tcallback(this.parent)\r\n\t\t},\r\n\t\tvalueOf: function(context) {\r\n\t\t\tif (this.value) {\r\n\t\t\t\treturn Variable.prototype.valueOf.call(this, context)\r\n\t\t\t}\r\n\t\t\tvar key = this.key\r\n\t\t\tvar property = this\r\n\t\t\tvar object = this.parent.valueOf(context)\r\n\t\t\tfunction gotValueAndListen(object) {\r\n\t\t\t\tif (property.dependents) {\r\n\t\t\t\t\tvar listeners = propertyListenersMap.get(object)\r\n\t\t\t\t\tif (listeners && listeners.observer && listeners.observer.addKey) {\r\n\t\t\t\t\t\tlisteners.observer.addKey(key)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tvar value = property.gotValue(object == null ? undefined : typeof object.get === 'function' ? object.get(key) : object[key])\r\n\t\t\t\treturn value\r\n\t\t\t}\r\n\t\t\tif (object && object.then) {\r\n\t\t\t\treturn when(object, gotValueAndListen)\r\n\t\t\t}\r\n\t\t\treturn gotValueAndListen(object)\r\n\t\t},\r\n\t\tput: function(value, context) {\r\n\t\t\treturn this._changeValue(context, RequestChange, value)\r\n\t\t},\r\n\t\tparentUpdated: function(updateEvent, context) {\r\n\t\t\treturn Variable.prototype.updated.call(this, updateEvent, this.parent, context)\r\n\t\t},\r\n\t\tupdated: function(updateEvent, by, context) {\r\n\t\t\tif (updateEvent = Variable.prototype.updated.call(this, updateEvent, by, context)) {\r\n\t\t\t\tthis.parent.updated(new PropertyChangeEvent(this.key, updateEvent, this.parent), this, context)\r\n\t\t\t}\r\n\t\t},\r\n\t\t_changeValue: function(context, type, newValue) {\r\n\t\t\tvar key = this.key\r\n\t\t\tvar parent = this.parent\r\n\t\t\tvar variable = this\r\n\t\t\tif (this.value) {\r\n\t\t\t\tif (type === RequestChange) {\r\n\t\t\t\t\t// put() go into the existing variable, if it has one\r\n\t\t\t\t\tthis.value.put(newValue)\r\n\t\t\t\t\treturn\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.value = null\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tparent._willModify(context)\r\n\t\t\treturn when(parent.valueOf(context), function(object) {\r\n\t\t\t\tif (object == null) {\r\n\t\t\t\t\t// nothing there yet, create an object to hold the new property\r\n\t\t\t\t\tvar response = parent.put(object = typeof key == 'number' ? [] : {}, context)\r\n\t\t\t\t} else if (typeof object != 'object') {\r\n\t\t\t\t\t// if the parent is not an object, we can't set anything (that will be retained)\r\n\t\t\t\t\treturn deny\r\n\t\t\t\t}\r\n\t\t\t\tif (newValue && newValue.put) {\r\n\t\t\t\t\tvariable.value = newValue\r\n\t\t\t\t}\r\n\t\t\t\tvar oldValue = typeof object.get === 'function' ? object.get(key) : object[key]\r\n\t\t\t\t/*if (oldValue === newValue) {\r\n\t\t\t\t\t// no actual change to make\r\n\t\t\t\t\treturn noChange\r\n\t\t\t\t}*/\r\n\t\t\t\tif (typeof object.set === 'function') {\r\n\t\t\t\t\tobject.set(key, newValue)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (type == RequestChange && oldValue && oldValue.put) {\r\n\t\t\t\t\t\t// if a put and the property value is a variable, assign it to that.\r\n\t\t\t\t\t\toldValue.put(newValue)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tobject[key] = newValue && newValue.valueOf(context)\r\n\t\t\t\t\t\t// or set the setter/getter\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tvariable.updated(null, variable, context)\r\n\r\n\t\t\t\t// now notify any object listeners\r\n\t\t\t\tvar listeners = propertyListenersMap.get(object)\r\n\t\t\t\t// we need to do it before the other listeners, so we can update it before\r\n\t\t\t\t// we trigger a full clobbering of the object\r\n\t\t\t\tif (listeners) {\r\n\t\t\t\t\tlisteners = listeners.slice(0)\r\n\t\t\t\t\tfor (var i = 0, l = listeners.length; i < l; i++) {\r\n\t\t\t\t\t\tvar listener = listeners[i]\r\n\t\t\t\t\t\tif (listener !== parent) {\r\n\t\t\t\t\t\t\t// now go ahead and actually trigger the other listeners (but make sure we don't do the parent again)\r\n\t\t\t\t\t\t\tlistener._propertyChange(key, object, context, type)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t},\r\n\t\t_willModify: function() {\r\n\t\t\tthis.parent._willModify()\r\n\t\t\treturn Variable.prototype._willModify.call(this)\r\n\t\t},\r\n\t\tvalidate: function(target, schema) {\r\n\t\t\treturn this.parent.validate(target.valueOf(), schema)\r\n\t\t}\r\n\t})\r\n\tObject.defineProperty(Property.prototype, 'schema', {\r\n\t\tget: function() {\r\n\t\t\tvar parentSchemaProperties = this.parent.schema.properties\r\n\t\t\treturn parentSchemaProperties && parentSchemaProperties[this.key]\r\n\t\t},\r\n\t\tset: function(schema) {\r\n\t\t\t// have to repeat the override\r\n\t\t\tObject.defineProperty(this, 'schema', {\r\n\t\t\t\tvalue: schema\r\n\t\t\t})\r\n\t\t}\r\n\t})\r\n\tVariable.Property = Property\r\n\r\n\tvar Item = Variable.Item = lang.compose(Variable, function Item(value, content) {\r\n\t\tthis.value = value\r\n\t\tthis.collection = content\r\n\t}, {})\r\n\r\n\tvar Composite = Variable.Composite = lang.compose(Caching, function Composite(args) {\r\n\t\tthis.args = args\r\n\t}, {\r\n\t\tforDependencies: function(callback) {\r\n\t\t\t// depend on the args\r\n\t\t\tCaching.prototype.forDependencies.call(this, callback)\r\n\t\t\tvar args = this.args\r\n\t\t\tfor (var i = 0, l = args.length; i < l; i++) {\r\n\t\t\t\tvar arg = args[i]\r\n\t\t\t\tif (arg && arg.notifies) {\r\n\t\t\t\t\tcallback(arg)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tupdated: function(updateEvent, by, context) {\r\n\t\t\tvar args = this.args\r\n\t\t\tif (by !== this.notifyingValue && updateEvent && updateEvent.type !== 'refresh') {\r\n\t\t\t\t// using a painful search instead of indexOf, because args may be an arguments object\r\n\t\t\t\tfor (var i = 0, l = args.length; i < l; i++) {\r\n\t\t\t\t\tvar arg = args[i]\r\n\t\t\t\t\tif (arg === by) {\r\n\t\t\t\t\t\t// if one of the args was updated, we need to do a full refresh (we can't compute differential events without knowledge of how the mapping function works)\r\n\t\t\t\t\t\tupdateEvent = new RefreshEvent()\r\n\t\t\t\t\t\tcontinue\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn Caching.prototype.updated.call(this, updateEvent, by, context)\r\n\t\t},\r\n\r\n\t\tgetUpdates: function(since) {\r\n\t\t\t// this always issues updates, nothing incremental can flow through it\r\n\t\t\tif (!since || since.version < getVersion()) {\r\n\t\t\t\treturn [new RefreshEvent()]\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tgetVersion: function(context) {\r\n\t\t\tvar args = this.args\r\n\t\t\tvar version = Variable.prototype.getVersion.call(this, context)\r\n\t\t\tfor (var i = 0, l = args.length; i < l; i++) {\r\n\t\t\t\tvar arg = args[i]\r\n\t\t\t\tif (arg && arg.getVersion) {\r\n\t\t\t\t\tversion = Math.max(version, arg.getVersion(context))\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn version\r\n\t\t},\r\n\r\n\t\tgetValue: function(context) {\r\n\t\t\tvar results = []\r\n\t\t\tvar args = this.args\r\n\t\t\tfor (var i = 0, l = args.length; i < l; i++) {\r\n\t\t\t\tvar arg = args[i]\r\n\t\t\t\tresults[i] = arg && arg.valueOf(context)\r\n\t\t\t}\r\n\t\t\treturn whenAll(results, function(resolved) {\r\n\t\t\t\treturn resolved\r\n\t\t\t})\r\n\t\t}\r\n\t})\r\n\r\n\t// a call variable is the result of a call\r\n\tvar Call = lang.compose(Composite, function Call(functionVariable, args) {\r\n\t\tthis.functionVariable = functionVariable\r\n\t\tthis.args = args\r\n\t}, {\r\n\t\tfixed: true,\r\n\t\tforDependencies: function(callback) {\r\n\t\t\t// depend on the args\r\n\t\t\tComposite.prototype.forDependencies.call(this, callback)\r\n\t\t\tif (this.functionVariable.notifies) {\r\n\t\t\t\tcallback(this.functionVariable)\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tgetValue: function(context) {\r\n\t\t\tvar functionValue = this.functionVariable.valueOf(context)\r\n\t\t\tif (functionValue.then) {\r\n\t\t\t\tvar call = this\r\n\t\t\t\treturn functionValue.then(function(functionValue) {\r\n\t\t\t\t\treturn call.invoke(functionValue, call.args, context)\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\treturn this.invoke(functionValue, this.args, context)\r\n\t\t},\r\n\r\n\t\tgetVersion: function(context) {\r\n\t\t\t// TODO: shortcut if we are live and since equals this.lastUpdate\r\n\t\t\tvar argsVersion = Composite.prototype.getVersion.call(this, context)\r\n\t\t\tif (this.functionVariable.getVersion) {\r\n\t\t\t\treturn Math.max(argsVersion, this.functionVariable.getVersion(context))\r\n\t\t\t}\r\n\t\t\treturn argsVersion\r\n\t\t},\r\n\r\n\t\texecute: function(context) {\r\n\t\t\tvar call = this\r\n\t\t\treturn when(this.functionVariable.valueOf(context), function(functionValue) {\r\n\t\t\t\treturn call.invoke(functionValue, call.args, context, true)\r\n\t\t\t})\r\n\t\t},\r\n\r\n\t\tput: function(value, context) {\r\n\t\t\tvar call = this\r\n\t\t\treturn when(this.valueOf(context), function(originalValue) {\r\n\t\t\t\tif (originalValue === value) {\r\n\t\t\t\t\treturn noChange\r\n\t\t\t\t}\r\n\t\t\t\treturn when(call.functionVariable.valueOf(context), function(functionValue) {\r\n\t\t\t\t\treturn call.invoke(function() {\r\n\t\t\t\t\t\tif (functionValue.reverse) {\r\n\t\t\t\t\t\t\tfunctionValue.reverse.call(call, value, call.args, context)\r\n\t\t\t\t\t\t\treturn Variable.prototype.put.call(call, value, context)\r\n\t\t\t\t\t\t} else if (originalValue && originalValue.put) {\r\n\t\t\t\t\t\t\treturn originalValue.put(value)\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\treturn deny\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}, call.args, context)\r\n\t\t\t\t});\t\t\t\t\r\n\t\t\t})\r\n\t\t},\r\n\t\tinvoke: function(functionValue, args, context, observeArguments) {\r\n\t\t\tvar instance = this.functionVariable.parent\r\n\t\t\tif (functionValue.handlesVariables || functionValue.property) {\r\n\t\t\t\treturn functionValue.apply(instance, args, context)\r\n\t\t\t}else{\r\n\t\t\t\tvar results = []\r\n\t\t\t\tfor (var i = 0, l = args.length; i < l; i++) {\r\n\t\t\t\t\tvar arg = args[i]\r\n\t\t\t\t\tresults[i] = arg && arg.valueOf(context)\r\n\t\t\t\t}\r\n\t\t\t\tinstance = instance && instance.valueOf(context)\r\n\t\t\t\tif (functionValue.handlesPromises) {\r\n\t\t\t\t\treturn functionValue.apply(instance, results, context)\r\n\t\t\t\t}else{\r\n\t\t\t\t\t// include the instance in whenAll\r\n\t\t\t\t\tresults.push(instance)\r\n\t\t\t\t\t// wait for the values to be received\r\n\t\t\t\t\treturn whenAll(results, function(inputs) {\r\n\t\t\t\t\t\tif (observeArguments) {\r\n\t\t\t\t\t\t\tvar handles = []\r\n\t\t\t\t\t\t\tfor (var i = 0, l = inputs.length; i < l; i++) {\r\n\t\t\t\t\t\t\t\tvar input = inputs[i]\r\n\t\t\t\t\t\t\t\tif (input && typeof input === 'object') {\r\n\t\t\t\t\t\t\t\t\thandles.push(observe(input))\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tvar instance = inputs.pop()\r\n\t\t\t\t\t\t\ttry{\r\n\t\t\t\t\t\t\t\tvar result = functionValue.apply(instance, inputs, context)\r\n\t\t\t\t\t\t\t}finally{\r\n\t\t\t\t\t\t\t\twhen(result, function() {\r\n\t\t\t\t\t\t\t\t\tfor (var i = 0; i < l; i++) {\r\n\t\t\t\t\t\t\t\t\t\thandles[i].done()\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn result\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar instance = inputs.pop()\r\n\t\t\t\t\t\treturn functionValue.apply(instance, inputs, context)\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tsetReverse: function(reverse) {\r\n\t\t\tthis.functionVariable.valueOf().reverse = reverse\r\n\t\t\treturn this\r\n\t\t}\r\n\t})\r\n\tVariable.Call = Call\r\n\r\n\tvar ContextualizedVariable = lang.compose(Variable, function ContextualizedVariable(Source, subject) {\r\n\t\tthis.constructor = Source\r\n\t\tthis.subject = subject\r\n\t}, {\r\n\t\tvalueOf: function() {\r\n\t\t\treturn this.constructor.valueOf(new Context(this.subject))\r\n\t\t},\r\n\r\n\t\tput: function(value) {\r\n\t\t\treturn this.constructor.put(value, new Context(this.subject))\r\n\t\t},\r\n\t\tparentUpdated: function(event, context) {\r\n\t\t\t// if we receive an outside update, send it to the constructor\r\n\t\t\tthis.constructor.updated(event, this.parent, this.context)\r\n\t\t}\r\n\t})\r\n\r\n\r\n\tfunction iterateMethod(method) {\r\n\t\tVariable.prototype[method] = function() {\r\n\t\t\treturn new IterativeMethod(this, method, arguments)\r\n\t\t}\r\n\t}\r\n\r\n\titerateMethod('filter')\r\n\titerateMethod('map')\r\n\titerateMethod('reduce')\r\n\titerateMethod('reduceRight')\r\n\titerateMethod('some')\r\n\titerateMethod('every')\r\n\titerateMethod('slice')\r\n\t\r\n\tvar IterativeMethod = lang.compose(Composite, function(source, method, args) {\r\n\t\tthis.source = source\r\n\t\t// source.interestWithin = true\r\n\t\tthis.method = method\r\n\t\tthis.args = args\r\n\t}, {\r\n\t\tgetValue: function(context) {\r\n\t\t\tvar method = this.method\r\n\t\t\tvar args = this.args\r\n\t\t\tvar variable = this\r\n\t\t\treturn when(this.source.valueOf(context), function(array) {\r\n\t\t\t\tif (array && array.forEach) {\r\n\t\t\t\t\tif (variable.dependents) {\r\n\t\t\t\t\t\tvar contextualizedVariable\r\n\t\t\t\t\t\tif (context) {\r\n\t\t\t\t\t\t\tvar contextMap = variable.contextMap || (variable.contextMap = new WeakMap())\r\n\t\t\t\t\t\t\tif (contextMap.has(context.distinctSubject)) {\r\n\t\t\t\t\t\t\t\tcontextualizedVariable = contextMap.get(context.distinctSubject)\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tcontextMap.set(context.distinctSubject, contextualizedVariable = new ContextualizedVariable(variable, context.distinctSubject))\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tcontextualizedVariable = variable\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (method === 'map'){\r\n\t\t\t\t\t\t// fast path, and special behavior for map\r\n\t\t\t\t\t\treturn args[0](array)\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// if not an array convert to an array\r\n\t\t\t\t\tarray = [array]\r\n\t\t\t\t}\r\n\t\t\t\t// apply method\r\n\t\t\t\treturn array[method].apply(array, args)\r\n\t\t\t})\r\n\t\t},\r\n\t\tupdated: function(event, by, context) {\r\n\t\t\tif (!event || event.modifier === this || (event.modifier && event.modifier.constructor === this)) {\r\n\t\t\t\treturn Composite.prototype.updated.call(this, event, by, context)\r\n\t\t\t}\r\n\t\t\tvar propagatedEvent = event.type === 'refresh' ? event : // always propagate refreshes\r\n\t\t\t\tthis[this.method + 'Updated'] ? this[this.method + 'Updated'](event, context) : // if we have an updated handler, use it\r\n\t\t\t\tnew RefreshEvent() // else recompute the array method\r\n\t\t\t// TODO: make sure we normalize the event structure\r\n\t\t\tif (propagatedEvent) {\r\n\t\t\t\tComposite.prototype.updated.call(this, propagatedEvent, by, context)\r\n\t\t\t}\r\n\t\t},\r\n\t\tfilterUpdated: function(event, context) {\r\n\t\t\tvar contextualizedVariable = getMaterializedContextualInstance(this, context) || this\r\n\t\t\tif (event.type === 'delete') {\r\n\t\t\t\tvar index = contextualizedVariable.cachedValue.indexOf(event.oldValue)\r\n\t\t\t\tif (index > -1) {\r\n\t\t\t\t\tcontextualizedVariable.splice(index, 1)\r\n\t\t\t\t}\r\n\t\t\t} else if (event.type === 'add') {\r\n\t\t\t\tif ([event.value].filter(this.args[0]).length > 0) {\r\n\t\t\t\t\tcontextualizedVariable.push(event.value)\r\n\t\t\t\t}\r\n\t\t\t} else if (event.type === 'update') {\r\n\t\t\t\tvar object = event.parent.valueOf(context)\r\n\t\t\t\tvar index = contextualizedVariable.cachedValue.indexOf(object)\r\n\t\t\t\tvar matches = [object].filter(this.args[0]).length > 0\r\n\t\t\t\tif (index > -1) {\r\n\t\t\t\t\tif (matches) {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\ttype: 'updated',\r\n\t\t\t\t\t\t\tobject: object,\r\n\t\t\t\t\t\t\tindex: index\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tcontextualizedVariable.splice(index, 1)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\telse {\r\n\t\t\t\t\tif (matches) {\r\n\t\t\t\t\t\tcontextualizedVariable.push(object)\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// else nothing mactches\r\n\t\t\t\t}\r\n\t\t\t\treturn\r\n\t\t\t} else {\r\n\t\t\t\treturn event\r\n\t\t\t}\r\n\t\t},\r\n\t\tmapUpdated: function(event, context) {\r\n\t\t\tvar contextualizedVariable = getMaterializedContextualInstance(this, context) || this\r\n\t\t\tif (event.type === 'delete') {\r\n\t\t\t\tcontextualizedVariable.splice(event.previousIndex, 1)\r\n\t\t\t} else if (event.type === 'add') {\r\n\t\t\t\tcontextualizedVariable.push(this.args[0].call(this.args[1], event.value))\r\n\t\t\t} else if (event.type === 'update') {\r\n\t\t\t\tvar object = event.parent.valueOf(context)\r\n\t\t\t\tvar array = contextualizedVariable.cachedValue\r\n\t\t\t\tif (array && array.map) {\r\n\t\t\t\t\tvar index = array.indexOf(object)\r\n\t\t\t\t\tvar matches = [object].filter(this.args[0]).length > 0\r\n\t\t\t\t\tcontextualizedVariable.splice(index, 1, this.args[0].call(this.args[1], event.value))\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn event\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\treturn event\r\n\t\t\t}\r\n\t\t},\r\n\t\t// TODO: Create specialized updated handlers for faster recomputation of other array derivatives\r\n\t\tforDependencies: function(callback) {\r\n\t\t\t// depend on the args\r\n\t\t\tComposite.prototype.forDependencies.call(this, callback)\r\n\t\t\tcallback(this.source)\r\n\t\t},\r\n\t\tgetVersion: function(context) {\r\n\t\t\treturn Math.max(Composite.prototype.getVersion.call(this, context), this.source.getVersion(context))\r\n\t\t}\t\t\r\n\t})\r\n\r\n\r\n\tvar getValue\r\n\tvar GeneratorVariable = Variable.GeneratorVariable = lang.compose(Variable.Composite, function ReactiveGenerator(generator){\r\n\t\tthis.generator = generator\r\n\t\tthis.args = []\r\n\t}, {\r\n\t\tgetValue: getValue = function(context, resuming) {\r\n\t\t\tvar lastValue\r\n\t\t\tvar i\r\n\t\t\tvar generatorIterator\r\n\t\t\tvar isThrowing\r\n\t\t\tif (resuming) {\r\n\t\t\t\t// resuming from a promise\r\n\t\t\t\tgeneratorIterator = resuming.iterator\r\n\t\t\t\ti = resuming.i\r\n\t\t\t\tlastValue = resuming.value\r\n\t\t\t\tisThrowing = resuming.isThrowing\r\n\t\t\t} else {\r\n\t\t\t\t// a fresh start\r\n\t\t\t\ti = 0\r\n\t\t\t\tgeneratorIterator = this.generator()\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar args = this.args\r\n\t\t\tdo {\r\n\t\t\t\tvar stepReturn = generatorIterator[isThrowing ? 'throw' : 'next'](lastValue)\r\n\t\t\t\tif (stepReturn.done) {\r\n\t\t\t\t\treturn stepReturn.value\r\n\t\t\t\t}\r\n\t\t\t\tvar nextVariable = stepReturn.value\r\n\t\t\t\t// compare with the arguments from the last\r\n\t\t\t\t// execution to see if they are the same\r\n\t\t\t\tif (args[i] !== nextVariable) {\r\n\t\t\t\t\tif (args[i]) {\r\n\t\t\t\t\t\targs[i].stopNotifies(this)\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// subscribe if it is a variable\r\n\t\t\t\t\tif (nextVariable && nextVariable.notifies) {\r\n\t\t\t\t\t\tnextVariable.notifies(this)\r\n\t\t\t\t\t\tthis.args[i] = nextVariable\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.args[i] = null\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\ti++\r\n\t\t\t\tlastValue = nextVariable && nextVariable.valueOf(context)\r\n\t\t\t\tif (lastValue && lastValue.then) {\r\n\t\t\t\t\t// if it is a promise, we will wait on it\r\n\t\t\t\t\tvar variable = this\r\n\t\t\t\t\t// and return the promise so that the getValue caller can wait on this\r\n\t\t\t\t\treturn lastValue.then(function(value) {\r\n\t\t\t\t\t\treturn getValue.call(variable, context, {\r\n\t\t\t\t\t\t\ti: i,\r\n\t\t\t\t\t\t\titerator: generatorIterator,\r\n\t\t\t\t\t\t\tvalue: value\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}, function(error) {\r\n\t\t\t\t\t\treturn getValue.call(variable, context, {\r\n\t\t\t\t\t\t\ti: i,\r\n\t\t\t\t\t\t\titerator: generatorIterator,\r\n\t\t\t\t\t\t\tvalue: error,\r\n\t\t\t\t\t\t\tisThrowing: true\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t} while(true)\r\n\t\t}\r\n\t})\r\n\r\n\tvar Validating = lang.compose(Caching, function(target) {\r\n\t\tthis.target = target\r\n\t}, {\r\n\t\tforDependencies: function(callback) {\r\n\t\t\tCaching.prototype.forDependencies.call(this, callback)\r\n\t\t\tcallback(this.target)\r\n\t\t},\r\n\t\tgetVersion: function(context) {\r\n\t\t\treturn Math.max(Variable.prototype.getVersion.call(this, context), this.target.getVersion(context))\r\n\t\t},\r\n\t\tgetValue: function(context) {\r\n\t\t\tvar target = this.target\r\n\t\t\treturn target.validate(target, target.schema)\r\n\t\t}\r\n\t})\r\n\r\n\tfunction validate(target) {\r\n\t\tvar schemaForObject = schema(target)\r\n\t\treturn new Validating(target, schemaForObject)\r\n\t}\r\n\tVariable.VArray = Variable\r\n\tVariable.VPromised = Variable\r\n\tVariable.deny = deny\r\n\tVariable.noChange = noChange\r\n\tfunction addFlag(name) {\r\n\t\tVariable[name] = function(functionValue) {\r\n\t\t\tfunctionValue[name] = true\r\n\t\t}\r\n\t}\r\n\taddFlag(Variable, 'handlesContext')\r\n\taddFlag(Variable, 'handlesPromises')\r\n\r\n\tfunction objectUpdated(object) {\r\n\t\t// simply notifies any subscribers to an object, that it has changed\r\n\t\tvar listeners = propertyListenersMap.get(object)\r\n\t\tif (listeners) {\r\n\t\t\tfor (var i = 0, l = listeners.length; i < l; i++) {\r\n\t\t\t\tlisteners[i]._propertyChange(null, object)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction all(array) {\r\n\t\t// This is intended to mirror Promise.all. It actually takes\r\n\t\t// an iterable, but for now we are just looking for array-like\r\n\t\tif (array.length > -1) {\r\n\t\t\treturn new Composite(array)\r\n\t\t}\r\n\t\tif (arguments.length > 1) {\r\n\t\t\t// support multiple arguments as an array\r\n\t\t\treturn new Composite(arguments)\r\n\t\t}\r\n\t\tif (typeof array === 'object') {\r\n\t\t\t// allow an object as a hash to be mapped\r\n\t\t\tvar keyMapping = []\r\n\t\t\tvar valueArray = []\r\n\t\t\tfor (var key in array) {\r\n\t\t\t\tkeyMapping.push(key)\r\n\t\t\t\tvalueArray.push(array[key])\r\n\t\t\t}\r\n\t\t\treturn new Variable(function(results) {\r\n\t\t\t\tvar resultObject = {}\r\n\t\t\t\tfor (var i = 0; i < results.length; i++) {\r\n\t\t\t\t\tresultObject[keyMapping[i]] = results[i]\r\n\t\t\t\t}\r\n\t\t\t\treturn resultObject\r\n\t\t\t}).apply(null, valueArray)\r\n\t\t}\r\n\t\tthrow new TypeError('Variable.all requires an array')\r\n\t}\r\n\r\n\tfunction hasOwn(Target, createForInstance) {\r\n\t\tvar ownedClasses = this.ownedClasses || (this.ownedClasses = new WeakMap())\r\n\t\t// TODO: assign to super classes\r\n\t\tvar Class = this\r\n\t\townedClasses.set(Target, createForInstance || function() { return new Target() })\r\n\t\treturn this\r\n\t}\r\n\tfunction getForClass(subject, Target) {\r\n\t\tvar createInstance = subject.constructor.ownedClasses && subject.constructor.ownedClasses.get(Target)\r\n\t\tif (createInstance) {\r\n\t\t\tvar ownedInstances = subject.ownedInstances || (subject.ownedInstances = new WeakMap())\r\n\t\t\tvar instance = ownedInstances.get(Target)\r\n\t\t\tif (!instance) {\r\n\t\t\t\townedInstances.set(Target, instance = createInstance(subject))\r\n\t\t\t\tinstance.subject = subject\r\n\t\t\t}\r\n\t\t\treturn instance\r\n\t\t}\r\n\t}\r\n\tfunction generalizeClass() {\r\n\t\tvar prototype = this.prototype\r\n\t\tvar prototypeNames = Object.getOwnPropertyNames(prototype)\r\n\t\tfor(var i = 0, l = prototypeNames.length; i < l; i++) {\r\n\t\t\tvar name = prototypeNames[i]\r\n\t\t\tObject.defineProperty(this, name, getGeneralizedDescriptor(Object.getOwnPropertyDescriptor(prototype, name), name, this))\r\n\t\t}\r\n\t}\r\n\tfunction getGeneralizedDescriptor(descriptor, name, Class) {\r\n\t\tif (typeof descriptor.value === 'function') {\r\n\t\t\treturn {\r\n\t\t\t\tvalue: generalizeMethod(Class, name)\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\treturn descriptor\r\n\t\t}\r\n\t}\r\n\tfunction generalizeMethod(Class, name) {\r\n\t\t// I think we can just rely on `this`, but we could use the argument:\r\n\t\t// function(possibleEvent) {\r\n\t\t// \tvar target = possibleEvent && possibleEvent.target\r\n\t\tvar method = Class[name] = function() {\r\n\t\t\tvar instance = Class.for(this)\r\n\t\t\treturn instance[name].apply(instance, arguments)\r\n\t\t}\r\n\t\tmethod.for = function(context) {\r\n\t\t\tvar instance = Class.for(context)\r\n\t\t\treturn function() {\r\n\t\t\t\treturn instance[name].apply(instance, arguments)\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn method\r\n\t}\r\n\r\n\tvar defaultContext = {\r\n\t\tname: 'Default context',\r\n\t\tdescription: 'This object is the default context for classes, corresponding to a singleton instance of that class',\r\n\t\tconstructor: {\r\n\t\t\tgetForClass: function(subject, Class) {\r\n\t\t\t\treturn Class.defaultInstance\r\n\t\t\t}\r\n\t\t},\r\n\t\tcontains: function() {\r\n\t\t\treturn true // contains everything\r\n\t\t}\r\n\t}\r\n\tfunction instanceForContext(Class, context) {\r\n\t\tif (!context) {\r\n\t\t\tthrow new TypeError('Accessing a generalized class without context to resolve to an instance, call for(context) (where context is an element or related variable instance) on your variable first')\r\n\t\t}\r\n\t\tvar instance = context.subject.constructor.getForClass && context.subject.constructor.getForClass(context.subject, Class) || Class.defaultInstance\r\n\t\tcontext.distinctSubject = mergeSubject(context.distinctSubject, instance.subject)\r\n\t\treturn instance\r\n\t}\r\n\t// a variable inheritance change goes through its own prototype, so classes/constructor\r\n\t// can be used as variables as well\r\n\tfor (var key in VariablePrototype) {\r\n\t\tObject.defineProperty(Variable, key, Object.getOwnPropertyDescriptor(VariablePrototype, key))\r\n\t}\r\n\tVariable.valueOf = function(context) {\r\n\t\t// contextualized getValue\r\n\t\treturn instanceForContext(this, context).valueOf()\r\n\t}\r\n\tVariable.setValue = function(value, context) {\r\n\t\t// contextualized setValue\r\n\t\treturn instanceForContext(this, context).put(value)\r\n\t}\r\n\tVariable.getForClass = getForClass\r\n\tVariable.generalize = generalizeClass\r\n\tVariable.call = Function.prototype.call // restore these\r\n\tVariable.apply = Function.prototype.apply\r\n\tVariable.extend = function(properties) {\r\n\t\t// TODO: handle arguments\r\n\t\tvar Base = this\r\n\t\tfunction ExtendedVariable() {\r\n\t\t\tif (this instanceof ExtendedVariable) {\r\n\t\t\t\treturn Base.apply(this, arguments)\r\n\t\t\t} else {\r\n\t\t\t\treturn ExtendedVariable.extend(properties)\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar prototype = ExtendedVariable.prototype = Object.create(this.prototype)\r\n\t\tExtendedVariable.prototype.constructor = ExtendedVariable\r\n\t\tsetPrototypeOf(ExtendedVariable, this)\r\n\t\tfor (var key in properties) {\r\n\t\t\tvar descriptor = Object.getOwnPropertyDescriptor(properties, key)\r\n\t\t\tObject.defineProperty(prototype, key, descriptor)\r\n\t\t\tObject.defineProperty(ExtendedVariable, key, getGeneralizedDescriptor(descriptor, key, ExtendedVariable))\r\n\t\t}\r\n\t\tif (properties && properties.hasOwn) {\r\n\t\t\thasOwn.call(ExtendedVariable, properties.hasOwn)\r\n\t\t}\r\n\t\treturn ExtendedVariable\r\n\t}\r\n\tObject.defineProperty(Variable, 'defaultInstance', {\r\n\t\tget: function() {\r\n\t\t\treturn this.hasOwnProperty('_defaultInstance') ?\r\n\t\t\t\tthis._defaultInstance : (\r\n\t\t\t\t\tthis._defaultInstance = new this(),\r\n\t\t\t\t\tthis._defaultInstance.subject = defaultContext,\r\n\t\t\t\t\tthis._defaultInstance)\r\n\t\t}\r\n\t})\r\n\tVariable.hasOwn = hasOwn\r\n\tVariable.all = all\r\n\tVariable.objectUpdated = objectUpdated\r\n\tVariable.assign = function(target) {\r\n\t\t// copy properties, using variable sources\r\n\t\tfor (var i = 1; i < arguments.length; i++) {\r\n\t\t\tvar source = arguments[i]\r\n\t\t\tvar sourceVariable\r\n\t\t\tif (source && source.notifies) {\r\n\t\t\t\tsourceVariable = source\r\n\t\t\t\tsource = null\r\n\t\t\t} else {\r\n\t\t\t\tsourceVariable = Variable.instanceMap && Variable.instanceMap.get(source)\r\n\t\t\t}\r\n\t\t\tvar sourceProperties = sourceVariable && sourceVariable._properties\r\n\t\t\tif (sourceProperties) {\r\n\t\t\t\tfor (var key in sourceProperties) {\r\n\t\t\t\t\tvar property = sourceProperties[key]\r\n\t\t\t\t\tif (property && property.value) {\r\n\t\t\t\t\t\tvar targetVariable = targetVariable || Variable.for(target)\r\n\t\t\t\t\t\ttargetVariable.property(key).put(property)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor (var key in source) {\r\n\t\t\t\tif (!(sourceVariable && sourceVariable._properties && sourceVariable._properties[key])) {\r\n\t\t\t\t\ttarget[key] = source[key]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn target\r\n\t}\r\n\tVariable.assign.handlesVariables = true\r\n\r\n\treturn Variable\r\n})\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./Variable.js\n ** module id = 2\n ** module chunks = 0\n **/","define([], function () {\r\n\tvar getPrototypeOf = Object.getPrototypeOf || (function(base) { return base.__proto__ })\r\n\tvar setPrototypeOf = Object.setPrototypeOf || (function(base, proto) { base.__proto__ = proto})\r\n\tvar hasFeatures = {\r\n\t\trequestAnimationFrame: typeof requestAnimationFrame != 'undefined',\r\n\t\tdefineProperty: Object.defineProperty && (function() {\r\n\t\t\ttry{\r\n\t\t\t\tObject.defineProperty({}, 't', {})\r\n\t\t\t\treturn true\r\n\t\t\t}catch(e) {\r\n\t\t\t}\r\n\t\t})(),\r\n\t\tpromise: typeof Promise !== 'undefined',\r\n\t\tMutationObserver: typeof MutationObserver !== 'undefined',\r\n\t\t'WeakMap': typeof WeakMap === 'function'\r\n\t}\r\n\tfunction has(feature) {\r\n\t\treturn hasFeatures[feature]\r\n\t}\r\n\t// This is an polyfill for Object.observe with just enough functionality\r\n\t// for what Variables need\r\n\t// An observe function, with polyfile\r\n\tvar observe =\r\n\t\thas('defineProperty') ? \r\n\t\tfunction observe(target, listener) {\r\n\t\t\t/*for(var i in target) {\r\n\t\t\t\taddKey(i)\r\n\t\t\t}*/\r\n\t\t\tlistener.addKey = addKey\r\n\t\t\tlistener.remove = function() {\r\n\t\t\t\tlistener = null\r\n\t\t\t}\r\n\t\t\treturn listener\r\n\t\t\tfunction addKey(key) {\r\n\t\t\t\tvar keyFlag = 'key' + key\r\n\t\t\t\tif(this[keyFlag]) {\r\n\t\t\t\t\treturn\r\n\t\t\t\t}else{\r\n\t\t\t\t\tthis[keyFlag] = true\r\n\t\t\t\t}\r\n\t\t\t\tvar currentValue = target[key]\r\n\t\t\t\tvar targetAncestor = target\r\n\t\t\t\tvar descriptor\r\n\t\t\t\tdo {\r\n\t\t\t\t\tdescriptor = Object.getOwnPropertyDescriptor(targetAncestor, key)\r\n\t\t\t\t} while(!descriptor && (targetAncestor = getPrototypeOf(targetAncestor)))\r\n\r\n\t\t\t\tif(descriptor && descriptor.set) {\r\n\t\t\t\t\tvar previousSet = descriptor.set\r\n\t\t\t\t\tvar previousGet = descriptor.get\r\n\t\t\t\t\tObject.defineProperty(target, key, {\r\n\t\t\t\t\t\tget: function() {\r\n\t\t\t\t\t\t\treturn (currentValue = previousGet.call(this))\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tset: function(value) {\r\n\t\t\t\t\t\t\tpreviousSet.call(this, value)\r\n\t\t\t\t\t\t\tif(currentValue !== value) {\r\n\t\t\t\t\t\t\t\tcurrentValue = value\r\n\t\t\t\t\t\t\t\tif(listener) {\r\n\t\t\t\t\t\t\t\t\tlistener([{target: this, name: key}])\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tenumerable: descriptor.enumerable\r\n\t\t\t\t\t})\r\n\t\t\t\t}else{\r\n\t\t\t\t\tObject.defineProperty(target, key, {\r\n\t\t\t\t\t\tget: function() {\r\n\t\t\t\t\t\t\treturn currentValue\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tset: function(value) {\r\n\t\t\t\t\t\t\tif(currentValue !== value) {\r\n\t\t\t\t\t\t\t\tcurrentValue = value\r\n\t\t\t\t\t\t\t\tif(listener) {\r\n\t\t\t\t\t\t\t\t\tlistener([{target: this, name: key}])\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tenumerable: !descriptor || descriptor.enumerable\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} :\r\n\t\t// and finally a polling-based solution, for the really old browsers\r\n\t\tfunction(target, listener) {\r\n\t\t\tif(!timerStarted) {\r\n\t\t\t\ttimerStarted = true\r\n\t\t\t\tsetInterval(function() {\r\n\t\t\t\t\tfor(var i = 0, l = watchedObjects.length; i < l; i++) {\r\n\t\t\t\t\t\tdiff(watchedCopies[i], watchedObjects[i], listeners[i])\r\n\t\t\t\t\t}\r\n\t\t\t\t}, 20)\r\n\t\t\t}\r\n\t\t\tvar copy = {}\r\n\t\t\tfor(var i in target) {\r\n\t\t\t\tif(target.hasOwnProperty(i)) {\r\n\t\t\t\t\tcopy[i] = target[i]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\twatchedObjects.push(target)\r\n\t\t\twatchedCopies.push(copy)\r\n\t\t\tlisteners.push(listener)\r\n\t\t}\r\n\tvar queuedListeners\r\n\tfunction queue(listener, object, name) {\r\n\t\tif(queuedListeners) {\r\n\t\t\tif(queuedListeners.indexOf(listener) === -1) {\r\n\t\t\t\tqueuedListeners.push(listener)\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\tqueuedListeners = [listener]\r\n\t\t\tlang.nextTurn(function() {\r\n\t\t\t\tqueuedListeners.forEach(function(listener) {\r\n\t\t\t\t\tvar events = []\r\n\t\t\t\t\tlistener.properties.forEach(function(property) {\r\n\t\t\t\t\t\tevents.push({target: listener.object, name: property})\r\n\t\t\t\t\t})\r\n\t\t\t\t\tlistener(events)\r\n\t\t\t\t\tlistener.object = null\r\n\t\t\t\t\tlistener.properties = null\r\n\t\t\t\t})\r\n\t\t\t\tqueuedListeners = null\r\n\t\t\t}, 0)\r\n\t\t}\r\n\t\tlistener.object = object\r\n\t\tvar properties = listener.properties || (listener.properties = [])\r\n\t\tif(properties.indexOf(name) === -1) {\r\n\t\t\tproperties.push(name)\r\n\t\t}\r\n\t}\r\n\tvar unobserve = has('observe') ? Object.unobserve :\r\n\t\tfunction(target, listener) {\r\n\t\t\tif(listener.remove) {\r\n\t\t\t\tlistener.remove()\r\n\t\t\t}\r\n\t\t\tfor(var i = 0, l = watchedObjects.length; i < l; i++) {\r\n\t\t\t\tif(watchedObjects[i] === target && listeners[i] === listener) {\r\n\t\t\t\t\twatchedObjects.splice(i, 1)\r\n\t\t\t\t\twatchedCopies.splice(i, 1)\r\n\t\t\t\t\tlisteners.splice(i, 1)\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\tvar watchedObjects = []\r\n\tvar watchedCopies = []\r\n\tvar listeners = []\r\n\tvar timerStarted = false\r\n\tfunction diff(previous, current, callback) {\r\n\t\t// TODO: keep an array of properties for each watch for faster iteration\r\n\t\tvar queued\r\n\t\tfor(var i in previous) {\r\n\t\t\tif(previous.hasOwnProperty(i) && previous[i] !== current[i]) {\r\n\t\t\t\t// a property has changed\r\n\t\t\t\tprevious[i] = current[i]\r\n\t\t\t\t(queued || (queued = [])).push({name: i})\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor(var i in current) {\r\n\t\t\tif(current.hasOwnProperty(i) && !previous.hasOwnProperty(i)) {\r\n\t\t\t\t// a property has been added\r\n\t\t\t\tprevious[i] = current[i]\r\n\t\t\t\t(queued || (queued = [])).push({name: i})\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(queued) {\r\n\t\t\tcallback(queued)\r\n\t\t}\r\n\t}\r\n\r\n\tvar id = 1\r\n\t// a function that returns a function, to stop JSON serialization of an\r\n\t// object\r\n\tfunction toJSONHidden() {\r\n\t\treturn toJSONHidden\r\n\t}\r\n\t// An object that will be hidden from JSON serialization\r\n\tvar Hidden = function () {\r\n\t}\r\n\tHidden.prototype.toJSON = toJSONHidden\r\n\r\n\tvar lang = {\r\n\t\trequestAnimationFrame: has('requestAnimationFrame') ? requestAnimationFrame :\r\n\t\t\t(function() {\r\n\t\t\t\tvar toRender = []\r\n\t\t\t\tvar queued = false\r\n\t\t\t\tfunction processAnimationFrame() {\r\n\t\t\t\t\tfor (var i = 0; i < toRender.length; i++) {\r\n\t\t\t\t\t\ttoRender[i]()\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttoRender = []\r\n\t\t\t\t\tqueued = false\r\n\t\t\t\t}\r\n\t\t\t\tfunction requestAnimationFrame(renderer) {\r\n\t\t\t\t \tif (!queued) {\r\n\t\t\t\t\t\tsetTimeout(processAnimationFrame)\r\n\t\t\t\t\t\tqueued = true\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttoRender.push(renderer)\r\n\t\t\t\t}\r\n\t\t\t\treturn requestAnimationFrame\r\n\t\t\t})(),\r\n\t\tPromise: has('promise') ? Promise : (function() {\r\n\t\t\tfunction Promise(execute) {\r\n\t\t\t\tvar isResolved, resolution, errorResolution\r\n\t\t\t\tvar queue = 0\r\n\t\t\t\tfunction resolve(value) {\r\n\t\t\t\t\t// resolve function\r\n\t\t\t\t\tif(value && value.then) {\r\n\t\t\t\t\t\t// received a promise, wait for it\r\n\t\t\t\t\t\tvalue.then(resolve, reject)\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tresolution = value\r\n\t\t\t\t\t\tfinished()\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tfunction reject(error) {\r\n\t\t\t\t\t// reject function\r\n\t\t\t\t\terrorResolution = error\r\n\t\t\t\t\tfinished()\r\n\t\t\t\t}\r\n\t\t\t\texecute(resolve, reject)\r\n\t\t\t\tfunction finished() {\r\n\t\t\t\t\tisResolved = true\r\n\t\t\t\t\tfor(var i = 0, l = queue.length; i < l; i++) {\r\n\t\t\t\t\t\tqueue[i]()\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// clean out the memory\r\n\t\t\t\t\tqueue = 0\r\n\t\t\t\t}\r\n\t\t\t\treturn {\r\n\t\t\t\t\tthen: function(callback, errback) {\r\n\t\t\t\t\t\treturn new Promise(function(resolve, reject) {\r\n\t\t\t\t\t\t\tfunction handle() {\r\n\t\t\t\t\t\t\t\t// promise fulfilled, call the appropriate callback\r\n\t\t\t\t\t\t\t\ttry{\r\n\t\t\t\t\t\t\t\t\tif(errorResolution && !errback) {\r\n\t\t\t\t\t\t\t\t\t\t// errors without a handler flow through\r\n\t\t\t\t\t\t\t\t\t\treject(errorResolution)\r\n\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t// resolve to the callback's result\r\n\t\t\t\t\t\t\t\t\t\tresolve(errorResolution ?\r\n\t\t\t\t\t\t\t\t\t\t\terrback(errorResolution) :\r\n\t\t\t\t\t\t\t\t\t\t\tcallback ?\r\n\t\t\t\t\t\t\t\t\t\t\t\tcallback(resolution) : resolution)\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}catch(newError) {\r\n\t\t\t\t\t\t\t\t\t// caught an error, reject the returned promise\r\n\t\t\t\t\t\t\t\t\treject(newError)\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif(isResolved) {\r\n\t\t\t\t\t\t\t\t// already resolved, immediately handle\r\n\t\t\t\t\t\t\t\thandle()\r\n\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t(queue || (queue = [])).push(handle)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn Promise\r\n\t\t}()),\r\n\r\n\t\tWeakMap: has('WeakMap') ? WeakMap :\r\n\t \tfunction (values, name) {\r\n\t \t\tvar mapProperty = '__' + (name || '') + id++\r\n\t \t\treturn has('defineProperty') ?\r\n\t \t\t{\r\n\t \t\t\tget: function (key) {\r\n\t \t\t\t\treturn key[mapProperty]\r\n\t \t\t\t},\r\n\t \t\t\tset: function (key, value) {\r\n\t \t\t\t\tObject.defineProperty(key, mapProperty, {\r\n\t \t\t\t\t\tvalue: value,\r\n\t \t\t\t\t\tenumerable: false\r\n\t \t\t\t\t})\r\n\t \t\t\t}\r\n\t \t\t} :\r\n\t \t\t{\r\n\t \t\t\tget: function (key) {\r\n\t \t\t\t\tvar intermediary = key[mapProperty]\r\n\t \t\t\t\treturn intermediary && intermediary.value\r\n\t \t\t\t},\r\n\t \t\t\tset: function (key, value) {\r\n\t \t\t\t\t// we use an intermediary that is hidden from JSON serialization, at least\r\n\t \t\t\t\tvar intermediary = key[mapProperty] || (key[mapProperty] = new Hidden())\r\n\t \t\t\t\tintermediary.value = value\r\n\t \t\t\t}\r\n\t \t\t}\r\n\t \t},\r\n\r\n\t\tobserve: observe,\r\n\t\tunobserve: unobserve,\r\n\t\twhen: function(value, callback, errorHandler) {\r\n\t\t\treturn value && value.then ?\r\n\t\t\t\t(value.then(callback, errorHandler) || value) : callback(value)\r\n\t\t},\r\n\t\twhenAll: function(inputs, callback) {\r\n\t\t\tvar promiseInvolved\r\n\t\t\tfor(var i = 0, l = inputs.length; i < l; i++) {\r\n\t\t\t\tif(inputs[i] && inputs[i].then) {\r\n\t\t\t\t\tpromiseInvolved = true\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(promiseInvolved) {\r\n\t\t\t\t// we have asynch inputs, do lazy loading\r\n\t\t\t\treturn {\r\n\t\t\t\t\tthen: function(onResolve, onError) {\r\n\t\t\t\t\t\tvar remaining = 1\r\n\t\t\t\t\t\tvar result\r\n\t\t\t\t\t\tvar readyInputs = []\r\n\t\t\t\t\t\tvar lastPromiseResult\r\n\t\t\t\t\t\tfor(var i = 0; i < inputs.length; i++) {\r\n\t\t\t\t\t\t\tvar input = inputs[i]\r\n\t\t\t\t\t\t\tremaining++\r\n\t\t\t\t\t\t\tif(input && input.then) {\r\n\t\t\t\t\t\t\t\t(function(i, previousPromiseResult) {\r\n\t\t\t\t\t\t\t\t\tlastPromiseResult = input.then(function(value) {\r\n\t\t\t\t\t\t\t\t\t\treadyInputs[i] = value\r\n\t\t\t\t\t\t\t\t\t\tonEach()\r\n\t\t\t\t\t\t\t\t\t\tif(!remaining) {\r\n\t\t\t\t\t\t\t\t\t\t\treturn result\r\n\t\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t\treturn previousPromiseResult\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}, onError)\r\n\t\t\t\t\t\t\t\t})(i, lastPromiseResult)\r\n\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\treadyInputs[i] = input\r\n\t\t\t\t\t\t\t\tonEach()\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tonEach()\r\n\t\t\t\t\t\tfunction onEach() {\r\n\t\t\t\t\t\t\tremaining--\r\n\t\t\t\t\t\t\tif(!remaining) {\r\n\t\t\t\t\t\t\t\tresult = onResolve(callback(readyInputs))\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn lastPromiseResult\r\n\t\t\t\t\t},\r\n\t\t\t\t\tinputs: inputs\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// just sync inputs\r\n\t\t\treturn callback(inputs)\r\n\r\n\t\t},\r\n\t\tcompose: function(Base, constructor, properties) {\r\n\t\t\tvar prototype = constructor.prototype = Object.create(Base.prototype)\r\n\t\t\tsetPrototypeOf(constructor, Base)\r\n\t\t\tfor(var i in properties) {\r\n\t\t\t\tprototype[i] = properties[i]\r\n\t\t\t}\r\n\t\t\tprototype.constructor = constructor\r\n\t\t\treturn constructor\r\n\t\t},\r\n\t\tnextTurn: has('MutationObserver') ?\r\n\t\t\tfunction (callback) {\r\n\t\t\t\t// promises don't resolve consistently on the next micro turn (Edge doesn't do it right),\r\n\t\t\t\t// so use mutation observer\r\n\t\t\t\t// TODO: make a faster mode that doesn't recreate each time\r\n\t\t\t\tvar div = document.createElement('div')\r\n\t\t\t\tvar observer = new MutationObserver(callback)\r\n\t\t\t\tobserver.observe(div, {\r\n\t\t\t\t\tattributes: true\r\n\t\t\t\t})\r\n\t\t\t\tdiv.setAttribute('a', id++)\r\n\t\t\t} :\r\n\t\t\tfunction (callback) {\r\n\t\t\t\t// TODO: we can do better for other, older browsers\r\n\t\t\t\tsetTimeout(callback, 0)\r\n\t\t\t},\r\n\t\tcopy: Object.assign || function(target, source) {\r\n\t\t\tfor(var i in source) {\r\n\t\t\t\ttarget[i] = source[i]\r\n\t\t\t}\r\n\t\t\treturn target\r\n\t\t}\r\n\t}\r\n\treturn lang\r\n})\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./util/lang.js\n ** module id = 3\n ** module chunks = 0\n **/","define(['./util/lang'], function (lang, Variable) {\r\n\tvar doc = typeof document !== 'undefined' && document\r\n\tvar invalidatedElements\r\n\tvar queued\r\n\tvar toRender = []\r\n\tvar nextId = 1\r\n\tvar requestAnimationFrame = lang.requestAnimationFrame\r\n\r\n\tfunction Context(subject){\r\n\t\tthis.subject = subject\r\n\t}\r\n\r\n\tfunction Renderer(options) {\r\n\t\tvar variable = options.variable\r\n\r\n\t\tthis.variable = variable\r\n\t\tthis.elements = []\r\n\t\tif (options) {\r\n\t\t\tif (options.selector) {\r\n\t\t\t\tthis.selector = options.selector\r\n\t\t\t}\r\n\t\t\tif (options.elements) {\r\n\t\t\t\tthis.elements = options.elements\r\n\t\t\t\tthis.element = this.elements[0]\r\n\t\t\t}\r\n\t\t\tif (options.element) {\r\n\t\t\t\tthis.element = options.element\r\n\t\t\t\tthis.elements.push(options.element)\r\n\t\t\t}\r\n\t\t\tfor(var i = 0, l = this.elements.length; i < l; i++) {\r\n\t\t\t\t(this.elements[i].alkaliRenderers || (this.elements[i].alkaliRenderers = [])).push(this)\r\n\t\t\t}\r\n\t\t\tif (options.update) {\r\n\t\t\t\tthis.updateRendering = options.update\r\n\t\t\t}\r\n\t\t\tif (options.shouldRender) {\r\n\t\t\t\tthis.shouldRender = options.shouldRender\r\n\t\t\t}\r\n\t\t\tif (options.renderUpdate) {\r\n\t\t\t\tthis.renderUpdate = options.renderUpdate\r\n\t\t\t}\r\n\t\t\tif (options.alwaysUpdate) {\r\n\t\t\t\tthis.alwaysUpdate = options.alwaysUpdate\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (variable.updated) {\r\n\t\t\t// if it has update, we don't need to instantiate a closure\r\n\t\t\tvariable.notifies(this)\r\n\t\t} else {\r\n\t\t\t// baconjs-esqe API\r\n\t\t\tvar renderer = this\r\n\t\t\tvariable.subscribe(function (event) {\r\n\t\t\t\t// replace the variable with an object\r\n\t\t\t\t// that returns the value from the event\r\n\t\t\t\trenderer.variable = {\r\n\t\t\t\t\tvalueOf: function () {\r\n\t\t\t\t\t\treturn event.value()\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\trenderer.updated()\r\n\t\t\t})\r\n\t\t}\r\n\t\tif(options && options.updateOnStart !== false){\r\n\t\t\tthis.updateRendering(true)\r\n\t\t}\r\n\t}\r\n\tRenderer.prototype = {\r\n\t\tconstructor: Renderer,\r\n\t\tupdateRendering: function () {\r\n\t\t\tthrow new Error ('updateRendering must be implemented by sub class of Renderer')\r\n\t\t},\r\n\t\tupdated: function (updateEvent, by, context) {\r\n\t\t\tif (!this.invalidated) {\r\n\t\t\t\tif (!context || this.contextMatches(context)) {\r\n\t\t\t\t\t// do this only once, until we render again\r\n\t\t\t\t\tthis.invalidated = true\r\n\t\t\t\t\tvar renderer = this\r\n\t\t\t\t\trequestAnimationFrame(function(){\r\n\t\t\t\t\t\tinvalidatedElements = null\r\n\t\t\t\t\t\trenderer.updateRendering(renderer.alwaysUpdate)\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tcontextMatches: function(context) {\r\n\t\t\treturn true\r\n\t\t\treturn context == this.elements ||\r\n\t\t\t\t// if context is any element in this.elements - perhaps return only the specific matching elements?\r\n\t\t\t\t(this.elements.indexOf(context) != -1) ||\r\n\t\t\t  // (context is an array and any/all elements are contained in this.elements) ||\r\n\t\t\t\t// context contains() any of this.elements\r\n\t\t\t\t(function(elements) {\r\n\t\t\t\t\tfor(var i = 0, l = elements.length; i < l; i++) {\r\n\t\t\t\t\t\tif (context.contains(elements[i])) return true\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn false\r\n\t\t\t\t})(this.elements)\r\n\t\t},\r\n\t\tinvalidateElement: function(element) {\r\n\t\t\tif(!invalidatedElements){\r\n\t\t\t\tinvalidatedElements = new WeakMap(null, 'invalidated')\r\n\t\t\t\t// TODO: if this is not a real weak map, we don't want to GC it, or it will leak\r\n\t\t\t}\r\n\t\t\tvar invalidatedParts = invalidatedElements.get(element)\r\n\t\t\tinvalidatedElements.set(element, invalidatedParts = {})\r\n\t\t\tif (!invalidatedParts[id]) {\r\n\t\t\t\tinvalidatedParts[id] = true\r\n\t\t\t}\r\n\t\t\tif (!queued) {\r\n\t\t\t\tlang.queueTask(processQueue)\r\n\t\t\t\tqueued = true\r\n\t\t\t}\r\n\t\t\tvar renderer = this\r\n\t\t\ttoRender.push(function(){\r\n\t\t\t\trenderer.invalidated = false\r\n\t\t\t\trenderer.updateElement(element)\r\n\t\t\t})\r\n\t\t},\r\n\t\tgetId: function(){\r\n\t\t\treturn this.id || (this.id = nextId++)\r\n\t\t},\r\n\t\tstop: function() {\r\n\t\t\tthis.variable.stopNotifies(this)\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction ElementRenderer(options) {\r\n\t\tRenderer.call(this, options)\r\n\t}\r\n\tElementRenderer.prototype = Object.create(Renderer.prototype)\r\n\tElementRenderer.prototype.shouldRender = function (element) {\r\n\t\treturn document.body.contains(element)\r\n\t}\r\n\tElementRenderer.prototype.getSubject = function () {\r\n\t\treturn this.element || this.elements[0]\r\n\t}\r\n\tElementRenderer.prototype.updateRendering = function (always, element) {\r\n\t\tvar elements = this.elements || (element && [element]) || []\r\n\t\tif(!elements.length){\r\n\t\t\tif(this.selector){\r\n\t\t\t\telements = document.querySelectorAll(this.selector)\r\n\t\t\t}else{\r\n\t\t\t\tthrow new Error('No element or selector was provided to the Renderer')\r\n\t\t\t}\r\n\t\t\treturn\r\n\t\t}\r\n\t\tfor(var i = 0, l = elements.length; i < l; i++){\r\n\t\t\tif(always || this.shouldRender(elements[i])){\r\n\t\t\t\t// it is connected\r\n\t\t\t\tthis.updateElement(elements[i])\r\n\t\t\t}else{\r\n\t\t\t\tvar id = this.getId()\r\n\t\t\t\tvar renderers = elements[i].renderersOnShow\r\n\t\t\t\tif(!renderers){\r\n\t\t\t\t\trenderers = elements[i].renderersOnShow = []\r\n\t\t\t\t\telements[i].className += ' needs-rerendering'\r\n\t\t\t\t}\r\n\t\t\t\tif (!renderers[id]) {\r\n\t\t\t\t\trenderers[id] = this\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tElementRenderer.prototype.addElement = function (element) {\r\n\t\tif (this.selector) {\r\n\t\t\telement.renderersOnShow = [this]\r\n\t\t} else {\r\n\t\t\tthis.elements.push(element)\r\n\t\t}\r\n\t\t// and immediately do an update\r\n\t\tthis.updateElement(element)\r\n\t}\r\n\tElementRenderer.prototype.updateElement = function(element) {\r\n\t\tthis.invalidated = false\r\n\t\ttry {\r\n\t\t\t// TODO: might make something cheaper than for(element) for setting context?\r\n\t\t\tvar value = !this.omitValueOf && this.variable.valueOf(new Context(element))\r\n\t\t} catch (error) {\r\n\t\t\telement.appendChild(document.createTextNode(error))\r\n\t\t}\r\n\t\tif(value !== undefined || this.started){\r\n\t\t\tthis.started = true\r\n\t\t\tif(value && value.then){\r\n\t\t\t\tif(this.renderLoading){\r\n\t\t\t\t\tthis.renderLoading(value, element)\r\n\t\t\t\t}\r\n\t\t\t\tvar renderer = this\r\n\t\t\t\tvalue.then(function (value) {\r\n\t\t\t\t\trenderer.renderUpdate(value, element)\r\n\t\t\t\t})\r\n\t\t\t}else{\r\n\t\t\t\tthis.renderUpdate(value, element)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tElementRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\tthrow new Error('renderUpdate(newValue) must be implemented')\r\n\t}\r\n\tRenderer.Renderer = Renderer\r\n\tRenderer.ElementRenderer = ElementRenderer\r\n\r\n\tfunction AttributeRenderer(options) {\r\n\t\tif(options.name){\r\n\t\t\tthis.name = options.name\r\n\t\t}\r\n\t\tElementRenderer.apply(this, arguments)\r\n\t}\r\n\tAttributeRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\tAttributeRenderer.prototype.type = 'AttributeRenderer'\r\n\tAttributeRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\telement.setAttribute(this.name, newValue)\r\n\t}\r\n\tRenderer.AttributeRenderer = AttributeRenderer\r\n\r\n\tfunction PropertyRenderer(options) {\r\n\t\tif (options.name) {\r\n\t\t\tthis.name = options.name\r\n\t\t}\r\n\t\tElementRenderer.apply(this, arguments)\r\n\t}\r\n\tPropertyRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\tPropertyRenderer.prototype.type = 'PropertyRenderer'\r\n\tPropertyRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\telement[this.name] = newValue\r\n\t}\r\n\tRenderer.PropertyRenderer = PropertyRenderer\r\n\r\n\tfunction InputPropertyRenderer(options) {\r\n\t\tif (options.element && options.element.tagName === 'SELECT' && options.name === 'value') {\r\n\t\t\t// use the deferred value assignment for <select>\r\n\t\t\tthis.renderUpdate = this.renderSelectValueUpdate\r\n\t\t}\r\n\t\tPropertyRenderer.apply(this, arguments)\r\n\t}\r\n\tInputPropertyRenderer.prototype = Object.create(PropertyRenderer.prototype)\r\n\tInputPropertyRenderer.prototype.type = 'InputPropertyRenderer'\r\n\tInputPropertyRenderer.prototype.renderUpdate = function(newValue, element) {\r\n\t\tif (element.type === 'number') {\r\n\t\t\tif (isNaN(newValue)) {\r\n\t\t\t\tnewValue = ''\r\n\t\t\t}\r\n\t\t}\r\n\t\telement[this.name] = newValue\r\n\t}\r\n\tInputPropertyRenderer.prototype.renderSelectValueUpdate = function (newValue, element) {\r\n\t\telement.value = newValue\r\n\t\tif (element.value != newValue && !element.value) {\r\n\t\t\t// if we didn't successfully set the value of a <select>, we may need to wait until the children are constructed\r\n\t\t\telement.eventualValue = newValue\r\n\t\t\tlang.nextTurn(function() {\r\n\t\t\t\tif (element.eventualValue) {\r\n\t\t\t\t\telement.value = element.eventualValue\r\n\t\t\t\t\telement.eventualValue = undefined\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t} else {\r\n\t\t\telement.eventualValue = undefined\r\n\t\t}\r\n\t}\r\n\tRenderer.InputPropertyRenderer = InputPropertyRenderer\r\n\r\n\tfunction StyleRenderer(options) {\r\n\t\tif(options.name){\r\n\t\t\tthis.name = options.name\r\n\t\t}\r\n\t\tElementRenderer.apply(this, arguments)\r\n\t}\r\n\tStyleRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\tStyleRenderer.prototype.type = 'StyleRenderer'\r\n\tStyleRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\telement.style[this.name] = newValue\r\n\t}\r\n\tRenderer.StyleRenderer = StyleRenderer\r\n\r\n\tfunction ContentRenderer(options) {\r\n\t\tElementRenderer.apply(this, arguments)\r\n\t}\r\n\tContentRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\tContentRenderer.prototype.type = 'ContentRenderer'\r\n\tContentRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\telement.innerHTML = ''\r\n\t\tif (newValue === undefined){\r\n\t\t\tnewValue = ''\r\n\t\t}\r\n\t\telement.appendChild(document.createTextNode(newValue))\r\n\t}\r\n\tRenderer.ContentRenderer = ContentRenderer\r\n\r\n\tfunction TextRenderer(options) {\r\n\t\tthis.position = options.position\r\n\t\tthis.textNode = options.textNode\r\n\t\tElementRenderer.apply(this, arguments)\r\n\t}\r\n\tTextRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\tTextRenderer.prototype.type = 'TextRenderer'\r\n\tTextRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\tif (newValue == null){\r\n\t\t\tnewValue = ''\r\n\t\t} else if (newValue.nodeType) {\r\n\t\t\tif (this.textNode && this.textNode.parentNode == element) {\r\n\t\t\t\t// text node is attached, we can replace it with the node\r\n\t\t\t\telement.replaceChild(newValue, this.textNode)\r\n\t\t\t} else {\r\n\t\t\t\telement.appendChild(newValue)\r\n\t\t\t}\r\n\t\t\tthis.textNode = newValue\r\n\t\t\treturn\r\n\t\t}\r\n\t\t(this.textNode || element.childNodes[this.position]).nodeValue = newValue\r\n\t}\r\n\tRenderer.TextRenderer = TextRenderer\r\n\r\n\tfunction ListRenderer(options) {\r\n\t\tif (options.each) {\r\n\t\t\tthis.each = options.each\r\n\t\t}\r\n\t\tElementRenderer.apply(this, arguments)\r\n\t}\r\n\tListRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\tListRenderer.prototype.updated = function (updateEvent, context) {\r\n\t\t(this.updates || (this.updates = [])).push(updateEvent)\r\n\t\tElementRenderer.prototype.updated.call(this, updateEvent, context)\r\n\t}\r\n\tListRenderer.prototype.type = 'ListRenderer'\r\n\tListRenderer.prototype.omitValueOf = true\r\n\tListRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\tvar container\r\n\t\tvar each = this.each\r\n\t\tvar thisElement = this.elements[0]\r\n\t\tvar renderer = this\r\n\t\tif (!this.builtList) {\r\n\t\t\tthis.builtList = true\r\n\t\t\tcontainer = document.createDocumentFragment()\r\n\t\t\tvar childElements = this.childElements = []\r\n\t\t\tthis.variable.for(thisElement).forEach(function(item) {\r\n\t\t\t\teachItem(item)\r\n\t\t\t})\r\n\t\t\tthis.element.appendChild(container)\r\n\t\t} else {\r\n\t\t\tvar childElements = this.childElements\r\n\t\t\tvar updates = this.updates\r\n\t\t\tcontainer = this.element\r\n\t\t\tupdates.forEach(function(update) {\r\n\t\t\t\tif (update.type === 'refresh') {\r\n\t\t\t\t\trenderer.builtList = false\r\n\t\t\t\t\tfor (var i = 0, l = childElements.length; i < l; i++) {\r\n\t\t\t\t\t\tthisElement.removeChild(childElements[i])\r\n\t\t\t\t\t}\r\n\t\t\t\t\trenderer.renderUpdate()\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (update.previousIndex > -1) {\r\n\t\t\t\t\t\tthisElement.removeChild(childElements[update.previousIndex])\r\n\t\t\t\t\t\tchildElements.splice(update.previousIndex, 1)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (update.index > -1) {\r\n\t\t\t\t\t\tvar nextChild = childElements[update.index] || null\r\n\t\t\t\t\t\teachItem(update.value, update.index, nextChild)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\tthis.updates = [] // clear the updates\r\n\t\t}\r\n\t\tfunction eachItem(item, index, nextChild) {\r\n\t\t\tvar childElement\r\n\t\t\tif (each.create) {\r\n\t\t\t\tchildElement = each.create({parent: thisElement, _item: item}) // TODO: make a faster object here potentially\r\n\t\t\t} else {\r\n\t\t\t\tchildElement = each(item, thisElement)\r\n\t\t\t}\r\n\t\t\tif (nextChild) {\r\n\t\t\t\tcontainer.insertBefore(childElement, nextChild)\r\n\t\t\t\tchildElements.splice(index, 0, childElement)\r\n\t\t\t} else {\r\n\t\t\t\tcontainer.appendChild(childElement)\r\n\t\t\t\tchildElements.push(childElement)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tRenderer.ListRenderer = ListRenderer\r\n\r\n\tRenderer.onShowElement = function(shownElement){\r\n\t\trequestAnimationFrame(function(){\r\n\t\t\tinvalidatedElements = null\r\n\t\t\tvar elements = [].slice.call(shownElement.getElementsByClassName('needs-rerendering'))\r\n\t\t\tif (shownElement.className.indexOf('needs-rerendering') > 0){\r\n\t\t\t\tvar includingTop = [shownElement]\r\n\t\t\t\tincludingTop.push.apply(includingTop, elements)\r\n\t\t\t\telements = includingTop\r\n\t\t\t}\r\n\t\t\tfor (var i = 0, l = elements.length; i < l; i++){\r\n\t\t\t\tvar element = elements[i]\r\n\t\t\t\tvar renderers = element.renderersOnShow\r\n\t\t\t\tif(renderers){\r\n\t\t\t\t\telement.renderersOnShow = null\r\n\t\t\t\t\t// remove needs-rerendering class\r\n\t\t\t\t\telement.className = element.className.replace(/\\s?needs\\-rerendering\\s?/g, '')\r\n\t\t\t\t\tfor (var id in renderers) {\r\n\t\t\t\t\t\tvar renderer = renderers[id]\r\n\t\t\t\t\t\trenderer.updateElement(element)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n\r\n\tfunction onElementRemoval(element){\r\n\t\t// cleanup element renderers\r\n\t\tif(element.alkaliRenderers){\r\n\t\t\tvar renderers = element.alkaliRenderers\r\n\t\t\tfor(var i = 0; i < renderers.length; i++){\r\n\t\t\t\tvar renderer = renderers[i]\r\n\t\t\t\trenderer.variable.stopNotifies(renderer)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tRenderer.onElementRemoval = function(element, onlyChildren){\r\n\t\tif(!onlyChildren){\r\n\t\t\tonElementRemoval(element)\r\n\t\t}\r\n\t\tvar children = element.getElementsByTagName('*')\r\n\t\tfor(var i = 0, l = children.length; i < l; i++){\r\n\t\t\tvar child = children[i]\r\n\t\t\tif(child.alkaliRenderers){\r\n\t\t\t\tonElementRemoval(child)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn Renderer\r\n})\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./Renderer.js\n ** module id = 4\n ** module chunks = 0\n **/","define(['./util/lang', './Variable', './operators'], function (lang, Variable, operators) {\r\n\r\n\tfunction react(generator, options) {\r\n    if (typeof generator !== 'function') {\r\n      throw new Error('react() must be called with a generator. You need to use the babel-plugin-transform-alkali plugin if you want to use reactive expressions')\r\n    }\r\n\t\tif (options && options.reverse) {\r\n\t\t\tgenerator.reverse = options.reverse\r\n\t\t}\r\n\t\treturn new Variable.GeneratorVariable(generator)\r\n\t}\r\n  Object.assign(react, operators)\r\n  react.from = function(value) {\r\n    if (value && value.notifies) {\r\n      return value\r\n    }\r\n    return Variable.for(value)\r\n  }\r\n  react.prop = function(object, property) {\r\n    if (object) {\r\n      if (object.property) {\r\n        // it is a variable already\r\n        var directPropertyValue = object[property]\r\n        return directPropertyValue !== undefined ? directPropertyValue : object.property(property)\r\n      } else if (typeof object === 'object') {\r\n        // get the mapped variable for the object\r\n        return Variable.for(object).property(property)\r\n      }\r\n      // not an object\r\n      return object[property]\r\n    }\r\n    // not even truthy\r\n    return object\r\n  }\r\n  react.cond = function(test, consequent, alternate) {\r\n    return operators.if(test, operators.choose(consequent, alternate))\r\n  }\r\n  react.fcall = function(target, args) {\r\n    return new Variable.Call(target, args)\r\n  }\r\n  react.mcall = function(target, key, args) {\r\n    return new Variable.Call(target[key].bind(target), args)\r\n  }\r\n\treturn react\r\n})\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./react.js\n ** module id = 5\n ** module chunks = 0\n **/","define(['./Variable'], function (Variable) {\r\n\tvar deny = Variable.deny;\r\n\tvar operatingFunctions = {};\r\n\tvar operators = {};\r\n\tfunction getOperatingFunction(expression){\r\n\t\t// jshint evil: true\r\n\t\treturn operatingFunctions[expression] ||\r\n\t\t\t(operatingFunctions[expression] =\r\n\t\t\t\tnew Function('a', 'b', 'deny', 'return ' + expression));\r\n\t}\r\n\tfunction operator(operator, name, precedence, forward, reverseA, reverseB){\r\n\t\t// defines the standard operators\r\n\t\tvar reverse = function(output, inputs){\r\n\t\t\tvar a = inputs[0],\r\n\t\t\t\tb = inputs[1];\r\n\t\t\tif(a && a.put){\r\n\t\t\t\tvar result = reverseA(output, b && b.valueOf());\r\n\t\t\t\tif(result !== deny){\r\n\t\t\t\t\ta.put(result);\r\n\t\t\t\t}\r\n\t\t\t}else if(b && b.put){\r\n\t\t\t\tb.put(reverseB(output, a && a.valueOf()));\r\n\t\t\t}else{\r\n\t\t\t\treturn deny;\r\n\t\t\t}\r\n\t\t};\r\n\t\t// define a function that can lazily ensure the operating function\r\n\t\t// is available\r\n\t\tvar operatorHandler = {\r\n\t\t\tapply: function(instance, args){\r\n\t\t\t\tforward = getOperatingFunction(forward);\r\n\t\t\t\treverseA = reverseA && getOperatingFunction(reverseA);\r\n\t\t\t\treverseB = reverseB && getOperatingFunction(reverseB);\r\n\t\t\t\tforward.reverse = reverse;\r\n\t\t\t\toperators[operator] = operatorHandler = new Variable(forward);\r\n\r\n\t\t\t\taddFlags(operatorHandler);\r\n\t\t\t\targs = Array.prototype.slice.call(args);\r\n\t\t\t\targs.push(deny)\r\n\t\t\t\treturn operatorHandler.apply(instance, args);\r\n\t\t\t}\r\n\t\t};\r\n\t\tfunction addFlags(operatorHandler){\r\n\t\t\toperatorHandler.precedence = precedence;\r\n\t\t\toperatorHandler.infix = reverseB !== false;\r\n\t\t}\r\n\t\taddFlags(operatorHandler);\r\n\t\toperators[operator] = operatorHandler;\r\n\t\toperators[name] = function() {\r\n\t\t\treturn operatorHandler.apply(null, arguments)\r\n\t\t}\r\n\t}\r\n\t// using order precedence from:\r\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence\r\n\toperator('+', 'add', 6, 'a+b', 'a-b', 'a-b');\r\n\toperator('-', 'subtract', 6, 'a-b', 'a+b', 'b-a');\r\n\toperator('*', 'multiply', 5, 'a*b', 'a/b', 'a/b');\r\n\toperator('/', 'divide', 5, 'a/b', 'a*b', 'b/a');\r\n//\toperator('^', 7, 'a^b', 'a^(-b)', 'Math.log(a)/Math.log(b)');\r\n\toperator('?', 'if', 16, 'b[a?0:1]', 'a===b[0]||(a===b[1]?false:deny)', '[a,b]');\r\n\toperator(':', 'choose', 15, '[a,b]', 'a[0]?a[1]:deny', 'a[1]');\r\n\toperator('!', 'not', 4, '!a', '!a', false);\r\n\toperator('%', 'remainder', 5, 'a%b');\r\n\toperator('>', 'greater', 8, 'a>b');\r\n\toperator('>=', 'greaterOrEqual', 8, 'a>=b');\r\n\toperator('<', 'less', 8, 'a<b');\r\n\toperator('<=', 'lessOrEqual', 8, 'a<=b');\r\n\toperator('===', 'looseEqual', 9, 'a===b');\r\n\toperator('==', 'equal', 9, 'a==b');\r\n\toperator('&', 'and', 8, 'a&&b');\r\n\toperator('|', 'or', 8, 'a||b');\r\n\toperator('round', 'round', 8, 'Math.round(a*Math.pow(10,b||1))/Math.pow(10,b||1)', 'a', 'a');\r\n\treturn operators;\r\n})\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./operators.js\n ** module id = 6\n ** module chunks = 0\n **/","define(['./util/lang', './Variable'], function (lang, Variable) {\r\n\r\n\tfunction deepCopy(source, target, derivativeMap) {\r\n\t\tif (source && typeof source == 'object') {\r\n\t\t\tif (source instanceof Array) {\r\n\t\t\t\ttarget = [] // always create a new array for array targets\r\n\t\t\t\tfor(var i = 0, l = source.length; i < l; i++) {\r\n\t\t\t\t\ttarget[i] = deepCopy(source[i], null, derivativeMap)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (!target || typeof target !== 'object') {\r\n\t\t\t\t\ttarget = derivativeMap && derivativeMap.get(source)\r\n\t\t\t\t\tif (!target) {\r\n\t\t\t\t\t\ttarget = {}\r\n\t\t\t\t\t\tderivativeMap && derivativeMap.set(source, target)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tfor (var i in source) {\r\n\t\t\t\t\ttarget[i] = deepCopy(source[i], target[i], derivativeMap)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn target\r\n\t\t}\r\n\t\treturn source\r\n\t}\r\n\r\n\tvar Copy = lang.compose(Variable, function(copiedFrom) {\r\n\t\t// this is the variable that we derive from\r\n\t\tthis.copiedFrom = copiedFrom\r\n\t\tthis.derivativeMap = new lang.WeakMap(null, 'derivative')\r\n\t\tthis.isDirty = new Variable(false)\r\n\t}, {\r\n\t\tvalueOf: function(context) {\r\n\t\t\tif(this.state) {\r\n\t\t\t\tthis.state = null\r\n\t\t\t}\r\n\t\t\tvar value = this.copiedFrom.valueOf(context)\r\n\t\t\tif(value && typeof value == 'object') {\r\n\t\t\t\tvar derivative = this.derivativeMap.get(value)\r\n\t\t\t\tif (derivative == null) {\r\n\t\t\t\t\tthis.derivativeMap.set(value, derivative = deepCopy(value, undefined, this.derivativeMap))\r\n\t\t\t\t\tthis.setValue(derivative, context)\r\n\t\t\t\t}\r\n\t\t\t\treturn derivative\r\n\t\t\t}\r\n\t\t\tvar thisValue = this.getValue(context)\r\n\t\t\tif(thisValue === undefined) {\r\n\t\t\t\treturn value\r\n\t\t\t}\r\n\t\t\treturn thisValue\r\n\t\t},\r\n\t\tgetCopyOf: function(value) {\r\n\t\t\tvar derivative = this.derivativeMap.get(value)\r\n\t\t\tif (derivative == null) {\r\n\t\t\t\tthis.derivativeMap.set(value, derivative = deepCopy(value, undefined, this.derivativeMap))\r\n\t\t\t}\r\n\t\t\treturn derivative\r\n\t\t},\r\n\t\tsave: function() {\r\n\t\t\t// copy back to the original object\r\n\t\t\tvar original = this.copiedFrom.valueOf()\r\n\t\t\tvar newCopiedFrom = deepCopy(this.valueOf(), original)\r\n\t\t\tif (original !== newCopiedFrom) {\r\n\t\t\t\t// if we have replaced it with a new object/value, put it\r\n\t\t\t\tthis.copiedFrom.put && this.copiedFrom.put(newCopiedFrom)\r\n\t\t\t} else {\r\n\t\t\t\t// else we have modified an existing object, but we still need to notify\r\n\t\t\t\tif (this.copiedFrom.notifies && this.copiedFrom.updated) { // copiedFrom doesn't have to be a variable, it can be a plain object\r\n\t\t\t\t\tthis.copiedFrom.updated()\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.isDirty.put(false)\r\n\t\t\tthis.onSave && this.onSave()\r\n\t\t},\r\n\t\trevert: function() {\r\n\t\t\tvar original = this.copiedFrom.valueOf()\r\n\t\t\tthis.put(deepCopy(original, this.derivativeMap.get(original), this.derivativeMap))\r\n\t\t\tthis.isDirty.put(false)\r\n\t\t},\r\n\t\tupdated: function() {\r\n\t\t\tthis.isDirty.put(true)\r\n\t\t\treturn Variable.prototype.updated.apply(this, arguments)\r\n\t\t}\r\n\t})\r\n\treturn Copy\r\n})\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./Copy.js\n ** module id = 7\n ** module chunks = 0\n **/"],"sourceRoot":""}