{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///index.js","webpack:///webpack/bootstrap 58ee9498e40228bba837","webpack:///./index.js","webpack:///./Element.js","webpack:///./util/lang.js","webpack:///./Renderer.js","webpack:///./Variable.js","webpack:///./react.js","webpack:///./operators.js","webpack:///./Copy.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","apply","undefined","Element","Renderer","react","Copy","operators","Variable","main","Object","create","VMap","VArray","VPromised","all","Transform","Call","Caching","spawn","func","valueOf","ElementRenderer","assign","lang","booleanStyle","options","element","value","key","style","defaultStyle","directStyle","layoutChildren","parent","children","container","prepend","fragment","length","doc","createDocumentFragment","i","l","childNode","child","currentParent","appendChild","isContentNode","contentNode","notifies","ref","isIterable","variableAsContent","Array","nodeType","Error","createTextNode","insertBefore","firstChild","content","textNode","TextRenderer","variable","bidirectionalHandler","InputPropertyRenderer","name","inputs","tagName","bindChanges","prototype","renderSelectValueUpdate","type","isNaN","noop","applyAttribute","AttributeRenderer","setAttribute","applySubProperties","renderer","SubPropertyRenderer","compose","PropertyRenderer","arguments","renderUpdate","subKey","subValue","assignProperties","properties","styleDefinition","propertyHandler","_propertyHandlers","styleDefinitions","StyleRenderer","slice","addEventListener","defineProperty","enumerable","configurable","writable","buildContent","each","defineHasOwn","ItemClass","getCollectionOf","Item","hasOwn","itemVariable","from","_item","ListRenderer","forEach","item","childElement","buildInputContent","conversion","nextTurn","inputEvents","event","result","put","Context","deny","parseFloat","inputType","inputProperty","date","datetime","time","applyToClass","applyOnCreate","_applyOnCreate","classHandlers","TypeError","getApplySet","Class","hasOwnProperty","getForClass","parentApplySet","getPrototypeOf","propertyHandlers","keys","getOwnPropertyNames","isGenerator","propertyName","toLowerCase","renderDescriptor","renderMethod","map","WeakMap","get","has","set","makeElementConstructor","selector","constructor","withProperties","forTarget","property","propertyForElement","superConstructor","selectorMatch","match","SELECTOR_REGEX","operator","className","remaining","createElement","presumptiveParentMap","setPrototypeOf","ElementApplyOnCreate","argument","created","ready","append","registerTag","registerElement","getConstructor","tags","setupElement","props","elementPropertyHandlers","assigned","handlers","generate","elements","elementName","ElementClass","generateInputs","HTMLInputElement","target","From","Target","createInstance","elementMap","ownedClasses","instanceMap","parentNode","ownedInstances","instance","subject","ThisElementVariable","_Variable","elementOverlay","alkaliRenderers","variableProperties","cleanup","renderers","stop","needsRestart","restart","elementAttached","attached","elementDetached","detached","firstVisit","node","state","__alkaliAttached__","action","body","contains","knownElementProperties","newValue","definition","ClassNameRenderer","currentClassName","changingClassName","removed","replace","document","tag","INPUT","TEXTAREA","display","visibility","color","opacity","zoom","minZoom","maxZoom","fontWeight","position","textDecoration","base","proto","__proto__","classes","flag","class","for","role","render","GeneratorVariable","bind","dataset","attributes","styleObjectHandler","HTMLElement","input","copy","valueAsNumber","valueAsDate","checked","e","select","textarea","a","area","button","dialog","embed","form","frame","frameset","iframe","option","optgroup","output","label","td","th","script","track","link","meta","meter","progress","del","ins","source","video","keygen","object","param","radios","querySelectorAll","radio","dispatchEvent","Event","within","aliases","Anchor","Paragraph","Textarea","DList","UList","OList","ListItem","Text","TextInput","TableRow","TableCell","TableHeaderCell","TableHeader","TableBody","alias","to","refresh","moveLiveElementsEnabled","Symbol","hasInstance","extend","ExtendedElement","descriptor","getOwnPropertyDescriptor","MutationObserver","lifeStates","nodes","observer","mutations","il","mutation","j","jl","nodeIteration","k","kl","baseNode","currentNode","nextNode","nextSibling","observe","childList","subtree","specify","distinctive","generics","push","distinctSubject","subjectMap","specifiedInstance","defaultInstance","getContextualized","_contextMap","context","matches","merge","childContext","getDistinctElement","feature","hasFeatures","diff","previous","current","callback","queued","toJSONHidden","displayName","queuedListeners","requestAnimationFrame","promise","Promise","listener","addKey","keyFlag","currentValue","targetAncestor","previousSet","previousGet","remove","timerStarted","setInterval","watchedObjects","watchedCopies","listeners","unobserve","splice","Hidden","toJSON","processAnimationFrame","toRender","setTimeout","execute","resolve","then","reject","resolution","finished","error","errorResolution","isResolved","queue","errback","handle","newError","values","mapProperty","intermediary","when","errorHandler","whenAll","promiseInvolved","onResolve","onError","onEach","readyInputs","lastPromiseResult","previousPromiseResult","Base","div","update","updateRendering","shouldRender","alwaysUpdate","updated","subscribe","updateOnStart","contextualized","ContentRenderer","onElementRemoval","stopNotifies","invalidatedElements","nextId","updateEvent","by","invalidated","contextMatches","newContext","addInput","invalidateElement","invalidatedParts","queueTask","processQueue","updateElement","getId","getSubject","always","thisElement","renderersOnShow","addElement","omitValueOf","started","renderLoading","eventualValue","innerHTML","builtList","updates","replaceChild","childNodes","nodeValue","eachItem","index","nextChild","childElements","removeChild","previousIndex","onShowElement","shownElement","getElementsByClassName","indexOf","includingTop","onlyChildren","getElementsByTagName","NotifyingContext","registerListener","propertyListenersMap","listenerId","autoObserveObjects","listeningToObject","deregisterListener","RefreshEvent","visited","Set","PropertyChangeEvent","childEvent","AddEvent","args","DeleteEvent","forPropertyNotifyingValues","returnedVariable","hasChildNotifiers","subProperties","_properties","arrayToModify","_willModify","cachedValue","array","updateVersion","results","cachedVersion","version","insertedAt","added","startingIndex","arrayLength","addedCount","arrayPosition","modifier","removedAt","removalCount","oldValue","defineArrayMethod","method","IterativeResults","IterativeMethod","addFlag","functionValue","objectUpdated","_propertyChange","transform","Composite","keyMapping","valueArray","resultObject","createForInstance","generalizeClass","prototypeNames","getGeneralizedDescriptor","generalizeMethod","instanceForContext","noChange","RequestChange","RequestSet","contextFromCache","contextualize","parentContext","contextMap","inputVariable","nextProperty","VariablePrototype","_currentValue","valueContext","gotValueAndListen","gotValue","getValue","previousNotifyingValue","ownObject","isMap","Map","PropertyClass","propertyVariable","ContextualizedVariable","defaultContext","_changeValue","onPropertyChange","eachKey","forDependencies","hasNotifyingChild","init","dependency","handles","computedVariable","getVersion","Math","max","selectVariable","getUpdates","since","nextUpdateMap","add","__debug","console","log","stack","contextualInstance","dependent","fixed","collection","invalidate","updateQueued","next","updateReceiver","unsubscribe","size","setValue","undefine","proxy","proxiedVariable","thisVariable","complete","onValue","toString","callbackOrItemClass","callbackOrContext","transformFunction","reverse","schema","parentSchemaProperties","validate","valid","isValid","validation","Validating","structured","structure","existing","observeObject","observerCount","events","el","done","deliverChanges","collectionOf","_sN","_debug","unshift","pop","shift","iterator","withComputedValue","computedValue","transformContext","contextualizedVariable","newVersion","argumentName","resolved","getArguments","invoke","argsVersion","originalValue","observeArguments","handlesVariables","handlesPromises","setReverse","generic","notify","filter","emit","keyGenerator","valueGenerator","hasKeyFunction","hasValueFunction","hasKey","group","generator","resuming","lastValue","generatorIterator","isThrowing","stepReturn","nextVariable","delegatedGenerator","description","_collectionOf","_collection","Collection","generalize","Function","ExtendedVariable","_defaultInstance","preserveObjects","_getAsObject","ObjectTransform","prop","directPropertyValue","cond","test","consequent","alternate","choose","fcall","mcall","ncall","concat","obj","getOperatingFunction","expression","operatingFunctions","precedence","forward","reverseA","reverseB","addFlags","operatorHandler","infix","b","deepCopy","derivativeMap","copiedFrom","isDirty","derivative","thisValue","getCopyOf","save","original","newCopiedFrom","onSave","revert"],"mappings":"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ACA,WACA,QACA,QACA,QACA,KACA,QACA,MACA,WACA,KACA,KACA,UACA,MACA,MACA,QACA,SACA,OACA,QACA,SACA,SACA,SACA,IACA,QACA,WACA,MACA,UACA,QACA,IACA,SACA,SACA,WACA,SACA,KACA,MACA,IACA,MACA,QACA,OACA,OACA,MACA,OACA,SACA,QACA,KACA,SACA,QACA,QACA,SACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,WACA,QACA,OACA,OACA,QACA,KACA,OACA,OACA,MACA,IACA,UACA,QACA,OACA,SACA,SACA,aACA,SACA,OACA,OACA,WACA,MACA,UACA,UACA,MACA,MACA,SACA,UACA,WACA,KACA,SACA,SACA,OACA,KACA,OACA,MAEAI,GACA,WACA,WACA,SACA,QACA,QACA,OACA,WACA,QACA,QACA,SACA,QACA,SACA,MACA,OACA,MACA,QAEA,IAAAV,OAyDA2H,IACAC,OAAA,IACAC,UAAA,IACAC,SAAA,WACAC,MAAA,KACAC,MAAA,KACAC,MAAA,KACAC,SAAA,KACAC,KAAA,QACAC,UAAA,QACAC,SAAA,KACAC,UAAA,KACAC,gBAAA,KACAC,YAAA,QACAC,UAAA,QAEA,QAAAC,MAAAf,KACA,SAAAe,EAAAC,GACAnT,OAAAsF,eAAA7F,GAAAyT,GACAtK,IAAA,WACA,MAAAnK,MAAA0U,OAGGD,GAAAf,GAAAe,IAGHzT,IAAA2K,SACA3K,GAAAkC,UACAlC,GAAA2T,QAAA1T,EAAA0T,QACA3T,GAAAuB,SACAqS,yBAAA,GAEA5T,GAAAyD,QAAA,SAAAjC,GAEA,OACAqB,eAAA,EACArC,OAAAgB,EAAAhB,OAAAmP,KAAAnO,KAIAxB,GAAAwL,aAAA,aACA,mBAAAqI,SAEAtT,OAAAsF,eAAA7F,GAAAwL,aAAAqI,OAAAC,aAAmErS,MAAA,SAAAkK,GACnE,MAAAA,MAAAnL,QAAAmL,aAKA3L,GAAA+T,OAAA,SAAA3L,EAAA/C,GACA,QAAA2O,KACA,MAAA5L,GAAAtI,MAAAd,KAAAgG,WAEAsF,GAAA0J,EAAA5L,EACA,IA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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"alkali\"] = factory();\n\telse\n\t\troot[\"alkali\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"alkali\"] = factory();\n\telse\n\t\troot[\"alkali\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/// <reference path=\"./typings.d.ts\" />\r\n\t(function (root, factory) { if (true) {\r\n\t  !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1), __webpack_require__(3), __webpack_require__(5), __webpack_require__(7), __webpack_require__(6), __webpack_require__(4)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) } else if (typeof module === 'object' && module.exports) {        \r\n\t  module.exports = factory(require('./Element'), require('./Renderer'), require('./react'), require('./Copy'), require('./operators'), require('./Variable')) // Node\r\n\t}}(this, function (Element, Renderer, react, Copy, operators, Variable) {\r\n\t\r\n\t\tvar main = Object.create(Element)\r\n\t\tmain.Copy = Copy\r\n\t\tmain.Element = Element\r\n\t\tmain.Variable = Variable\r\n\t\tmain.VMap = Variable.VMap\r\n\t\tmain.VArray = Variable.VArray\r\n\t\tmain.VPromised = Variable.VPromised\r\n\t\tmain.all = Variable.all\r\n\t\tmain.Transform = Variable.Call\r\n\t\tmain.Caching = Variable.Caching\r\n\t\tmain.react = react\r\n\t\tmain.spawn = function(func) {\r\n\t\t\treturn react(func).valueOf()\r\n\t\t}\r\n\t\tmain.Renderer = Renderer.ElementRenderer\r\n\t\tObject.assign(main, Renderer)\r\n\t\tObject.assign(main, operators)\r\n\t\treturn main\r\n\t}))\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) { if (true) {\r\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(3), __webpack_require__(4)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) } else if (typeof module === 'object' && module.exports) {        \r\n\t  module.exports = factory(require('./util/lang'), require('./Renderer'), require('./Variable')) // Node\r\n\t}}(this, function (lang, Renderer, Variable) {\r\n\t\tvar knownElementProperties = [\r\n\t\t\t'textContent', // Node\r\n\t\t\t'id', 'className', 'innerHTML', // Element\r\n\t\t\t'title', 'lang', 'translate', 'dir', 'tabIndex', 'accessKey', 'draggable', 'spellcheck', 'contentEditable', 'innerText', 'webkitdropzone'] // HTMLElement\r\n\t\r\n\t\tvar SELECTOR_REGEX = /^(\\.|#)([-\\w]+)(.+)?/\r\n\t\tvar isGenerator = lang.isGenerator\r\n\t\tvar Context = Variable.Context\r\n\t\tvar PropertyRenderer = Renderer.PropertyRenderer\r\n\t\tvar InputPropertyRenderer = Renderer.InputPropertyRenderer\r\n\t\tvar AttributeRenderer = Renderer.AttributeRenderer\r\n\t\tvar StyleRenderer = lang.compose(Renderer.StyleRenderer, function StyleRenderer() {\r\n\t\t\tRenderer.StyleRenderer.apply(this, arguments)\r\n\t\t}, {\r\n\t\t\trenderUpdate: function(newValue, element) {\r\n\t\t\t\tvar definition = styleDefinitions[this.name]\r\n\t\t\t\tif (definition) {\r\n\t\t\t\t\tdefinition(element, newValue, this.name)\r\n\t\t\t\t} else {\r\n\t\t\t\t\telement.style[this.name] = newValue\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\tvar ClassNameRenderer = lang.compose(Renderer.ElementRenderer, function ClassNameRenderer(options) {\r\n\t\t\tthis.className = options.className\r\n\t\t\tRenderer.apply(this, arguments)\r\n\t\t}, {\r\n\t\t\trenderUpdate: function(newValue, element) {\r\n\t\t\t\tvar currentClassName = element.className\r\n\t\t\t\tvar changingClassName = this.className\r\n\t\t\t\t// remove the className (needed for addition or removal)\r\n\t\t\t\t// see http://jsperf.com/remove-class-name-algorithm/2 for some tests on this\r\n\t\t\t\tvar removed = currentClassName && (' ' + currentClassName + ' ').replace(' ' + changingClassName + ' ', ' ')\r\n\t\t\t\tif (newValue) {\r\n\t\t\t\t\t// addition, add the className\r\n\t\t\t\t\tchangingClassName = currentClassName ? (removed + changingClassName).slice(1) : changingClassName;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// we already have removed the class, just need to trim\r\n\t\t\t\t\tchangingClassName = removed.slice(1, removed.length - 1)\r\n\t\t\t\t}\r\n\t\t\t\t// only assign if it changed, this can save a lot of time\r\n\t\t\t\tif (changingClassName != currentClassName) {\r\n\t\t\t\t\telement.className = changingClassName\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\t// TODO: check for renderContent with text updater\r\n\t\tvar TextRenderer = Renderer.TextRenderer\r\n\t\tvar ListRenderer = Renderer.ListRenderer\r\n\t\r\n\t\tvar doc = typeof document !== 'undefined' ? document : {\r\n\t\t\tcreateElement: function(tag) {\r\n\t\t\t\treturn {}\r\n\t\t\t},\r\n\t\t\taddEventListener: function() {\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tvar inputs = {\r\n\t\t\tINPUT: 1,\r\n\t\t\tTEXTAREA: 1\r\n\t\t\t// SELECT: 1, we exclude this, so the default \"content\" of the element can be the options\r\n\t\t}\r\n\t\r\n\t\tfunction booleanStyle(options) {\r\n\t\t\treturn function(element, value, key) {\r\n\t\t\t\tif (typeof value === 'boolean') {\r\n\t\t\t\t\t// has a boolean conversion\r\n\t\t\t\t\tvalue = options[value ? 0 : 1]\r\n\t\t\t\t}\r\n\t\t\t\telement.style[key] = value\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction defaultStyle(element, value, key) {\r\n\t\t\tif (typeof value === 'number') {\r\n\t\t\t\tvalue = value + 'px'\r\n\t\t\t}\r\n\t\t\telement.style[key] = value\r\n\t\t}\r\n\t\tfunction directStyle(element, value, key) {\r\n\t\t\telement.style[key] = value\r\n\t\t}\r\n\t\r\n\t\tvar styleDefinitions = {\r\n\t\t\tdisplay: booleanStyle(['', 'none']),\r\n\t\t\tvisibility: booleanStyle(['visible', 'hidden']),\r\n\t\t\tcolor: directStyle,\r\n\t\t\topacity: directStyle,\r\n\t\t\tzoom: directStyle,\r\n\t\t\tminZoom: directStyle,\r\n\t\t\tmaxZoom: directStyle,\r\n\t\t\tfontWeight: directStyle,\r\n\t\t\tposition: booleanStyle(['absolute', '']),\r\n\t\t\ttextDecoration: booleanStyle(['underline', '']),\r\n\t\t\tfontWeight: booleanStyle(['bold', 'normal'])\r\n\t\t}\r\n\t\t;[\"alignContent\",\"alignItems\",\"alignSelf\",\"animation\",\"animationDelay\",\"animationDirection\",\"animationDuration\",\"animationFillMode\",\"animationIterationCount\",\"animationName\",\"animationPlayState\",\"animationTimingFunction\",\"backfaceVisibility\",\"background\",\"backgroundAttachment\",\"backgroundBlendMode\",\"backgroundClip\",\"backgroundColor\",\"backgroundImage\",\"backgroundOrigin\",\"backgroundPosition\",\"backgroundPositionX\",\"backgroundPositionY\",\"backgroundRepeat\",\"backgroundRepeatX\",\"backgroundRepeatY\",\"backgroundSize\",\"baselineShift\",\"border\",\"borderBottom\",\"borderBottomColor\",\"borderBottomLeftRadius\",\"borderBottomRightRadius\",\"borderBottomStyle\",\"borderBottomWidth\",\"borderCollapse\",\"borderColor\",\"borderImage\",\"borderImageOutset\",\"borderImageRepeat\",\"borderImageSlice\",\"borderImageSource\",\"borderImageWidth\",\"borderLeft\",\"borderLeftColor\",\"borderLeftStyle\",\"borderLeftWidth\",\"borderRadius\",\"borderRight\",\"borderRightColor\",\"borderRightStyle\",\"borderRightWidth\",\"borderSpacing\",\"borderStyle\",\"borderTop\",\"borderTopColor\",\"borderTopLeftRadius\",\"borderTopRightRadius\",\"borderTopStyle\",\"borderTopWidth\",\"borderWidth\",\"bottom\",\"boxShadow\",\"boxSizing\",\"bufferedRendering\",\"captionSide\",\"clear\",\"clip\",\"clipPath\",\"clipRule\",\"color\",\"colorInterpolation\",\"colorInterpolationFilters\",\"colorRendering\",\"counterIncrement\",\"counterReset\",\"cursor\",\"direction\",\"display\",\"emptyCells\",\"fill\",\"fillOpacity\",\"fillRule\",\"filter\",\"flex\",\"flexBasis\",\"flexDirection\",\"flexFlow\",\"flexGrow\",\"flexShrink\",\"flexWrap\",\"float\",\"floodColor\",\"floodOpacity\",\"font\",\"fontFamily\",\"fontFeatureSettings\",\"fontKerning\",\"fontSize\",\"fontStretch\",\"fontStyle\",\"fontVariant\",\"fontVariantLigatures\",\"fontWeight\",\"height\",\"imageRendering\",\"isolation\",\"justifyContent\",\"left\",\"letterSpacing\",\"lightingColor\",\"lineHeight\",\"listStyle\",\"listStyleImage\",\"listStylePosition\",\"listStyleType\",\"margin\",\"marginBottom\",\"marginLeft\",\"marginRight\",\"marginTop\",\"marker\",\"markerEnd\",\"markerMid\",\"markerStart\",\"mask\",\"maskType\",\"maxHeight\",\"maxWidth\",\"maxZoom\",\"minHeight\",\"minWidth\",\"minZoom\",\"mixBlendMode\",\"motion\",\"motionOffset\",\"motionPath\",\"motionRotation\",\"objectFit\",\"objectPosition\",\"opacity\",\"order\",\"orientation\",\"orphans\",\"outline\",\"outlineColor\",\"outlineOffset\",\"outlineStyle\",\"outlineWidth\",\"overflow\",\"overflowWrap\",\"overflowX\",\"overflowY\",\"padding\",\"paddingBottom\",\"paddingLeft\",\"paddingRight\",\"paddingTop\",\"page\",\"pageBreakAfter\",\"pageBreakBefore\",\"pageBreakInside\",\"paintOrder\",\"perspective\",\"perspectiveOrigin\",\"pointerEvents\",\"position\",\"quotes\",\"resize\",\"right\",\"shapeImageThreshold\",\"shapeMargin\",\"shapeOutside\",\"shapeRendering\",\"size\",\"speak\",\"src\",\"stopColor\",\"stopOpacity\",\"stroke\",\"strokeDasharray\",\"strokeDashoffset\",\"strokeLinecap\",\"strokeLinejoin\",\"strokeMiterlimit\",\"strokeOpacity\",\"strokeWidth\",\"tabSize\",\"tableLayout\",\"textAlign\",\"textAlignLast\",\"textAnchor\",\"textCombineUpright\",\"textDecoration\",\"textIndent\",\"textOrientation\",\"textOverflow\",\"textRendering\",\"textShadow\",\"textTransform\",\"top\",\"touchAction\",\"transform\",\"transformOrigin\",\"transformStyle\",\"transition\",\"transitionDelay\",\"transitionDuration\",\"transitionProperty\",\"transitionTimingFunction\",\"unicodeBidi\",\"unicodeRange\",\"userZoom\",\"vectorEffect\",\"verticalAlign\",\"visibility\",\"whiteSpace\",\"widows\",\"width\",\"willChange\",\"wordBreak\",\"wordSpacing\",\"wordWrap\",\"writingMode\",\"zIndex\",\"zoom\"].forEach(function(property) {\r\n\t\t\tstyleDefinitions[property] = styleDefinitions[property] || defaultStyle\r\n\t\t})\r\n\t\tvar styleSheet\r\n\t\tvar presumptiveParentMap = new WeakMap()\r\n\t\r\n\t\tvar setPrototypeOf = Object.setPrototypeOf || (function(base, proto) { base.__proto__ = proto})\r\n\t\tvar getPrototypeOf = Object.getPrototypeOf || (function(base) { return base.__proto__ })\r\n\t\tfunction createCssRule(selector) {\r\n\t\t\tif (!styleSheet) {\r\n\t\t\t\tvar styleSheetElement = doc.createElement(\"style\")\r\n\t\t\t\tstyleSheetElement.setAttribute(\"type\", \"text/css\")\r\n\t//\t\t\tstyleSheet.appendChild(doc.createTextNode(css))\r\n\t\t\t\tdoc.head.insertBefore(styleSheetElement, doc.head.firstChild)\r\n\t\t\t\tstyleSheet = styleSheetElement.sheet\r\n\t\t\t}\r\n\t\t\tvar cssRules = styleSheet.cssRules || styleSheet.rules\r\n\t\t\treturn cssRules[styleSheet.addRule(selector, ' ', cssRules.length)]\r\n\t\t}\r\n\t\r\n\t\t// TODO: Need to do some more testing to see if that would improve performance:\r\n\t\t// var fragmentThresholdHeuristic = (typeof navigator !== 'undefined' && navigator.userAgent.indexOf('Chrome') > 0) ? 1 : 3\r\n\t\r\n\t\tfunction layoutChildren(parent, children, container, prepend) {\r\n\t\t\tvar fragment = (children.length > 1 || prepend) ? doc.createDocumentFragment() : parent\r\n\t\t\tfor(var i = 0, l = children.length; i < l; i++) {\r\n\t\t\t\tvar child = children[i]\r\n\t\t\t\tvar childNode\r\n\t\t\t\tif (child != null) { // we just skip nulls and undefined, helps make it easier to write conditional element logic\r\n\t\t\t\t\tif (child.create) {\r\n\t\t\t\t\t\t// an element constructor\r\n\t\t\t\t\t\tcurrentParent = parent\r\n\t\t\t\t\t\tchildNode = child.create()\r\n\t\t\t\t\t\tfragment.appendChild(childNode)\r\n\t\t\t\t\t\tif (child.isContentNode) {\r\n\t\t\t\t\t\t\tcontainer.contentNode = childNode\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (child.notifies) {\r\n\t\t\t\t\t\t// a variable\r\n\t\t\t\t\t\tvar ref = child.isIterable ? fragment : parent\r\n\t\t\t\t\t\tfragment.appendChild(childNode = variableAsContent(ref, child))\r\n\t\t\t\t\t} else if (typeof child == 'object') {\r\n\t\t\t\t\t\tif (child instanceof Array) {\r\n\t\t\t\t\t\t\t// array of sub-children\r\n\t\t\t\t\t\t\tcontainer = container || parent\r\n\t\t\t\t\t\t\tchildNode = childNode || parent\r\n\t\t\t\t\t\t\tlayoutChildren(childNode.contentNode || childNode, child, container)\r\n\t\t\t\t\t\t} else if (child.nodeType) {\r\n\t\t\t\t\t\t\t// an element itself\r\n\t\t\t\t\t\t\tfragment.appendChild(childNode = child)\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// TODO: apply properties to last child, but with binding to the parent (for events)\r\n\t\t\t\t\t\t\tthrow new Error('Unknown child type ' + child)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// a primitive value\r\n\t\t\t\t\t\tchildNode = doc.createTextNode(child)\r\n\t\t\t\t\t\tfragment.appendChild(childNode)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (fragment != parent) {\r\n\t\t\t\tif (prepend) {\r\n\t\t\t\t\tparent.insertBefore(fragment, parent.firstChild)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tparent.appendChild(fragment)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn childNode\r\n\t\t}\r\n\t\tfunction variableAsContent(parent, content) {\r\n\t\t\tif (content == null) {\r\n\t\t\t\treturn doc.createTextNode('')\r\n\t\t\t}\r\n\t\t\tvar textNode\r\n\t\t\tif (content.notifies) {\r\n\t\t\t\ttextNode = doc.createTextNode('')\r\n\t\t\t\tnew TextRenderer({\r\n\t\t\t\t\telement: parent,\r\n\t\t\t\t\ttextNode: textNode,\r\n\t\t\t\t\tvariable: content\r\n\t\t\t\t})\r\n\t\t\t} else {\r\n\t\t\t\ttextNode = doc.createTextNode(content)\r\n\t\t\t}\r\n\t\t\treturn textNode\r\n\t\t}\r\n\t\r\n\t\tfunction bidirectionalHandler(element, value, key) {\r\n\t\t\tif (value && value.notifies) {\r\n\t\t\t\tnew InputPropertyRenderer({\r\n\t\t\t\t\tname: key,\r\n\t\t\t\t\tvariable: value,\r\n\t\t\t\t\telement: element\r\n\t\t\t\t})\r\n\t\t\t\tif (inputs[element.tagName] || element.tagName === 'SELECT') {\r\n\t\t\t\t\tbindChanges(element, value, key)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (element.tagName === 'SELECT' && key === 'value') {\r\n\t\t\t\t\t// use the deferred <select> value assignment\r\n\t\t\t\t\tInputPropertyRenderer.prototype.renderSelectValueUpdate(value, element)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (element.type === 'number') {\r\n\t\t\t\t\t\tif (isNaN(value)) {\r\n\t\t\t\t\t\t\tvalue = ''\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telement[key] = value\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction noop() {}\r\n\t\tvar propertyHandlers = {\r\n\t\t\tchildren: noop,\r\n\t\t\ttagName: noop,\r\n\t\t\tclasses: function(element, classes) {\r\n\t\t\t\tif (!(classes.length > -1)) {\r\n\t\t\t\t\t// index the classes, if necessary\r\n\t\t\t\t\tvar i = 0\r\n\t\t\t\t\tfor (var key in classes) {\r\n\t\t\t\t\t\tif (!classes[i]) {\r\n\t\t\t\t\t\t\tclasses[i] = key\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ti++\r\n\t\t\t\t\t}\r\n\t\t\t\t\tclasses.length = i\r\n\t\t\t\t}\r\n\t\t\t\tfor (var i = 0, l = classes.length; i < l; i++) {\r\n\t\t\t\t\t// find each class name\r\n\t\t\t\t\tvar className = classes[i]\r\n\t\t\t\t\tvar flag = classes[className]\r\n\t\t\t\t\tif (flag && flag.notifies) {\r\n\t\t\t\t\t\t// if it is a variable, we react to it\r\n\t\t\t\t\t\tnew ClassNameRenderer({\r\n\t\t\t\t\t\t\telement: element,\r\n\t\t\t\t\t\t\tclassName: className,\r\n\t\t\t\t\t\t\tvariable: flag\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t} else if (flag || flag === undefined) {\r\n\t\t\t\t\t\telement.className += ' ' + className\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tclass: applyAttribute,\r\n\t\t\tfor: applyAttribute, // TODO: move to label?\r\n\t\t\trole: applyAttribute,\r\n\t\t\trender: function(element, value, key, properties) {\r\n\t\t\t\t// TODO: This doesn't need to be a property updater (is in place for *render())\r\n\t\t\t\t// we should also verify it is a generator\r\n\t\t\t\t// and maybe, at some point, find an optimization to eliminate the bind()\r\n\t\t\t\tnew PropertyRenderer({\r\n\t\t\t\t\tname: key,\r\n\t\t\t\t\tvariable: new Variable.GeneratorVariable(value.bind(element, properties)),\r\n\t\t\t\t\telement: element\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tdataset: applySubProperties(function(newValue, element, key) {\r\n\t\t\t\telement.dataset[key || this.name] = newValue\r\n\t\t\t}),\r\n\t\t\tattributes: applySubProperties(function(newValue, element, key) {\r\n\t\t\t\telement.setAttribute(key || this.name, newValue)\r\n\t\t\t}),\r\n\t\t\tstyle: function(element, value, key) {\r\n\t\t\t\tif (typeof value === 'string') {\r\n\t\t\t\t\telement.setAttribute('style', value)\r\n\t\t\t\t} else if (value && value.notifies) {\r\n\t\t\t\t\tnew AttributeRenderer({\r\n\t\t\t\t\t\tname: 'style',\r\n\t\t\t\t\t\tvariable: value,\r\n\t\t\t\t\t\telement: element\r\n\t\t\t\t\t})\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstyleObjectHandler(element, value, key)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tknownElementProperties.forEach(function(property) {\r\n\t\t\tpropertyHandlers[property] = true\r\n\t\t})\r\n\t\tif (typeof HTMLElement !== 'undefined') {\r\n\t\t\tHTMLElement.prototype._propertyHandlers = propertyHandlers // inherit this, at least for now\r\n\t\t}\r\n\t\tvar elementPropertyHandlers = {\r\n\t\t\tinput: lang.copy(['accept', 'alt', 'autocomplete', 'autofocus', 'capture', 'defaultChecked', 'dirName', 'disabled', 'form', 'files', 'formAction', 'formEnctype', 'formMethod', 'formNoValidate', 'formTarget', 'indeterminate', 'inputMode', 'list', 'max', 'maxLength', 'min', 'minLength', 'multiple', 'name', 'pattern', 'placeholder', 'readOnly', 'required', 'size', 'src', 'step', 'type', 'defaultValue', 'willValidate', 'validity', 'validationMessage', 'useMap', 'autocapitalize', 'webkitdirectory', 'incremental', 'stepUp', 'stepDown'], {\r\n\t\t\t\tvalue: bidirectionalHandler,\r\n\t\t\t\tvalueAsNumber: bidirectionalHandler,\r\n\t\t\t\tvalueAsDate: bidirectionalHandler,\r\n\t\t\t\tchecked: bidirectionalHandler,\r\n\t\t\t\ttype: function(element, value) {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\telement.type = value\r\n\t\t\t\t\t} catch(e) {\r\n\t\t\t\t\t\t// IE 11 will throw an error here\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}),\r\n\t\t\tselect: lang.copy(['name', 'size', 'type', 'selectedIndex', 'validationMessage'], {\r\n\t\t\t\tvalue: bidirectionalHandler\r\n\t\t\t}),\r\n\t\t\ttextarea: lang.copy(['cols', 'dirName', 'maxLength', 'minLength', 'name', 'placeholder', 'rows', 'wrap', 'type', 'defaultValue', 'textLength', 'validationMessage', 'autocapitalize'], {\r\n\t\t\t\tvalue: bidirectionalHandler\r\n\t\t\t}),\r\n\t\t\ta: ['target', 'download', 'ping', 'rel', 'hreflang', 'type', 'referrerPolicy', 'href', 'media'],\r\n\t\t\tarea: ['target', 'download', 'coords', 'rel', 'hreflang', 'type', 'referrerPolicy', 'href', 'media', 'alt', 'shape'],\r\n\t\t\tbutton: ['formAction', 'formEnctype', 'formMethod', 'formTarget', 'name', 'type', 'value', 'validationMessage'],\r\n\t\t\tdialog: ['open'],\r\n\t\t\tembed: ['src', 'type', 'name'],\r\n\t\t\tform: ['acceptCharset', 'action', 'autocomplete', 'enctype', 'encoding', 'method', 'name', 'target', 'novalidate'],\r\n\t\t\tframe: ['name', 'scrolling', 'src', 'frameBorder'],\r\n\t\t\tframeset: ['cols', 'rows'],\r\n\t    iframe: ['src', 'srcdoc', 'name', 'referrerPolicy', 'align', 'scrolling', 'frameBorder', 'longDesc'],\r\n\t    option: ['label', 'value', 'text', 'index'],\r\n\t    optgroup: ['label'],\r\n\t    output: ['name', 'type', 'defaultValue', 'value', 'validationMessage'],\r\n\t    label: ['htmlFor'],\r\n\t    td: ['colSpan', 'rowSpan'],\r\n\t    th: ['colSpan', 'rowSpan'],\r\n\t    script: ['src', 'type', 'charset', 'text', 'event', 'htmlFor', 'integrity'],\r\n\t    style: ['media', 'type'],\r\n\t    track: ['kind', 'src', 'srclang', 'label'],\r\n\t    link: ['href', 'rel', 'media', 'hreflang', 'type', 'charset', 'rev', 'target', 'integrity', 'as'],\r\n\t    meta: ['name', 'httpEquiv', 'content', 'scheme'],\r\n\t    meter: ['value', 'min', 'max', 'low', 'high', 'optimum'],\r\n\t    progress: ['value', 'max', 'position'],\r\n\t    del: ['cite', 'dateTime'],\r\n\t    ins: ['cite', 'dateTime'],\r\n\t    source: ['src', 'type', 'srcset', 'sizes', 'media'],\r\n\t    video: ['videoWidth', 'videoHeight', 'poster', 'webkitDecodedFrameCount', 'webkitDroppedFrameCount'],\r\n\t    keygen: ['challenge', 'keytype', 'name', 'type', 'validationMessage'],\r\n\t    object: ['data', 'type', 'name', 'useMap', 'validationMessage', 'archive', 'code', 'hspace', 'standby', 'vspace', 'codeBase', 'codeType'],\r\n\t    param: ['name', 'value', 'type', 'valueType']\r\n\t\t}\r\n\t\r\n\t\tfunction applyAttribute(element, value, key) {\r\n\t\t\tif (value && value.notifies) {\r\n\t\t\t\tnew AttributeRenderer({\r\n\t\t\t\t\tname: key,\r\n\t\t\t\t\tvariable: value,\r\n\t\t\t\t\telement: element\r\n\t\t\t\t})\r\n\t\t\t} else {\r\n\t\t\t\telement.setAttribute(key, value)\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tvar styleObjectHandler = applySubProperties(function(newValue, element, key) {\r\n\t\t\telement.style[key || this.name] = newValue\r\n\t\t})\r\n\t\r\n\t\tfunction applySubProperties(renderer) {\r\n\t\t\tvar SubPropertyRenderer = lang.compose(PropertyRenderer, function SubPropertyRenderer(options) {\r\n\t\t\t\tPropertyRenderer.apply(this, arguments)\r\n\t\t\t}, {\r\n\t\t\t\trenderUpdate: renderer\r\n\t\t\t})\r\n\t\t\treturn function(element, value, key) {\r\n\t\t\t\tfor (var subKey in value) {\r\n\t\t\t\t\tvar subValue = value[subKey]\r\n\t\t\t\t\tif (subValue && subValue.notifies) {\r\n\t\t\t\t\t\tnew SubPropertyRenderer({\r\n\t\t\t\t\t\t\tname: subKey,\r\n\t\t\t\t\t\t\tvariable: subValue,\r\n\t\t\t\t\t\t\telement: element\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\trenderer(subValue, element, subKey)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction assignProperties(element, properties) {\r\n\t\t\tfor (var key in properties) {\r\n\t\t\t\tvar value = properties[key]\r\n\t\t\t\tvar styleDefinition\r\n\t\t\t\tvar propertyHandler = element._propertyHandlers[key]\r\n\t\t\t\tif (propertyHandler) {\r\n\t\t\t\t\tif (propertyHandler === true) {\r\n\t\t\t\t\t\t// a standard, known element property\r\n\t\t\t\t\t\tif (value && value.notifies) {\r\n\t\t\t\t\t\t\tnew PropertyRenderer({\r\n\t\t\t\t\t\t\t\tname: key,\r\n\t\t\t\t\t\t\t\tvariable: value,\r\n\t\t\t\t\t\t\t\telement: element\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\telement[key] = value\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tpropertyHandler(element, value, key, properties)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if ((styleDefinition = styleDefinitions[key])) {\r\n\t\t\t\t\tif (value && value.notifies) {\r\n\t\t\t\t\t\tnew StyleRenderer({\r\n\t\t\t\t\t\t\tname: key,\r\n\t\t\t\t\t\t\tvariable: value,\r\n\t\t\t\t\t\t\telement: element\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tstyleDefinition(element, value, key)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (element[key] == null) {\r\n\t\t\t\t\t// we are working an unknown/unstandard property (or an event listener)\r\n\t\t\t\t\t// undefined or null means we can safely set\r\n\t\t\t\t\t// TODO: we may want to do the event listener check first so we can handle oncustomevent (that needs an addEventListener call to work)\r\n\t\t\t\t\telement[key] = value\r\n\t\t\t\t} else if (typeof value === 'function' && key.slice(0, 2) === 'on') {\r\n\t\t\t\t\t// event listener with one already defined on the prototype\r\n\t\t\t\t\telement.addEventListener(key.slice(2), value)\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// otherwise bypass/override the native getter/setter\r\n\t\t\t\t\tObject.defineProperty(element, key, {\r\n\t\t\t\t\t\tvalue: value,\r\n\t\t\t\t\t\tenumerable: true,\r\n\t\t\t\t\t\tconfigurable: true,\r\n\t\t\t\t\t\twritable: true\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction buildContent(element, content, key, properties) {\r\n\t\t\tvar each = element.each || properties.each\r\n\t\t\tif (each && content) {\r\n\t\t\t\t// render as list\r\n\t\t\t\tif (each.create) {\r\n\t\t\t\t\teach.defineHasOwn = function () {\r\n\t\t\t\t\t\tvar ItemClass = content.getCollectionOf && content.getCollectionOf() || Item\r\n\t\t\t\t\t\thasOwn(each, ItemClass, function (element) {\r\n\t\t\t\t\t\t\tvar itemVariable = ItemClass.from(element._item)\r\n\t\t\t\t\t\t\treturn itemVariable\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (content.notifies) {\r\n\t\t\t\t\tnew ListRenderer({\r\n\t\t\t\t\t\teach: each,\r\n\t\t\t\t\t\tvariable: content,\r\n\t\t\t\t\t\telement: element\r\n\t\t\t\t\t})\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar fragment = doc.createDocumentFragment()\r\n\t\t\t\t\tif (each.defineHasOwn) {\r\n\t\t\t\t\t\teach.defineHasOwn()\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcontent.forEach(function(item) {\r\n\t\t\t\t\t\tif (each.create) {\r\n\t\t\t\t\t\t\tchildElement = each.create({parent: element, _item: item}) // TODO: make a faster object here potentially\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tchildElement = each(item, element)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfragment.appendChild(childElement)\r\n\t\t\t\t\t})\r\n\t\t\t\t\telement.appendChild(fragment)\r\n\t\t\t\t}\r\n\t\t\t} else if (inputs[element.tagName]) {\r\n\t\t\t\t// render into input\r\n\t\t\t\tbuildInputContent(element, content)\r\n\t\t\t} else if (content instanceof Array) {\r\n\t\t\t\t// treat array as children (potentially of the content node)\r\n\t\t\t\telement = element.contentNode || element\r\n\t\t\t\tlayoutChildren(element, content, element)\r\n\t\t\t} else {\r\n\t\t\t\t// render as string\r\n\t\t\t\telement.appendChild(variableAsContent(element, content))\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction bindChanges(element, variable, key, conversion) {\r\n\t\t\tlang.nextTurn(function() { // wait for next turn in case inputChanges isn't set yet\r\n\t\t\t\tvar inputEvents = element.inputEvents || ['change', 'alkali-change']\r\n\t\t\t\tfor (var i = 0, l = inputEvents.length; i < l; i++) {\r\n\t\t\t\t\telement.addEventListener(inputEvents[i], function (event) {\r\n\t\t\t\t\t\tvar value = element[key]\r\n\t\t\t\t\t\tvar result = variable.put(conversion ? conversion(value, element) : value, new Context(element))\r\n\t\t\t\t\t\tif (result === Variable.deny) {\r\n\t\t\t\t\t\t\tthrow new Error('Variable change denied')\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t}\r\n\t\r\n\t\tdoc.addEventListener('click', function(event) {\r\n\t\t\tvar target = event.target\r\n\t\t\tif (target.type === 'radio') {\r\n\t\t\t\tvar radios = doc.querySelectorAll('input[type=radio]')\r\n\t\t\t\tfor (var i = 0, l = radios.length; i < l; i++) {\r\n\t\t\t\t\tvar radio = radios[i]\r\n\t\t\t\t\tif (radio.name === target.name && radio !== target) {\r\n\t\t\t\t\t\tradio.dispatchEvent(new Event('alkali-change', {}))\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\tfunction conversion(value, element) {\r\n\t\t\tif (element.type == 'number') {\r\n\t\t\t\treturn parseFloat(value)\r\n\t\t\t}\r\n\t\t\treturn value\r\n\t\t}\r\n\t\r\n\t\tfunction buildInputContent(element, content) {\r\n\t\t\tvar inputType = element.type\r\n\t\t\tvar inputProperty = inputType in {date: 1, datetime: 1, time: 1} ?\r\n\t\t\t\t\t'valueAsDate' : (inputType === 'checkbox' || inputType === 'radio') ?\r\n\t\t\t\t\t\t'checked' : 'value'\r\n\t\r\n\t\t\tif (content && content.notifies) {\r\n\t\t\t\t// a variable, respond to changes\r\n\t\t\t\tnew InputPropertyRenderer({\r\n\t\t\t\t\tvariable: content,\r\n\t\t\t\t\tname: inputProperty,\r\n\t\t\t\t\telement: element\r\n\t\t\t\t})\r\n\t\t\t\t// and bind the other way as well, updating the variable in response to input changes\r\n\t\t\t\tbindChanges(element, content, inputProperty, conversion)\r\n\t\t\t} else {\r\n\t\t\t\t// primitive\r\n\t\t\t\telement[inputProperty] = content\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar classHandlers = {\r\n\t\t\thasOwn: function(Element, value) {\r\n\t\t\t\thasOwn(Element, value)\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction applyToClass(value, Element) {\r\n\t\t\tvar applyOnCreate = Element._applyOnCreate\r\n\t\t\tif (value && typeof value === 'object') {\r\n\t\t\t\tif (value instanceof Array || value.notifies) {\r\n\t\t\t\t\tapplyOnCreate.content = value\r\n\t\t\t\t} else {\r\n\t\t\t\t\tfor (var key in value) {\r\n\t\t\t\t\t// TODO: eventually we want to be able to set these as rules statically per element\r\n\t\t\t\t\t/*if (styleDefinitions[key]) {\r\n\t\t\t\t\t\tvar styles = Element.styles || (Element.styles = [])\r\n\t\t\t\t\t\tstyles.push(key)\r\n\t\t\t\t\t\tstyles[key] = descriptor.value\r\n\t\t\t\t\t} else {*/\r\n\t\t\t\t\t\tif (classHandlers[key]) {\r\n\t\t\t\t\t\t\thasOwn(Element, value[key])\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// TODO: do deep merging of styles and classes, but not variables\r\n\t\t\t\t\t\t\tapplyOnCreate[key] = value[key]\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else if (typeof value === 'function' && !value.for) {\r\n\t\t\t\tthrow new TypeError('Function as argument not supported')\r\n\t\t\t} else {\r\n\t\t\t\tapplyOnCreate.content = value\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction getApplySet(Class) {\r\n\t\t\tif (Class.hasOwnProperty('_applyOnCreate')) {\r\n\t\t\t\treturn Class._applyOnCreate\r\n\t\t\t}\r\n\t\t\t// this means we didn't extend and evaluate the prototype yet\r\n\t\t\tif (Class.getForClass) {\r\n\t\t\t\t// we are extending an alkali constructor\r\n\t\t\t\t// if this class is inheriting from an alkali constructor, work our way up the chain\r\n\t\t\t\tapplyOnCreate = Class._applyOnCreate = {}\r\n\t\t\t\tvar parentApplySet = getApplySet(getPrototypeOf(Class))\r\n\t\t\t\tfor (var key in parentApplySet) {\r\n\t\t\t\t\tapplyOnCreate[key] = parentApplySet[key]\r\n\t\t\t\t}\r\n\t\t\t\t// we need to check the prototype for event handlers\r\n\t\t\t\tvar prototype = Class.prototype\r\n\t\t\t\tvar propertyHandlers\r\n\t\t\t\tvar keys = Object.getOwnPropertyNames(prototype)\r\n\t\t\t\tfor (var i = 0, l = keys.length; i < l; i++) {\r\n\t\t\t\t\tvar key = keys[i]\r\n\t\t\t\t\tif (key.slice(0, 2) === 'on' || (key === 'render' && isGenerator(prototype[key]))) {\r\n\t\t\t\t\t\tapplyOnCreate[key] = prototype[key]\r\n\t\t\t\t\t} else if (key.slice(0, 6) === 'render') {\r\n\t\t\t\t\t\tvar propertyName = key[6].toLowerCase() + key.slice(7)\r\n\t\t\t\t\t\tif (!propertyHandlers) {\r\n\t\t\t\t\t\t\tpropertyHandlers = prototype._propertyHandlers = Object.create(prototype._propertyHandlers)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tpropertyHandlers[propertyName] = true // TODO: is it better to implement this with property handlers?\r\n\t\t\t\t\t\tObject.defineProperty(prototype, propertyName, renderDescriptor(key))\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn applyOnCreate\r\n\t\t\t}\r\n\t\t\treturn null\r\n\t\t}\r\n\t\r\n\t\tfunction renderDescriptor(renderMethod) {\r\n\t\t\tvar map = new WeakMap()\r\n\t\t\treturn {\r\n\t\t\t\tget: function() {\r\n\t\t\t\t\treturn map.has(this) ? map.get(this) : null\r\n\t\t\t\t},\r\n\t\t\t\tset: function(value) {\r\n\t\t\t\t\tmap.set(this, value)\r\n\t\t\t\t\tthis[renderMethod](value)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction makeElementConstructor() {\r\n\t\t\tfunction Element(selector, properties) {\r\n\t\t\t\tif (this instanceof Element){\r\n\t\t\t\t\t// create DOM element\r\n\t\t\t\t\t// Need to detect if we have registered the element and `this` is actually already the correct instance\r\n\t\t\t\t\treturn create.apply(Element.prototype === getPrototypeOf(this) ? Element :// this means it is from this constructor\r\n\t\t\t\t\t\tthis.constructor, // this means it was constructed from a subclass\r\n\t\t\t\t\t\targuments)\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// extend to create new class\r\n\t\t\t\t\treturn withProperties.apply(Element, arguments)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tElement.create = create\r\n\t\t\tElement.with = withProperties\r\n\t\t\tElement.for = forTarget\r\n\t\t\tElement.property = propertyForElement\r\n\t\t\tElement.getForClass = getForClass\r\n\t\t\treturn Element\r\n\t\t}\r\n\t\r\n\t\tfunction withProperties(selector, properties) {\r\n\t\t\tvar Element = makeElementConstructor()\r\n\t\t\tElement.superConstructor = this\r\n\t\t\tElement.tagName = this.tagName\r\n\t\t\tif (this.children) {\r\n\t\t\t\t// just copy this property\r\n\t\t\t\tElement.children = this.children\r\n\t\t\t}\r\n\t\t\tElement.prototype = this.prototype\r\n\t\r\n\t\t\tvar applyOnCreate = Element._applyOnCreate = {}\r\n\t\t\tvar parentApplySet = getApplySet(this)\r\n\t\t\t// copy parent properties\r\n\t\t\tfor (var key in parentApplySet) {\r\n\t\t\t\tapplyOnCreate[key] = parentApplySet[key]\r\n\t\t\t}\r\n\t\r\n\t\t\tvar i = 0 // for arguments\r\n\t\t\tif (typeof selector === 'string') {\r\n\t\t\t\tvar selectorMatch = selector.match(SELECTOR_REGEX)\r\n\t\t\t\tif (selectorMatch) {\r\n\t\t\t\t\tdo {\r\n\t\t\t\t\t\tvar operator = selectorMatch[1]\r\n\t\t\t\t\t\tvar name = selectorMatch[2]\r\n\t\t\t\t\t\tif (operator == '.') {\r\n\t\t\t\t\t\t\tif (applyOnCreate.className) {\r\n\t\t\t\t\t\t\t\tapplyOnCreate.className += ' ' + name\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tapplyOnCreate.className = name\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tapplyOnCreate.id = name\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar remaining = selectorMatch[3]\r\n\t\t\t\t\t\tselectorMatch = remaining && remaining.match(SELECTOR_REGEX)\r\n\t\t\t\t\t} while (selectorMatch)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tapplyOnCreate.content = selector\r\n\t\t\t\t}\r\n\t\t\t\ti++ // skip the first argument\r\n\t\t\t}\r\n\t\r\n\t\t\tfor (var l = arguments.length; i < l; i++) {\r\n\t\t\t\tapplyToClass(arguments[i], Element)\r\n\t\t\t}\r\n\t\t\treturn Element\r\n\t\t}\r\n\t\tvar currentParent\r\n\t\tfunction create(selector, properties) {\r\n\t\t\t// TODO: make this a symbol\r\n\t\t\tvar applyOnCreate = getApplySet(this)\r\n\t\t\tif (currentParent) {\r\n\t\t\t\tvar parent = currentParent\r\n\t\t\t\tcurrentParent = null\r\n\t\t\t}\r\n\t/*\t\tif (this._initialized != this) {\r\n\t\t\t\tthis._initialized = this\r\n\t\t\t\tthis.initialize && this.initialize()\r\n\t\t\t\tvar styles = this.styles\r\n\t\t\t\tif (styles) {\r\n\t\t\t\t\tvar rule = createCssRule(getUniqueSelector(this))\r\n\t\t\t\t\tfor (var i = 0, l = styles.length; i < l; i++) {\r\n\t\t\t\t\t\tvar key = styles[i]\r\n\t\t\t\t\t\tvar value = styles[key]\r\n\t\t\t\t\t\t// TODO: if it is a contextualized variable, do this on the element\r\n\t\t\t\t\t\tvar styleDefinition = styleDefinitions[key]\r\n\t\t\t\t\t\tif (styleDefinition) {\r\n\t\t\t\t\t\t\tstyleDefinition(rule, value, key)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (!this.hasOwnProperty('_applyOnCreate')) {\r\n\t\t\t\t\tapplyOnCreate = getApplySet(this)\r\n\t\t\t\t}\r\n\t\t\t}*/\r\n\t\t\tvar element = doc.createElement(this.tagName)\r\n\t\t\tif (selector && selector.parent) {\r\n\t\t\t\tparent = selector.parent\r\n\t\t\t}\r\n\t\t\tif (parent) {\r\n\t\t\t\tpresumptiveParentMap.set(element, parent)\r\n\t\t\t}\r\n\t\t\tif (!(element instanceof this)) {\r\n\t\t\t\t// ideally we want to avoid this call, as it is expensive, but for classes that\r\n\t\t\t\t// don't register a tag name, we have to make sure the prototype chain is correct\r\n\t\t\t\tsetPrototypeOf(element, this.prototype)\r\n\t\t\t}\r\n\t\t\tif (element.constructor != this) {\r\n\t\t\t\telement.constructor = this // need to do this for hasOwn contextualization to work\r\n\t\t\t}\r\n\t\t\tif (arguments.length > 0) {\r\n\t\t\t\t// copy applyOnCreate when we have arguments\r\n\t\t\t\tvar ElementApplyOnCreate = applyOnCreate\r\n\t\t\t\tapplyOnCreate = {}\r\n\t\t\t\tfor (var key in ElementApplyOnCreate) {\r\n\t\t\t\t\tapplyOnCreate[key] = ElementApplyOnCreate[key]\r\n\t\t\t\t}\r\n\t\t\t\tvar i = 0\r\n\t\t\t\tif (typeof selector == 'string') {\r\n\t\t\t\t\ti++\r\n\t\t\t\t\tvar selectorMatch = selector.match(SELECTOR_REGEX)\r\n\t\t\t\t\tif (selectorMatch) {\r\n\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\tvar operator = selectorMatch[1]\r\n\t\t\t\t\t\t\tvar name = selectorMatch[2]\r\n\t\t\t\t\t\t\tif (operator == '.') {\r\n\t\t\t\t\t\t\t\tif (applyOnCreate.className) {\r\n\t\t\t\t\t\t\t\t\tapplyOnCreate.className += ' ' + name\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tif (element.className) {\r\n\t\t\t\t\t\t\t\t\t\t\telement.className += ' ' + name\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\telement.className = name\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tif (applyOnCreate.id) {\r\n\t\t\t\t\t\t\t\t\tapplyOnCreate.id = name\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t// just skip right to the element\r\n\t\t\t\t\t\t\t\t\telement.id = name\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tvar remaining = selectorMatch[3]\r\n\t\t\t\t\t\t\tselectorMatch = remaining && remaining.match(SELECTOR_REGEX)\r\n\t\t\t\t\t\t} while (selectorMatch)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tapplyOnCreate.content = selector\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (selector && selector._item) {\r\n\t\t\t\t\t// this is kind of hack, to get the Item available before the properties, eventually we may want to\r\n\t\t\t\t\t// order static properties before variable binding applications, but for now.\r\n\t\t\t\t\telement._item = selector._item\r\n\t\t\t\t}\r\n\t\t\t\tfor (var l = arguments.length; i < l; i++) {\r\n\t\t\t\t\tvar argument = arguments[i]\r\n\t\t\t\t\tif (argument && typeof argument === 'object') {\r\n\t\t\t\t\t\tif (argument instanceof Array || argument.notifies) {\r\n\t\t\t\t\t\t\tapplyOnCreate.content = argument\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tfor (var key in argument) {\r\n\t\t\t\t\t\t\t\t// TODO: do deep merging of styles and classes, but not variables\r\n\t\t\t\t\t\t\t\tapplyOnCreate[key] = argument[key]\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (typeof argument === 'function' && argument.for) {\r\n\t\t\t\t\t\tapplyOnCreate.content = argument.for(element)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tapplyOnCreate.content = argument\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (element.created) {\r\n\t\t\t\tapplyOnCreate = element.created(applyOnCreate) || applyOnCreate\r\n\t\t\t} else if (applyOnCreate.created) {\r\n\t\t\t\tapplyOnCreate = applyOnCreate.created.call(element, applyOnCreate) || applyOnCreate\r\n\t\t\t}\r\n\t\t\t// TODO: inline this for better performance, possibly\r\n\t\t\tassignProperties(element, applyOnCreate)\r\n\t\t\tif (this.children) {\r\n\t\t\t\tlayoutChildren(element, this.children, element)\r\n\t\t\t}\r\n\t\t\t// always do this last, so it can be properly inserted inside the children\r\n\t\t\tif (applyOnCreate.content) {\r\n\t\t\t\tbuildContent(element, applyOnCreate.content, 'content', applyOnCreate)\r\n\t\t\t}\r\n\t\t\telement.ready && element.ready(applyOnCreate)\r\n\t\t\treturn element\r\n\t\t}\r\n\t\r\n\t\tvar slice = [].slice\r\n\t\tfunction append(parent){\r\n\t\t\treturn this.nodeType ?\r\n\t\t\t\tlayoutChildren(this, arguments, this) : // called as a method\r\n\t\t\t\tlayoutChildren(parent, slice.call(arguments, 1), parent) // called as a function\r\n\t\t}\r\n\t\r\n\t\tfunction prepend(parent){\r\n\t\t\treturn this.nodeType ?\r\n\t\t\t\tlayoutChildren(this, arguments, this, true) : // called as a method\r\n\t\t\t\tlayoutChildren(parent, slice.call(arguments, 1), parent, true) // called as a function\r\n\t\t}\r\n\t\r\n\t\tfunction registerTag(tagName) {\r\n\t\t\tthis.tagName = tagName\r\n\t\t\tif (doc.registerElement && this.prototype.constructor === this) {\r\n\t\t\t\tdoc.registerElement(tagName, this)\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tvar Element = withProperties.call(typeof HTMLElement !== 'undefined' ? HTMLElement : function() {})\r\n\t\r\n\t\tElement.registerTag = registerTag\r\n\t\tElement.assign = function(target, properties) {\r\n\t\t\tif (typeof target === 'function') {\r\n\t\t\t\t// assign properties to an existing constructor/class\r\n\t\t\t\tgetApplySet(target) // make sure we have our own applyOnCreate first\r\n\t\t\t\tapplyToClass(properties, target)\r\n\t\t\t} else {\r\n\t\t\t\t// assign to an element\r\n\t\t\t\t// TODO: Handle content property separately\r\n\t\t\t\treturn assignProperties(target, properties)\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tElement.within = function(element){\r\n\t\t\t// find closest child\r\n\t\t}\r\n\t\r\n\t\tgenerate([\r\n\t\t\t'Video',\r\n\t\t\t'Source',\r\n\t\t\t'Media',\r\n\t\t\t'Audio',\r\n\t\t\t'UL',\r\n\t\t\t'U',\r\n\t\t\t'Track',\r\n\t\t\t'Title',\r\n\t\t\t'TextArea',\r\n\t\t\t'Template',\r\n\t\t\t'TBody',\r\n\t\t\t'THead',\r\n\t\t\t'TFoot',\r\n\t\t\t'TR',\r\n\t\t\t'Table',\r\n\t\t\t'Col',\r\n\t\t\t'ColGroup',\r\n\t\t\t'TH',\r\n\t\t\t'TD',\r\n\t\t\t'Caption',\r\n\t\t\t'Sup',\r\n\t\t\t'Sub',\r\n\t\t\t'Style',\r\n\t\t\t'Strong',\r\n\t\t\t'Span',\r\n\t\t\t'Small',\r\n\t\t\t'Shadow',\r\n\t\t\t'Select',\r\n\t\t\t'Script',\r\n\t\t\t'S',\r\n\t\t\t'Quote',\r\n\t\t\t'Progress',\r\n\t\t\t'Pre',\r\n\t\t\t'Picture',\r\n\t\t\t'Param',\r\n\t\t\t'P',\r\n\t\t\t'Output',\r\n\t\t\t'Option',\r\n\t\t\t'Optgroup',\r\n\t\t\t'Object',\r\n\t\t\t'OL',\r\n\t\t\t'Ins',\r\n\t\t\t'I',\r\n\t\t\t'Del',\r\n\t\t\t'Meter',\r\n\t\t\t'Meta',\r\n\t\t\t'Menu',\r\n\t\t\t'Map',\r\n\t\t\t'Link',\r\n\t\t\t'Legend',\r\n\t\t\t'Label',\r\n\t\t\t'LI',\r\n\t\t\t'KeyGen',\r\n\t\t\t'Input',\r\n\t\t\t'Image',\r\n\t\t\t'IFrame',\r\n\t\t\t'H1',\r\n\t\t\t'H2',\r\n\t\t\t'H3',\r\n\t\t\t'H4',\r\n\t\t\t'H5',\r\n\t\t\t'H6',\r\n\t\t\t'Hr',\r\n\t\t\t'FrameSet',\r\n\t\t\t'Frame',\r\n\t\t\t'Form',\r\n\t\t\t'Font',\r\n\t\t\t'Embed',\r\n\t\t\t'Em',\r\n\t\t\t'Code',\r\n\t\t\t'Cite',\r\n\t\t\t'Dfn',\r\n\t\t\t'B',\r\n\t\t\t'Article',\r\n\t\t\t'Aside',\r\n\t\t\t'Abbr',\r\n\t\t\t'Footer',\r\n\t\t\t'Figure',\r\n\t\t\t'FigCaption',\r\n\t\t\t'Header',\r\n\t\t\t'Main',\r\n\t\t\t'Mark',\r\n\t\t\t'MenuItem',\r\n\t\t\t'Nav',\r\n\t\t\t'Section',\r\n\t\t\t'Summary',\r\n\t\t\t'WBr',\r\n\t\t\t'Div',\r\n\t\t\t'Dialog',\r\n\t\t\t'Details',\r\n\t\t\t'DataList',\r\n\t\t\t'DL',\r\n\t\t\t'Canvas',\r\n\t\t\t'Button',\r\n\t\t\t'Base',\r\n\t\t\t'Br',\r\n\t\t\t'Area',\r\n\t\t\t'A'\r\n\t\t])\r\n\t\tgenerateInputs([\r\n\t\t\t'Checkbox',\r\n\t\t\t'Password',\r\n\t\t\t'Submit',\r\n\t\t\t'Radio',\r\n\t\t\t'Color',\r\n\t\t\t'Date',\r\n\t\t\t'DateTime',\r\n\t\t\t'Email',\r\n\t\t\t'Month',\r\n\t\t\t'Number',\r\n\t\t\t'Range',\r\n\t\t\t'Search',\r\n\t\t\t'Tel',\r\n\t\t\t'Time',\r\n\t\t\t'Url',\r\n\t\t\t'Week'])\r\n\t\r\n\t\tvar tags = {}\r\n\t\tfunction getConstructor(tagName) {\r\n\t\t\ttagName = tagName.toLowerCase()\r\n\t\t\treturn tags[tagName] ||\r\n\t\t\t\t(tags[tagName] =\r\n\t\t\t\t\tsetupElement(withProperties.call(doc.createElement(tagName).constructor), tagName))\r\n\t\t}\r\n\t\r\n\t\tfunction setupElement(Element, tagName) {\r\n\t\t\tvar props = elementPropertyHandlers[tagName]\r\n\t\t\tif (props && !props.assigned) {\r\n\t\t\t\tvar handlers = Element.prototype._propertyHandlers = Object.create(propertyHandlers)\r\n\t\t\t\tfor (var i = 0, l = props.length; i < l; i++) {\r\n\t\t\t\t\thandlers[props[i]] = true\r\n\t\t\t\t}\r\n\t\t\t\tif (props.value) {\r\n\t\t\t\t\tfor (var i in props) {\r\n\t\t\t\t\t\tif (!(i > -1)) { // assign any string properties if necessary\r\n\t\t\t\t\t\t\thandlers[i] = props[i]\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tprops.assigned = true\r\n\t\t\t}\r\n\t\t\tElement.tagName = tagName\r\n\t\t\treturn Element\r\n\t\t}\r\n\t\tfunction generate(elements) {\r\n\t\t\telements.forEach(function(elementName) {\r\n\t\t\t\tvar ElementClass\r\n\t\t\t\tObject.defineProperty(Element, elementName, {\r\n\t\t\t\t\tget: function() {\r\n\t\t\t\t\t\treturn ElementClass || (ElementClass = getConstructor(elementName))\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t})\r\n\t\t}\r\n\t\tfunction generateInputs(elements) {\r\n\t\t\telements.forEach(function(inputType) {\r\n\t\t\t\tvar ElementClass\r\n\t\t\t\tObject.defineProperty(Element, inputType, {\r\n\t\t\t\t\tget: function() {\r\n\t\t\t\t\t\t// TODO: make all inputs extend from input generated from generate\r\n\t\t\t\t\t\treturn ElementClass || (ElementClass = setupElement(withProperties.call(HTMLInputElement, {\r\n\t\t\t\t\t\t\ttype: inputType.toLowerCase()\r\n\t\t\t\t\t\t}), 'input'))\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t\t// alias all the inputs with an Input suffix\r\n\t\t\t\tObject.defineProperty(Element, inputType + 'Input', {\r\n\t\t\t\t\tget: function() {\r\n\t\t\t\t\t\treturn this[inputType]\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t})\r\n\t\t}\r\n\t\r\n\t\tvar aliases = {\r\n\t\t\tAnchor: 'A',\r\n\t\t\tParagraph: 'P',\r\n\t\t\tTextarea: 'TextArea',\r\n\t\t\tDList: 'DL',\r\n\t\t\tUList: 'UL',\r\n\t\t\tOList: 'OL',\r\n\t\t\tListItem: 'LI',\r\n\t\t\tText: 'Input',\r\n\t\t\tTextInput: 'Input',\r\n\t\t\tTableRow: 'TR',\r\n\t\t\tTableCell: 'TD',\r\n\t\t\tTableHeaderCell: 'TH',\r\n\t\t\tTableHeader: 'THead',\r\n\t\t\tTableBody: 'TBody'\r\n\t\t}\r\n\t\tfor (var alias in aliases) {\r\n\t\t\t(function(alias, to) {\r\n\t\t\t\tObject.defineProperty(Element, alias, {\r\n\t\t\t\t\tget: function() {\r\n\t\t\t\t\t\treturn this[to]\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t})(alias, aliases[alias])\r\n\t\t}\r\n\t\r\n\t\tElement.append = append\r\n\t\tElement.prepend = prepend\r\n\t\tElement.refresh = Renderer.refresh\r\n\t\tElement.options = {\r\n\t\t\tmoveLiveElementsEnabled: true,\r\n\t\t}\r\n\t\tElement.content = function(element){\r\n\t\t\t// container marker\r\n\t\t\treturn {\r\n\t\t\t\tisContentNode: true,\r\n\t\t\t\tcreate: element.create.bind(element)\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tElement.ElementClass = function() {}\r\n\t\tif (typeof Symbol !== 'undefined') {\r\n\t\t\t// make instanceof work for Element\r\n\t\t\tObject.defineProperty(Element.ElementClass, Symbol.hasInstance, { value: function(target) {\r\n\t\t\t\treturn target && (target.create && target.with)\r\n\t\t\t}})\r\n\t\t}\r\n\t\r\n\t\t// TODO: unify this in lang\r\n\t\tElement.extend = function(Class, properties) {\r\n\t\t\tfunction ExtendedElement() {\r\n\t\t\t\treturn Class.apply(this, arguments)\r\n\t\t\t}\r\n\t\t\tsetPrototypeOf(ExtendedElement, Class)\r\n\t\t\tvar prototype = ExtendedElement.prototype = Object.create(Class.prototype)\r\n\t\t\tprototype.constructor = ExtendedElement\r\n\t\t\tObject.getOwnPropertyNames(properties).forEach(function(key) {\r\n\t\t\t\tvar descriptor = Object.getOwnPropertyDescriptor(properties, key)\r\n\t\t\t\tif (classHandlers[key]) {\r\n\t\t\t\t\tclassHandlers[key](ExtendedElement, descriptor.value)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tObject.defineProperty(prototype, key, descriptor)\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\treturn ExtendedElement\r\n\t\t}\r\n\t\r\n\t\tfunction forTarget(target) {\r\n\t\t\treturn target.constructor.getForClass(target, this)\r\n\t\t}\r\n\t\r\n\t\tfunction hasOwn(From, Target, createInstance) {\r\n\t\t\tif (typeof Target === 'object') {\r\n\t\t\t\t// we were given an actual instance, use that\r\n\t\t\t\tvar elementMap = From.ownedClasses || (From.ownedClasses = new WeakMap())\r\n\t\t\t\tvar instanceMap = {get: function () {\r\n\t\t\t\t\treturn Target\r\n\t\t\t\t}}\r\n\t\t\t\telementMap.set(Target.constructor, instanceMap)\r\n\t\t\t\treturn hasOwn(From, Target.Class, Target.createInstance)\r\n\t\t\t}\r\n\t\t\tif (Target instanceof Array) {\r\n\t\t\t\treturn Target.forEach(function(Target) {\r\n\t\t\t\t\thasOwn(From, Target)\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tvar instanceMap = new WeakMap()\r\n\t\t\tinstanceMap.createInstance = createInstance\r\n\t\t\tvar elementMap = From.ownedClasses || (From.ownedClasses = new WeakMap())\r\n\t\t\t// TODO: Go up through prototype chain of Target and set each one\r\n\t\t\telementMap.set(Target, instanceMap)\r\n\t\t\treturn From\r\n\t\t}\r\n\t\r\n\t\tfunction getForClass(element, Target) {\r\n\t\t\tvar createInstance\r\n\t\t\twhile (element && !(createInstance = element.constructor.ownedClasses && element.constructor.ownedClasses.get(Target))) {\r\n\t\t\t\telement = element.parentNode || presumptiveParentMap.get(element)\r\n\t\t\t}\r\n\t\t\tif (createInstance) {\r\n\t\t\t\tvar ownedInstances = element.ownedInstances || (element.ownedInstances = new WeakMap())\r\n\t\t\t\tvar instance = ownedInstances.get(Target)\r\n\t\t\t\tif (instance === undefined) {\r\n\t\t\t\t\townedInstances.set(Target, instance = createInstance(element))\r\n\t\t\t\t\tinstance.subject = element\r\n\t\t\t\t}\r\n\t\t\t\treturn instance\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction propertyForElement(key) {\r\n\t\t\t// we just need to establish one Variable class for each element, so we cache it\r\n\t\t\tThisElementVariable = this._Variable\r\n\t\t\tif (!ThisElementVariable) {\r\n\t\t\t\t// need our own branded variable class for this element class\r\n\t\t\t\tThisElementVariable = this._Variable = Variable()\r\n\t\r\n\t\t\t\thasOwn(this, ThisElementVariable, function(element) {\r\n\t\t\t\t\t// TODO: we might want to do this in init instead\r\n\t\t\t\t\tvar elementOverlay\r\n\t\t\t\t\tif (element.alkaliRenderers) {\r\n\t\t\t\t\t\tvar variableProperties = {}\r\n\t\t\t\t\t\tfor (var i = 0; i < element.alkaliRenderers.length; i++){\r\n\t\t\t\t\t\t\tvar renderer = element.alkaliRenderers[i]\r\n\t\t\t\t\t\t\tif (renderer.name) {\r\n\t\t\t\t\t\t\t\tvariableProperties[renderer.name] = {value: renderer.variable}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telementOverlay = Object.create(element, variableProperties)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\telementOverlay = element\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar instance = new ThisElementVariable(elementOverlay)\r\n\t\t\t\t\t// we are not observing, because you can't delegate getters and setters in safari\r\n\t\t\t\t\t// instance.observeObject()\r\n\t\t\t\t\treturn instance\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\t// now actually get the property class\r\n\t\t\treturn ThisElementVariable.property(key)\r\n\t\t}\r\n\t\r\n\t\tvar Item = Element.Item = Variable.Item\r\n\t\r\n\t\tfunction enterRenderer(Renderer, options/*, target*/) {\r\n\t\t\t// this will be used for optimized class-level variables\r\n\t\t\t/*if (target.started) { // TODO: Might want to pass in started as a parameter\r\n\t\t\t\t// this means that the renderer has already been created, so we just need to add this instance\r\n\t\t\t\tRenderer.prototype.renderUpdate.call(options, element)\r\n\t\t\t} else {*/\r\n\t\t\tnew Renderer(options)\r\n\t\t\t//}\r\n\t\t}\r\n\t\r\n\t\tfunction cleanup(target) {\r\n\t\t\tvar renderers = target.alkaliRenderers\r\n\t\t\tif (renderers) {\r\n\t\t\t\tfor (var i = 0, l = renderers.length; i < l; i++) {\r\n\t\t\t\t\trenderers[i].stop()\r\n\t\t\t\t}\r\n\t\t\t\ttarget.needsRestart = true\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction restart(target) {\r\n\t\t\tvar renderers = target.alkaliRenderers\r\n\t\t\tif (renderers) {\r\n\t\t\t\tfor (var i = 0, l = renderers.length; i < l; i++) {\r\n\t//\t\t\t\tupdaters[i].start()\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t// setup the mutation observer so we can be notified of attachments and removals\r\n\t\tfunction elementAttached(element) {\r\n\t\t\tvar Class = element.constructor\r\n\t\t\tif (Class.create) {\r\n\t/*\t\t\tif (Class.attachedInstances) {\r\n\t\t\t\t\tClass.attachedInstances.push(element)\r\n\t\t\t\t\tif (Class.attachedInstances.length === 1 && Class.needsRestart) {\r\n\t\t\t\t\t\trestart(Class)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tClass.attachedInstances = [element]\r\n\t\t\t\t}*/\r\n\t\t\t\tif (element.attached) {\r\n\t\t\t\t\telement.attached()\r\n\t\t\t\t}\r\n\t\t\t\tif (element.needsRestart) {\r\n\t\t\t\t\trestart(element)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction elementDetached(element) {\r\n\t\t\t/*var attachedInstances = element.constructor.attachedInstances\r\n\t\t\tif (attachedInstances) {\r\n\t\t\t\tvar index = attachedInstances.indexOf(element)\r\n\t\t\t\tif (index > -1) {\r\n\t\t\t\t\tattachedInstances.splice(index, 1)\r\n\t\t\t\t\tif (attachedInstances.length === 0) {\r\n\t\t\t\t\t\tcleanup(Class)\r\n\t\t\t\t\t}\r\n\t\t\t\t}*/\r\n\t\t\t\tif (element.detached) {\r\n\t\t\t\t\telement.detached()\r\n\t\t\t\t}\r\n\t\t\t\tcleanup(element)\r\n\t\t\t//}\r\n\t\t}\r\n\t\tif (typeof MutationObserver === 'function') {\r\n\t\t\tvar lifeStates = [{\r\n\t\t\t\tname: 'detached',\r\n\t\t\t\tnodes: 'removedNodes',\r\n\t\t\t\taction: elementDetached\r\n\t\t\t}, {\r\n\t\t\t\tname: 'attached',\r\n\t\t\t\tnodes: 'addedNodes',\r\n\t\t\t\taction: elementAttached\r\n\t\t\t}]\r\n\t\t\tfunction firstVisit(node, state) {\r\n\t\t\t\tif (state.name === 'attached') {\r\n\t\t\t\t\tif (node.__alkaliAttached__) {\r\n\t\t\t\t\t\treturn false\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tnode.__alkaliAttached__ = true\r\n\t\t\t\t\t\tstate.action(node)\r\n\t\t\t\t\t\treturn true\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (node.__alkaliAttached__) {\r\n\t\t\t\t\tif (doc.body.contains(node)) {\r\n\t\t\t\t\t\t// detached event, but it is actually still attached (will get attached in a later mutation record)\r\n\t\t\t\t\t\t// so don't get through the detached/attached lifecycle\r\n\t\t\t\t\t\treturn false\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnode.__alkaliAttached__ = false\r\n\t\t\t\t\tstate.action(node)\r\n\t\t\t\t}\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\t\t\tvar observer = new MutationObserver(function(mutations) {\r\n\t\t\t\tfor (var i = 0, il = mutations.length; i < il; i++) {\r\n\t\t\t\t\tvar mutation = mutations[i]\r\n\t\t\t\t\t// invoke action on element if we haven't already\r\n\t\t\t\t\tactionIteration:\r\n\t\t\t\t\tfor (var j = 0, jl = lifeStates.length; j < jl; j++) { // two steps, removed nodes and added nodes\r\n\t\t\t\t\t\tvar state = lifeStates[j]\r\n\t\t\t\t\t\tvar nodes = mutation[state.nodes]\r\n\t\t\t\t\t\t// iterate over node list\r\n\t\t\t\t\t\tnodeIteration:\r\n\t\t\t\t\t\tfor (var k = 0, kl = nodes.length; k < kl; k++) {\r\n\t\t\t\t\t\t\tvar baseNode = nodes[k]\r\n\t\t\t\t\t\t\tif (firstVisit(baseNode, state)) {\r\n\t\t\t\t\t\t\t\t// start traversal with child, if it exists\r\n\t\t\t\t\t\t\t\tvar currentNode = baseNode.firstChild\r\n\t\t\t\t\t\t\t\tif (currentNode) {\r\n\t\t\t\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\t\t\t\tvar nextNode\r\n\t\t\t\t\t\t\t\t\t\tif (currentNode.nodeType === 1 && firstVisit(currentNode, state)) {\r\n\t\t\t\t\t\t\t\t\t\t\t// depth-first search\r\n\t\t\t\t\t\t\t\t\t\t\tnextNode = currentNode.firstChild\r\n\t\t\t\t\t\t\t\t\t\t\tif (!nextNode) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tnextNode = currentNode.nextSibling\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\tnextNode = currentNode.nextSibling\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tif (!nextNode) {\r\n\t\t\t\t\t\t\t\t\t\t\t// come back out to parents\r\n\t\t\t\t\t\t\t\t\t\t\t// TODO: try keeping a stack to make this faster\r\n\t\t\t\t\t\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentNode = currentNode.parentNode\r\n\t\t\t\t\t\t\t\t\t\t\t\tif (currentNode === baseNode) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tcontinue nodeIteration\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t} while (!(nextNode = currentNode.nextSibling))\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tcurrentNode = nextNode\r\n\t\t\t\t\t\t\t\t\t} while (true)\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// if (options.moveLiveElementsEnabled) {\r\n\t\t\t\t\t\t\t// TODO: any options that we can really do here?\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\tobserver.observe(doc.body || doc, {\r\n\t\t\t\tchildList: true,\r\n\t\t\t\tsubtree: true\r\n\t\t\t})\r\n\t\t}\r\n\t\r\n\t\tlang.copy(Variable.Context.prototype, {\r\n\t\t\tspecify: function(Variable) {\r\n\t\t\t\tvar element = this.subject\r\n\t\t\t\tvar distinctive = true\r\n\t\t\t\t;(this.generics || (this.generics = [])).push(Variable)\r\n\t\t\t\tdo {\r\n\t\t\t\t\tif (this.distinctSubject === element) {\r\n\t\t\t\t\t\tdistinctive = false\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar subjectMap = element.constructor.ownedClasses\r\n\t\t\t\t\tif (subjectMap) {\r\n\t\t\t\t\t\tvar instanceMap = subjectMap.get(Variable)\r\n\t\t\t\t\t\tif (instanceMap) {\r\n\t\t\t\t\t\t\tif (distinctive) {\r\n\t\t\t\t\t\t\t\tthis.distinctSubject = element\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tspecifiedInstance = instanceMap.get(element)\r\n\t\t\t\t\t\t\tif (!specifiedInstance) {\r\n\t\t\t\t\t\t\t\tinstanceMap.set(element, specifiedInstance = instanceMap.createInstance ?\r\n\t\t\t\t\t\t\t\t\tinstanceMap.createInstance(element) : new Variable())\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn specifiedInstance\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} while ((element = element.parentNode || presumptiveParentMap.get(element)))\r\n\t\t\t\t// else if no specific context is found, return default instance\r\n\t\t\t\treturn Variable.defaultInstance\r\n\t\t\t},\r\n\t\r\n\t\t\tgetContextualized: function(variable) {\r\n\t\t\t\t// returns a variable that has already been contextualized\r\n\t\t\t\tvar element = this.subject\r\n\t\t\t\tif (!element) {\r\n\t\t\t\t\t// no element, just use the default variable\r\n\t\t\t\t\treturn variable\r\n\t\t\t\t}\r\n\t\t\t\tif (variable._contextMap) {\r\n\t\t\t\t\tdo {\r\n\t\t\t\t\t\tvar instance = variable._contextMap.get(element)\r\n\t\t\t\t\t\tif (instance && instance.context.matches(element)) {\r\n\t\t\t\t\t\t\treturn instance\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} while ((element = element.parentNode || presumptiveParentMap.get(element)))\r\n\t\t\t\t}\r\n\t\t\t\tif (variable.context && variable.context.matches(this.subject)) {\r\n\t\t\t\t\t// check if the default variable is allowed\r\n\t\t\t\t\treturn variable\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\r\n\t\t\tmerge: function(childContext) {\r\n\t\t\t\tif (!this.distinctSubject || this.distinctSubject.contains(childContext.distinctSubject)) {\r\n\t\t\t\t\tthis.distinctSubject = childContext.distinctSubject\r\n\t\t\t\t}\r\n\t\t\t\t[].push.apply(this.generics || (this.generics = []), childContext.generics)\r\n\t\t\t},\r\n\t\t\tgetDistinctElement: function(Variable, element) {\r\n\t\t\t\tdo {\r\n\t\t\t\t\tvar subjectMap = element.constructor.ownedClasses\r\n\t\t\t\t\tif (subjectMap) {\r\n\t\t\t\t\t\tvar instanceMap = subjectMap.get(Variable)\r\n\t\t\t\t\t\tif (instanceMap && instanceMap.has(element)) {\r\n\t\t\t\t\t\t\treturn element\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} while ((element = element.parentNode || presumptiveParentMap.get(element)))\r\n\t\t\t},\r\n\t\t\tmatches: function(element) {\r\n\t\t\t\tvar generics = this.generics\r\n\t\t\t\tif (generics) {\r\n\t\t\t\t\tfor (var i = 0, l = generics.length; i < l; i++) {\r\n\t\t\t\t\t\tif (this.getDistinctElement(generics[i], element) !== this.distinctSubject) {\r\n\t\t\t\t\t\t\treturn false\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\r\n\t\r\n\t\treturn Element\r\n\t}))\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) { if (true) {\r\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) } else if (typeof module === 'object' && module.exports) {        \r\n\t  module.exports = factory() // Node\r\n\t}}(this, function () {\r\n\t\tvar getPrototypeOf = Object.getPrototypeOf || (function(base) { return base.__proto__ })\r\n\t\tvar setPrototypeOf = Object.setPrototypeOf || (function(base, proto) { base.__proto__ = proto})\r\n\t\tvar hasFeatures = {\r\n\t\t\trequestAnimationFrame: typeof requestAnimationFrame != 'undefined',\r\n\t\t\tdefineProperty: Object.defineProperty && (function() {\r\n\t\t\t\ttry{\r\n\t\t\t\t\tObject.defineProperty({}, 't', {})\r\n\t\t\t\t\treturn true\r\n\t\t\t\t}catch(e) {\r\n\t\t\t\t}\r\n\t\t\t})(),\r\n\t\t\tpromise: typeof Promise !== 'undefined',\r\n\t\t\tMutationObserver: typeof MutationObserver !== 'undefined',\r\n\t\t\t'WeakMap': typeof WeakMap === 'function'\r\n\t\t}\r\n\t\tfunction has(feature) {\r\n\t\t\treturn hasFeatures[feature]\r\n\t\t}\r\n\t\t// This is an polyfill for Object.observe with just enough functionality\r\n\t\t// for what Variables need\r\n\t\t// An observe function, with polyfile\r\n\t\tvar observe =\r\n\t\t\thas('defineProperty') ? \r\n\t\t\tfunction observe(target, listener) {\r\n\t\t\t\t/*for(var i in target) {\r\n\t\t\t\t\taddKey(i)\r\n\t\t\t\t}*/\r\n\t\t\t\tlistener.addKey = addKey\r\n\t\t\t\tlistener.remove = function() {\r\n\t\t\t\t\tlistener = null\r\n\t\t\t\t}\r\n\t\t\t\treturn listener\r\n\t\t\t\tfunction addKey(key) {\r\n\t\t\t\t\tvar keyFlag = 'key' + key\r\n\t\t\t\t\tif(this[keyFlag]) {\r\n\t\t\t\t\t\treturn\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tthis[keyFlag] = true\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar currentValue = target[key]\r\n\t\t\t\t\tvar targetAncestor = target\r\n\t\t\t\t\tvar descriptor\r\n\t\t\t\t\tdo {\r\n\t\t\t\t\t\tdescriptor = Object.getOwnPropertyDescriptor(targetAncestor, key)\r\n\t\t\t\t\t} while(!descriptor && (targetAncestor = getPrototypeOf(targetAncestor)))\r\n\t\r\n\t\t\t\t\tif(descriptor && descriptor.set) {\r\n\t\t\t\t\t\tvar previousSet = descriptor.set\r\n\t\t\t\t\t\tvar previousGet = descriptor.get\r\n\t\t\t\t\t\tObject.defineProperty(target, key, {\r\n\t\t\t\t\t\t\tget: function() {\r\n\t\t\t\t\t\t\t\treturn (currentValue = previousGet.call(this))\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\tset: function(value) {\r\n\t\t\t\t\t\t\t\tpreviousSet.call(this, value)\r\n\t\t\t\t\t\t\t\tif(currentValue !== value) {\r\n\t\t\t\t\t\t\t\t\tcurrentValue = value\r\n\t\t\t\t\t\t\t\t\tif(listener) {\r\n\t\t\t\t\t\t\t\t\t\tlistener([{target: this, name: key}])\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\tenumerable: descriptor.enumerable\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tObject.defineProperty(target, key, {\r\n\t\t\t\t\t\t\tget: function() {\r\n\t\t\t\t\t\t\t\treturn currentValue\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\tset: function(value) {\r\n\t\t\t\t\t\t\t\tif(currentValue !== value) {\r\n\t\t\t\t\t\t\t\t\tcurrentValue = value\r\n\t\t\t\t\t\t\t\t\tif(listener) {\r\n\t\t\t\t\t\t\t\t\t\tlistener([{target: this, name: key}])\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\tenumerable: !descriptor || descriptor.enumerable\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} :\r\n\t\t\t// and finally a polling-based solution, for the really old browsers\r\n\t\t\tfunction(target, listener) {\r\n\t\t\t\tif(!timerStarted) {\r\n\t\t\t\t\ttimerStarted = true\r\n\t\t\t\t\tsetInterval(function() {\r\n\t\t\t\t\t\tfor(var i = 0, l = watchedObjects.length; i < l; i++) {\r\n\t\t\t\t\t\t\tdiff(watchedCopies[i], watchedObjects[i], listeners[i])\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}, 20)\r\n\t\t\t\t}\r\n\t\t\t\tvar copy = {}\r\n\t\t\t\tfor(var i in target) {\r\n\t\t\t\t\tif(target.hasOwnProperty(i)) {\r\n\t\t\t\t\t\tcopy[i] = target[i]\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\twatchedObjects.push(target)\r\n\t\t\t\twatchedCopies.push(copy)\r\n\t\t\t\tlisteners.push(listener)\r\n\t\t\t}\r\n\t\tvar queuedListeners\r\n\t\tfunction queue(listener, object, name) {\r\n\t\t\tif(queuedListeners) {\r\n\t\t\t\tif(queuedListeners.indexOf(listener) === -1) {\r\n\t\t\t\t\tqueuedListeners.push(listener)\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\tqueuedListeners = [listener]\r\n\t\t\t\tlang.nextTurn(function() {\r\n\t\t\t\t\tqueuedListeners.forEach(function(listener) {\r\n\t\t\t\t\t\tvar events = []\r\n\t\t\t\t\t\tlistener.properties.forEach(function(property) {\r\n\t\t\t\t\t\t\tevents.push({target: listener.object, name: property})\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t\tlistener(events)\r\n\t\t\t\t\t\tlistener.object = null\r\n\t\t\t\t\t\tlistener.properties = null\r\n\t\t\t\t\t})\r\n\t\t\t\t\tqueuedListeners = null\r\n\t\t\t\t}, 0)\r\n\t\t\t}\r\n\t\t\tlistener.object = object\r\n\t\t\tvar properties = listener.properties || (listener.properties = [])\r\n\t\t\tif(properties.indexOf(name) === -1) {\r\n\t\t\t\tproperties.push(name)\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar unobserve = has('observe') ? Object.unobserve :\r\n\t\t\tfunction(target, listener) {\r\n\t\t\t\tif(listener.remove) {\r\n\t\t\t\t\tlistener.remove()\r\n\t\t\t\t}\r\n\t\t\t\tfor(var i = 0, l = watchedObjects.length; i < l; i++) {\r\n\t\t\t\t\tif(watchedObjects[i] === target && listeners[i] === listener) {\r\n\t\t\t\t\t\twatchedObjects.splice(i, 1)\r\n\t\t\t\t\t\twatchedCopies.splice(i, 1)\r\n\t\t\t\t\t\tlisteners.splice(i, 1)\r\n\t\t\t\t\t\treturn\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\tvar watchedObjects = []\r\n\t\tvar watchedCopies = []\r\n\t\tvar listeners = []\r\n\t\tvar timerStarted = false\r\n\t\tfunction diff(previous, current, callback) {\r\n\t\t\t// TODO: keep an array of properties for each watch for faster iteration\r\n\t\t\tvar queued\r\n\t\t\tfor(var i in previous) {\r\n\t\t\t\tif(previous.hasOwnProperty(i) && previous[i] !== current[i]) {\r\n\t\t\t\t\t// a property has changed\r\n\t\t\t\t\tprevious[i] = current[i]\r\n\t\t\t\t\t(queued || (queued = [])).push({name: i})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor(var i in current) {\r\n\t\t\t\tif(current.hasOwnProperty(i) && !previous.hasOwnProperty(i)) {\r\n\t\t\t\t\t// a property has been added\r\n\t\t\t\t\tprevious[i] = current[i]\r\n\t\t\t\t\t(queued || (queued = [])).push({name: i})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(queued) {\r\n\t\t\t\tcallback(queued)\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tvar id = 1\r\n\t\t// a function that returns a function, to stop JSON serialization of an\r\n\t\t// object\r\n\t\tfunction toJSONHidden() {\r\n\t\t\treturn toJSONHidden\r\n\t\t}\r\n\t\t// An object that will be hidden from JSON serialization\r\n\t\tvar Hidden = function () {\r\n\t\t}\r\n\t\tHidden.prototype.toJSON = toJSONHidden\r\n\t\r\n\t\tvar lang = {\r\n\t\t\trequestAnimationFrame: has('requestAnimationFrame') ? requestAnimationFrame :\r\n\t\t\t\t(function() {\r\n\t\t\t\t\tvar toRender = []\r\n\t\t\t\t\tvar queued = false\r\n\t\t\t\t\tfunction processAnimationFrame() {\r\n\t\t\t\t\t\tfor (var i = 0; i < toRender.length; i++) {\r\n\t\t\t\t\t\t\ttoRender[i]()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttoRender = []\r\n\t\t\t\t\t\tqueued = false\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfunction requestAnimationFrame(renderer) {\r\n\t\t\t\t\t \tif (!queued) {\r\n\t\t\t\t\t\t\tsetTimeout(processAnimationFrame)\r\n\t\t\t\t\t\t\tqueued = true\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttoRender.push(renderer)\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn requestAnimationFrame\r\n\t\t\t\t})(),\r\n\t\t\tPromise: has('promise') ? Promise : (function() {\r\n\t\t\t\tfunction Promise(execute) {\r\n\t\t\t\t\tvar isResolved, resolution, errorResolution\r\n\t\t\t\t\tvar queue = 0\r\n\t\t\t\t\tfunction resolve(value) {\r\n\t\t\t\t\t\t// resolve function\r\n\t\t\t\t\t\tif(value && value.then) {\r\n\t\t\t\t\t\t\t// received a promise, wait for it\r\n\t\t\t\t\t\t\tvalue.then(resolve, reject)\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\tresolution = value\r\n\t\t\t\t\t\t\tfinished()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfunction reject(error) {\r\n\t\t\t\t\t\t// reject function\r\n\t\t\t\t\t\terrorResolution = error\r\n\t\t\t\t\t\tfinished()\r\n\t\t\t\t\t}\r\n\t\t\t\t\texecute(resolve, reject)\r\n\t\t\t\t\tfunction finished() {\r\n\t\t\t\t\t\tisResolved = true\r\n\t\t\t\t\t\tfor(var i = 0, l = queue.length; i < l; i++) {\r\n\t\t\t\t\t\t\tqueue[i]()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// clean out the memory\r\n\t\t\t\t\t\tqueue = 0\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tthen: function(callback, errback) {\r\n\t\t\t\t\t\t\treturn new Promise(function(resolve, reject) {\r\n\t\t\t\t\t\t\t\tfunction handle() {\r\n\t\t\t\t\t\t\t\t\t// promise fulfilled, call the appropriate callback\r\n\t\t\t\t\t\t\t\t\ttry{\r\n\t\t\t\t\t\t\t\t\t\tif(errorResolution && !errback) {\r\n\t\t\t\t\t\t\t\t\t\t\t// errors without a handler flow through\r\n\t\t\t\t\t\t\t\t\t\t\treject(errorResolution)\r\n\t\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t\t// resolve to the callback's result\r\n\t\t\t\t\t\t\t\t\t\t\tresolve(errorResolution ?\r\n\t\t\t\t\t\t\t\t\t\t\t\terrback(errorResolution) :\r\n\t\t\t\t\t\t\t\t\t\t\t\tcallback ?\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tcallback(resolution) : resolution)\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}catch(newError) {\r\n\t\t\t\t\t\t\t\t\t\t// caught an error, reject the returned promise\r\n\t\t\t\t\t\t\t\t\t\treject(newError)\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif(isResolved) {\r\n\t\t\t\t\t\t\t\t\t// already resolved, immediately handle\r\n\t\t\t\t\t\t\t\t\thandle()\r\n\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t(queue || (queue = [])).push(handle)\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn Promise\r\n\t\t\t}()),\r\n\t\r\n\t\t\tWeakMap: has('WeakMap') ? WeakMap :\r\n\t\t \tfunction (values, name) {\r\n\t\t \t\tvar mapProperty = '__' + (name || '') + id++\r\n\t\t \t\treturn has('defineProperty') ?\r\n\t\t \t\t{\r\n\t\t \t\t\tget: function (key) {\r\n\t\t \t\t\t\treturn key[mapProperty]\r\n\t\t \t\t\t},\r\n\t\t \t\t\tset: function (key, value) {\r\n\t\t \t\t\t\tObject.defineProperty(key, mapProperty, {\r\n\t\t \t\t\t\t\tvalue: value,\r\n\t\t \t\t\t\t\tenumerable: false\r\n\t\t \t\t\t\t})\r\n\t\t \t\t\t}\r\n\t\t \t\t} :\r\n\t\t \t\t{\r\n\t\t \t\t\tget: function (key) {\r\n\t\t \t\t\t\tvar intermediary = key[mapProperty]\r\n\t\t \t\t\t\treturn intermediary && intermediary.value\r\n\t\t \t\t\t},\r\n\t\t \t\t\tset: function (key, value) {\r\n\t\t \t\t\t\t// we use an intermediary that is hidden from JSON serialization, at least\r\n\t\t \t\t\t\tvar intermediary = key[mapProperty] || (key[mapProperty] = new Hidden())\r\n\t\t \t\t\t\tintermediary.value = value\r\n\t\t \t\t\t}\r\n\t\t \t\t}\r\n\t\t \t},\r\n\t\r\n\t\t\tobserve: observe,\r\n\t\t\tunobserve: unobserve,\r\n\t\t\twhen: function(value, callback, errorHandler) {\r\n\t\t\t\treturn value && value.then ?\r\n\t\t\t\t\t(value.then(callback, errorHandler) || value) : callback(value)\r\n\t\t\t},\r\n\t\t\twhenAll: function(inputs, callback) {\r\n\t\t\t\tvar promiseInvolved\r\n\t\t\t\tfor(var i = 0, l = inputs.length; i < l; i++) {\r\n\t\t\t\t\tif(inputs[i] && inputs[i].then) {\r\n\t\t\t\t\t\tpromiseInvolved = true\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif(promiseInvolved) {\r\n\t\t\t\t\t// we have asynch inputs, do lazy loading\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tthen: function(onResolve, onError) {\r\n\t\t\t\t\t\t\tvar remaining = 1\r\n\t\t\t\t\t\t\tvar result\r\n\t\t\t\t\t\t\tvar readyInputs = []\r\n\t\t\t\t\t\t\tvar lastPromiseResult\r\n\t\t\t\t\t\t\tfor(var i = 0; i < inputs.length; i++) {\r\n\t\t\t\t\t\t\t\tvar input = inputs[i]\r\n\t\t\t\t\t\t\t\tremaining++\r\n\t\t\t\t\t\t\t\tif(input && input.then) {\r\n\t\t\t\t\t\t\t\t\t(function(i, previousPromiseResult) {\r\n\t\t\t\t\t\t\t\t\t\tlastPromiseResult = input.then(function(value) {\r\n\t\t\t\t\t\t\t\t\t\t\treadyInputs[i] = value\r\n\t\t\t\t\t\t\t\t\t\t\tonEach()\r\n\t\t\t\t\t\t\t\t\t\t\tif(!remaining) {\r\n\t\t\t\t\t\t\t\t\t\t\t\treturn result\r\n\t\t\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t\t\treturn previousPromiseResult\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}, onError)\r\n\t\t\t\t\t\t\t\t\t})(i, lastPromiseResult)\r\n\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\treadyInputs[i] = input\r\n\t\t\t\t\t\t\t\t\tonEach()\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tonEach()\r\n\t\t\t\t\t\t\tfunction onEach() {\r\n\t\t\t\t\t\t\t\tremaining--\r\n\t\t\t\t\t\t\t\tif(!remaining) {\r\n\t\t\t\t\t\t\t\t\tresult = onResolve(callback(readyInputs))\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn lastPromiseResult\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tinputs: inputs\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// just sync inputs\r\n\t\t\t\treturn callback(inputs)\r\n\t\r\n\t\t\t},\r\n\t\t\tcompose: function(Base, constructor, properties) {\r\n\t\t\t\tvar prototype = constructor.prototype = Object.create(Base.prototype)\r\n\t\t\t\tsetPrototypeOf(constructor, Base)\r\n\t\t\t\tfor(var i in properties) {\r\n\t\t\t\t\tprototype[i] = properties[i]\r\n\t\t\t\t}\r\n\t\t\t\tprototype.constructor = constructor\r\n\t\t\t\treturn constructor\r\n\t\t\t},\r\n\t\t\tnextTurn: has('MutationObserver') ?\r\n\t\t\t\tfunction (callback) {\r\n\t\t\t\t\t// promises don't resolve consistently on the next micro turn (Edge doesn't do it right),\r\n\t\t\t\t\t// so use mutation observer\r\n\t\t\t\t\t// TODO: make a faster mode that doesn't recreate each time\r\n\t\t\t\t\tvar div = document.createElement('div')\r\n\t\t\t\t\tvar observer = new MutationObserver(callback)\r\n\t\t\t\t\tobserver.observe(div, {\r\n\t\t\t\t\t\tattributes: true\r\n\t\t\t\t\t})\r\n\t\t\t\t\tdiv.setAttribute('a', id++)\r\n\t\t\t\t} :\r\n\t\t\t\tfunction (callback) {\r\n\t\t\t\t\t// TODO: we can do better for other, older browsers\r\n\t\t\t\t\tsetTimeout(callback, 0)\r\n\t\t\t\t},\r\n\t\t\tcopy: Object.assign || function(target, source) {\r\n\t\t\t\tfor(var i in source) {\r\n\t\t\t\t\ttarget[i] = source[i]\r\n\t\t\t\t}\r\n\t\t\t\treturn target\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction isGenerator(func) {\r\n\t\t\tif (typeof func === 'function') {\r\n\t\t\t\tvar constructor = func.constructor\r\n\t\t\t\t// this is used to handle both native generators and transpiled generators\r\n\t\t\t\treturn (constructor.displayName || constructor.name) === 'GeneratorFunction'\r\n\t\t\t}\r\n\t\t}\r\n\t\tlang.isGenerator = isGenerator\r\n\t\treturn lang\r\n\t}))\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) { if (true) {\r\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(4)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) } else if (typeof module === 'object' && module.exports) {        \r\n\t  module.exports = factory(require('./util/lang'), require('./Variable')) // Node\r\n\t}}(this, function (lang, Variable) {\r\n\t\tvar doc = typeof document !== 'undefined' && document\r\n\t\tvar invalidatedElements\r\n\t\tvar queued\r\n\t\tvar toRender = []\r\n\t\tvar nextId = 1\r\n\t\tvar requestAnimationFrame = lang.requestAnimationFrame\r\n\t\tvar Context = Variable.Context\r\n\t\r\n\t\tfunction Renderer(options) {\r\n\t\t\tvar variable = options.variable\r\n\t\r\n\t\t\tthis.variable = variable\r\n\t\t\tif (options.selector) {\r\n\t\t\t\tthis.selector = options.selector\r\n\t\t\t}\r\n\t\t\tif (options.elements) {\r\n\t\t\t\tthis.elements = options.elements\r\n\t\t\t\tthis.element = this.elements[0]\r\n\t\t\t\tfor(var i = 0, l = this.elements.length; i < l; i++) {\r\n\t\t\t\t\t(this.elements[i].alkaliRenderers || (this.elements[i].alkaliRenderers = [])).push(this)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (options.element) {\r\n\t\t\t\tvar element = this.element = options.element;\r\n\t\t\t\t(element.alkaliRenderers || (element.alkaliRenderers = [])).push(this)\r\n\t\t\t} else {\r\n\t\t\t\tthrow new Error('No element provided to Renderer')\r\n\t\t\t}\r\n\t\t\tif (options.update) {\r\n\t\t\t\tthis.updateRendering = options.update\r\n\t\t\t}\r\n\t\t\tif (options.shouldRender) {\r\n\t\t\t\tthis.shouldRender = options.shouldRender\r\n\t\t\t}\r\n\t\t\tif (options.renderUpdate) {\r\n\t\t\t\tthis.renderUpdate = options.renderUpdate\r\n\t\t\t}\r\n\t\t\tif (options.alwaysUpdate) {\r\n\t\t\t\tthis.alwaysUpdate = options.alwaysUpdate\r\n\t\t\t}\r\n\t\t\tif (!variable.updated) {\r\n\t\t\t\t// baconjs-esqe API\r\n\t\t\t\tvar renderer = this\r\n\t\t\t\tvariable.subscribe(function (event) {\r\n\t\t\t\t\t// replace the variable with an object\r\n\t\t\t\t\t// that returns the value from the event\r\n\t\t\t\t\trenderer.variable = {\r\n\t\t\t\t\t\tvalueOf: function () {\r\n\t\t\t\t\t\t\treturn event.value()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\trenderer.updated()\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tif (options.updateOnStart === false){\r\n\t\t\t\t// even if we don't render on start, we still need to compute the value so we can depend on the computed variables\r\n\t\t\t\tthis.variable.valueOf(this)\r\n\t\t\t\tvar contextualized = this.contextualized || this.variable\r\n\t\t\t\t// TODO: we may need to handle recontextualization if it returns a promise\r\n\t\t\t\tcontextualized.notifies(this)\r\n\t\t\t} else {\r\n\t\t\t\tthis.updateRendering(true)\r\n\t\t\t}\r\n\t\t}\r\n\t\tRenderer.prototype = {\r\n\t\t\tconstructor: Renderer,\r\n\t\t\tupdateRendering: function () {\r\n\t\t\t\tthrow new Error ('updateRendering must be implemented by sub class of Renderer')\r\n\t\t\t},\r\n\t\t\tupdated: function (updateEvent, by, context) {\r\n\t\t\t\tif (!this.invalidated) {\r\n\t\t\t\t\tif (!context || this.contextMatches(context)) {\r\n\t\t\t\t\t\t// do this only once, until we render again\r\n\t\t\t\t\t\tthis.invalidated = true\r\n\t\t\t\t\t\tvar renderer = this\r\n\t\t\t\t\t\trequestAnimationFrame(function(){\r\n\t\t\t\t\t\t\tinvalidatedElements = null\r\n\t\t\t\t\t\t\trenderer.updateRendering(renderer.alwaysUpdate)\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tnewContext: function() {\r\n\t\t\t\treturn new Variable.Context(this.element)\r\n\t\t\t},\r\n\t\t\taddInput: function(variable) {\r\n\t\t\t\tthis.contextualized = variable\r\n\t\t\t},\r\n\t\t\tgetContextualized: function() {\r\n\t\t\t\treturn this.contextualized\r\n\t\t\t},\r\n\t\t\tspecify: function(Variable) {\r\n\t\t\t\t// a new context to get thsi\r\n\t\t\t\treturn this.newContext().specify(Variable)\r\n\t\t\t},\r\n\t\t\tmerge: function(){\r\n\t\t\t\t// noop\r\n\t\t\t},\r\n\t\t\tcontextMatches: function(context) {\r\n\t\t\t\treturn true\r\n\t\t\t},\r\n\t\t\tinvalidateElement: function(element) {\r\n\t\t\t\tif(!invalidatedElements){\r\n\t\t\t\t\tinvalidatedElements = new WeakMap(null, 'invalidated')\r\n\t\t\t\t}\r\n\t\t\t\tvar invalidatedParts = invalidatedElements.get(element)\r\n\t\t\t\tinvalidatedElements.set(element, invalidatedParts = {})\r\n\t\t\t\tif (!invalidatedParts[id]) {\r\n\t\t\t\t\tinvalidatedParts[id] = true\r\n\t\t\t\t}\r\n\t\t\t\tif (!queued) {\r\n\t\t\t\t\tlang.queueTask(processQueue)\r\n\t\t\t\t\tqueued = true\r\n\t\t\t\t}\r\n\t\t\t\tvar renderer = this\r\n\t\t\t\ttoRender.push(function(){\r\n\t\t\t\t\trenderer.invalidated = false\r\n\t\t\t\t\trenderer.updateElement(element)\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tgetId: function(){\r\n\t\t\t\treturn this.id || (this.id = nextId++)\r\n\t\t\t},\r\n\t\t\tstop: function() {\r\n\t\t\t\tvar contextualized = this.contextualized || this.variable\r\n\t\t\t\tcontextualized.stopNotifies(this)\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction ElementRenderer(options) {\r\n\t\t\tRenderer.call(this, options)\r\n\t\t}\r\n\t\tElementRenderer.prototype = Object.create(Renderer.prototype)\r\n\t\tElementRenderer.prototype.shouldRender = function (element) {\r\n\t\t\treturn document.body.contains(element)\r\n\t\t}\r\n\t\tElementRenderer.prototype.getSubject = function () {\r\n\t\t\treturn this.element\r\n\t\t}\r\n\t\tElementRenderer.prototype.updateRendering = function (always, element) {\r\n\t\t\tif (!element && this.elements) {\r\n\t\t\t\tvar elements = this.elements\r\n\t\t\t\tif(!elements.length){\r\n\t\t\t\t\tif(this.selector){\r\n\t\t\t\t\t\telements = document.querySelectorAll(this.selector)\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tthrow new Error('No element or selector was provided to the Renderer')\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t\tfor(var i = 0, l = elements.length; i < l; i++){\r\n\t\t\t\t\tthis.updateRendering(always, elements[i])\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tvar thisElement = element || this.element\r\n\t\r\n\t\t\t\tif(always || this.shouldRender(thisElement)){\r\n\t\t\t\t\t// it is connected\r\n\t\t\t\t\tthis.updateElement(thisElement)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar id = this.getId()\r\n\t\t\t\t\tvar renderers = thisElement.renderersOnShow\r\n\t\t\t\t\tif(!renderers){\r\n\t\t\t\t\t\trenderers = thisElement.renderersOnShow = []\r\n\t\t\t\t\t\tthisElement.className += ' needs-rerendering'\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!renderers[id]) {\r\n\t\t\t\t\t\trenderers[id] = this\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tElementRenderer.prototype.addElement = function (element) {\r\n\t\t\tif (this.selector) {\r\n\t\t\t\telement.renderersOnShow = [this]\r\n\t\t\t} else {\r\n\t\t\t\tthis.elements.push(element)\r\n\t\t\t}\r\n\t\t\t// and immediately do an update\r\n\t\t\tthis.updateElement(element)\r\n\t\t}\r\n\t\tElementRenderer.prototype.updateElement = function(element) {\r\n\t\t\tthis.invalidated = false\r\n\t\t\ttry {\r\n\t\t\t\tif (!this.omitValueOf) {\r\n\t\t\t\t\tvar value = this.variable.valueOf(this)\r\n\t\t\t\t\tvar contextualized = this.contextualized || this.variable\r\n\t\t\t\t\t// TODO: we may need to handle recontextualization if it returns a promise\r\n\t\t\t\t\tcontextualized.notifies(this)\r\n\t\t\t\t}\r\n\t\t\t} catch (error) {\r\n\t\t\t\telement.appendChild(document.createTextNode(error))\r\n\t\t\t}\r\n\t\t\tif(value !== undefined || this.started || this.omitValueOf){\r\n\t\t\t\tthis.started = true\r\n\t\t\t\tif(value && value.then){\r\n\t\t\t\t\tif(this.renderLoading){\r\n\t\t\t\t\t\tthis.renderLoading(value, element)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar renderer = this\r\n\t\t\t\t\tvalue.then(function (value) {\r\n\t\t\t\t\t\trenderer.renderUpdate(value, element)\r\n\t\t\t\t\t})\r\n\t\t\t\t}else{\r\n\t\t\t\t\tthis.renderUpdate(value, element)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tElementRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\t\tthrow new Error('renderUpdate(newValue) must be implemented')\r\n\t\t}\r\n\t\tRenderer.Renderer = Renderer\r\n\t\tRenderer.ElementRenderer = ElementRenderer\r\n\t\r\n\t\tfunction AttributeRenderer(options) {\r\n\t\t\tif(options.name){\r\n\t\t\t\tthis.name = options.name\r\n\t\t\t}\r\n\t\t\tElementRenderer.apply(this, arguments)\r\n\t\t}\r\n\t\tAttributeRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\t\tAttributeRenderer.prototype.type = 'AttributeRenderer'\r\n\t\tAttributeRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\t\telement.setAttribute(this.name, newValue)\r\n\t\t}\r\n\t\tRenderer.AttributeRenderer = AttributeRenderer\r\n\t\r\n\t\tfunction PropertyRenderer(options) {\r\n\t\t\tif (options.name) {\r\n\t\t\t\tthis.name = options.name\r\n\t\t\t}\r\n\t\t\tElementRenderer.apply(this, arguments)\r\n\t\t}\r\n\t\tPropertyRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\t\tPropertyRenderer.prototype.type = 'PropertyRenderer'\r\n\t\tPropertyRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\t\telement[this.name] = newValue\r\n\t\t}\r\n\t\tRenderer.PropertyRenderer = PropertyRenderer\r\n\t\r\n\t\tfunction InputPropertyRenderer(options) {\r\n\t\t\tif (options.element && options.element.tagName === 'SELECT' && options.name === 'value') {\r\n\t\t\t\t// use the deferred value assignment for <select>\r\n\t\t\t\tthis.renderUpdate = this.renderSelectValueUpdate\r\n\t\t\t}\r\n\t\t\tPropertyRenderer.apply(this, arguments)\r\n\t\t}\r\n\t\tInputPropertyRenderer.prototype = Object.create(PropertyRenderer.prototype)\r\n\t\tInputPropertyRenderer.prototype.type = 'InputPropertyRenderer'\r\n\t\tInputPropertyRenderer.prototype.renderUpdate = function(newValue, element) {\r\n\t\t\tif (newValue == null || (element.type === 'number' && isNaN(newValue))) {\r\n\t\t\t\tnewValue = ''\r\n\t\t\t}\r\n\t\t\telement[this.name] = newValue\r\n\t\t}\r\n\t\tInputPropertyRenderer.prototype.renderSelectValueUpdate = function (newValue, element) {\r\n\t\t\telement.value = newValue\r\n\t\t\tif (element.value != newValue && !element.value) {\r\n\t\t\t\t// if we didn't successfully set the value of a <select>, we may need to wait until the children are constructed\r\n\t\t\t\telement.eventualValue = newValue\r\n\t\t\t\tlang.nextTurn(function() {\r\n\t\t\t\t\tif (element.eventualValue) {\r\n\t\t\t\t\t\telement.value = element.eventualValue\r\n\t\t\t\t\t\telement.eventualValue = undefined\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t} else {\r\n\t\t\t\telement.eventualValue = undefined\r\n\t\t\t}\r\n\t\t}\r\n\t\tRenderer.InputPropertyRenderer = InputPropertyRenderer\r\n\t\r\n\t\tfunction StyleRenderer(options) {\r\n\t\t\tif(options.name){\r\n\t\t\t\tthis.name = options.name\r\n\t\t\t}\r\n\t\t\tElementRenderer.apply(this, arguments)\r\n\t\t}\r\n\t\tStyleRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\t\tStyleRenderer.prototype.type = 'StyleRenderer'\r\n\t\tStyleRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\t\telement.style[this.name] = newValue\r\n\t\t}\r\n\t\tRenderer.StyleRenderer = StyleRenderer\r\n\t\r\n\t\tfunction ContentRenderer(options) {\r\n\t\t\tElementRenderer.apply(this, arguments)\r\n\t\t}\r\n\t\tContentRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\t\tContentRenderer.prototype.type = 'ContentRenderer'\r\n\t\tContentRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\t\telement.innerHTML = ''\r\n\t\t\tif (newValue === undefined){\r\n\t\t\t\tnewValue = ''\r\n\t\t\t}\r\n\t\t\telement.appendChild(document.createTextNode(newValue))\r\n\t\t}\r\n\t\tRenderer.ContentRenderer = ContentRenderer\r\n\t\r\n\t\tfunction TextRenderer(options) {\r\n\t\t\tthis.position = options.position\r\n\t\t\tthis.textNode = options.textNode\r\n\t\t\tElementRenderer.apply(this, arguments)\r\n\t\t}\r\n\t\tTextRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\t\tTextRenderer.prototype.type = 'TextRenderer'\r\n\t\tTextRenderer.prototype.updated = function (updateEvent, context) {\r\n\t\t\tif (this.builtList) {\r\n\t\t\t\tif (updateEvent.type === 'refresh') {\r\n\t\t\t\t\tthis.builtList = false\r\n\t\t\t\t\tthis.omitValueOf = false\r\n\t\t\t\t} else {\r\n\t\t\t\t\t(this.updates || (this.updates = [])).push(updateEvent)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tElementRenderer.prototype.updated.call(this, updateEvent, context)\r\n\t\t}\r\n\t\tTextRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\t\tif (newValue == null){\r\n\t\t\t\tnewValue = ''\r\n\t\t\t}\r\n\t\t\tif (newValue.nodeType) {\r\n\t\t\t\tif (this.textNode && this.textNode.parentNode == element) {\r\n\t\t\t\t\t// text node is attached, we can replace it with the node\r\n\t\t\t\t\telement.replaceChild(newValue, this.textNode)\r\n\t\t\t\t} else {\r\n\t\t\t\t\telement.appendChild(newValue)\r\n\t\t\t\t}\r\n\t\t\t\tthis.textNode = newValue\r\n\t\t\t} else if (newValue instanceof Array) {\r\n\t\t\t\tthis.renderUpdate = ListRenderer.prototype.renderUpdate\r\n\t\t\t\tthis.omitValueOf = true\r\n\t\t\t\tthis.renderUpdate(newValue, element)\r\n\t\t\t} else {\r\n\t\t\t\t(this.textNode || element.childNodes[this.position]).nodeValue = newValue\r\n\t\t\t}\r\n\t\t}\r\n\t\tRenderer.TextRenderer = TextRenderer\r\n\t\r\n\t\tfunction ListRenderer(options) {\r\n\t\t\tif (options.each) {\r\n\t\t\t\tthis.each = options.each\r\n\t\t\t}\r\n\t\t\tElementRenderer.apply(this, arguments)\r\n\t\t}\r\n\t\tListRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\t\tListRenderer.prototype.updated = function (updateEvent, context) {\r\n\t\t\tif (this.builtList) {\r\n\t\t\t\tif (updateEvent.type === 'refresh') {\r\n\t\t\t\t\tthis.builtList = false\r\n\t\t\t\t\tthis.omitValueOf = false\r\n\t\t\t\t} else {\r\n\t\t\t\t\t(this.updates || (this.updates = [])).push(updateEvent)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tElementRenderer.prototype.updated.call(this, updateEvent, context)\r\n\t\t}\r\n\t\tListRenderer.prototype.type = 'ListRenderer'\r\n\t\tListRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\t\tvar container\r\n\t\t\tvar each = this.each || function(item) { // TODO: make a single identity function\r\n\t\t\t\treturn item\r\n\t\t\t}\r\n\t\t\tvar thisElement = this.element\r\n\t\t\tvar renderer = this\r\n\t\t\tif (!this.builtList) {\r\n\t\t\t\tthis.builtList = true\r\n\t\t\t\tthis.omitValueOf = true\r\n\t\t\t\telement.innerHTML = ''\r\n\t\t\t\tcontainer = document.createDocumentFragment()\r\n\t\t\t\tvar childElements = this.childElements = []\r\n\t\t\t\tif (each.defineHasOwn) {\r\n\t\t\t\t\teach.defineHasOwn()\r\n\t\t\t\t}\r\n\t\t\t\tnewValue.forEach(function(item) {\r\n\t\t\t\t\teachItem(item)\r\n\t\t\t\t})\r\n\t\t\t\tvar contextualized = this.contextualized || this.variable\r\n\t\t\t\tcontextualized.notifies(this)\r\n\t\r\n\t\t\t\tthisElement.appendChild(container)\r\n\t\t\t} else {\r\n\t\t\t\tvar childElements = this.childElements\r\n\t\t\t\tvar updates = this.updates\r\n\t\t\t\tcontainer = thisElement\r\n\t\t\t\tupdates.forEach(function(update) {\r\n\t\t\t\t\tif (update.type === 'refresh') {\r\n\t\t\t\t\t\trenderer.builtList = false\r\n\t\t\t\t\t\tfor (var i = 0, l = childElements.length; i < l; i++) {\r\n\t\t\t\t\t\t\tthisElement.removeChild(childElements[i])\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\trenderer.renderUpdate()\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (update.previousIndex > -1) {\r\n\t\t\t\t\t\t\tthisElement.removeChild(childElements[update.previousIndex])\r\n\t\t\t\t\t\t\tchildElements.splice(update.previousIndex, 1)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (update.index > -1) {\r\n\t\t\t\t\t\t\tvar nextChild = childElements[update.index] || null\r\n\t\t\t\t\t\t\teachItem(update.value, update.index, nextChild)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t\tthis.updates = [] // clear the updates\r\n\t\t\t}\r\n\t\t\tfunction eachItem(item, index, nextChild) {\r\n\t\t\t\tvar childElement\r\n\t\t\t\tif (each.create) {\r\n\t\t\t\t\tchildElement = each.create({parent: thisElement, _item: item}) // TODO: make a faster object here potentially\r\n\t\t\t\t} else {\r\n\t\t\t\t\tchildElement = each(item, thisElement)\r\n\t\t\t\t\tif (childElement.create) {\r\n\t\t\t\t\t\tchildElement = childElement.create({parent: thisElement, _item: item})\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (nextChild) {\r\n\t\t\t\t\tcontainer.insertBefore(childElement, nextChild)\r\n\t\t\t\t\tchildElements.splice(index, 0, childElement)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcontainer.appendChild(childElement)\r\n\t\t\t\t\tchildElements.push(childElement)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tRenderer.ListRenderer = ListRenderer\r\n\t\r\n\t\tRenderer.onShowElement = function(shownElement){\r\n\t\t\trequestAnimationFrame(function(){\r\n\t\t\t\tinvalidatedElements = null\r\n\t\t\t\tvar elements = [].slice.call(shownElement.getElementsByClassName('needs-rerendering'))\r\n\t\t\t\tif (shownElement.className.indexOf('needs-rerendering') > 0){\r\n\t\t\t\t\tvar includingTop = [shownElement]\r\n\t\t\t\t\tincludingTop.push.apply(includingTop, elements)\r\n\t\t\t\t\telements = includingTop\r\n\t\t\t\t}\r\n\t\t\t\tfor (var i = 0, l = elements.length; i < l; i++){\r\n\t\t\t\t\tvar element = elements[i]\r\n\t\t\t\t\tvar renderers = element.renderersOnShow\r\n\t\t\t\t\tif(renderers){\r\n\t\t\t\t\t\telement.renderersOnShow = null\r\n\t\t\t\t\t\t// remove needs-rerendering class\r\n\t\t\t\t\t\telement.className = element.className.replace(/\\s?needs\\-rerendering\\s?/g, '')\r\n\t\t\t\t\t\tfor (var id in renderers) {\r\n\t\t\t\t\t\t\tvar renderer = renderers[id]\r\n\t\t\t\t\t\t\trenderer.updateElement(element)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t}\r\n\t\r\n\t\tfunction onElementRemoval(element){\r\n\t\t\t// cleanup element renderers\r\n\t\t\tif(element.alkaliRenderers){\r\n\t\t\t\tvar renderers = element.alkaliRenderers\r\n\t\t\t\tfor(var i = 0; i < renderers.length; i++){\r\n\t\t\t\t\tvar renderer = renderers[i]\r\n\t\t\t\t\trenderer.variable.stopNotifies(renderer)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tRenderer.onElementRemoval = function(element, onlyChildren){\r\n\t\t\tif(!onlyChildren){\r\n\t\t\t\tonElementRemoval(element)\r\n\t\t\t}\r\n\t\t\tvar children = element.getElementsByTagName('*')\r\n\t\t\tfor(var i = 0, l = children.length; i < l; i++){\r\n\t\t\t\tvar child = children[i]\r\n\t\t\t\tif(child.alkaliRenderers){\r\n\t\t\t\t\tonElementRemoval(child)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn Renderer\r\n\t}))\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) { if (true) {\r\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) } else if (typeof module === 'object' && module.exports) {        \r\n\t  module.exports = factory(require('./util/lang')) // Node\r\n\t}}(this, function (lang) {\r\n\t\tvar deny = {}\r\n\t\tvar noChange = {}\r\n\t\tvar WeakMap = lang.WeakMap\r\n\t\tvar setPrototypeOf = Object.setPrototypeOf || (function(base, proto) { base.__proto__ = proto})\r\n\t\tvar getPrototypeOf = Object.getPrototypeOf || (function(base) { return base.__proto__ })\r\n\t\tvar isGenerator = lang.isGenerator\r\n\t\t// update types\r\n\t\tvar RequestChange = 3\r\n\t\tvar RequestSet = 4\r\n\t\r\n\t\tvar nextId = 1\r\n\t\tvar propertyListenersMap = new WeakMap(null, 'propertyListenersMap')\r\n\t\r\n\t\tvar CacheEntry = lang.compose(WeakMap, function() {\r\n\t\t},{\r\n\t\t\t_propertyChange: function(propertyName) {\r\n\t\t\t\tthis.variable._propertyChange(propertyName, contextFromCache(this))\r\n\t\t\t}\r\n\t\t})\r\n\t\tvar listenerId = 1\r\n\t\r\n\t\tfunction when(value, callback) {\r\n\t\t\tif (value && value.then) {\r\n\t\t\t\treturn value.then(callback)\r\n\t\t\t}\r\n\t\t\treturn callback(value)\r\n\t\t}\r\n\t\r\n\t\tfunction Context(subject){\r\n\t\t\tthis.subject = subject\r\n\t\t\tthis.inputs = []\r\n\t\t}\r\n\t\tContext.prototype = {\r\n\t\t\tconstructor: Context,\r\n\t\t\tnewContext: function(variable) {\r\n\t\t\t\treturn new Context(this.subject)\r\n\t\t\t},\r\n\t\t\tcontextualize: function(variable, parentContext) {\r\n\t\t\t\t// resolve the contextualization of a variable, and updates this context to be aware of what distinctive aspect of the context has\r\n\t\t\t\t// been used for resolution\r\n\t\t\t\tvar contextualized\r\n\t\t\t\tif (this.distinctSubject) {\r\n\t\t\t\t\tvar contextMap = variable._contextMap || (variable._contextMap = new WeakMap())\r\n\t\t\t\t\tcontextualized = contextMap.get(this.distinctSubject)\r\n\t\t\t\t\tif (!contextualized) {\r\n\t\t\t\t\t\tcontextMap.set(this.distinctSubject, contextualized = Object.create(variable))\r\n\t\t\t\t\t\tcontextualized.listeners = false\r\n\t\t\t\t\t\tcontextualized.context = this\r\n\t\t\t\t\t\tvar inputs = this.inputs\r\n\t\t\t\t\t\tfor (var i = 0, l = inputs.length; i < l; i++) {\r\n\t\t\t\t\t\t\tcontextualized[inputs[i]] = inputs[++i]\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.contextualized = contextualized\r\n\t\t\t\t\t// do the merge\r\n\t\t\t\t\tif (parentContext) {\r\n\t\t\t\t\t\tparentContext.merge(this)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcontextualized = variable\r\n\t\t\t\t}\r\n\t\t\t\t//if (this.contextualized && this.contextualized !== contextualized) {\r\n\t\t\t\t\t// TOOD: if it has previously been contextualized to a different context (can happen in a promise/async situation), stop previous notifiers and start new ones\r\n\t\t\t\t//}\r\n\t\t\t\tparentContext.addInput(contextualized)\r\n\t\t\t\treturn contextualized\r\n\t\t\t},\r\n\t\t\tmerge: function(childContext) {\r\n\t\t\t\tif (!this.distinctSubject) {\r\n\t\t\t\t\tthis.distinctSubject = childContext.distinctSubject\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tspecify: function(Variable) {\r\n\t\t\t\t// specify a particular instance of a generic variable\r\n\t\t\t\tvar subject = this.subject\r\n\t\t\t\tvar subjectMap = subject.constructor.ownedClasses\r\n\t\t\t\tvar specifiedInstance\r\n\t\t\t\tif (subjectMap) {\r\n\t\t\t\t\tif (!this.distinctSubject) {\r\n\t\t        this.distinctSubject = subject\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar instanceMap = subjectMap.get(Variable)\r\n\t\t\t\t\tif (instanceMap) {\r\n\t\t\t\t\t\tspecifiedInstance = instanceMap.get(subject)\r\n\t\t\t\t\t\tif (!specifiedInstance) {\r\n\t\t\t\t\t\t\tinstanceMap.set(subject, specifiedInstance = instanceMap.createInstance ? instanceMap.createInstance(subject) : new Variable())\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn specifiedInstance\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// else if no specific context is found, return default instance\r\n\t\t\t\treturn Variable.defaultInstance\r\n\t\t\t},\r\n\t\t\tgetContextualized: function(variable) {\r\n\t\r\n\t\t\t\t// returns a variable that has already been contextualized\r\n\t\t\t\tvar instance = variable._contextMap && this.subject && variable._contextMap.get(this.subject)\r\n\t\t\t\tif (instance && instance.context && instance.context.matches(this)) {\r\n\t\t\t\t\treturn instance\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\taddInput: function(inputVariable) {\r\n\t\t\t\tthis.inputs.push(this.nextProperty, inputVariable)\r\n\t\t\t},\r\n\t\t\tmatches: function(context) {\r\n\t\t\t\t// does another context match the resolution of this one?\r\n\t\t\t\treturn context.subject === this.subject\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction NotifyingContext(listener, subject){\r\n\t\t\tthis.subject = subject\r\n\t\t\tthis.listener = listener\r\n\t\t}\r\n\t\tNotifyingContext.prototype = Object.create(Context.prototype)\r\n\t\tNotifyingContext.prototype.constructor = NotifyingContext\r\n\t\tNotifyingContext.prototype.addInput = function(contextualized) {\r\n\t\t\tcontextualized.notifies(this.listener)\r\n\t\t}\r\n\t\r\n\t\tfunction whenAll(inputs, callback){\r\n\t\t\tvar promiseInvolved\r\n\t\t\tfor (var i = 0, l = inputs.length; i < l; i++) {\r\n\t\t\t\tif (inputs[i] && inputs[i].then) {\r\n\t\t\t\t\tpromiseInvolved = true\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (promiseInvolved) {\r\n\t\t\t\treturn lang.whenAll(inputs, callback)\r\n\t\t\t}\r\n\t\t\treturn callback(inputs)\r\n\t\t}\r\n\t\r\n\t\tfunction registerListener(value, listener) {\r\n\t\t\tvar listeners = propertyListenersMap.get(value)\r\n\t\t\tvar id = listener.listenerId || (listener.listenerId = ('-' + listenerId++))\r\n\t\t\tif (listeners) {\r\n\t\t\t\tif (listeners[id] === undefined) {\r\n\t\t\t\t\tlisteners[id] = listeners.push(listener) - 1\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\tpropertyListenersMap.set(value, listeners = [listener])\r\n\t\t\t\tlisteners[id] = 0\r\n\t\t\t\tif (Variable.autoObserveObjects) {\r\n\t\t\t\t\tobserve(value)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tlistener.listeningToObject = value\r\n\t\t}\r\n\t\tfunction deregisterListener(listener) {\r\n\t\t\tif (listener.listeningToObject) {\r\n\t\t\t\tvar value = listener.listeningToObject\r\n\t\t\t\tlistener.listeningToObject = null\r\n\t\t\t\tvar listeners = propertyListenersMap.get(value)\r\n\t\t\t\tif (listeners) {\r\n\t\t\t\t\tvar index = listeners[listener.listenerId]\r\n\t\t\t\t\tif (index > -1) {\r\n\t\t\t\t\t\tlisteners.splice(index, 1)\r\n\t\t\t\t\t\tdelete listeners[listener.listenerId]\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction RefreshEvent() {\r\n\t\t\tthis.visited = new Set()\r\n\t\t}\r\n\t\tRefreshEvent.prototype.type = 'refresh'\r\n\t\r\n\t\tfunction PropertyChangeEvent(key, childEvent, parent) {\r\n\t\t\tthis.key = key\r\n\t\t\tthis.childEvent = childEvent\r\n\t\t\tthis.parent = parent\r\n\t\t\tthis.visited = childEvent.visited\r\n\t\t}\r\n\t\tPropertyChangeEvent.prototype.type = 'update'\r\n\t\r\n\t\tfunction AddEvent(args) {\r\n\t\t\tthis.visited = new Set()\r\n\t\t\tfor (var key in args) {\r\n\t\t\t\tthis[key] = args[key]\r\n\t\t\t}\r\n\t\t}\r\n\t\tAddEvent.prototype.type = 'add'\r\n\t\tfunction DeleteEvent(args) {\r\n\t\t\tthis.visited = new Set()\r\n\t\t\tfor (var key in args) {\r\n\t\t\t\tthis[key] = args[key]\r\n\t\t\t}\r\n\t\t}\r\n\t\tDeleteEvent.prototype.type = 'delete'\r\n\t\r\n\t\tfunction forPropertyNotifyingValues(properties, callback) {\r\n\t\t\tfor (var key in properties) {\r\n\t\t\t\tvar property = properties[key]\r\n\t\t\t\tif (property.returnedVariable) {\r\n\t\t\t\t\tcallback(property.returnedVariable)\r\n\t\t\t\t}\r\n\t\t\t\tif (property.hasChildNotifiers) {\r\n\t\t\t\t\tvar subProperties = property._properties\r\n\t\t\t\t\tif (subProperties) {\r\n\t\t\t\t\t\tforPropertyNotifyingValues(subProperties, callback)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction Variable(value) {\r\n\t\t\tif (this instanceof Variable) {\r\n\t\t\t\t// new call, may eventually use new.target\r\n\t\t\t\tif (value === undefined) {\r\n\t\t\t\t\tif (this.default !== undefined) {\r\n\t\t\t\t\t\tthis.value = this.default\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.value = value\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\treturn Variable.extend(value)\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar VariablePrototype = Variable.prototype = {\r\n\t\t\t// for debugging use\r\n\t\t\tget _currentValue() {\r\n\t\t\t\treturn this.valueOf()\r\n\t\t\t},\r\n\t\t\tset _currentValue(value) {\r\n\t\t\t\tthis.put(value)\r\n\t\t\t},\r\n\t\t\tconstructor: Variable,\r\n\t\t\tvalueOf: function(context) {\r\n\t\t\t\tvar valueContext\r\n\t\t\t\tif (this.parent) {\r\n\t\t\t\t\tif (context) {\r\n\t\t\t\t\t\tvalueContext = context.newContext()\r\n\t\t\t\t\t\tvalueContext.nextProperty = 'parent'\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar key = this.key\r\n\t\t\t\t\tvar property = this\r\n\t\t\t\t\tvar object = this.parent.valueOf(valueContext)\r\n\t\t\t\t\tvar gotValueAndListen = function(object) {\r\n\t\t\t\t\t\tvar value = property.gotValue(object == null ? undefined : typeof object.get === 'function' ? object.get(key) : object[key], context, valueContext)\r\n\t\t\t\t\t\tif (property.listeners) {\r\n\t\t\t\t\t\t\tvar listeners = propertyListenersMap.get(object)\r\n\t\t\t\t\t\t\tif (listeners && listeners.observer && listeners.observer.addKey) {\r\n\t\t\t\t\t\t\t\tlisteners.observer.addKey(key)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn value\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (object && object.then) {\r\n\t\t\t\t\t\t// call it initially so the dependencies can be registered\r\n\t\t\t\t\t\tthis.gotValue(null, context, valueContext)\r\n\t\t\t\t\t\treturn when(object, gotValueAndListen)\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn gotValueAndListen(object)\r\n\t\t\t\t}\r\n\t\t\t\treturn this.gotValue(this.getValue ?\r\n\t\t\t\t\tthis.getValue(context && (valueContext = context.newContext())) :\r\n\t\t\t\t\tthis.value, context, valueContext)\r\n\t\t\t},\r\n\t\t\tgotValue: function(value, parentContext, context) {\r\n\t\t\t\tvar previousNotifyingValue = this.returnedVariable\r\n\t\t\t\tvar variable = this\r\n\t\t\t\tif (previousNotifyingValue) {\r\n\t\t\t\t\tif (value === previousNotifyingValue) {\r\n\t\t\t\t\t\t// nothing changed, immediately return valueOf (or ownObject if we have it)\r\n\t\t\t\t\t\tif (variable.ownObject) {\r\n\t\t\t\t\t\t\treturn variable.ownObject\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (parentContext) {\r\n\t\t\t\t\t\t\tif (!context) {\r\n\t\t\t\t\t\t\t\tcontext = parentContext.newContext()\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tcontext.contextualize(this, parentContext)\r\n\t\t\t\t\t\t\tcontext.nextProperty = 'returnedVariable'\r\n\t\t\t\t\t\t\treturn value.valueOf(context)\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\treturn value.valueOf()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// if there was a another value that we were dependent on before, stop listening to it\r\n\t\t\t\t\t// TODO: we may want to consider doing cleanup after the next rendering turn\r\n\t\t\t\t\tif (variable.listeners) {\r\n\t\t\t\t\t\tpreviousNotifyingValue.stopNotifies(variable)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvariable.returnedVariable = null\r\n\t\t\t\t}\r\n\t\t\t\tif (value && value.notifies) {\r\n\t\t\t\t\tvariable.returnedVariable = value\r\n\t\t\t\t\tif (variable.listeners) {\r\n\t\t\t\t\t\tvalue.notifies(variable)\r\n\t\t\t\t\t}\r\n\t\t\t\t\t/*var parent = variable\r\n\t\t\t\t\tdo {\r\n\t\t\t\t\t\tif (parent.listeners) {\r\n\t\t\t\t\t\t\t// the value is another variable, start receiving notifications, if we, or any parent is live\r\n\t\t\t\t\t\t\tvariable.returnedVariable.notifies(variable)\r\n\t\t\t\t\t\t\tbreak\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tparent.hasNotifyingChild = true\r\n\t\t\t\t\t} while((parent = parent.parent))*/\r\n\t\t\t\t\tcontext = context || parentContext && (context = parentContext.newContext())\r\n\t\t\t\t\tif (context) {\r\n\t\t\t\t\t\tcontext.nextProperty = 'returnedVariable'\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvalue = value.valueOf(context)\r\n\t\t\t\t\tif (variable.ownObject) {\r\n\t\t\t\t\t\tif (getPrototypeOf(variable.ownObject) !== value) {\r\n\t\t\t\t\t\t\tsetPrototypeOf(variable.ownObject, value)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvalue = variable.ownObject\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (value === undefined) {\r\n\t\t\t\t\tvalue = variable.default\r\n\t\t\t\t}\r\n\t\t\t\tif (context) {\r\n\t\t\t\t\tcontext.contextualize(this, parentContext)\r\n\t\t\t\t}\r\n\t\t\t\tif (parentContext) {\r\n\t\r\n\t\t\t\t\t/*if (!contextualized.listeners) {\r\n\t\t\t\t\t\t// mark it as initialized, since we have already recursively dependended on inputs\r\n\t\t\t\t\t\tcontextualized.listeners = []\r\n\t\t\t\t\t}*/\r\n\t\r\n\t\t\t\t\tif (!context) {\r\n\t\t\t\t\t\tparentContext.addInput(this)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (value && value.then) {\r\n\t\t\t\t\treturn when(value, function(value) {\r\n\t\t\t\t\t\treturn Variable.prototype.gotValue.call(variable, value, context)\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t\treturn value\r\n\t\t\t},\r\n\t\t\tisMap: function() {\r\n\t\t\t\treturn this.value instanceof Map\r\n\t\t\t},\r\n\t\t\tPropertyClass: Variable,\r\n\t\t\tproperty: function(key, PropertyClass) {\r\n\t\t\t\tvar isMap = this.isMap()\r\n\t\t\t\tvar properties = this._properties || (this._properties = isMap ? new Map() : {})\r\n\t\t\t\tvar propertyVariable = isMap ? properties.get(key) : properties[key]\r\n\t\t\t\tif (!propertyVariable) {\r\n\t\t\t\t\t// create the property variable\r\n\t\t\t\t\tpropertyVariable = new (PropertyClass || this.PropertyClass)()\r\n\t\t\t\t\tpropertyVariable.key = key\r\n\t\t\t\t\tpropertyVariable.parent = this\r\n\t\t\t\t\tif (isMap) {\r\n\t\t\t\t\t\tproperties.set(key, propertyVariable)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tproperties[key] = propertyVariable\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn propertyVariable\r\n\t\t\t},\r\n\t\t\tfor: function(subject) {\r\n\t\t\t\tif (subject && subject.target && !subject.constructor.getForClass) {\r\n\t\t\t\t\t// makes HTML events work\r\n\t\t\t\t\tsubject = subject.target\r\n\t\t\t\t}\r\n\t\t\t\tif (this.parent) {\r\n\t\t\t\t\treturn this.parent.for(subject).property(this.key)\r\n\t\t\t\t}\r\n\t\t\t\treturn new ContextualizedVariable(this, subject || defaultContext)\r\n\t\t\t},\r\n\t\t\t_changeValue: function(context, type, newValue) {\r\n\t\t\t\tvar key = this.key\r\n\t\t\t\tvar parent = this.parent\r\n\t\t\t\tvar variable = this\r\n\t\t\t\tparent._willModify(context)\r\n\t\t\t\treturn when(parent.valueOf(context), function(object) {\r\n\t\t\t\t\tif (object == null) {\r\n\t\t\t\t\t\t// nothing there yet, create an object to hold the new property\r\n\t\t\t\t\t\tparent.put(object = typeof key == 'number' ? [] : {}, context)\r\n\t\t\t\t\t} else if (typeof object != 'object') {\r\n\t\t\t\t\t\t// if the parent is not an object, we can't set anything (that will be retained)\r\n\t\t\t\t\t\treturn deny\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar oldValue = typeof object.get === 'function' ? object.get(key) : object[key]\r\n\t\t\t\t\tif (oldValue === newValue) {\r\n\t\t\t\t\t\t// no actual change to make\r\n\t\t\t\t\t\treturn noChange\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (typeof object.set === 'function') {\r\n\t\t\t\t\t\tobject.set(key, newValue)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (type == RequestChange && oldValue && oldValue.put) {\r\n\t\t\t\t\t\t\t// if a put and the property value is a variable, assign it to that.\r\n\t\t\t\t\t\t\toldValue.put(newValue)\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tobject[key] = newValue\r\n\t\t\t\t\t\t\t// or set the setter/getter\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar event = new RefreshEvent()\r\n\t\t\t\t\tevent.oldValue = oldValue\r\n\t\t\t\t\tevent.target = variable\r\n\t\t\t\t\tvariable.updated(event, variable, context)\r\n\t\r\n\t\t\t\t\t// now notify any object listeners\r\n\t\t\t\t\tvar listeners = propertyListenersMap.get(object)\r\n\t\t\t\t\t// we need to do it before the other listeners, so we can update it before\r\n\t\t\t\t\t// we trigger a full clobbering of the object\r\n\t\t\t\t\tif (listeners) {\r\n\t\t\t\t\t\tlisteners = listeners.slice(0)\r\n\t\t\t\t\t\tfor (var i = 0, l = listeners.length; i < l; i++) {\r\n\t\t\t\t\t\t\tvar listener = listeners[i]\r\n\t\t\t\t\t\t\tif (listener !== parent) {\r\n\t\t\t\t\t\t\t\t// now go ahead and actually trigger the other listeners (but make sure we don't do the parent again)\r\n\t\t\t\t\t\t\t\tlistener._propertyChange(key, object, context, type)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\r\n\t\t\t_propertyChange: function(propertyName, object, context, type) {\r\n\t\t\t\tif (this.onPropertyChange) {\r\n\t\t\t\t\tthis.onPropertyChange(propertyName, object, context)\r\n\t\t\t\t}\r\n\t\t\t\tthis.updated(new PropertyChangeEvent(propertyName, new RefreshEvent(), this), null, context)\r\n\t\t\t},\r\n\t\t\teachKey: function(callback) {\r\n\t\t\t\tfor (var i in this._properties) {\r\n\t\t\t\t\tcallback(i)\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tapply: function(instance, args) {\r\n\t\t\t\treturn new Call(this, args)\r\n\t\t\t},\r\n\t\t\tcall: function(instance) {\r\n\t\t\t\treturn this.apply(instance, Array.prototype.slice.call(arguments, 1))\r\n\t\t\t},\r\n\t\t\tforDependencies: function(callback) {\r\n\t\t\t\tif (this.returnedVariable) {\r\n\t\t\t\t\tcallback(this.returnedVariable)\r\n\t\t\t\t}\r\n\t\t\t\tif (this.hasNotifyingChild) {\r\n\t\t\t\t\tvar properties = this._properties\r\n\t\t\t\t\tif (properties) {\r\n\t\t\t\t\t\tforPropertyNotifyingValues(properties, callback)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (this.parent) {\r\n\t\t\t\t\tcallback(this.parent)\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tinit: function() {\r\n\t\t\t\tvar variable = this\r\n\t\t\t\tthis.forDependencies(function(dependency) {\r\n\t\t\t\t\tdependency.notifies(variable)\r\n\t\t\t\t})\r\n\t\r\n\t\t\t\tif (this.listeningToObject === null) {\r\n\t\t\t\t\t// we were previously listening to an object, but it needs to be restored\r\n\t\t\t\t\t// calling valueOf will cause the listening object to be restored\r\n\t\t\t\t\tthis.valueOf()\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tcleanup: function() {\r\n\t\t\t\tthis.listeners = false\r\n\t\t\t\tvar handles = this.handles\r\n\t\t\t\tif (handles) {\r\n\t\t\t\t\tfor (var i = 0; i < handles.length; i++) {\r\n\t\t\t\t\t\thandles[i].remove()\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tthis.handles = null\r\n\t\t\t\tvar returnedVariable = this.returnedVariable\r\n\t\t\t\tif (returnedVariable) {\r\n\t\t\t\t\t// TODO: move this into the caching class\r\n\t\t\t\t\tthis.computedVariable = null\r\n\t\t\t\t}\r\n\t\t\t\tvar variable = this\r\n\t\t\t\tthis.forDependencies(function(dependency) {\r\n\t\t\t\t\tdependency.stopNotifies(variable)\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\r\n\t\t\tupdateVersion: function(version) {\r\n\t\t\t\tthis.version = nextId++\r\n\t\t\t},\r\n\t\r\n\t\t\tgetVersion: function(context) {\r\n\t\t\t\treturn Math.max(this.version || 0, this.returnedVariable && this.returnedVariable.getVersion ? this.returnedVariable.getVersion(context) : 0)\r\n\t\t\t},\r\n\t\r\n\t\t\tgetSubject: function(selectVariable) {\r\n\t\t\t\treturn this.subject\r\n\t\t\t},\r\n\t\r\n\t\t\tgetUpdates: function(since) {\r\n\t\t\t\tvar updates = []\r\n\t\t\t\tvar nextUpdateMap = this.nextUpdateMap\r\n\t\t\t\tif (nextUpdateMap && since) {\r\n\t\t\t\t\twhile ((since = nextUpdateMap.get(since))) {\r\n\t\t\t\t\t\tif (since.type === 'refresh') {\r\n\t\t\t\t\t\t\t// if it was refresh, we can clear any prior entries\r\n\t\t\t\t\t\t\tupdates = []\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tupdates.push(since)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn updates\r\n\t\t\t},\r\n\t\r\n\t\t\tupdated: function(updateEvent, by, context) {\r\n\t\t\t\tif (!updateEvent) {\r\n\t\t\t\t\tupdateEvent = new RefreshEvent()\r\n\t\t\t\t}\r\n\t\t\t\tif (updateEvent.visited.has(this)){\r\n\t\t\t\t\t// if this event has already visited this variable, skip it\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t\tupdateEvent.visited.add(this)\r\n\t\t\t\tif (this.__debug) {\r\n\t\t\t\t\t// debug is on\r\n\t\t\t\t\tconsole.log('Variable changed at')\r\n\t\t\t\t\tconsole.log((new Error().stack || '').replace(/Error/, ''))\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar contextualInstance = context ? context.getContextualized(this) : this\r\n\t\t\t\tif (contextualInstance) {\r\n\t\t\t\t\tcontextualInstance.updated(updateEvent, this, context)\r\n\t\t\t\t}\r\n\t\t\t\t/*\r\n\t\t\t\t// at some point we could do an update list so that we could incrementally update\r\n\t\t\t\t// lists in non-live situations\r\n\t\t\t\tif (this.lastUpdate) {\r\n\t\t\t\t\tvar nextUpdateMap = this.nextUpdateMap\r\n\t\t\t\t\tif (!nextUpdateMap) {\r\n\t\t\t\t\t\tnextUpdateMap = this.nextUpdateMap = new WeakMap()\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnextUpdateMap.set(this.lastUpdate, updateEvent)\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.lastUpdate = updateEvent */\r\n\t\t\t\tthis.updateVersion()\r\n\t\r\n\t\t\t\tvar listeners = this.listeners\r\n\t\t\t\tif (listeners) {\r\n\t\t\t\t\tvar variable = this\r\n\t\t\t\t\t// make a copy, in case they change\r\n\t\t\t\t\tlisteners.forEach(function(dependent) {\r\n\t\t\t\t\t\tif ((updateEvent instanceof PropertyChangeEvent) &&\r\n\t\t\t\t\t\t\t\tdependent.parent) {\r\n\t\t\t\t\t\t\tif (dependent.key === updateEvent.key) {\r\n\t\t\t\t\t\t\t\tdependent.updated(updateEvent.childEvent, variable, context)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tdependent.updated(updateEvent, variable, context)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t\tif (updateEvent instanceof PropertyChangeEvent) {\r\n\t\t\t\t\tif (this.returnedVariable && this.fixed) {\r\n\t\t\t\t\t\tthis.returnedVariable.updated(updateEvent, this, context)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (this.constructor.collection) {\r\n\t\t\t\t\t\tthis.constructor.collection.updated(updateEvent, this, context)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (this.parent) {\r\n\t\t\t\t\t\tthis.parent.updated(new PropertyChangeEvent(this.key, updateEvent, this.parent), this, context)\r\n\t\t\t\t}\r\n\t\t\t\treturn updateEvent\r\n\t\t\t},\r\n\t\r\n\t\t\tinvalidate: function() {\r\n\t\t\t\t// for back-compatibility for now\r\n\t\t\t\tthis.updated()\r\n\t\t\t},\r\n\t\r\n\t\t\tnotifies: function(target) {\r\n\t\t\t\tvar listeners = this.listeners\r\n\t\t\t\tif (!listeners || !this.hasOwnProperty('listeners')) {\r\n\t\t\t\t\tthis.listeners = listeners = new Set()\r\n\t\t\t\t\tthis.init()\r\n\t\t\t\t}\r\n\t\t\t\tlisteners.add(target)\r\n\t\t\t},\r\n\t\t\tsubscribe: function(listener) {\r\n\t\t\t\t// ES7 Observable (and baconjs) compatible API\r\n\t\t\t\tvar updated\r\n\t\t\t\tvar updateQueued\r\n\t\t\t\tvar variable = this\r\n\t\t\t\t// it is important to make sure you register for notifications before getting the value\r\n\t\t\t\tif (typeof listener === 'function') {\r\n\t\t\t\t\t// BaconJS compatible API\r\n\t\t\t\t\tvar variable = this\r\n\t\t\t\t\tvar event = {\r\n\t\t\t\t\t\tvalue: function() {\r\n\t\t\t\t\t\t\treturn variable.valueOf()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tupdated = function() {\r\n\t\t\t\t\t\tupdateQueued = false\r\n\t\t\t\t\t\tlistener(event)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\telse if (listener.next) {\r\n\t\t\t\t\t// Assuming ES7 Observable API. It is actually a streaming API, this pretty much violates all principles of reactivity, but we will support it\r\n\t\t\t\t\tupdated = function() {\r\n\t\t\t\t\t\tupdateQueued = false\r\n\t\t\t\t\t\tlistener.next(variable.valueOf())\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow new Error('Subscribing to an invalid listener, the listener must be a function, or have an update or next method')\r\n\t\t\t\t}\r\n\t\t\t\tvar updateReceiver = {\r\n\t\t\t\t\tupdated: function() {\r\n\t\t\t\t\t\tif (updateQueued) {\r\n\t\t\t\t\t\t\treturn\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tupdateQueued = true\r\n\t\t\t\t\t\tlang.nextTurn(updated)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tupdated()\r\n\t\t\t\tthis.notifies(updateReceiver)\r\n\t\t\t\treturn {\r\n\t\t\t\t\tunsubscribe: function() {\r\n\t\t\t\t\t\tvariable.stopNotifies(updateReceiver)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tstopNotifies: function(dependent) {\r\n\t\t\t\tvar listeners = this.listeners\r\n\t\t\t\tif (listeners) {\r\n\t\t\t\t\tlisteners.delete(dependent)\r\n\t\t\t\t\tif (listeners.size === 0) {\r\n\t\t\t\t\t\t// clear the listeners so it will be reinitialized if it has\r\n\t\t\t\t\t\t// listeners again\r\n\t\t\t\t\t\tthis.cleanup()\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tput: function(value, context) {\r\n\t\t\t\tvar variable = this\r\n\t\t\t\tif (this.parent) {\r\n\t\t\t\t\treturn this._changeValue(context, RequestChange, value)\r\n\t\t\t\t}\r\n\t\t\t\tif (this.ownObject) {\r\n\t\t\t\t\tthis.ownObject = false\r\n\t\t\t\t}\r\n\t\t\t\treturn when(this.getValue ? this.getValue(context) : this.value, function(oldValue) {\r\n\t\t\t\t\tif (oldValue === value) {\r\n\t\t\t\t\t\treturn noChange\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (variable.fixed &&\r\n\t\t\t\t\t\t\t// if it is set to fixed, we see we can put in the current variable\r\n\t\t\t\t\t\t\toldValue && oldValue.put) {\r\n\t\t\t\t\t\treturn oldValue.put(value)\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn when(variable.setValue(value, context), function(value) {\r\n\t\t\t\t\t\tvar event = new RefreshEvent()\r\n\t\t\t\t\t\tevent.oldValue = oldValue\r\n\t\t\t\t\t\tevent.target = variable\r\n\t\t\t\t\t\tvariable.updated(event, variable, context)\r\n\t\t\t\t\t})\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tget: function(key) {\r\n\t\t\t\tif (this._properties && this._properties[key]) {\r\n\t\t\t\t\treturn this.property(key).valueOf()\r\n\t\t\t\t}\r\n\t\t\t\treturn when(this.valueOf(), function(object) {\r\n\t\t\t\t\tvar value = object && (typeof object.get === 'function' ? object.get(key) : object[key])\r\n\t\t\t\t\tif (value && value.notifies) {\r\n\t\t\t\t\t\t// nested variable situation, get underlying value\r\n\t\t\t\t\t\treturn value.valueOf()\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn value\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tset: function(key, value) {\r\n\t\t\t\t// TODO: create an optimized route when the property doesn't exist yet\r\n\t\t\t\tthis.property(key)._changeValue(null, RequestSet, value)\r\n\t\t\t},\r\n\t\t\tundefine: function(key, context) {\r\n\t\t\t\tthis.set(key, undefined, context)\r\n\t\t\t},\r\n\t\t\tproxy: function(proxiedVariable) {\r\n\t\t\t\tvar thisVariable = this\r\n\t\t\t\tthis.fixed = true\r\n\t\t\t\treturn when(this.setValue(proxiedVariable), function(value) {\r\n\t\t\t\t\tthisVariable.updated(new RefreshEvent(), thisVariable)\r\n\t\t\t\t\treturn thisVariable\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tnext: function(value) {\r\n\t\t\t\t// for ES7 observable compatibility\r\n\t\t\t\tthis.put(value)\r\n\t\t\t},\r\n\t\t\terror: function(error) {\r\n\t\t\t\t// for ES7 observable compatibility\r\n\t\t\t\tvar listeners = this.listeners\r\n\t\t\t\tif (listeners) {\r\n\t\t\t\t\t// make a copy, in case they change\r\n\t\t\t\t\tlisteners.forEach(function(dependent) {\r\n\t\t\t\t\t\t// skip notifying property listeners if we are headed up the parent chain\r\n\t\t\t\t\t\tdependent.error(error)\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tcomplete: function(value) {\r\n\t\t\t\t// for ES7 observable compatibility\r\n\t\t\t\tthis.put(value)\r\n\t\t\t},\r\n\t\t\tsetValue: function(value) {\r\n\t\t\t\tthis.value = value\r\n\t\t\t},\r\n\t\t\tonValue: function(listener) {\r\n\t\t\t\treturn this.subscribe(function(event) {\r\n\t\t\t\t\tlang.when(event.value(), function(value) {\r\n\t\t\t\t\t\tlistener(value)\r\n\t\t\t\t\t})\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\ttoJSON: function() {\r\n\t\t\t\treturn this.valueOf()\r\n\t\t\t},\r\n\t\t\ttoString: function() {\r\n\t\t\t\treturn this.valueOf()\r\n\t\t\t},\r\n\t\t\tforEach: function(callbackOrItemClass, callbackOrContext, context) {\r\n\t\t\t\t// iterate through current value of variable\r\n\t\t\t\tif (callbackOrItemClass.notifies) {\r\n\t\t\t\t\treturn this.forEach(function(item) {\r\n\t\t\t\t\t\tvar itemVariable = callbackOrItemClass.from(item)\r\n\t\t\t\t\t\tcallbackOrContext.call(this, itemVariable)\r\n\t\t\t\t\t}, context)\r\n\t\t\t\t}\r\n\t\t\t\treturn when(this.valueOf(callbackOrContext), function(value) {\r\n\t\t\t\t\tif (value && value.forEach) {\r\n\t\t\t\t\t\tvalue.forEach(callbackOrItemClass)\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tfor (var i in value) {\r\n\t\t\t\t\t\t\tcallbackOrItemClass.call(value, value[i], i)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\r\n\t\t\tto: function (transformFunction, reverse) {\r\n\t\t\t\tif (typeof transformFunction !== 'function') {\r\n\t\t\t\t\tif (typeof transformFunction === 'object') {\r\n\t\t\t\t\t\tthis.to(transformFunction.get, transformFunction.set)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthrow new Error('No function provided to transform')\r\n\t\t\t\t}\r\n\t\t\t\tif (reverse) {\r\n\t\t\t\t\ttransformFunction.reverse = function(value, args, context) {\r\n\t\t\t\t\t\t// for direct to, we can just use the first argument\r\n\t\t\t\t\t\treverse.call(this, args[0], context)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn new Call(transformFunction, [this])\r\n\t\t\t},\r\n\t\t\tget schema() {\r\n\t\t\t\t// default schema is the constructor\r\n\t\t\t\tif (this.parent) {\r\n\t\t\t\t\tvar parentSchemaProperties = this.parent.schema.properties\r\n\t\t\t\t\treturn parentSchemaProperties && parentSchemaProperties[this.key]\r\n\t\t\t\t}\r\n\t\t\t\treturn this.returnedVariable ? this.returnedVariable.schema : this.constructor\r\n\t\t\t},\r\n\t\t\tset schema(schema) {\r\n\t\t\t\t// but allow it to be overriden\r\n\t\t\t\tObject.defineProperty(this, 'schema', {\r\n\t\t\t\t\tvalue: schema\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tvalidate: function(target, schema) {\r\n\t\t\t\tif (this.returnedVariable) {\r\n\t\t\t\t\treturn this.returnedVariable.validate(target, schema)\r\n\t\t\t\t}\r\n\t\t\t\tif (this.parent) {\r\n\t\t\t\t\treturn this.parent.validate(target.valueOf(), schema)\r\n\t\t\t\t}\r\n\t\t\t\tif (schema && schema.type && (schema.type !== typeof target)) {\r\n\t\t\t\t\treturn ['Target type of ' + typeof target + ' does not match schema type of ' + schema.type]\r\n\t\t\t\t}\r\n\t\t\t\tvar valid = []\r\n\t\t\t\tvalid.isValid = true\r\n\t\t\t\treturn valid\r\n\t\t\t},\r\n\t\r\n\t\t\tget validation() {\r\n\t\t\t\tvar validation = new Validating(this)\r\n\t\t\t\tObject.defineProperty(this, 'validation', {\r\n\t\t\t\t\tvalue: validation\r\n\t\t\t\t})\r\n\t\t\t\treturn validation\r\n\t\t\t},\r\n\t\t\tset validation(validation) {\r\n\t\t\t\t// but allow it to be overriden\r\n\t\t\t\tObject.defineProperty(this, 'validation', {\r\n\t\t\t\t\tvalue: validation\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tset structured(structure) {\r\n\t\t\t\t// find any variable properties and attaches them as a property\r\n\t\t\t\tvar keys = Object.keys(this)\r\n\t\t\t\tvar properties = keys.length > 1 && this._properties || (this._properties = {})\r\n\t\t\t\tfor(var i = 0, l = keys.length; i < l; i++) {\r\n\t\t\t\t\tvar key = keys[i]\r\n\t\t\t\t\tvar value = this[key]\r\n\t\t\t\t\tif (value instanceof Variable) {\r\n\t\t\t\t\t\tvar existing = properties[key]\r\n\t\t\t\t\t\tif (existing) {\r\n\t\t\t\t\t\t\tif (existing !== value) {\r\n\t\t\t\t\t\t\t\t// an existing property exists, put in it\r\n\t\t\t\t\t\t\t\texisting.put(value)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tif (value.parent) {\r\n\t\t\t\t\t\t\t\tif (value.parent === this) {\r\n\t\t\t\t\t\t\t\t\tcontinue // just being assigned to another property\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t// property already exists with different parent, make a proxy\r\n\t\t\t\t\t\t\t\t\tvar newValue = new Variable()\r\n\t\t\t\t\t\t\t\t\tnewValue.proxy(value)\r\n\t\t\t\t\t\t\t\t\tvalue = newValue\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tvalue.key = key\r\n\t\t\t\t\t\t\tvalue.parent = this\r\n\t\t\t\t\t\t\tproperties[key] = value\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tgetId: function() {\r\n\t\t\t\treturn this.id || (this.id = nextId++)\r\n\t\t\t},\r\n\t\t\tobserveObject: function() {\r\n\t\t\t\tvar variable = this\r\n\t\t\t\treturn when(this.valueOf(), function(object) {\r\n\t\t\t\t\tvar listeners = propertyListenersMap.get(object)\r\n\t\t\t\t\tif (!listeners) {\r\n\t\t\t\t\t\tpropertyListenersMap.set(object, listeners = [])\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (listeners.observerCount) {\r\n\t\t\t\t\t\tlisteners.observerCount++\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tlisteners.observerCount = 1\r\n\t\t\t\t\t\tvar observer = listeners.observer = lang.observe(object, function(events) {\r\n\t\t\t\t\t\t\tfor (var i = 0, l = listeners.length; i < l; i++) {\r\n\t\t\t\t\t\t\t\tvar listener = listeners[i]\r\n\t\t\t\t\t\t\t\tfor (var j = 0, el = events.length; j < el; j++) {\r\n\t\t\t\t\t\t\t\t\tvar event = events[j]\r\n\t\t\t\t\t\t\t\t\tlistener._propertyChange(event.name, object)\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t\tif (observer.addKey) {\r\n\t\t\t\t\t\t\tfor (var i = 0, l = listeners.length; i < l; i++) {\r\n\t\t\t\t\t\t\t\tvar listener = listeners[i]\r\n\t\t\t\t\t\t\t\tlistener.eachKey(function(key) {\r\n\t\t\t\t\t\t\t\t\tobserver.addKey(key)\r\n\t\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tregisterListener(object, variable)\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tremove: function() {\r\n\t\t\t\t\t\t\tderegisterListener(object, variable)\r\n\t\t\t\t\t\t\tif (!(--listeners.observerCount)) {\r\n\t\t\t\t\t\t\t\tlisteners.observer.remove()\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tdone: function() {\r\n\t\t\t\t\t\t\t// deliver changes\r\n\t\t\t\t\t\t\tlang.deliverChanges(observer)\r\n\t\t\t\t\t\t\tthis.remove()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tgetCollectionOf: function() {\r\n\t\t\t\treturn this.constructor.collectionOf\r\n\t\t\t},\r\n\t\t\t_willModify: function(context) {\r\n\t\t\t\t// an intent to modify, so we need to make sure we have our own copy\r\n\t\t\t\t// of an object when necessary\r\n\t\t\t\tif (this.fixed) {\r\n\t\t\t\t\tif (this.value && this.value._willModify) {\r\n\t\t\t\t\t\treturn this.value._willModify(context)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (!this.ownObject && this.value && this.value.notifies) {\r\n\t\t\t\t\tvar variable = this\r\n\t\t\t\t\treturn when(this.valueOf(context), function(value) {\r\n\t\t\t\t\t\tif (value && typeof value === 'object') {\r\n\t\t\t\t\t\t\tif (value instanceof Array) {\r\n\t\t\t\t\t\t\t\tvariable.ownObject = value.slice(0)\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tvariable.ownObject = Object.create(value)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t} else if (this.parent) {\r\n\t\t\t\t\tthis.parent._willModify()\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\t_sN: function(name) {\r\n\t\t\t\t// for compilers to set a name\r\n\t\t\t\tthis.name = name\r\n\t\t\t\treturn this\r\n\t\t\t},\r\n\t\t\tget _debug() {\r\n\t\t\t\tif (this.__debug === undefined) {\r\n\t\t\t\t\tthis.__debug = true\r\n\t\t\t\t}\r\n\t\t\t\treturn this.__debug\r\n\t\t\t},\r\n\t\t\tset _debug(_debug) {\r\n\t\t\t\tthis.__debug = _debug\r\n\t\t\t},\r\n\t\t\t// TODO: Move these to VArray\r\n\t\t\tsplice: function(startingIndex, removalCount) {\r\n\t\t\t\tvar args = arguments\r\n\t\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\t\tvar results = array.splice.apply(array, args)\r\n\t\t\t\t\tremovedAt(this, results, startingIndex, removalCount, array.length)\r\n\t\t\t\t\tinsertedAt(this, [].slice.call(args, 2), startingIndex, array.length)\r\n\t\t\t\t\treturn results\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tpush: function() {\r\n\t\t\t\tvar args = arguments\r\n\t\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\t\tvar results = array.push.apply(array, args)\r\n\t\t\t\t\tinsertedAt(this, args, array.length - args.length, array.length)\r\n\t\t\t\t\treturn results\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tunshift: function() {\r\n\t\t\t\tvar args = arguments\r\n\t\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\t\tvar results = array.unshift.apply(array, args)\r\n\t\t\t\t\tinsertedAt(this, args, 0, array.length)\r\n\t\t\t\t\treturn results\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tpop: function() {\r\n\t\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\t\tvar results = array.pop()\r\n\t\t\t\t\tremovedAt(this, [results], array.length, 1)\r\n\t\t\t\t\treturn results\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tshift: function() {\r\n\t\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\t\tvar results = array.shift()\r\n\t\t\t\t\tremovedAt(this, [results], 0, 1, array.length)\r\n\t\t\t\t\treturn results\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction arrayToModify(variable, callback) {\r\n\t\t\tvariable._willModify()\r\n\t\t\t// TODO: switch this to allow promises\r\n\t\t\twhen(variable.cachedValue || variable.valueOf(), function(array) {\r\n\t\t\t\tif (!array) {\r\n\t\t\t\t\tvariable.put(array = [])\r\n\t\t\t\t}\r\n\t\t\t\tvariable.updateVersion()\r\n\t\t\t\tvar results = callback.call(variable, array)\r\n\t\t\t\tvariable.cachedVersion = variable.version // update the cached version so it doesn't need to be recomputed\r\n\t\t\t\treturn results\r\n\t\t\t})\r\n\t\t}\r\n\t\r\n\t\tfunction insertedAt(variable, added, startingIndex, arrayLength) {\r\n\t\t\tvar addedCount = added.length\r\n\t\t\t// adjust the key positions of any index properties after splice\r\n\t\t\tif (addedCount > 0) {\r\n\t\t\t\tif (variable._properties) {\r\n\t\t\t\t\tvar arrayPosition\r\n\t\t\t\t\tfor (var i = arrayLength - addedCount; i > startingIndex;) {\r\n\t\t\t\t\t\tvar arrayPosition = variable._properties[--i]\r\n\t\t\t\t\t\tif (arrayPosition) {\r\n\t\t\t\t\t\t\tvariable._properties[i] = undefined\r\n\t\t\t\t\t\t\tarrayPosition.key += addedCount\r\n\t\t\t\t\t\t\tvariable._properties[arrayPosition.key] = arrayPosition\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// send out updates\r\n\t\t\t\tfor (var i = 0, l = added.length; i < l; i++) {\r\n\t\t\t\t\tvariable.updated(new AddEvent({\r\n\t\t\t\t\t\tvalue: added[i],\r\n\t\t\t\t\t\tindex: i + startingIndex,\r\n\t\t\t\t\t\tmodifier: variable\r\n\t\t\t\t\t}), variable)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction removedAt(variable, removed, startingIndex, removalCount, arrayLength) {\r\n\t\t\t// adjust the properties\r\n\t\t\tvar i = startingIndex + removalCount\r\n\t\t\tvar arrayPosition\r\n\t\t\tif (removalCount > 0) {\r\n\t\t\t\tif (variable._properties) {\r\n\t\t\t\t\tfor (var i = startingIndex + removalCount; i < arrayLength + removalCount; i++) {\r\n\t\t\t\t\t\tvar arrayPosition = variable._properties[i]\r\n\t\t\t\t\t\tif (arrayPosition) {\r\n\t\t\t\t\t\t\tvariable._properties[i] = undefined\r\n\t\t\t\t\t\t\tarrayPosition.key -= removalCount\r\n\t\t\t\t\t\t\tvariable._properties[arrayPosition.key] = arrayPosition\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// send out updates\r\n\t\t\t\tfor (var i = 0; i < removalCount; i++) {\r\n\t\t\t\t\tvariable.updated(new DeleteEvent({\r\n\t\t\t\t\t\tpreviousIndex: startingIndex,\r\n\t\t\t\t\t\toldValue: removed[i],\r\n\t\t\t\t\t\tmodifier: variable\r\n\t\t\t\t\t}), variable)\r\n\t\t\t\t}\r\n\t\t\t\tvariable.cachedVersion = variable.version // update the cached version so it doesn't need to be recomputed\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tif (typeof Symbol !== 'undefined') {\r\n\t\t\tVariable.prototype[Symbol.iterator] = function() {\r\n\t\t\t\treturn this.valueOf()[Symbol.iterator]()\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tVariable.VMap = lang.compose(Variable, function(value){\r\n\t\t\tthis.value = typeof value === 'undefined' ? this.default : value\r\n\t\t}, {\r\n\t\t\t// TODO: Move all the get and set functionality for maps out of Variable\r\n\t\t\tproperty: function(key, PropertyClass) {\r\n\t\t\t\tvar properties = this._properties || (this._properties = new Map())\r\n\t\t\t\tvar propertyVariable = properties.get(key)\r\n\t\t\t\tif (!propertyVariable) {\r\n\t\t\t\t\t// create the property variable\r\n\t\t\t\t\tpropertyVariable = new (PropertyClass || this.PropertyClass)()\r\n\t\t\t\t\tpropertyVariable.key = key\r\n\t\t\t\t\tpropertyVariable.parent = this\r\n\t\t\t\t\tproperties.set(key, propertyVariable)\r\n\t\t\t\t}\r\n\t\t\t\treturn propertyVariable\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\tvar Caching = Variable.Caching = lang.compose(Variable, function Caching(getValue, setValue) {\r\n\t\t\tif (getValue) {\r\n\t\t\t\tthis.getValue = getValue\r\n\t\t\t}\r\n\t\t\tif (setValue) {\r\n\t\t\t\tthis.setValue = setValue\r\n\t\t\t}\r\n\t\t}, {\r\n\t\t\tvalueOf: function(context) {\r\n\t\t\t\t// first check to see if we have the variable already computed\r\n\t\t\t\tvar contextualizedVariable = this\r\n\t\t\t\tif (context) {\r\n\t\t\t\t\tcontextualizedVariable = context.getContextualized(this)\r\n\t\t\t\t\tif (!contextualizedVariable && this.context && this.context.matches(context)) {\r\n\t\t\t\t\t\tcontextualizedVariable = this\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (contextualizedVariable && contextualizedVariable.cachedVersion === contextualizedVariable.getVersion()) {\r\n\t\t\t\t\tif (context) {\r\n\t\t\t\t\t\tcontext.addInput(contextualizedVariable)\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn contextualizedVariable.cachedValue\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar variable = this\r\n\t\t\t\tfunction withComputedValue(computedValue) {\r\n\t\t\t\t\tif (computedValue && computedValue.notifies && variable.listeners) {\r\n\t\t\t\t\t\tvariable.computedVariable = computedValue\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcomputedValue = variable.gotValue(computedValue, context, transformContext)\r\n\t\t\t\t\tvar contextualizedVariable = transformContext && transformContext.contextualized || variable\r\n\t\t\t\t\tcontextualizedVariable.cachedVersion = newVersion\r\n\t\t\t\t\tcontextualizedVariable.cachedValue = computedValue\r\n\t\t\t\t\tcontextualizedVariable.context = transformContext\r\n\t\t\t\t\treturn computedValue\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar transformContext\r\n\t\t\t\tif (context) {\r\n\t\t\t\t\ttransformContext = context.newContext()\r\n\t\t\t\t}\r\n\t\t\t\tvar newVersion = this.getVersion()\r\n\t\t\t\tvar computedValue = this.getValue(transformContext)\r\n\t\t\t\tif (computedValue && computedValue.then) {\r\n\t\t\t\t\t// call it initially so the dependencies can be registered\r\n\t\t\t\t\tthis.gotValue(null, context, transformContext)\r\n\t\t\t\t\treturn computedValue.then(withComputedValue)\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn withComputedValue(computedValue)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\tvar Item = Variable.Item = lang.compose(Variable, function Item(value, content) {\r\n\t\t\tthis.value = value\r\n\t\t\tthis.collection = content\r\n\t\t}, {})\r\n\t\r\n\t\tvar Composite = Variable.Composite = lang.compose(Caching, function Composite(args) {\r\n\t\t\tfor (var i = 0, l = args.length; i < l; i++) {\r\n\t\t\t\tthis[i > 0 ? 'input' + i : 'input'] = args[i]\r\n\t\t\t}\r\n\t\t}, {\r\n\t\t\tforDependencies: function(callback) {\r\n\t\t\t\t// depend on the args\r\n\t\t\t\tCaching.prototype.forDependencies.call(this, callback)\r\n\t\t\t\tvar argument, argumentName\r\n\t\t\t\tfor (var i = 0; (argument = this[argumentName = i > 0 ? 'input' + i : 'input']) || argumentName in this; i++) {\r\n\t\t\t\t\tif (argument && argument.notifies) {\r\n\t\t\t\t\t\tcallback(argument)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\r\n\t\t\tupdated: function(updateEvent, by, context) {\r\n\t\t\t\tif (by !== this.returnedVariable && updateEvent && updateEvent.type !== 'refresh') {\r\n\t\t\t\t\t// search for the output in the inputs\r\n\t\t\t\t\tvar argument, argumentName\r\n\t\t\t\t\tfor (var i = 0; (argument = this[argumentName = i > 0 ? 'input' + i : 'input']) || argumentName in this; i++) {\r\n\t\t\t\t\t\tif (argument === by) {\r\n\t\t\t\t\t\t\t// if one of the args was updated, we need to do a full refresh (we can't compute differential events without knowledge of how the mapping function works)\r\n\t\t\t\t\t\t\tupdateEvent = new RefreshEvent()\r\n\t\t\t\t\t\t\tcontinue\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn Caching.prototype.updated.call(this, updateEvent, by, context)\r\n\t\t\t},\r\n\t\r\n\t\t\tgetUpdates: function(since) {\r\n\t\t\t\t// this always issues updates, nothing incremental can flow through it\r\n\t\t\t\tif (!since || since.version < getVersion()) {\r\n\t\t\t\t\treturn [new RefreshEvent()]\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\r\n\t\t\tgetVersion: function(context) {\r\n\t\t\t\tvar version = Variable.prototype.getVersion.call(this, context)\r\n\t\t\t\tvar argument, argumentName\r\n\t\t\t\tfor (var i = 0; (argument = this[argumentName = i > 0 ? 'input' + i : 'input']) || argumentName in this; i++) {\r\n\t\t\t\t\tif (argument && argument.getVersion) {\r\n\t\t\t\t\t\tversion = Math.max(version, argument.getVersion(context))\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn version\r\n\t\t\t},\r\n\t\r\n\t\t\tgetValue: function(context) {\r\n\t\t\t\tvar results = []\r\n\t\t\t\tvar argument, argumentName\r\n\t\t\t\tfor (var i = 0; (argument = this[argumentName = i > 0 ? 'input' + i : 'input']) || argumentName in this; i++) {\r\n\t\t\t\t\tif (context) {\r\n\t\t\t\t\t\tcontext.nextProperty = argumentName\r\n\t\t\t\t\t}\r\n\t\t\t\t\tresults[i] = argument && argument.valueOf(context)\r\n\t\t\t\t}\r\n\t\t\t\treturn whenAll(results, function(resolved) {\r\n\t\t\t\t\treturn resolved\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tgetArguments: function() {\r\n\t\t\t\tvar args = []\r\n\t\t\t\tvar argument, argumentName\r\n\t\t\t\tfor (var i = 0; (argument = this[argumentName = i > 0 ? 'input' + i : 'input']) || argumentName in this; i++) {\r\n\t\t\t\t\targs.push(argument)\r\n\t\t\t\t}\r\n\t\t\t\treturn args\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\t// a call variable is the result of a call\r\n\t\tvar Call = lang.compose(Composite, function Transform(transform, args) {\r\n\t\t\tif (transform) {\r\n\t\t\t\tthis.transform = transform\r\n\t\t\t\tfor (var i = 0, l = args.length; i < l; i++) {\r\n\t\t\t\t\tthis[i > 0 ? 'input' + i : 'input'] = args[i]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}, {\r\n\t\t\tfixed: true,\r\n\t\t\tforDependencies: function(callback) {\r\n\t\t\t\t// depend on the args\r\n\t\t\t\tComposite.prototype.forDependencies.call(this, callback)\r\n\t\t\t\tif (this.transform.notifies) {\r\n\t\t\t\t\tcallback(this.transform)\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\r\n\t\t\tgetValue: function(context) {\r\n\t\t\t\tif (context) {\r\n\t\t\t\t\tcontext.nextProperty = 'transform'\r\n\t\t\t\t}\r\n\t\t\t\tvar functionValue = this.transform.valueOf(context)\r\n\t\t\t\tif (functionValue.then) {\r\n\t\t\t\t\tvar call = this\r\n\t\t\t\t\treturn functionValue.then(function(functionValue) {\r\n\t\t\t\t\t\treturn call.invoke(functionValue, context)\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t\treturn this.invoke(functionValue, context)\r\n\t\t\t},\r\n\t\r\n\t\t\tgetVersion: function(context) {\r\n\t\t\t\t// TODO: shortcut if we are live and since equals this.lastUpdate\r\n\t\t\t\tvar argsVersion = Composite.prototype.getVersion.call(this, context)\r\n\t\t\t\tif (this.transform.getVersion) {\r\n\t\t\t\t\treturn Math.max(argsVersion, this.transform.getVersion(context))\r\n\t\t\t\t}\r\n\t\t\t\treturn argsVersion\r\n\t\t\t},\r\n\t\r\n\t\t\texecute: function(context) {\r\n\t\t\t\tvar call = this\r\n\t\t\t\treturn when(this.transform.valueOf(context), function(functionValue) {\r\n\t\t\t\t\treturn call.invoke(functionValue, context, true)\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\r\n\t\t\tput: function(value, context) {\r\n\t\t\t\tvar call = this\r\n\t\t\t\treturn when(this.valueOf(context), function(originalValue) {\r\n\t\t\t\t\tif (originalValue === value) {\r\n\t\t\t\t\t\treturn noChange\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn when(call.transform.valueOf(context), function(functionValue) {\r\n\t\t\t\t\t\treturn call.invoke(function() {\r\n\t\t\t\t\t\t\tif (functionValue.reverse) {\r\n\t\t\t\t\t\t\t\tfunctionValue.reverse.call(call, value, call.getArguments(), context)\r\n\t\t\t\t\t\t\t\treturn Variable.prototype.put.call(call, value, context)\r\n\t\t\t\t\t\t\t} else if (originalValue && originalValue.put) {\r\n\t\t\t\t\t\t\t\treturn originalValue.put(value)\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\treturn deny\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}, context)\r\n\t\t\t\t\t});\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tinvoke: function(functionValue, context, observeArguments) {\r\n\t\t\t\tvar instance = this.transform.parent\r\n\t\t\t\tvar variable = this\r\n\t\t\t\tif (functionValue.handlesVariables || functionValue.property) {\r\n\t\t\t\t\treturn functionValue.apply(instance, this.getArguments(), context)\r\n\t\t\t\t}else{\r\n\t\t\t\t\tvar results = []\r\n\t\t\t\t\tvar argument, argumentName\r\n\t\t\t\t\tfor (var i = 0; (argument = this[argumentName = i > 0 ? 'input' + i : 'input']) || argumentName in this; i++) {\r\n\t\t\t\t\t\tif (context) {\r\n\t\t\t\t\t\t\tcontext.nextProperty = argumentName\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tresults[i] = argument && argument.valueOf(context)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tinstance = instance && instance.valueOf(context)\r\n\t\t\t\t\tif (functionValue.handlesPromises) {\r\n\t\t\t\t\t\treturn functionValue.apply(instance, results, context)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// include the instance in whenAll\r\n\t\t\t\t\t\tresults.push(instance)\r\n\t\t\t\t\t\t// wait for the values to be received\r\n\t\t\t\t\t\treturn whenAll(results, function(inputs) {\r\n\t\t\t\t\t\t\tif (observeArguments) {\r\n\t\t\t\t\t\t\t\tvar handles = []\r\n\t\t\t\t\t\t\t\tfor (var i = 0, l = inputs.length; i < l; i++) {\r\n\t\t\t\t\t\t\t\t\tvar input = inputs[i]\r\n\t\t\t\t\t\t\t\t\tif (input && typeof input === 'object') {\r\n\t\t\t\t\t\t\t\t\t\thandles.push(observe(input))\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tvar instance = inputs.pop()\r\n\t\t\t\t\t\t\t\ttry{\r\n\t\t\t\t\t\t\t\t\tvar result = functionValue.apply(instance || variable, inputs, context)\r\n\t\t\t\t\t\t\t\t}finally{\r\n\t\t\t\t\t\t\t\t\twhen(result, function() {\r\n\t\t\t\t\t\t\t\t\t\tfor (var i = 0; i < l; i++) {\r\n\t\t\t\t\t\t\t\t\t\t\thandles[i].done()\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\treturn result\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tvar instance = inputs.pop()\r\n\t\t\t\t\t\t\treturn functionValue.apply(instance || variable, inputs, context)\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tsetReverse: function(reverse) {\r\n\t\t\t\tthis.transform.valueOf().reverse = reverse\r\n\t\t\t\treturn this\r\n\t\t\t},\r\n\t\t\tgetCollectionOf: function() {\r\n\t\t\t\treturn this.returnedVariable && this.returnedVariable.getCollectionOf()\r\n\t\t\t}\r\n\t\t})\r\n\t\tVariable.Call = Call\r\n\t\r\n\t\tvar ContextualizedVariable = lang.compose(Variable, function ContextualizedVariable(generic, subject) {\r\n\t\t\tthis.generic = generic\r\n\t\t\tthis.subject = subject\r\n\t\t}, {\r\n\t\t\tvalueOf: function() {\r\n\t\t\t\t// TODO: Lookup Context type for all of these using registry or something\r\n\t\t\t\tvar subject = this.subject\r\n\t\t\t\treturn this.generic.valueOf(subject.getContextualized ? subject : new Context(subject))\r\n\t\t\t},\r\n\t\r\n\t\t\tforDependencies: function(callback) {\r\n\t\t\t\tthis.inputs && this.inputs.forEach(callback)\r\n\t\t\t},\r\n\t\r\n\t\t\tgetVersion: function() {\r\n\t\t\t\tvar version = Variable.prototype.getVersion.call(this)\r\n\t\t\t\tvar inputs = this.inputs || 0\r\n\t\t\t\tfor (var i = 0, l = inputs.length; i < l; i++) {\r\n\t\t\t\t\tvar input = inputs[i]\r\n\t\t\t\t\tif (input.getVersion) {\r\n\t\t\t\t\t\tversion = Math.max(version, input.getVersion())\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn version\r\n\t\t\t},\r\n\t\r\n\t\t\tput: function(value) {\r\n\t\t\t\tvar subject = this.subject\r\n\t\t\t\treturn this.generic.put(value, subject.getContextualized ? subject : new Context(subject))\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\tvar IterativeMethod = lang.compose(Composite, function(source, method, args) {\r\n\t\t\tthis.source = source\r\n\t\t\t// source.interestWithin = true\r\n\t\t\tthis.method = method\r\n\t\t\tthis.arguments = args\r\n\t\t}, {\r\n\t\t\tgetValue: function(context) {\r\n\t\t\t\tvar method = this.method\r\n\t\t\t\tvar args = this.arguments\r\n\t\t\t\tvar variable = this\r\n\t\t\t\tif (context) {\r\n\t\t\t\t\tcontext.nextProperty = 'source'\r\n\t\t\t\t}\r\n\t\t\t\treturn when(this.source.valueOf(context), function(array) {\r\n\t\t\t\t\tif (array && array.forEach) {\r\n\t\t\t\t\t\tif (context && context.notify) {\r\n\t\t\t\t\t\t\tvar contextualizedVariable\r\n\t\t\t\t\t\t\tif (context.distinctSubject) {\r\n\t\t\t\t\t\t\t\tvar contextMap = variable._contextMap || (variable._contextMap = new WeakMap())\r\n\t\t\t\t\t\t\t\tif (contextMap.has(context.distinctSubject)) {\r\n\t\t\t\t\t\t\t\t\tcontextualizedVariable = contextMap.get(context.distinctSubject)\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tcontextMap.set(context.distinctSubject, contextualizedVariable = Object.create(variable))\r\n\t\t\t\t\t\t\t\t\tcontextualizedVariable.listeners = false\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tcontextualizedVariable = variable\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tvariable.notifies(contextualizedVariable)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (method === 'map'){\r\n\t\t\t\t\t\t\t// fast path, and special behavior for map\r\n\t\t\t\t\t\t\treturn args[0](array)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// if not an array convert to an array\r\n\t\t\t\t\t\tarray = [array]\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (typeof method === 'string') {\r\n\t\t\t\t\t\t// apply method\r\n\t\t\t\t\t\treturn array[method].apply(array, args)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn method(array, args)\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\t// TODO: Create specialized updated handlers for faster recomputation of other array derivatives\r\n\t\t\tforDependencies: function(callback) {\r\n\t\t\t\t// depend on the args\r\n\t\t\t\tComposite.prototype.forDependencies.call(this, callback)\r\n\t\t\t\tcallback(this.source)\r\n\t\t\t},\r\n\t\t\tgetVersion: function(context) {\r\n\t\t\t\treturn Math.max(Composite.prototype.getVersion.call(this, context), this.source.getVersion(context))\r\n\t\t\t},\r\n\t\t\tgetCollectionOf: function(){\r\n\t\t\t\treturn this.source.getCollectionOf()\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\tfunction defineArrayMethod(method, constructor, properties) {\r\n\t\t\tvar IterativeResults = lang.compose(IterativeMethod, constructor, properties)\r\n\t\t\tIterativeResults.prototype.method || (IterativeResults.prototype.method = method)\r\n\t\t\tObject.defineProperty(IterativeResults.prototype, 'isIterable', {value: true});\r\n\t\t\tVariable.prototype[method] = function() {\r\n\t\t\t\tvar results = new IterativeResults()\r\n\t\t\t\tresults.source = this\r\n\t\t\t\tresults.arguments = arguments\r\n\t\t\t\treturn results\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tdefineArrayMethod('filter', function Filtered() {}, {\r\n\t\t\tupdated: function(event, by, context) {\r\n\t\t\t\tif (!event || event.modifier === this || (event.modifier && event.modifier.constructor === this)) {\r\n\t\t\t\t\treturn Composite.prototype.updated.call(this, event, by, context)\r\n\t\t\t\t}\r\n\t\t\t\tvar contextualizedVariable = context ? context.getContextualized(this) : this\r\n\t\t\t\tif (event.type === 'delete') {\r\n\t\t\t\t\tvar index = contextualizedVariable.cachedValue.indexOf(event.oldValue)\r\n\t\t\t\t\tif (index > -1) {\r\n\t\t\t\t\t\tcontextualizedVariable.splice(index, 1)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (event.type === 'add') {\r\n\t\t\t\t\tif ([event.value].filter(this.arguments[0]).length > 0) {\r\n\t\t\t\t\t\tcontextualizedVariable.push(event.value)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (event.type === 'update') {\r\n\t\t\t\t\tvar object = event.parent.valueOf(context)\r\n\t\t\t\t\tvar index = contextualizedVariable.cachedValue.indexOf(object)\r\n\t\t\t\t\tvar matches = [object].filter(this.arguments[0]).length > 0\r\n\t\t\t\t\tif (index > -1) {\r\n\t\t\t\t\t\tif (matches) {\r\n\t\t\t\t\t\t\treturn new PropertyChangeEvent(index, event, contextualizedVariable.cachedValue,\r\n\t\t\t\t\t\t\t\t// might need to do something with this\r\n\t\t\t\t\t\t\t\tobject)\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tcontextualizedVariable.splice(index, 1)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\telse {\r\n\t\t\t\t\t\tif (matches) {\r\n\t\t\t\t\t\t\tcontextualizedVariable.push(object)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// else nothing mactches\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn Composite.prototype.updated.call(this, event, by, context)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t\tdefineArrayMethod('map', function Mapped() {}, {\r\n\t\t\tupdated: function(event, by, context) {\r\n\t\t\t\tif (!event || event.modifier === this || (event.modifier && event.modifier.constructor === this)) {\r\n\t\t\t\t\treturn Composite.prototype.updated.call(this, event, by, context)\r\n\t\t\t\t}\r\n\t\t\t\tvar contextualizedVariable = context ? context.getContextualized(this) : this\r\n\t\t\t\tif (event.type === 'delete') {\r\n\t\t\t\t\tcontextualizedVariable.splice(event.previousIndex, 1)\r\n\t\t\t\t} else if (event.type === 'add') {\r\n\t\t\t\t\tcontextualizedVariable.push(this.arguments[0].call(this.arguments[1], event.value))\r\n\t\t\t\t} else if (event.type === 'update') {\r\n\t\t\t\t\tvar object = event.parent.valueOf(context)\r\n\t\t\t\t\tvar array = contextualizedVariable.cachedValue\r\n\t\t\t\t\tif (array && array.map) {\r\n\t\t\t\t\t\tvar index = array.indexOf(object)\r\n\t\t\t\t\t\tcontextualizedVariable.splice(index, 1, this.arguments[0].call(this.arguments[1], event.value))\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn Composite.prototype.updated.call(this, event, by, context)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn Composite.prototype.updated.call(this, event, by, context)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t\tdefineArrayMethod('reduce', function Reduced() {})\r\n\t\tdefineArrayMethod('reduceRight', function Reduced() {})\r\n\t\tdefineArrayMethod('some', function Aggregated() {})\r\n\t\tdefineArrayMethod('every', function Aggregated() {})\r\n\t\tdefineArrayMethod('slice', function Aggregated() {})\r\n\t\tdefineArrayMethod('keyBy', function UniqueIndex(source, args) {}, {\r\n\t\t\tisMap: function () {\r\n\t\t\t\treturn true\r\n\t\t\t},\r\n\t\t\tmethod: function(array, args) {\r\n\t\t\t\tvar index = new Map()\r\n\t\t\t\tvar keyGenerator = args[0]\r\n\t\t\t\tvar valueGenerator = args[1]\r\n\t\t\t\tvar hasKeyFunction = typeof keyGenerator === 'function'\r\n\t\t\t\tvar hasValueFunction = typeof valueGenerator === 'function'\r\n\t\t\t\tvar hasKey = !!keyGenerator\r\n\t\t\t\tfor (var i = 0, l = array.length; i < l; i++) {\r\n\t\t\t\t\tvar element = array[i]\r\n\t\t\t\t\tindex.set(\r\n\t\t\t\t\t\thasKeyFunction ? keyGenerator(element, emit) :\r\n\t\t\t\t\t\t\thasKey ? element[keyGenerator] : element,\r\n\t\t\t\t\t\thasValueFunction ? valueGenerator(element) : element)\r\n\t\t\t\t}\r\n\t\t\t\tfunction emit(key, value) {\r\n\t\t\t\t\tindex.set(key, value)\r\n\t\t\t\t}\r\n\t\t\t\treturn index\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\tdefineArrayMethod('groupBy', function UniqueIndex(source, args) {}, {\r\n\t\t\tisMap: function () {\r\n\t\t\t\treturn true\r\n\t\t\t},\r\n\t\t\tmethod: function(array, args) {\r\n\t\t\t\tvar index = new Map()\r\n\t\t\t\tvar keyGenerator = args[0]\r\n\t\t\t\tvar valueGenerator = args[1]\r\n\t\t\t\tvar hasKeyFunction = typeof keyGenerator === 'function'\r\n\t\t\t\tvar hasValueFunction = typeof valueGenerator === 'function'\r\n\t\t\t\tvar hasKey = !!keyGenerator\r\n\t\t\t\tfor (var i = 0, l = array.length; i < l; i++) {\r\n\t\t\t\t\tvar element = array[i]\r\n\t\t\t\t\tvar key = hasKeyFunction ? keyGenerator(element) :\r\n\t\t\t\t\t\t\thasKey ? element[keyGenerator] : element\r\n\t\t\t\t\tvar group = index.get(key)\r\n\t\t\t\t\tif (!group) {\r\n\t\t\t\t\t\tindex.set(key, group = [])\r\n\t\t\t\t\t}\r\n\t\t\t\t\tgroup.push(hasValueFunction ? valueGenerator(element) : element)\r\n\t\t\t\t}\r\n\t\t\t\tfunction emit(key, value) {\r\n\t\t\t\t\tvar group = index.get(key)\r\n\t\t\t\t\tif (!group) {\r\n\t\t\t\t\t\tindex.set(key, group = [])\r\n\t\t\t\t\t}\r\n\t\t\t\t\tgroup.push(value)\r\n\t\t\t\t}\r\n\t\t\t\treturn index\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\r\n\t\tvar getValue\r\n\t\tvar GeneratorVariable = Variable.GeneratorVariable = lang.compose(Variable.Composite, function ReactiveGenerator(generator){\r\n\t\t\tthis.generator = generator\r\n\t\t}, {\r\n\t\t\tgetValue: getValue = function(context, resuming) {\r\n\t\t\t\tvar lastValue\r\n\t\t\t\tvar i\r\n\t\t\t\tvar generatorIterator\r\n\t\t\t\tvar isThrowing\r\n\t\t\t\tif (resuming) {\r\n\t\t\t\t\t// resuming from a promise\r\n\t\t\t\t\tgeneratorIterator = resuming.iterator\r\n\t\t\t\t\ti = resuming.i\r\n\t\t\t\t\tlastValue = resuming.value\r\n\t\t\t\t\tisThrowing = resuming.isThrowing\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// a fresh start\r\n\t\t\t\t\ti = 0\r\n\t\t\t\t\tgeneratorIterator = this.generator()\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tdo {\r\n\t\t\t\t\tvar stepReturn = generatorIterator[isThrowing ? 'throw' : 'next'](lastValue)\r\n\t\t\t\t\tif (stepReturn.done) {\r\n\t\t\t\t\t\treturn stepReturn.value\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar nextVariable = stepReturn.value\r\n\t\t\t\t\t// compare with the arguments from the last\r\n\t\t\t\t\t// execution to see if they are the same\r\n\t\t\t\t\tvar argumentName = i > 0 ? 'input' + i : 'input'\r\n\t\t\t\t\tif (this[argumentName] !== nextVariable) {\r\n\t\t\t\t\t\tif (this[argumentName]) {\r\n\t\t\t\t\t\t\tthis[argumentName].stopNotifies(this)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// subscribe if it is a variable\r\n\t\t\t\t\t\tif (nextVariable && nextVariable.notifies) {\r\n\t\t\t\t\t\t\tif (this.listeners) {\r\n\t\t\t\t\t\t\t\tnextVariable.notifies(this)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tthis[argumentName] = nextVariable\r\n\t\t\t\t\t\t} else if (typeof nextVariable === 'function' && isGenerator(nextVariable)) {\r\n\t\t\t\t\t\t\tvar delegatedGenerator\r\n\t\t\t\t\t\t\tgetValue.call(this, context, delegatedGenerator = {\r\n\t\t\t\t\t\t\t\ti: i,\r\n\t\t\t\t\t\t\t\titerator: nextVariable()\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\ti = delegatedGenerator.i\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthis[argumentName] = null\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\ti++\r\n\t\t\t\t\tif (resuming) {\r\n\t\t\t\t\t\tresuming.i = i\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (context) {\r\n\t\t\t\t\t\tcontext.nextProperty = argumentName\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlastValue = nextVariable && nextVariable.valueOf(context)\r\n\t\t\t\t\tif (lastValue && lastValue.then) {\r\n\t\t\t\t\t\t// if it is a promise, we will wait on it\r\n\t\t\t\t\t\tvar variable = this\r\n\t\t\t\t\t\t// and return the promise so that the getValue caller can wait on this\r\n\t\t\t\t\t\treturn lastValue.then(function(value) {\r\n\t\t\t\t\t\t\treturn getValue.call(variable, context, {\r\n\t\t\t\t\t\t\t\ti: i,\r\n\t\t\t\t\t\t\t\titerator: generatorIterator,\r\n\t\t\t\t\t\t\t\tvalue: value\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t}, function(error) {\r\n\t\t\t\t\t\t\treturn getValue.call(variable, context, {\r\n\t\t\t\t\t\t\t\ti: i,\r\n\t\t\t\t\t\t\t\titerator: generatorIterator,\r\n\t\t\t\t\t\t\t\tvalue: error,\r\n\t\t\t\t\t\t\t\tisThrowing: true\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}\r\n\t\t\t\t} while(true)\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\tvar Validating = lang.compose(Caching, function(target) {\r\n\t\t\tthis.target = target\r\n\t\t}, {\r\n\t\t\tforDependencies: function(callback) {\r\n\t\t\t\tCaching.prototype.forDependencies.call(this, callback)\r\n\t\t\t\tcallback(this.target)\r\n\t\t\t},\r\n\t\t\tgetVersion: function(context) {\r\n\t\t\t\treturn Math.max(Variable.prototype.getVersion.call(this, context), this.target.getVersion(context))\r\n\t\t\t},\r\n\t\t\tgetValue: function(context) {\r\n\t\t\t\tvar target = this.target\r\n\t\t\t\t// need to actually access the target value, so it can be evaluated in case it\r\n\t\t\t\t// there is a returned variable that we should delegate to.\r\n\t\t\t\ttarget.valueOf(context)\r\n\t\t\t\treturn target.validate(target, target.schema)\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\tVariable.VArray = Variable\r\n\t\tVariable.VPromised = Variable\r\n\t\tVariable.deny = deny\r\n\t\tVariable.noChange = noChange\r\n\t\tfunction addFlag(name) {\r\n\t\t\tVariable[name] = function(functionValue) {\r\n\t\t\t\tfunctionValue[name] = true\r\n\t\t\t}\r\n\t\t}\r\n\t\taddFlag(Variable, 'handlesContext')\r\n\t\taddFlag(Variable, 'handlesPromises')\r\n\t\r\n\t\tfunction objectUpdated(object) {\r\n\t\t\t// simply notifies any subscribers to an object, that it has changed\r\n\t\t\tvar listeners = propertyListenersMap.get(object)\r\n\t\t\tif (listeners) {\r\n\t\t\t\tfor (var i = 0, l = listeners.length; i < l; i++) {\r\n\t\t\t\t\tlisteners[i]._propertyChange(null, object)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction all(array, transform) {\r\n\t\t\t// This is intended to mirror Promise.all. It actually takes\r\n\t\t\t// an iterable, but for now we are just looking for array-like\r\n\t\t\tif (array.length > -1) {\r\n\t\t\t\treturn typeof transform === 'function' ? new Call(transform, array) : new Composite(array)\r\n\t\t\t}\r\n\t\t\tif (arguments.length > 1) {\r\n\t\t\t\t// support multiple arguments as an array\r\n\t\t\t\treturn new Composite(arguments)\r\n\t\t\t}\r\n\t\t\tif (typeof array === 'object') {\r\n\t\t\t\t// allow an object as a hash to be mapped\r\n\t\t\t\tvar keyMapping = []\r\n\t\t\t\tvar valueArray = []\r\n\t\t\t\tfor (var key in array) {\r\n\t\t\t\t\tkeyMapping.push(key)\r\n\t\t\t\t\tvalueArray.push(array[key])\r\n\t\t\t\t}\r\n\t\t\t\treturn new Variable(function(results) {\r\n\t\t\t\t\tvar resultObject = {}\r\n\t\t\t\t\tfor (var i = 0; i < results.length; i++) {\r\n\t\t\t\t\t\tresultObject[keyMapping[i]] = results[i]\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn resultObject\r\n\t\t\t\t}).apply(null, valueArray)\r\n\t\t\t}\r\n\t\t\tthrow new TypeError('Variable.all requires an array')\r\n\t\t}\r\n\t\r\n\t\tfunction hasOwn(Target, createForInstance) {\r\n\t\r\n\t\t\tvar ownedClasses = this.ownedClasses || (this.ownedClasses = new WeakMap())\r\n\t\t\t// TODO: assign to super classes\r\n\t\t\tvar Class = this\r\n\t\t\townedClasses.set(Target, createForInstance || function() { return new Target() })\r\n\t\t\treturn this\r\n\t\t}\r\n\t\tfunction generalizeClass() {\r\n\t\t\tvar prototype = this.prototype\r\n\t\t\tvar prototypeNames = Object.getOwnPropertyNames(prototype)\r\n\t\t\tfor(var i = 0, l = prototypeNames.length; i < l; i++) {\r\n\t\t\t\tvar name = prototypeNames[i]\r\n\t\t\t\tObject.defineProperty(this, name, getGeneralizedDescriptor(Object.getOwnPropertyDescriptor(prototype, name), name, this))\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction getGeneralizedDescriptor(descriptor, name, Class) {\r\n\t\t\tif (typeof descriptor.value === 'function') {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tvalue: generalizeMethod(Class, name)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\treturn descriptor\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction generalizeMethod(Class, name) {\r\n\t\t\t// I think we can just rely on `this`, but we could use the argument:\r\n\t\t\t// function(possibleEvent) {\r\n\t\t\t// \tvar target = possibleEvent && possibleEvent.target\r\n\t\t\tvar method = Class[name] = function() {\r\n\t\t\t\tvar instance = Class.for(this)\r\n\t\t\t\treturn instance[name].apply(instance, arguments)\r\n\t\t\t}\r\n\t\t\tmethod.for = function(context) {\r\n\t\t\t\tvar instance = Class.for(context)\r\n\t\t\t\treturn function() {\r\n\t\t\t\t\treturn instance[name].apply(instance, arguments)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn method\r\n\t\t}\r\n\t\r\n\t\tvar defaultContext = {\r\n\t\t\tname: 'Default context',\r\n\t\t\tdescription: 'This object is the default context for classes, corresponding to a singleton instance of that class',\r\n\t\t\tconstructor: {\r\n\t\t\t\tgetForClass: function(subject, Class) {\r\n\t\t\t\t\treturn Class.defaultInstance\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tcontains: function() {\r\n\t\t\t\treturn true // contains everything\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction instanceForContext(Class, context) {\r\n\t\t\tif (!context) {\r\n\t\t\t\treturn Class.defaultInstance\r\n\t\t\t}\r\n\t\t\treturn context.specify(Class)\r\n\t//\t\tvar instance = context.subject.constructor.getForClass && context.subject.constructor.getForClass(context.subject, Class) || Class.defaultInstance\r\n\t//\t\tcontext.distinctSubject = mergeSubject(context.distinctSubject, instance.subject)\r\n\t//\t\treturn instance\r\n\t\t}\r\n\t\t// a variable inheritance change goes through its own prototype, so classes/constructor\r\n\t\t// can be used as variables as well\r\n\t\tfor (var key in VariablePrototype) {\r\n\t\t\tObject.defineProperty(Variable, key, Object.getOwnPropertyDescriptor(VariablePrototype, key))\r\n\t\t}\r\n\t\tVariable.valueOf = function(context) {\r\n\t\t\t// contextualized getValue\r\n\t\t\treturn instanceForContext(this, context).valueOf(context)\r\n\t\t}\r\n\t\tVariable.put = function(value, context) {\r\n\t\t\t// contextualized setValue\r\n\t\t\treturn instanceForContext(this, context).put(value, context)\r\n\t\t}\r\n\t\tVariable.for = function(subject) {\r\n\t\t\tif (subject != null) {\r\n\t\t\t\tif (subject.target && !subject.constructor.getForClass) {\r\n\t\t\t\t\t// makes HTML events work\r\n\t\t\t\t\tsubject = subject.target\r\n\t\t\t\t}\r\n\t\t\t\tvar instance\r\n\t\t\t\tinstance = new Context(subject).specify(this)\r\n\t\t\t\tif (instance && !instance.subject) {\r\n\t\t\t\t\tinstance.subject = subject\r\n\t\t\t\t}\r\n\t\t\t\t// TODO: Do we have a global context that we set on defaultInstance?\r\n\t\t\t\treturn instance || this.defaultInstance\r\n\t\t\t} else {\r\n\t\t\t\treturn this.defaultInstance\r\n\t\t\t}\r\n\t\t}\r\n\t\tVariable.from = function(value) {\r\n\t\t\tif (value && typeof value === 'object') {\r\n\t\t\t\t// a plain object, we use our own map to retrieve the instance (or create one)\r\n\t\t\t\tvar instanceMap = this.instanceMap || (this.instanceMap = new WeakMap())\r\n\t\t\t\tvar instance = instanceMap.get(value)\r\n\t\t\t\tif (!instance) {\r\n\t\t\t\t\tinstanceMap.set(value, instance = new this(value))\r\n\t\t\t\t}\r\n\t\t\t\treturn instance\r\n\t\t\t} else {\r\n\t\t\t\t// a primitive, just unconditionally create a new variable for it\r\n\t\t\t\treturn new this(value)\r\n\t\t\t}\r\n\t\t}\r\n\t\tVariable.notifies = function(target) {\r\n\t\t\tthis.defaultInstance.notifies(target)\r\n\t\t}\r\n\t\tVariable.stopNotifies = function(target) {\r\n\t\t\tthis.defaultInstance.stopNotifies(target)\r\n\t\t}\r\n\t\tVariable.getCollectionOf = function () {\r\n\t\t\treturn this.collectionOf\r\n\t\t}\r\n\t\tVariable.updated = function(updateEvent, by, context) {\r\n\t\t\treturn instanceForContext(this, context).updated(updateEvent, by, context)\r\n\t\t}\r\n\t\tObject.defineProperty(Variable, 'collectionOf', {\r\n\t\t\tget: function() {\r\n\t\t\t\treturn this._collectionOf\r\n\t\t\t},\r\n\t\t\tset: function(ItemClass) {\r\n\t\t\t\tif (this._collectionOf != ItemClass) {\r\n\t\t\t\t\tthis._collectionOf = ItemClass\r\n\t\t\t\t\tItemClass.collection = this\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t\tObject.defineProperty(Variable, 'collection', {\r\n\t\t\tget: function() {\r\n\t\t\t\treturn this._collection\r\n\t\t\t},\r\n\t\t\tset: function(Collection) {\r\n\t\t\t\tif (this._collection != Collection) {\r\n\t\t\t\t\tthis._collection = Collection\r\n\t\t\t\t\tCollection.collectionOf = this\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t\tVariable.Context = Context\r\n\t\tVariable.NotifyingContext = NotifyingContext\r\n\t\tVariable.generalize = generalizeClass\r\n\t\tVariable.call = Function.prototype.call // restore these\r\n\t\tVariable.apply = Function.prototype.apply\r\n\t\tVariable.extend = function(properties) {\r\n\t\t\t// TODO: handle arguments\r\n\t\t\tvar Base = this\r\n\t\t\tfunction ExtendedVariable() {\r\n\t\t\t\tif (this instanceof ExtendedVariable) {\r\n\t\t\t\t\tBase.apply(this, arguments)\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn ExtendedVariable.extend(properties)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tvar prototype = ExtendedVariable.prototype = Object.create(this.prototype)\r\n\t\t\tExtendedVariable.prototype.constructor = ExtendedVariable\r\n\t\t\tsetPrototypeOf(ExtendedVariable, this)\r\n\t\t\tfor (var key in properties) {\r\n\t\t\t\tvar descriptor = Object.getOwnPropertyDescriptor(properties, key)\r\n\t\t\t\tObject.defineProperty(prototype, key, descriptor)\r\n\t\t\t\tObject.defineProperty(ExtendedVariable, key, getGeneralizedDescriptor(descriptor, key, ExtendedVariable))\r\n\t\t\t}\r\n\t\t\tif (properties && properties.hasOwn) {\r\n\t\t\t\thasOwn.call(ExtendedVariable, properties.hasOwn)\r\n\t\t\t}\r\n\t\t\treturn ExtendedVariable\r\n\t\t}\r\n\t\tObject.defineProperty(Variable, 'defaultInstance', {\r\n\t\t\tget: function() {\r\n\t\t\t\treturn this.hasOwnProperty('_defaultInstance') ?\r\n\t\t\t\t\tthis._defaultInstance : (\r\n\t\t\t\t\t\tthis._defaultInstance = new this(),\r\n\t\t\t\t\t\tthis._defaultInstance.subject = defaultContext,\r\n\t\t\t\t\t\tthis._defaultInstance)\r\n\t\t\t}\r\n\t\t})\r\n\t\tVariable.hasOwn = function(Target, createInstance) {\r\n\t\t\tvar instanceMap = new WeakMap()\r\n\t\t\tinstanceMap.createInstance = createInstance\r\n\t\t\tvar subjectMap = this.ownedClasses || (this.ownedClasses = new WeakMap())\r\n\t\t\tsubjectMap.set(Target, instanceMap)\r\n\t\t}\r\n\t\r\n\t\tVariable.all = all\r\n\t\tVariable.objectUpdated = objectUpdated\r\n\t\r\n\t\treturn Variable\r\n\t}))\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) { if (true) {\r\n\t  !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(6), __webpack_require__(4)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) } else if (typeof module === 'object' && module.exports) {        \r\n\t  module.exports = factory(require('./util/lang'), require('./operators'), require('./Variable')) // Node\r\n\t}}(this, function (lang, operators, Variable) {\r\n\t\r\n\t  var isGenerator = lang.isGenerator\r\n\t  var ObjectTransform = lang.compose(Variable.Call, function ObjectTransform(transform, inputs) {\r\n\t    this.inputs = inputs\r\n\t    Variable.Call.apply(this, arguments)\r\n\t  }, {\r\n\t    _getAsObject: function() {\r\n\t      return this.transform.apply(this, preserveObjects(this.inputs))\r\n\t    }\r\n\t  })\r\n\t  function preserveObjects(inputs) {\r\n\t    for (var i = 0, l = inputs.length; i < l; i++) {\r\n\t      var input = inputs[i]\r\n\t      if (input && input._getAsObject) {\r\n\t        inputs[i] = input._getAsObject()\r\n\t      }\r\n\t    }\r\n\t    return inputs\r\n\t  }\r\n\t\tfunction react(generator, options) {\r\n\t    if (typeof generator !== 'function') {\r\n\t      throw new Error('react() must be called with a generator. You need to use the babel-plugin-transform-alkali plugin if you want to use reactive expressions')\r\n\t    }\r\n\t\t\tif (options && options.reverse) {\r\n\t\t\t\tgenerator.reverse = options.reverse\r\n\t\t\t}\r\n\t\t\treturn new Variable.GeneratorVariable(generator)\r\n\t\t}\r\n\t  Object.assign(react, operators)\r\n\t  react.from = function(value, options) {\r\n\t    if (value && value.property) {\r\n\t      return value\r\n\t    }\r\n\t    if (typeof value === 'function' && isGenerator(value)) {\r\n\t      return react(value, options)\r\n\t    }\r\n\t    return Variable.from(value)\r\n\t  }\r\n\t  react.prop = function(object, property) {\r\n\t    if (object) {\r\n\t      // TODO: Use a static set of public methods/properties that can be accessed\r\n\t      if (object.property) {\r\n\t        // it is a variable already, but check to see if we are using a method/property directly on the variable\r\n\t        var directPropertyValue = object[property]\r\n\t        return directPropertyValue !== undefined ? directPropertyValue : object.property(property)\r\n\t      }\r\n\t      return object[property]\r\n\t    }\r\n\t    // not even truthy, return undefined\r\n\t  }\r\n\t  react.cond = function(test, consequent, alternate) {\r\n\t    return operators.if(test, operators.choose(consequent, alternate))\r\n\t  }\r\n\t  react.fcall = function(target, args) {\r\n\t    if (target.property && typeof target === 'function') {\r\n\t      return target.apply(null, preserveObjects(args))\r\n\t    }\r\n\t    return new Variable.Call(target, args)\r\n\t  }\r\n\t  react.mcall = function(target, key, args) {\r\n\t    var method = target[key]\r\n\t    if (typeof method === 'function' && method.property || key === 'bind') {\r\n\t      // for now we check to see if looks like it could handle a variable, or is a bind call\r\n\t      return method.apply(target, preserveObjects(args))\r\n\t    }\r\n\t    return new Variable.Call(target[key].bind(target), args)\r\n\t  }\r\n\t  react.ncall = function(target, args) {\r\n\t    if (target.property && typeof target === 'function') {\r\n\t      return new (target.bind.apply(target, [null].concat(preserveObjects(args))))()\r\n\t    }\r\n\t    return new Variable.Call(function() {\r\n\t      return new (target.bind.apply(target, [null].concat(arguments)))()\r\n\t    }, args)\r\n\t  }\r\n\t\r\n\t  react.obj = function(transform, inputs) {\r\n\t    return new ObjectTransform(transform, inputs)\r\n\t  }\r\n\t\r\n\t\treturn react\r\n\t}))\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) { if (true) {\r\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(4)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) } else if (typeof module === 'object' && module.exports) {        \r\n\t  module.exports = factory(require('./Variable')) // Node\r\n\t}}(this, function (Variable) {\r\n\t\r\n\t\tvar deny = Variable.deny;\r\n\t\tvar operatingFunctions = {};\r\n\t\tvar operators = {};\r\n\t\tfunction getOperatingFunction(expression){\r\n\t\t\t// jshint evil: true\r\n\t\t\treturn operatingFunctions[expression] ||\r\n\t\t\t\t(operatingFunctions[expression] =\r\n\t\t\t\t\tnew Function('a', 'b', 'deny', 'return ' + expression));\r\n\t\t}\r\n\t\tfunction operator(operator, name, precedence, forward, reverseA, reverseB){\r\n\t\t\t// defines the standard operators\r\n\t\t\tvar reverse = function(output, inputs){\r\n\t\t\t\tvar a = inputs[0],\r\n\t\t\t\t\tb = inputs[1];\r\n\t\t\t\tif(a && a.put){\r\n\t\t\t\t\tvar result = reverseA(output, b && b.valueOf());\r\n\t\t\t\t\tif(result !== deny){\r\n\t\t\t\t\t\ta.put(result);\r\n\t\t\t\t\t}\r\n\t\t\t\t}else if(b && b.put){\r\n\t\t\t\t\tb.put(reverseB(output, a && a.valueOf()));\r\n\t\t\t\t}else{\r\n\t\t\t\t\treturn deny;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\t// define a function that can lazily ensure the operating function\r\n\t\t\t// is available\r\n\t\t\tvar operatorHandler = {\r\n\t\t\t\tapply: function(instance, args){\r\n\t\t\t\t\tforward = getOperatingFunction(forward);\r\n\t\t\t\t\treverseA = reverseA && getOperatingFunction(reverseA);\r\n\t\t\t\t\treverseB = reverseB && getOperatingFunction(reverseB);\r\n\t\t\t\t\tforward.reverse = reverse;\r\n\t\t\t\t\toperators[operator] = operatorHandler = new Variable(forward);\r\n\t\r\n\t\t\t\t\taddFlags(operatorHandler);\r\n\t\t\t\t\targs = Array.prototype.slice.call(args);\r\n\t\t\t\t\targs.push(deny)\r\n\t\t\t\t\treturn operatorHandler.apply(instance, args);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\tfunction addFlags(operatorHandler){\r\n\t\t\t\toperatorHandler.precedence = precedence;\r\n\t\t\t\toperatorHandler.infix = reverseB !== false;\r\n\t\t\t}\r\n\t\t\taddFlags(operatorHandler);\r\n\t\t\toperators[operator] = operatorHandler;\r\n\t\t\toperators[name] = function() {\r\n\t\t\t\treturn operatorHandler.apply(null, arguments)\r\n\t\t\t}\r\n\t\t}\r\n\t\t// using order precedence from:\r\n\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence\r\n\t\toperator('+', 'add', 6, 'a+b', 'a-b', 'a-b');\r\n\t\toperator('-', 'subtract', 6, 'a-b', 'a+b', 'b-a');\r\n\t\toperator('*', 'multiply', 5, 'a*b', 'a/b', 'a/b');\r\n\t\toperator('/', 'divide', 5, 'a/b', 'a*b', 'b/a');\r\n\t//\toperator('^', 7, 'a^b', 'a^(-b)', 'Math.log(a)/Math.log(b)');\r\n\t\toperator('?', 'if', 16, 'b[a?0:1]', 'a===b[0]||(a===b[1]?false:deny)', '[a,b]');\r\n\t\toperator(':', 'choose', 15, '[a,b]', 'a[0]?a[1]:deny', 'a[1]');\r\n\t\toperator('!', 'not', 4, '!a', '!a', false);\r\n\t\toperator('%', 'remainder', 5, 'a%b');\r\n\t\toperator('>', 'greater', 8, 'a>b');\r\n\t\toperator('>=', 'greaterOrEqual', 8, 'a>=b');\r\n\t\toperator('<', 'less', 8, 'a<b');\r\n\t\toperator('<=', 'lessOrEqual', 8, 'a<=b');\r\n\t\toperator('===', 'strictEqual', 9, 'a===b');\r\n\t\toperator('==', 'equal', 9, 'a==b');\r\n\t\toperator('&', 'and', 8, 'a&&b');\r\n\t\toperator('|', 'or', 8, 'a||b');\r\n\t\toperator('round', 'round', 8, 'Math.round(a*Math.pow(10,b||1))/Math.pow(10,b||1)', 'a', 'a');\r\n\t\treturn operators;\r\n\t}))\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) { if (true) {\r\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(4)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) } else if (typeof module === 'object' && module.exports) {        \r\n\t  module.exports = factory(require('./util/lang'), require('./Variable')) // Node\r\n\t}}(this, function (lang, Variable) {\r\n\t\r\n\t\tfunction deepCopy(source, target, derivativeMap) {\r\n\t\t\tif (source && typeof source == 'object') {\r\n\t\t\t\tif (source instanceof Array) {\r\n\t\t\t\t\ttarget = [] // always create a new array for array targets\r\n\t\t\t\t\tfor(var i = 0, l = source.length; i < l; i++) {\r\n\t\t\t\t\t\ttarget[i] = deepCopy(source[i], null, derivativeMap)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (!target || typeof target !== 'object') {\r\n\t\t\t\t\t\ttarget = derivativeMap && derivativeMap.get(source)\r\n\t\t\t\t\t\tif (!target) {\r\n\t\t\t\t\t\t\ttarget = {}\r\n\t\t\t\t\t\t\tderivativeMap && derivativeMap.set(source, target)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfor (var i in source) {\r\n\t\t\t\t\t\ttarget[i] = deepCopy(source[i], target[i], derivativeMap)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn target\r\n\t\t\t}\r\n\t\t\treturn source\r\n\t\t}\r\n\t\r\n\t\tvar Copy = lang.compose(Variable, function(copiedFrom) {\r\n\t\t\t// this is the variable that we derive from\r\n\t\t\tthis.copiedFrom = copiedFrom\r\n\t\t\tthis.derivativeMap = new lang.WeakMap(null, 'derivative')\r\n\t\t\tthis.isDirty = new Variable(false)\r\n\t\t}, {\r\n\t\t\tvalueOf: function(context) {\r\n\t\t\t\tif(this.state) {\r\n\t\t\t\t\tthis.state = null\r\n\t\t\t\t}\r\n\t\t\t\tvar value = this.copiedFrom.valueOf(context)\r\n\t\t\t\tif(value && typeof value == 'object') {\r\n\t\t\t\t\tvar derivative = this.derivativeMap.get(value)\r\n\t\t\t\t\tif (derivative == null) {\r\n\t\t\t\t\t\tthis.derivativeMap.set(value, derivative = deepCopy(value, undefined, this.derivativeMap))\r\n\t\t\t\t\t\tthis.setValue(derivative, context)\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn derivative\r\n\t\t\t\t}\r\n\t\t\t\tvar thisValue = this.getValue ? this.getValue(context) : this.value\r\n\t\t\t\tif(thisValue === undefined) {\r\n\t\t\t\t\treturn value\r\n\t\t\t\t}\r\n\t\t\t\treturn thisValue\r\n\t\t\t},\r\n\t\t\tgetCopyOf: function(value) {\r\n\t\t\t\tvar derivative = this.derivativeMap.get(value)\r\n\t\t\t\tif (derivative == null) {\r\n\t\t\t\t\tthis.derivativeMap.set(value, derivative = deepCopy(value, undefined, this.derivativeMap))\r\n\t\t\t\t}\r\n\t\t\t\treturn derivative\r\n\t\t\t},\r\n\t\t\tsave: function() {\r\n\t\t\t\t// copy back to the original object\r\n\t\t\t\tvar original = this.copiedFrom.valueOf()\r\n\t\t\t\tvar newCopiedFrom = deepCopy(this.valueOf(), original)\r\n\t\t\t\tif (original !== newCopiedFrom) {\r\n\t\t\t\t\t// if we have replaced it with a new object/value, put it\r\n\t\t\t\t\tthis.copiedFrom.put && this.copiedFrom.put(newCopiedFrom)\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// else we have modified an existing object, but we still need to notify\r\n\t\t\t\t\tif (this.copiedFrom.notifies && this.copiedFrom.updated) { // copiedFrom doesn't have to be a variable, it can be a plain object\r\n\t\t\t\t\t\tthis.copiedFrom.updated()\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tthis.isDirty.put(false)\r\n\t\t\t\tthis.onSave && this.onSave()\r\n\t\t\t},\r\n\t\t\trevert: function() {\r\n\t\t\t\tvar original = this.copiedFrom.valueOf()\r\n\t\t\t\tthis.put(deepCopy(original, this.derivativeMap.get(original), this.derivativeMap))\r\n\t\t\t\tthis.isDirty.put(false)\r\n\t\t\t},\r\n\t\t\tupdated: function() {\r\n\t\t\t\tthis.isDirty.put(true)\r\n\t\t\t\treturn Variable.prototype.updated.apply(this, arguments)\r\n\t\t\t}\r\n\t\t})\r\n\t\treturn Copy\r\n\t}))\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** index.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 58ee9498e40228bba837\n **/","/// <reference path=\"./typings.d.ts\" />\r\n(function (root, factory) { if (typeof define === 'function' && define.amd) {\r\n  define(['./Element', './Renderer', './react', './Copy', './operators', './Variable'], factory) } else if (typeof module === 'object' && module.exports) {        \r\n  module.exports = factory(require('./Element'), require('./Renderer'), require('./react'), require('./Copy'), require('./operators'), require('./Variable')) // Node\r\n}}(this, function (Element, Renderer, react, Copy, operators, Variable) {\r\n\r\n\tvar main = Object.create(Element)\r\n\tmain.Copy = Copy\r\n\tmain.Element = Element\r\n\tmain.Variable = Variable\r\n\tmain.VMap = Variable.VMap\r\n\tmain.VArray = Variable.VArray\r\n\tmain.VPromised = Variable.VPromised\r\n\tmain.all = Variable.all\r\n\tmain.Transform = Variable.Call\r\n\tmain.Caching = Variable.Caching\r\n\tmain.react = react\r\n\tmain.spawn = function(func) {\r\n\t\treturn react(func).valueOf()\r\n\t}\r\n\tmain.Renderer = Renderer.ElementRenderer\r\n\tObject.assign(main, Renderer)\r\n\tObject.assign(main, operators)\r\n\treturn main\r\n}))\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./index.js\n ** module id = 0\n ** module chunks = 0\n **/","(function (root, factory) { if (typeof define === 'function' && define.amd) {\r\n\tdefine(['./util/lang', './Renderer', './Variable'], factory) } else if (typeof module === 'object' && module.exports) {        \r\n  module.exports = factory(require('./util/lang'), require('./Renderer'), require('./Variable')) // Node\r\n}}(this, function (lang, Renderer, Variable) {\r\n\tvar knownElementProperties = [\r\n\t\t'textContent', // Node\r\n\t\t'id', 'className', 'innerHTML', // Element\r\n\t\t'title', 'lang', 'translate', 'dir', 'tabIndex', 'accessKey', 'draggable', 'spellcheck', 'contentEditable', 'innerText', 'webkitdropzone'] // HTMLElement\r\n\r\n\tvar SELECTOR_REGEX = /^(\\.|#)([-\\w]+)(.+)?/\r\n\tvar isGenerator = lang.isGenerator\r\n\tvar Context = Variable.Context\r\n\tvar PropertyRenderer = Renderer.PropertyRenderer\r\n\tvar InputPropertyRenderer = Renderer.InputPropertyRenderer\r\n\tvar AttributeRenderer = Renderer.AttributeRenderer\r\n\tvar StyleRenderer = lang.compose(Renderer.StyleRenderer, function StyleRenderer() {\r\n\t\tRenderer.StyleRenderer.apply(this, arguments)\r\n\t}, {\r\n\t\trenderUpdate: function(newValue, element) {\r\n\t\t\tvar definition = styleDefinitions[this.name]\r\n\t\t\tif (definition) {\r\n\t\t\t\tdefinition(element, newValue, this.name)\r\n\t\t\t} else {\r\n\t\t\t\telement.style[this.name] = newValue\r\n\t\t\t}\r\n\t\t}\r\n\t})\r\n\r\n\tvar ClassNameRenderer = lang.compose(Renderer.ElementRenderer, function ClassNameRenderer(options) {\r\n\t\tthis.className = options.className\r\n\t\tRenderer.apply(this, arguments)\r\n\t}, {\r\n\t\trenderUpdate: function(newValue, element) {\r\n\t\t\tvar currentClassName = element.className\r\n\t\t\tvar changingClassName = this.className\r\n\t\t\t// remove the className (needed for addition or removal)\r\n\t\t\t// see http://jsperf.com/remove-class-name-algorithm/2 for some tests on this\r\n\t\t\tvar removed = currentClassName && (' ' + currentClassName + ' ').replace(' ' + changingClassName + ' ', ' ')\r\n\t\t\tif (newValue) {\r\n\t\t\t\t// addition, add the className\r\n\t\t\t\tchangingClassName = currentClassName ? (removed + changingClassName).slice(1) : changingClassName;\r\n\t\t\t} else {\r\n\t\t\t\t// we already have removed the class, just need to trim\r\n\t\t\t\tchangingClassName = removed.slice(1, removed.length - 1)\r\n\t\t\t}\r\n\t\t\t// only assign if it changed, this can save a lot of time\r\n\t\t\tif (changingClassName != currentClassName) {\r\n\t\t\t\telement.className = changingClassName\r\n\t\t\t}\r\n\t\t}\r\n\t})\r\n\r\n\t// TODO: check for renderContent with text updater\r\n\tvar TextRenderer = Renderer.TextRenderer\r\n\tvar ListRenderer = Renderer.ListRenderer\r\n\r\n\tvar doc = typeof document !== 'undefined' ? document : {\r\n\t\tcreateElement: function(tag) {\r\n\t\t\treturn {}\r\n\t\t},\r\n\t\taddEventListener: function() {\r\n\t\t}\r\n\t}\r\n\r\n\tvar inputs = {\r\n\t\tINPUT: 1,\r\n\t\tTEXTAREA: 1\r\n\t\t// SELECT: 1, we exclude this, so the default \"content\" of the element can be the options\r\n\t}\r\n\r\n\tfunction booleanStyle(options) {\r\n\t\treturn function(element, value, key) {\r\n\t\t\tif (typeof value === 'boolean') {\r\n\t\t\t\t// has a boolean conversion\r\n\t\t\t\tvalue = options[value ? 0 : 1]\r\n\t\t\t}\r\n\t\t\telement.style[key] = value\r\n\t\t}\r\n\t}\r\n\r\n\tfunction defaultStyle(element, value, key) {\r\n\t\tif (typeof value === 'number') {\r\n\t\t\tvalue = value + 'px'\r\n\t\t}\r\n\t\telement.style[key] = value\r\n\t}\r\n\tfunction directStyle(element, value, key) {\r\n\t\telement.style[key] = value\r\n\t}\r\n\r\n\tvar styleDefinitions = {\r\n\t\tdisplay: booleanStyle(['', 'none']),\r\n\t\tvisibility: booleanStyle(['visible', 'hidden']),\r\n\t\tcolor: directStyle,\r\n\t\topacity: directStyle,\r\n\t\tzoom: directStyle,\r\n\t\tminZoom: directStyle,\r\n\t\tmaxZoom: directStyle,\r\n\t\tfontWeight: directStyle,\r\n\t\tposition: booleanStyle(['absolute', '']),\r\n\t\ttextDecoration: booleanStyle(['underline', '']),\r\n\t\tfontWeight: booleanStyle(['bold', 'normal'])\r\n\t}\r\n\t;[\"alignContent\",\"alignItems\",\"alignSelf\",\"animation\",\"animationDelay\",\"animationDirection\",\"animationDuration\",\"animationFillMode\",\"animationIterationCount\",\"animationName\",\"animationPlayState\",\"animationTimingFunction\",\"backfaceVisibility\",\"background\",\"backgroundAttachment\",\"backgroundBlendMode\",\"backgroundClip\",\"backgroundColor\",\"backgroundImage\",\"backgroundOrigin\",\"backgroundPosition\",\"backgroundPositionX\",\"backgroundPositionY\",\"backgroundRepeat\",\"backgroundRepeatX\",\"backgroundRepeatY\",\"backgroundSize\",\"baselineShift\",\"border\",\"borderBottom\",\"borderBottomColor\",\"borderBottomLeftRadius\",\"borderBottomRightRadius\",\"borderBottomStyle\",\"borderBottomWidth\",\"borderCollapse\",\"borderColor\",\"borderImage\",\"borderImageOutset\",\"borderImageRepeat\",\"borderImageSlice\",\"borderImageSource\",\"borderImageWidth\",\"borderLeft\",\"borderLeftColor\",\"borderLeftStyle\",\"borderLeftWidth\",\"borderRadius\",\"borderRight\",\"borderRightColor\",\"borderRightStyle\",\"borderRightWidth\",\"borderSpacing\",\"borderStyle\",\"borderTop\",\"borderTopColor\",\"borderTopLeftRadius\",\"borderTopRightRadius\",\"borderTopStyle\",\"borderTopWidth\",\"borderWidth\",\"bottom\",\"boxShadow\",\"boxSizing\",\"bufferedRendering\",\"captionSide\",\"clear\",\"clip\",\"clipPath\",\"clipRule\",\"color\",\"colorInterpolation\",\"colorInterpolationFilters\",\"colorRendering\",\"counterIncrement\",\"counterReset\",\"cursor\",\"direction\",\"display\",\"emptyCells\",\"fill\",\"fillOpacity\",\"fillRule\",\"filter\",\"flex\",\"flexBasis\",\"flexDirection\",\"flexFlow\",\"flexGrow\",\"flexShrink\",\"flexWrap\",\"float\",\"floodColor\",\"floodOpacity\",\"font\",\"fontFamily\",\"fontFeatureSettings\",\"fontKerning\",\"fontSize\",\"fontStretch\",\"fontStyle\",\"fontVariant\",\"fontVariantLigatures\",\"fontWeight\",\"height\",\"imageRendering\",\"isolation\",\"justifyContent\",\"left\",\"letterSpacing\",\"lightingColor\",\"lineHeight\",\"listStyle\",\"listStyleImage\",\"listStylePosition\",\"listStyleType\",\"margin\",\"marginBottom\",\"marginLeft\",\"marginRight\",\"marginTop\",\"marker\",\"markerEnd\",\"markerMid\",\"markerStart\",\"mask\",\"maskType\",\"maxHeight\",\"maxWidth\",\"maxZoom\",\"minHeight\",\"minWidth\",\"minZoom\",\"mixBlendMode\",\"motion\",\"motionOffset\",\"motionPath\",\"motionRotation\",\"objectFit\",\"objectPosition\",\"opacity\",\"order\",\"orientation\",\"orphans\",\"outline\",\"outlineColor\",\"outlineOffset\",\"outlineStyle\",\"outlineWidth\",\"overflow\",\"overflowWrap\",\"overflowX\",\"overflowY\",\"padding\",\"paddingBottom\",\"paddingLeft\",\"paddingRight\",\"paddingTop\",\"page\",\"pageBreakAfter\",\"pageBreakBefore\",\"pageBreakInside\",\"paintOrder\",\"perspective\",\"perspectiveOrigin\",\"pointerEvents\",\"position\",\"quotes\",\"resize\",\"right\",\"shapeImageThreshold\",\"shapeMargin\",\"shapeOutside\",\"shapeRendering\",\"size\",\"speak\",\"src\",\"stopColor\",\"stopOpacity\",\"stroke\",\"strokeDasharray\",\"strokeDashoffset\",\"strokeLinecap\",\"strokeLinejoin\",\"strokeMiterlimit\",\"strokeOpacity\",\"strokeWidth\",\"tabSize\",\"tableLayout\",\"textAlign\",\"textAlignLast\",\"textAnchor\",\"textCombineUpright\",\"textDecoration\",\"textIndent\",\"textOrientation\",\"textOverflow\",\"textRendering\",\"textShadow\",\"textTransform\",\"top\",\"touchAction\",\"transform\",\"transformOrigin\",\"transformStyle\",\"transition\",\"transitionDelay\",\"transitionDuration\",\"transitionProperty\",\"transitionTimingFunction\",\"unicodeBidi\",\"unicodeRange\",\"userZoom\",\"vectorEffect\",\"verticalAlign\",\"visibility\",\"whiteSpace\",\"widows\",\"width\",\"willChange\",\"wordBreak\",\"wordSpacing\",\"wordWrap\",\"writingMode\",\"zIndex\",\"zoom\"].forEach(function(property) {\r\n\t\tstyleDefinitions[property] = styleDefinitions[property] || defaultStyle\r\n\t})\r\n\tvar styleSheet\r\n\tvar presumptiveParentMap = new WeakMap()\r\n\r\n\tvar setPrototypeOf = Object.setPrototypeOf || (function(base, proto) { base.__proto__ = proto})\r\n\tvar getPrototypeOf = Object.getPrototypeOf || (function(base) { return base.__proto__ })\r\n\tfunction createCssRule(selector) {\r\n\t\tif (!styleSheet) {\r\n\t\t\tvar styleSheetElement = doc.createElement(\"style\")\r\n\t\t\tstyleSheetElement.setAttribute(\"type\", \"text/css\")\r\n//\t\t\tstyleSheet.appendChild(doc.createTextNode(css))\r\n\t\t\tdoc.head.insertBefore(styleSheetElement, doc.head.firstChild)\r\n\t\t\tstyleSheet = styleSheetElement.sheet\r\n\t\t}\r\n\t\tvar cssRules = styleSheet.cssRules || styleSheet.rules\r\n\t\treturn cssRules[styleSheet.addRule(selector, ' ', cssRules.length)]\r\n\t}\r\n\r\n\t// TODO: Need to do some more testing to see if that would improve performance:\r\n\t// var fragmentThresholdHeuristic = (typeof navigator !== 'undefined' && navigator.userAgent.indexOf('Chrome') > 0) ? 1 : 3\r\n\r\n\tfunction layoutChildren(parent, children, container, prepend) {\r\n\t\tvar fragment = (children.length > 1 || prepend) ? doc.createDocumentFragment() : parent\r\n\t\tfor(var i = 0, l = children.length; i < l; i++) {\r\n\t\t\tvar child = children[i]\r\n\t\t\tvar childNode\r\n\t\t\tif (child != null) { // we just skip nulls and undefined, helps make it easier to write conditional element logic\r\n\t\t\t\tif (child.create) {\r\n\t\t\t\t\t// an element constructor\r\n\t\t\t\t\tcurrentParent = parent\r\n\t\t\t\t\tchildNode = child.create()\r\n\t\t\t\t\tfragment.appendChild(childNode)\r\n\t\t\t\t\tif (child.isContentNode) {\r\n\t\t\t\t\t\tcontainer.contentNode = childNode\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (child.notifies) {\r\n\t\t\t\t\t// a variable\r\n\t\t\t\t\tvar ref = child.isIterable ? fragment : parent\r\n\t\t\t\t\tfragment.appendChild(childNode = variableAsContent(ref, child))\r\n\t\t\t\t} else if (typeof child == 'object') {\r\n\t\t\t\t\tif (child instanceof Array) {\r\n\t\t\t\t\t\t// array of sub-children\r\n\t\t\t\t\t\tcontainer = container || parent\r\n\t\t\t\t\t\tchildNode = childNode || parent\r\n\t\t\t\t\t\tlayoutChildren(childNode.contentNode || childNode, child, container)\r\n\t\t\t\t\t} else if (child.nodeType) {\r\n\t\t\t\t\t\t// an element itself\r\n\t\t\t\t\t\tfragment.appendChild(childNode = child)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// TODO: apply properties to last child, but with binding to the parent (for events)\r\n\t\t\t\t\t\tthrow new Error('Unknown child type ' + child)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// a primitive value\r\n\t\t\t\t\tchildNode = doc.createTextNode(child)\r\n\t\t\t\t\tfragment.appendChild(childNode)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (fragment != parent) {\r\n\t\t\tif (prepend) {\r\n\t\t\t\tparent.insertBefore(fragment, parent.firstChild)\r\n\t\t\t} else {\r\n\t\t\t\tparent.appendChild(fragment)\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn childNode\r\n\t}\r\n\tfunction variableAsContent(parent, content) {\r\n\t\tif (content == null) {\r\n\t\t\treturn doc.createTextNode('')\r\n\t\t}\r\n\t\tvar textNode\r\n\t\tif (content.notifies) {\r\n\t\t\ttextNode = doc.createTextNode('')\r\n\t\t\tnew TextRenderer({\r\n\t\t\t\telement: parent,\r\n\t\t\t\ttextNode: textNode,\r\n\t\t\t\tvariable: content\r\n\t\t\t})\r\n\t\t} else {\r\n\t\t\ttextNode = doc.createTextNode(content)\r\n\t\t}\r\n\t\treturn textNode\r\n\t}\r\n\r\n\tfunction bidirectionalHandler(element, value, key) {\r\n\t\tif (value && value.notifies) {\r\n\t\t\tnew InputPropertyRenderer({\r\n\t\t\t\tname: key,\r\n\t\t\t\tvariable: value,\r\n\t\t\t\telement: element\r\n\t\t\t})\r\n\t\t\tif (inputs[element.tagName] || element.tagName === 'SELECT') {\r\n\t\t\t\tbindChanges(element, value, key)\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (element.tagName === 'SELECT' && key === 'value') {\r\n\t\t\t\t// use the deferred <select> value assignment\r\n\t\t\t\tInputPropertyRenderer.prototype.renderSelectValueUpdate(value, element)\r\n\t\t\t} else {\r\n\t\t\t\tif (element.type === 'number') {\r\n\t\t\t\t\tif (isNaN(value)) {\r\n\t\t\t\t\t\tvalue = ''\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telement[key] = value\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction noop() {}\r\n\tvar propertyHandlers = {\r\n\t\tchildren: noop,\r\n\t\ttagName: noop,\r\n\t\tclasses: function(element, classes) {\r\n\t\t\tif (!(classes.length > -1)) {\r\n\t\t\t\t// index the classes, if necessary\r\n\t\t\t\tvar i = 0\r\n\t\t\t\tfor (var key in classes) {\r\n\t\t\t\t\tif (!classes[i]) {\r\n\t\t\t\t\t\tclasses[i] = key\r\n\t\t\t\t\t}\r\n\t\t\t\t\ti++\r\n\t\t\t\t}\r\n\t\t\t\tclasses.length = i\r\n\t\t\t}\r\n\t\t\tfor (var i = 0, l = classes.length; i < l; i++) {\r\n\t\t\t\t// find each class name\r\n\t\t\t\tvar className = classes[i]\r\n\t\t\t\tvar flag = classes[className]\r\n\t\t\t\tif (flag && flag.notifies) {\r\n\t\t\t\t\t// if it is a variable, we react to it\r\n\t\t\t\t\tnew ClassNameRenderer({\r\n\t\t\t\t\t\telement: element,\r\n\t\t\t\t\t\tclassName: className,\r\n\t\t\t\t\t\tvariable: flag\r\n\t\t\t\t\t})\r\n\t\t\t\t} else if (flag || flag === undefined) {\r\n\t\t\t\t\telement.className += ' ' + className\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tclass: applyAttribute,\r\n\t\tfor: applyAttribute, // TODO: move to label?\r\n\t\trole: applyAttribute,\r\n\t\trender: function(element, value, key, properties) {\r\n\t\t\t// TODO: This doesn't need to be a property updater (is in place for *render())\r\n\t\t\t// we should also verify it is a generator\r\n\t\t\t// and maybe, at some point, find an optimization to eliminate the bind()\r\n\t\t\tnew PropertyRenderer({\r\n\t\t\t\tname: key,\r\n\t\t\t\tvariable: new Variable.GeneratorVariable(value.bind(element, properties)),\r\n\t\t\t\telement: element\r\n\t\t\t})\r\n\t\t},\r\n\t\tdataset: applySubProperties(function(newValue, element, key) {\r\n\t\t\telement.dataset[key || this.name] = newValue\r\n\t\t}),\r\n\t\tattributes: applySubProperties(function(newValue, element, key) {\r\n\t\t\telement.setAttribute(key || this.name, newValue)\r\n\t\t}),\r\n\t\tstyle: function(element, value, key) {\r\n\t\t\tif (typeof value === 'string') {\r\n\t\t\t\telement.setAttribute('style', value)\r\n\t\t\t} else if (value && value.notifies) {\r\n\t\t\t\tnew AttributeRenderer({\r\n\t\t\t\t\tname: 'style',\r\n\t\t\t\t\tvariable: value,\r\n\t\t\t\t\telement: element\r\n\t\t\t\t})\r\n\t\t\t} else {\r\n\t\t\t\tstyleObjectHandler(element, value, key)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tknownElementProperties.forEach(function(property) {\r\n\t\tpropertyHandlers[property] = true\r\n\t})\r\n\tif (typeof HTMLElement !== 'undefined') {\r\n\t\tHTMLElement.prototype._propertyHandlers = propertyHandlers // inherit this, at least for now\r\n\t}\r\n\tvar elementPropertyHandlers = {\r\n\t\tinput: lang.copy(['accept', 'alt', 'autocomplete', 'autofocus', 'capture', 'defaultChecked', 'dirName', 'disabled', 'form', 'files', 'formAction', 'formEnctype', 'formMethod', 'formNoValidate', 'formTarget', 'indeterminate', 'inputMode', 'list', 'max', 'maxLength', 'min', 'minLength', 'multiple', 'name', 'pattern', 'placeholder', 'readOnly', 'required', 'size', 'src', 'step', 'type', 'defaultValue', 'willValidate', 'validity', 'validationMessage', 'useMap', 'autocapitalize', 'webkitdirectory', 'incremental', 'stepUp', 'stepDown'], {\r\n\t\t\tvalue: bidirectionalHandler,\r\n\t\t\tvalueAsNumber: bidirectionalHandler,\r\n\t\t\tvalueAsDate: bidirectionalHandler,\r\n\t\t\tchecked: bidirectionalHandler,\r\n\t\t\ttype: function(element, value) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\telement.type = value\r\n\t\t\t\t} catch(e) {\r\n\t\t\t\t\t// IE 11 will throw an error here\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}),\r\n\t\tselect: lang.copy(['name', 'size', 'type', 'selectedIndex', 'validationMessage'], {\r\n\t\t\tvalue: bidirectionalHandler\r\n\t\t}),\r\n\t\ttextarea: lang.copy(['cols', 'dirName', 'maxLength', 'minLength', 'name', 'placeholder', 'rows', 'wrap', 'type', 'defaultValue', 'textLength', 'validationMessage', 'autocapitalize'], {\r\n\t\t\tvalue: bidirectionalHandler\r\n\t\t}),\r\n\t\ta: ['target', 'download', 'ping', 'rel', 'hreflang', 'type', 'referrerPolicy', 'href', 'media'],\r\n\t\tarea: ['target', 'download', 'coords', 'rel', 'hreflang', 'type', 'referrerPolicy', 'href', 'media', 'alt', 'shape'],\r\n\t\tbutton: ['formAction', 'formEnctype', 'formMethod', 'formTarget', 'name', 'type', 'value', 'validationMessage'],\r\n\t\tdialog: ['open'],\r\n\t\tembed: ['src', 'type', 'name'],\r\n\t\tform: ['acceptCharset', 'action', 'autocomplete', 'enctype', 'encoding', 'method', 'name', 'target', 'novalidate'],\r\n\t\tframe: ['name', 'scrolling', 'src', 'frameBorder'],\r\n\t\tframeset: ['cols', 'rows'],\r\n    iframe: ['src', 'srcdoc', 'name', 'referrerPolicy', 'align', 'scrolling', 'frameBorder', 'longDesc'],\r\n    option: ['label', 'value', 'text', 'index'],\r\n    optgroup: ['label'],\r\n    output: ['name', 'type', 'defaultValue', 'value', 'validationMessage'],\r\n    label: ['htmlFor'],\r\n    td: ['colSpan', 'rowSpan'],\r\n    th: ['colSpan', 'rowSpan'],\r\n    script: ['src', 'type', 'charset', 'text', 'event', 'htmlFor', 'integrity'],\r\n    style: ['media', 'type'],\r\n    track: ['kind', 'src', 'srclang', 'label'],\r\n    link: ['href', 'rel', 'media', 'hreflang', 'type', 'charset', 'rev', 'target', 'integrity', 'as'],\r\n    meta: ['name', 'httpEquiv', 'content', 'scheme'],\r\n    meter: ['value', 'min', 'max', 'low', 'high', 'optimum'],\r\n    progress: ['value', 'max', 'position'],\r\n    del: ['cite', 'dateTime'],\r\n    ins: ['cite', 'dateTime'],\r\n    source: ['src', 'type', 'srcset', 'sizes', 'media'],\r\n    video: ['videoWidth', 'videoHeight', 'poster', 'webkitDecodedFrameCount', 'webkitDroppedFrameCount'],\r\n    keygen: ['challenge', 'keytype', 'name', 'type', 'validationMessage'],\r\n    object: ['data', 'type', 'name', 'useMap', 'validationMessage', 'archive', 'code', 'hspace', 'standby', 'vspace', 'codeBase', 'codeType'],\r\n    param: ['name', 'value', 'type', 'valueType']\r\n\t}\r\n\r\n\tfunction applyAttribute(element, value, key) {\r\n\t\tif (value && value.notifies) {\r\n\t\t\tnew AttributeRenderer({\r\n\t\t\t\tname: key,\r\n\t\t\t\tvariable: value,\r\n\t\t\t\telement: element\r\n\t\t\t})\r\n\t\t} else {\r\n\t\t\telement.setAttribute(key, value)\r\n\t\t}\r\n\t}\r\n\r\n\tvar styleObjectHandler = applySubProperties(function(newValue, element, key) {\r\n\t\telement.style[key || this.name] = newValue\r\n\t})\r\n\r\n\tfunction applySubProperties(renderer) {\r\n\t\tvar SubPropertyRenderer = lang.compose(PropertyRenderer, function SubPropertyRenderer(options) {\r\n\t\t\tPropertyRenderer.apply(this, arguments)\r\n\t\t}, {\r\n\t\t\trenderUpdate: renderer\r\n\t\t})\r\n\t\treturn function(element, value, key) {\r\n\t\t\tfor (var subKey in value) {\r\n\t\t\t\tvar subValue = value[subKey]\r\n\t\t\t\tif (subValue && subValue.notifies) {\r\n\t\t\t\t\tnew SubPropertyRenderer({\r\n\t\t\t\t\t\tname: subKey,\r\n\t\t\t\t\t\tvariable: subValue,\r\n\t\t\t\t\t\telement: element\r\n\t\t\t\t\t})\r\n\t\t\t\t} else {\r\n\t\t\t\t\trenderer(subValue, element, subKey)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction assignProperties(element, properties) {\r\n\t\tfor (var key in properties) {\r\n\t\t\tvar value = properties[key]\r\n\t\t\tvar styleDefinition\r\n\t\t\tvar propertyHandler = element._propertyHandlers[key]\r\n\t\t\tif (propertyHandler) {\r\n\t\t\t\tif (propertyHandler === true) {\r\n\t\t\t\t\t// a standard, known element property\r\n\t\t\t\t\tif (value && value.notifies) {\r\n\t\t\t\t\t\tnew PropertyRenderer({\r\n\t\t\t\t\t\t\tname: key,\r\n\t\t\t\t\t\t\tvariable: value,\r\n\t\t\t\t\t\t\telement: element\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\telement[key] = value\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tpropertyHandler(element, value, key, properties)\r\n\t\t\t\t}\r\n\t\t\t} else if ((styleDefinition = styleDefinitions[key])) {\r\n\t\t\t\tif (value && value.notifies) {\r\n\t\t\t\t\tnew StyleRenderer({\r\n\t\t\t\t\t\tname: key,\r\n\t\t\t\t\t\tvariable: value,\r\n\t\t\t\t\t\telement: element\r\n\t\t\t\t\t})\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstyleDefinition(element, value, key)\r\n\t\t\t\t}\r\n\t\t\t} else if (element[key] == null) {\r\n\t\t\t\t// we are working an unknown/unstandard property (or an event listener)\r\n\t\t\t\t// undefined or null means we can safely set\r\n\t\t\t\t// TODO: we may want to do the event listener check first so we can handle oncustomevent (that needs an addEventListener call to work)\r\n\t\t\t\telement[key] = value\r\n\t\t\t} else if (typeof value === 'function' && key.slice(0, 2) === 'on') {\r\n\t\t\t\t// event listener with one already defined on the prototype\r\n\t\t\t\telement.addEventListener(key.slice(2), value)\r\n\t\t\t} else {\r\n\t\t\t\t// otherwise bypass/override the native getter/setter\r\n\t\t\t\tObject.defineProperty(element, key, {\r\n\t\t\t\t\tvalue: value,\r\n\t\t\t\t\tenumerable: true,\r\n\t\t\t\t\tconfigurable: true,\r\n\t\t\t\t\twritable: true\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction buildContent(element, content, key, properties) {\r\n\t\tvar each = element.each || properties.each\r\n\t\tif (each && content) {\r\n\t\t\t// render as list\r\n\t\t\tif (each.create) {\r\n\t\t\t\teach.defineHasOwn = function () {\r\n\t\t\t\t\tvar ItemClass = content.getCollectionOf && content.getCollectionOf() || Item\r\n\t\t\t\t\thasOwn(each, ItemClass, function (element) {\r\n\t\t\t\t\t\tvar itemVariable = ItemClass.from(element._item)\r\n\t\t\t\t\t\treturn itemVariable\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (content.notifies) {\r\n\t\t\t\tnew ListRenderer({\r\n\t\t\t\t\teach: each,\r\n\t\t\t\t\tvariable: content,\r\n\t\t\t\t\telement: element\r\n\t\t\t\t})\r\n\t\t\t} else {\r\n\t\t\t\tvar fragment = doc.createDocumentFragment()\r\n\t\t\t\tif (each.defineHasOwn) {\r\n\t\t\t\t\teach.defineHasOwn()\r\n\t\t\t\t}\r\n\t\t\t\tcontent.forEach(function(item) {\r\n\t\t\t\t\tif (each.create) {\r\n\t\t\t\t\t\tchildElement = each.create({parent: element, _item: item}) // TODO: make a faster object here potentially\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tchildElement = each(item, element)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfragment.appendChild(childElement)\r\n\t\t\t\t})\r\n\t\t\t\telement.appendChild(fragment)\r\n\t\t\t}\r\n\t\t} else if (inputs[element.tagName]) {\r\n\t\t\t// render into input\r\n\t\t\tbuildInputContent(element, content)\r\n\t\t} else if (content instanceof Array) {\r\n\t\t\t// treat array as children (potentially of the content node)\r\n\t\t\telement = element.contentNode || element\r\n\t\t\tlayoutChildren(element, content, element)\r\n\t\t} else {\r\n\t\t\t// render as string\r\n\t\t\telement.appendChild(variableAsContent(element, content))\r\n\t\t}\r\n\t}\r\n\r\n\tfunction bindChanges(element, variable, key, conversion) {\r\n\t\tlang.nextTurn(function() { // wait for next turn in case inputChanges isn't set yet\r\n\t\t\tvar inputEvents = element.inputEvents || ['change', 'alkali-change']\r\n\t\t\tfor (var i = 0, l = inputEvents.length; i < l; i++) {\r\n\t\t\t\telement.addEventListener(inputEvents[i], function (event) {\r\n\t\t\t\t\tvar value = element[key]\r\n\t\t\t\t\tvar result = variable.put(conversion ? conversion(value, element) : value, new Context(element))\r\n\t\t\t\t\tif (result === Variable.deny) {\r\n\t\t\t\t\t\tthrow new Error('Variable change denied')\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n\r\n\tdoc.addEventListener('click', function(event) {\r\n\t\tvar target = event.target\r\n\t\tif (target.type === 'radio') {\r\n\t\t\tvar radios = doc.querySelectorAll('input[type=radio]')\r\n\t\t\tfor (var i = 0, l = radios.length; i < l; i++) {\r\n\t\t\t\tvar radio = radios[i]\r\n\t\t\t\tif (radio.name === target.name && radio !== target) {\r\n\t\t\t\t\tradio.dispatchEvent(new Event('alkali-change', {}))\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t})\r\n\r\n\tfunction conversion(value, element) {\r\n\t\tif (element.type == 'number') {\r\n\t\t\treturn parseFloat(value)\r\n\t\t}\r\n\t\treturn value\r\n\t}\r\n\r\n\tfunction buildInputContent(element, content) {\r\n\t\tvar inputType = element.type\r\n\t\tvar inputProperty = inputType in {date: 1, datetime: 1, time: 1} ?\r\n\t\t\t\t'valueAsDate' : (inputType === 'checkbox' || inputType === 'radio') ?\r\n\t\t\t\t\t'checked' : 'value'\r\n\r\n\t\tif (content && content.notifies) {\r\n\t\t\t// a variable, respond to changes\r\n\t\t\tnew InputPropertyRenderer({\r\n\t\t\t\tvariable: content,\r\n\t\t\t\tname: inputProperty,\r\n\t\t\t\telement: element\r\n\t\t\t})\r\n\t\t\t// and bind the other way as well, updating the variable in response to input changes\r\n\t\t\tbindChanges(element, content, inputProperty, conversion)\r\n\t\t} else {\r\n\t\t\t// primitive\r\n\t\t\telement[inputProperty] = content\r\n\t\t}\r\n\t}\r\n\tvar classHandlers = {\r\n\t\thasOwn: function(Element, value) {\r\n\t\t\thasOwn(Element, value)\r\n\t\t}\r\n\t}\r\n\r\n\tfunction applyToClass(value, Element) {\r\n\t\tvar applyOnCreate = Element._applyOnCreate\r\n\t\tif (value && typeof value === 'object') {\r\n\t\t\tif (value instanceof Array || value.notifies) {\r\n\t\t\t\tapplyOnCreate.content = value\r\n\t\t\t} else {\r\n\t\t\t\tfor (var key in value) {\r\n\t\t\t\t// TODO: eventually we want to be able to set these as rules statically per element\r\n\t\t\t\t/*if (styleDefinitions[key]) {\r\n\t\t\t\t\tvar styles = Element.styles || (Element.styles = [])\r\n\t\t\t\t\tstyles.push(key)\r\n\t\t\t\t\tstyles[key] = descriptor.value\r\n\t\t\t\t} else {*/\r\n\t\t\t\t\tif (classHandlers[key]) {\r\n\t\t\t\t\t\thasOwn(Element, value[key])\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// TODO: do deep merging of styles and classes, but not variables\r\n\t\t\t\t\t\tapplyOnCreate[key] = value[key]\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (typeof value === 'function' && !value.for) {\r\n\t\t\tthrow new TypeError('Function as argument not supported')\r\n\t\t} else {\r\n\t\t\tapplyOnCreate.content = value\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getApplySet(Class) {\r\n\t\tif (Class.hasOwnProperty('_applyOnCreate')) {\r\n\t\t\treturn Class._applyOnCreate\r\n\t\t}\r\n\t\t// this means we didn't extend and evaluate the prototype yet\r\n\t\tif (Class.getForClass) {\r\n\t\t\t// we are extending an alkali constructor\r\n\t\t\t// if this class is inheriting from an alkali constructor, work our way up the chain\r\n\t\t\tapplyOnCreate = Class._applyOnCreate = {}\r\n\t\t\tvar parentApplySet = getApplySet(getPrototypeOf(Class))\r\n\t\t\tfor (var key in parentApplySet) {\r\n\t\t\t\tapplyOnCreate[key] = parentApplySet[key]\r\n\t\t\t}\r\n\t\t\t// we need to check the prototype for event handlers\r\n\t\t\tvar prototype = Class.prototype\r\n\t\t\tvar propertyHandlers\r\n\t\t\tvar keys = Object.getOwnPropertyNames(prototype)\r\n\t\t\tfor (var i = 0, l = keys.length; i < l; i++) {\r\n\t\t\t\tvar key = keys[i]\r\n\t\t\t\tif (key.slice(0, 2) === 'on' || (key === 'render' && isGenerator(prototype[key]))) {\r\n\t\t\t\t\tapplyOnCreate[key] = prototype[key]\r\n\t\t\t\t} else if (key.slice(0, 6) === 'render') {\r\n\t\t\t\t\tvar propertyName = key[6].toLowerCase() + key.slice(7)\r\n\t\t\t\t\tif (!propertyHandlers) {\r\n\t\t\t\t\t\tpropertyHandlers = prototype._propertyHandlers = Object.create(prototype._propertyHandlers)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tpropertyHandlers[propertyName] = true // TODO: is it better to implement this with property handlers?\r\n\t\t\t\t\tObject.defineProperty(prototype, propertyName, renderDescriptor(key))\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn applyOnCreate\r\n\t\t}\r\n\t\treturn null\r\n\t}\r\n\r\n\tfunction renderDescriptor(renderMethod) {\r\n\t\tvar map = new WeakMap()\r\n\t\treturn {\r\n\t\t\tget: function() {\r\n\t\t\t\treturn map.has(this) ? map.get(this) : null\r\n\t\t\t},\r\n\t\t\tset: function(value) {\r\n\t\t\t\tmap.set(this, value)\r\n\t\t\t\tthis[renderMethod](value)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction makeElementConstructor() {\r\n\t\tfunction Element(selector, properties) {\r\n\t\t\tif (this instanceof Element){\r\n\t\t\t\t// create DOM element\r\n\t\t\t\t// Need to detect if we have registered the element and `this` is actually already the correct instance\r\n\t\t\t\treturn create.apply(Element.prototype === getPrototypeOf(this) ? Element :// this means it is from this constructor\r\n\t\t\t\t\tthis.constructor, // this means it was constructed from a subclass\r\n\t\t\t\t\targuments)\r\n\t\t\t} else {\r\n\t\t\t\t// extend to create new class\r\n\t\t\t\treturn withProperties.apply(Element, arguments)\r\n\t\t\t}\r\n\t\t}\r\n\t\tElement.create = create\r\n\t\tElement.with = withProperties\r\n\t\tElement.for = forTarget\r\n\t\tElement.property = propertyForElement\r\n\t\tElement.getForClass = getForClass\r\n\t\treturn Element\r\n\t}\r\n\r\n\tfunction withProperties(selector, properties) {\r\n\t\tvar Element = makeElementConstructor()\r\n\t\tElement.superConstructor = this\r\n\t\tElement.tagName = this.tagName\r\n\t\tif (this.children) {\r\n\t\t\t// just copy this property\r\n\t\t\tElement.children = this.children\r\n\t\t}\r\n\t\tElement.prototype = this.prototype\r\n\r\n\t\tvar applyOnCreate = Element._applyOnCreate = {}\r\n\t\tvar parentApplySet = getApplySet(this)\r\n\t\t// copy parent properties\r\n\t\tfor (var key in parentApplySet) {\r\n\t\t\tapplyOnCreate[key] = parentApplySet[key]\r\n\t\t}\r\n\r\n\t\tvar i = 0 // for arguments\r\n\t\tif (typeof selector === 'string') {\r\n\t\t\tvar selectorMatch = selector.match(SELECTOR_REGEX)\r\n\t\t\tif (selectorMatch) {\r\n\t\t\t\tdo {\r\n\t\t\t\t\tvar operator = selectorMatch[1]\r\n\t\t\t\t\tvar name = selectorMatch[2]\r\n\t\t\t\t\tif (operator == '.') {\r\n\t\t\t\t\t\tif (applyOnCreate.className) {\r\n\t\t\t\t\t\t\tapplyOnCreate.className += ' ' + name\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tapplyOnCreate.className = name\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tapplyOnCreate.id = name\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar remaining = selectorMatch[3]\r\n\t\t\t\t\tselectorMatch = remaining && remaining.match(SELECTOR_REGEX)\r\n\t\t\t\t} while (selectorMatch)\r\n\t\t\t} else {\r\n\t\t\t\tapplyOnCreate.content = selector\r\n\t\t\t}\r\n\t\t\ti++ // skip the first argument\r\n\t\t}\r\n\r\n\t\tfor (var l = arguments.length; i < l; i++) {\r\n\t\t\tapplyToClass(arguments[i], Element)\r\n\t\t}\r\n\t\treturn Element\r\n\t}\r\n\tvar currentParent\r\n\tfunction create(selector, properties) {\r\n\t\t// TODO: make this a symbol\r\n\t\tvar applyOnCreate = getApplySet(this)\r\n\t\tif (currentParent) {\r\n\t\t\tvar parent = currentParent\r\n\t\t\tcurrentParent = null\r\n\t\t}\r\n/*\t\tif (this._initialized != this) {\r\n\t\t\tthis._initialized = this\r\n\t\t\tthis.initialize && this.initialize()\r\n\t\t\tvar styles = this.styles\r\n\t\t\tif (styles) {\r\n\t\t\t\tvar rule = createCssRule(getUniqueSelector(this))\r\n\t\t\t\tfor (var i = 0, l = styles.length; i < l; i++) {\r\n\t\t\t\t\tvar key = styles[i]\r\n\t\t\t\t\tvar value = styles[key]\r\n\t\t\t\t\t// TODO: if it is a contextualized variable, do this on the element\r\n\t\t\t\t\tvar styleDefinition = styleDefinitions[key]\r\n\t\t\t\t\tif (styleDefinition) {\r\n\t\t\t\t\t\tstyleDefinition(rule, value, key)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!this.hasOwnProperty('_applyOnCreate')) {\r\n\t\t\t\tapplyOnCreate = getApplySet(this)\r\n\t\t\t}\r\n\t\t}*/\r\n\t\tvar element = doc.createElement(this.tagName)\r\n\t\tif (selector && selector.parent) {\r\n\t\t\tparent = selector.parent\r\n\t\t}\r\n\t\tif (parent) {\r\n\t\t\tpresumptiveParentMap.set(element, parent)\r\n\t\t}\r\n\t\tif (!(element instanceof this)) {\r\n\t\t\t// ideally we want to avoid this call, as it is expensive, but for classes that\r\n\t\t\t// don't register a tag name, we have to make sure the prototype chain is correct\r\n\t\t\tsetPrototypeOf(element, this.prototype)\r\n\t\t}\r\n\t\tif (element.constructor != this) {\r\n\t\t\telement.constructor = this // need to do this for hasOwn contextualization to work\r\n\t\t}\r\n\t\tif (arguments.length > 0) {\r\n\t\t\t// copy applyOnCreate when we have arguments\r\n\t\t\tvar ElementApplyOnCreate = applyOnCreate\r\n\t\t\tapplyOnCreate = {}\r\n\t\t\tfor (var key in ElementApplyOnCreate) {\r\n\t\t\t\tapplyOnCreate[key] = ElementApplyOnCreate[key]\r\n\t\t\t}\r\n\t\t\tvar i = 0\r\n\t\t\tif (typeof selector == 'string') {\r\n\t\t\t\ti++\r\n\t\t\t\tvar selectorMatch = selector.match(SELECTOR_REGEX)\r\n\t\t\t\tif (selectorMatch) {\r\n\t\t\t\t\tdo {\r\n\t\t\t\t\t\tvar operator = selectorMatch[1]\r\n\t\t\t\t\t\tvar name = selectorMatch[2]\r\n\t\t\t\t\t\tif (operator == '.') {\r\n\t\t\t\t\t\t\tif (applyOnCreate.className) {\r\n\t\t\t\t\t\t\t\tapplyOnCreate.className += ' ' + name\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tif (element.className) {\r\n\t\t\t\t\t\t\t\t\t\telement.className += ' ' + name\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\telement.className = name\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tif (applyOnCreate.id) {\r\n\t\t\t\t\t\t\t\tapplyOnCreate.id = name\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// just skip right to the element\r\n\t\t\t\t\t\t\t\telement.id = name\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar remaining = selectorMatch[3]\r\n\t\t\t\t\t\tselectorMatch = remaining && remaining.match(SELECTOR_REGEX)\r\n\t\t\t\t\t} while (selectorMatch)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tapplyOnCreate.content = selector\r\n\t\t\t\t}\r\n\t\t\t} else if (selector && selector._item) {\r\n\t\t\t\t// this is kind of hack, to get the Item available before the properties, eventually we may want to\r\n\t\t\t\t// order static properties before variable binding applications, but for now.\r\n\t\t\t\telement._item = selector._item\r\n\t\t\t}\r\n\t\t\tfor (var l = arguments.length; i < l; i++) {\r\n\t\t\t\tvar argument = arguments[i]\r\n\t\t\t\tif (argument && typeof argument === 'object') {\r\n\t\t\t\t\tif (argument instanceof Array || argument.notifies) {\r\n\t\t\t\t\t\tapplyOnCreate.content = argument\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tfor (var key in argument) {\r\n\t\t\t\t\t\t\t// TODO: do deep merging of styles and classes, but not variables\r\n\t\t\t\t\t\t\tapplyOnCreate[key] = argument[key]\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (typeof argument === 'function' && argument.for) {\r\n\t\t\t\t\tapplyOnCreate.content = argument.for(element)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tapplyOnCreate.content = argument\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (element.created) {\r\n\t\t\tapplyOnCreate = element.created(applyOnCreate) || applyOnCreate\r\n\t\t} else if (applyOnCreate.created) {\r\n\t\t\tapplyOnCreate = applyOnCreate.created.call(element, applyOnCreate) || applyOnCreate\r\n\t\t}\r\n\t\t// TODO: inline this for better performance, possibly\r\n\t\tassignProperties(element, applyOnCreate)\r\n\t\tif (this.children) {\r\n\t\t\tlayoutChildren(element, this.children, element)\r\n\t\t}\r\n\t\t// always do this last, so it can be properly inserted inside the children\r\n\t\tif (applyOnCreate.content) {\r\n\t\t\tbuildContent(element, applyOnCreate.content, 'content', applyOnCreate)\r\n\t\t}\r\n\t\telement.ready && element.ready(applyOnCreate)\r\n\t\treturn element\r\n\t}\r\n\r\n\tvar slice = [].slice\r\n\tfunction append(parent){\r\n\t\treturn this.nodeType ?\r\n\t\t\tlayoutChildren(this, arguments, this) : // called as a method\r\n\t\t\tlayoutChildren(parent, slice.call(arguments, 1), parent) // called as a function\r\n\t}\r\n\r\n\tfunction prepend(parent){\r\n\t\treturn this.nodeType ?\r\n\t\t\tlayoutChildren(this, arguments, this, true) : // called as a method\r\n\t\t\tlayoutChildren(parent, slice.call(arguments, 1), parent, true) // called as a function\r\n\t}\r\n\r\n\tfunction registerTag(tagName) {\r\n\t\tthis.tagName = tagName\r\n\t\tif (doc.registerElement && this.prototype.constructor === this) {\r\n\t\t\tdoc.registerElement(tagName, this)\r\n\t\t}\r\n\t}\r\n\r\n\tvar Element = withProperties.call(typeof HTMLElement !== 'undefined' ? HTMLElement : function() {})\r\n\r\n\tElement.registerTag = registerTag\r\n\tElement.assign = function(target, properties) {\r\n\t\tif (typeof target === 'function') {\r\n\t\t\t// assign properties to an existing constructor/class\r\n\t\t\tgetApplySet(target) // make sure we have our own applyOnCreate first\r\n\t\t\tapplyToClass(properties, target)\r\n\t\t} else {\r\n\t\t\t// assign to an element\r\n\t\t\t// TODO: Handle content property separately\r\n\t\t\treturn assignProperties(target, properties)\r\n\t\t}\r\n\t}\r\n\r\n\tElement.within = function(element){\r\n\t\t// find closest child\r\n\t}\r\n\r\n\tgenerate([\r\n\t\t'Video',\r\n\t\t'Source',\r\n\t\t'Media',\r\n\t\t'Audio',\r\n\t\t'UL',\r\n\t\t'U',\r\n\t\t'Track',\r\n\t\t'Title',\r\n\t\t'TextArea',\r\n\t\t'Template',\r\n\t\t'TBody',\r\n\t\t'THead',\r\n\t\t'TFoot',\r\n\t\t'TR',\r\n\t\t'Table',\r\n\t\t'Col',\r\n\t\t'ColGroup',\r\n\t\t'TH',\r\n\t\t'TD',\r\n\t\t'Caption',\r\n\t\t'Sup',\r\n\t\t'Sub',\r\n\t\t'Style',\r\n\t\t'Strong',\r\n\t\t'Span',\r\n\t\t'Small',\r\n\t\t'Shadow',\r\n\t\t'Select',\r\n\t\t'Script',\r\n\t\t'S',\r\n\t\t'Quote',\r\n\t\t'Progress',\r\n\t\t'Pre',\r\n\t\t'Picture',\r\n\t\t'Param',\r\n\t\t'P',\r\n\t\t'Output',\r\n\t\t'Option',\r\n\t\t'Optgroup',\r\n\t\t'Object',\r\n\t\t'OL',\r\n\t\t'Ins',\r\n\t\t'I',\r\n\t\t'Del',\r\n\t\t'Meter',\r\n\t\t'Meta',\r\n\t\t'Menu',\r\n\t\t'Map',\r\n\t\t'Link',\r\n\t\t'Legend',\r\n\t\t'Label',\r\n\t\t'LI',\r\n\t\t'KeyGen',\r\n\t\t'Input',\r\n\t\t'Image',\r\n\t\t'IFrame',\r\n\t\t'H1',\r\n\t\t'H2',\r\n\t\t'H3',\r\n\t\t'H4',\r\n\t\t'H5',\r\n\t\t'H6',\r\n\t\t'Hr',\r\n\t\t'FrameSet',\r\n\t\t'Frame',\r\n\t\t'Form',\r\n\t\t'Font',\r\n\t\t'Embed',\r\n\t\t'Em',\r\n\t\t'Code',\r\n\t\t'Cite',\r\n\t\t'Dfn',\r\n\t\t'B',\r\n\t\t'Article',\r\n\t\t'Aside',\r\n\t\t'Abbr',\r\n\t\t'Footer',\r\n\t\t'Figure',\r\n\t\t'FigCaption',\r\n\t\t'Header',\r\n\t\t'Main',\r\n\t\t'Mark',\r\n\t\t'MenuItem',\r\n\t\t'Nav',\r\n\t\t'Section',\r\n\t\t'Summary',\r\n\t\t'WBr',\r\n\t\t'Div',\r\n\t\t'Dialog',\r\n\t\t'Details',\r\n\t\t'DataList',\r\n\t\t'DL',\r\n\t\t'Canvas',\r\n\t\t'Button',\r\n\t\t'Base',\r\n\t\t'Br',\r\n\t\t'Area',\r\n\t\t'A'\r\n\t])\r\n\tgenerateInputs([\r\n\t\t'Checkbox',\r\n\t\t'Password',\r\n\t\t'Submit',\r\n\t\t'Radio',\r\n\t\t'Color',\r\n\t\t'Date',\r\n\t\t'DateTime',\r\n\t\t'Email',\r\n\t\t'Month',\r\n\t\t'Number',\r\n\t\t'Range',\r\n\t\t'Search',\r\n\t\t'Tel',\r\n\t\t'Time',\r\n\t\t'Url',\r\n\t\t'Week'])\r\n\r\n\tvar tags = {}\r\n\tfunction getConstructor(tagName) {\r\n\t\ttagName = tagName.toLowerCase()\r\n\t\treturn tags[tagName] ||\r\n\t\t\t(tags[tagName] =\r\n\t\t\t\tsetupElement(withProperties.call(doc.createElement(tagName).constructor), tagName))\r\n\t}\r\n\r\n\tfunction setupElement(Element, tagName) {\r\n\t\tvar props = elementPropertyHandlers[tagName]\r\n\t\tif (props && !props.assigned) {\r\n\t\t\tvar handlers = Element.prototype._propertyHandlers = Object.create(propertyHandlers)\r\n\t\t\tfor (var i = 0, l = props.length; i < l; i++) {\r\n\t\t\t\thandlers[props[i]] = true\r\n\t\t\t}\r\n\t\t\tif (props.value) {\r\n\t\t\t\tfor (var i in props) {\r\n\t\t\t\t\tif (!(i > -1)) { // assign any string properties if necessary\r\n\t\t\t\t\t\thandlers[i] = props[i]\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tprops.assigned = true\r\n\t\t}\r\n\t\tElement.tagName = tagName\r\n\t\treturn Element\r\n\t}\r\n\tfunction generate(elements) {\r\n\t\telements.forEach(function(elementName) {\r\n\t\t\tvar ElementClass\r\n\t\t\tObject.defineProperty(Element, elementName, {\r\n\t\t\t\tget: function() {\r\n\t\t\t\t\treturn ElementClass || (ElementClass = getConstructor(elementName))\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t})\r\n\t}\r\n\tfunction generateInputs(elements) {\r\n\t\telements.forEach(function(inputType) {\r\n\t\t\tvar ElementClass\r\n\t\t\tObject.defineProperty(Element, inputType, {\r\n\t\t\t\tget: function() {\r\n\t\t\t\t\t// TODO: make all inputs extend from input generated from generate\r\n\t\t\t\t\treturn ElementClass || (ElementClass = setupElement(withProperties.call(HTMLInputElement, {\r\n\t\t\t\t\t\ttype: inputType.toLowerCase()\r\n\t\t\t\t\t}), 'input'))\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\t// alias all the inputs with an Input suffix\r\n\t\t\tObject.defineProperty(Element, inputType + 'Input', {\r\n\t\t\t\tget: function() {\r\n\t\t\t\t\treturn this[inputType]\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t})\r\n\t}\r\n\r\n\tvar aliases = {\r\n\t\tAnchor: 'A',\r\n\t\tParagraph: 'P',\r\n\t\tTextarea: 'TextArea',\r\n\t\tDList: 'DL',\r\n\t\tUList: 'UL',\r\n\t\tOList: 'OL',\r\n\t\tListItem: 'LI',\r\n\t\tText: 'Input',\r\n\t\tTextInput: 'Input',\r\n\t\tTableRow: 'TR',\r\n\t\tTableCell: 'TD',\r\n\t\tTableHeaderCell: 'TH',\r\n\t\tTableHeader: 'THead',\r\n\t\tTableBody: 'TBody'\r\n\t}\r\n\tfor (var alias in aliases) {\r\n\t\t(function(alias, to) {\r\n\t\t\tObject.defineProperty(Element, alias, {\r\n\t\t\t\tget: function() {\r\n\t\t\t\t\treturn this[to]\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t})(alias, aliases[alias])\r\n\t}\r\n\r\n\tElement.append = append\r\n\tElement.prepend = prepend\r\n\tElement.refresh = Renderer.refresh\r\n\tElement.options = {\r\n\t\tmoveLiveElementsEnabled: true,\r\n\t}\r\n\tElement.content = function(element){\r\n\t\t// container marker\r\n\t\treturn {\r\n\t\t\tisContentNode: true,\r\n\t\t\tcreate: element.create.bind(element)\r\n\t\t}\r\n\t}\r\n\r\n\tElement.ElementClass = function() {}\r\n\tif (typeof Symbol !== 'undefined') {\r\n\t\t// make instanceof work for Element\r\n\t\tObject.defineProperty(Element.ElementClass, Symbol.hasInstance, { value: function(target) {\r\n\t\t\treturn target && (target.create && target.with)\r\n\t\t}})\r\n\t}\r\n\r\n\t// TODO: unify this in lang\r\n\tElement.extend = function(Class, properties) {\r\n\t\tfunction ExtendedElement() {\r\n\t\t\treturn Class.apply(this, arguments)\r\n\t\t}\r\n\t\tsetPrototypeOf(ExtendedElement, Class)\r\n\t\tvar prototype = ExtendedElement.prototype = Object.create(Class.prototype)\r\n\t\tprototype.constructor = ExtendedElement\r\n\t\tObject.getOwnPropertyNames(properties).forEach(function(key) {\r\n\t\t\tvar descriptor = Object.getOwnPropertyDescriptor(properties, key)\r\n\t\t\tif (classHandlers[key]) {\r\n\t\t\t\tclassHandlers[key](ExtendedElement, descriptor.value)\r\n\t\t\t} else {\r\n\t\t\t\tObject.defineProperty(prototype, key, descriptor)\r\n\t\t\t}\r\n\t\t})\r\n\t\treturn ExtendedElement\r\n\t}\r\n\r\n\tfunction forTarget(target) {\r\n\t\treturn target.constructor.getForClass(target, this)\r\n\t}\r\n\r\n\tfunction hasOwn(From, Target, createInstance) {\r\n\t\tif (typeof Target === 'object') {\r\n\t\t\t// we were given an actual instance, use that\r\n\t\t\tvar elementMap = From.ownedClasses || (From.ownedClasses = new WeakMap())\r\n\t\t\tvar instanceMap = {get: function () {\r\n\t\t\t\treturn Target\r\n\t\t\t}}\r\n\t\t\telementMap.set(Target.constructor, instanceMap)\r\n\t\t\treturn hasOwn(From, Target.Class, Target.createInstance)\r\n\t\t}\r\n\t\tif (Target instanceof Array) {\r\n\t\t\treturn Target.forEach(function(Target) {\r\n\t\t\t\thasOwn(From, Target)\r\n\t\t\t})\r\n\t\t}\r\n\t\tvar instanceMap = new WeakMap()\r\n\t\tinstanceMap.createInstance = createInstance\r\n\t\tvar elementMap = From.ownedClasses || (From.ownedClasses = new WeakMap())\r\n\t\t// TODO: Go up through prototype chain of Target and set each one\r\n\t\telementMap.set(Target, instanceMap)\r\n\t\treturn From\r\n\t}\r\n\r\n\tfunction getForClass(element, Target) {\r\n\t\tvar createInstance\r\n\t\twhile (element && !(createInstance = element.constructor.ownedClasses && element.constructor.ownedClasses.get(Target))) {\r\n\t\t\telement = element.parentNode || presumptiveParentMap.get(element)\r\n\t\t}\r\n\t\tif (createInstance) {\r\n\t\t\tvar ownedInstances = element.ownedInstances || (element.ownedInstances = new WeakMap())\r\n\t\t\tvar instance = ownedInstances.get(Target)\r\n\t\t\tif (instance === undefined) {\r\n\t\t\t\townedInstances.set(Target, instance = createInstance(element))\r\n\t\t\t\tinstance.subject = element\r\n\t\t\t}\r\n\t\t\treturn instance\r\n\t\t}\r\n\t}\r\n\r\n\tfunction propertyForElement(key) {\r\n\t\t// we just need to establish one Variable class for each element, so we cache it\r\n\t\tThisElementVariable = this._Variable\r\n\t\tif (!ThisElementVariable) {\r\n\t\t\t// need our own branded variable class for this element class\r\n\t\t\tThisElementVariable = this._Variable = Variable()\r\n\r\n\t\t\thasOwn(this, ThisElementVariable, function(element) {\r\n\t\t\t\t// TODO: we might want to do this in init instead\r\n\t\t\t\tvar elementOverlay\r\n\t\t\t\tif (element.alkaliRenderers) {\r\n\t\t\t\t\tvar variableProperties = {}\r\n\t\t\t\t\tfor (var i = 0; i < element.alkaliRenderers.length; i++){\r\n\t\t\t\t\t\tvar renderer = element.alkaliRenderers[i]\r\n\t\t\t\t\t\tif (renderer.name) {\r\n\t\t\t\t\t\t\tvariableProperties[renderer.name] = {value: renderer.variable}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telementOverlay = Object.create(element, variableProperties)\r\n\t\t\t\t} else {\r\n\t\t\t\t\telementOverlay = element\r\n\t\t\t\t}\r\n\t\t\t\tvar instance = new ThisElementVariable(elementOverlay)\r\n\t\t\t\t// we are not observing, because you can't delegate getters and setters in safari\r\n\t\t\t\t// instance.observeObject()\r\n\t\t\t\treturn instance\r\n\t\t\t})\r\n\t\t}\r\n\t\t// now actually get the property class\r\n\t\treturn ThisElementVariable.property(key)\r\n\t}\r\n\r\n\tvar Item = Element.Item = Variable.Item\r\n\r\n\tfunction enterRenderer(Renderer, options/*, target*/) {\r\n\t\t// this will be used for optimized class-level variables\r\n\t\t/*if (target.started) { // TODO: Might want to pass in started as a parameter\r\n\t\t\t// this means that the renderer has already been created, so we just need to add this instance\r\n\t\t\tRenderer.prototype.renderUpdate.call(options, element)\r\n\t\t} else {*/\r\n\t\tnew Renderer(options)\r\n\t\t//}\r\n\t}\r\n\r\n\tfunction cleanup(target) {\r\n\t\tvar renderers = target.alkaliRenderers\r\n\t\tif (renderers) {\r\n\t\t\tfor (var i = 0, l = renderers.length; i < l; i++) {\r\n\t\t\t\trenderers[i].stop()\r\n\t\t\t}\r\n\t\t\ttarget.needsRestart = true\r\n\t\t}\r\n\t}\r\n\tfunction restart(target) {\r\n\t\tvar renderers = target.alkaliRenderers\r\n\t\tif (renderers) {\r\n\t\t\tfor (var i = 0, l = renderers.length; i < l; i++) {\r\n//\t\t\t\tupdaters[i].start()\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t// setup the mutation observer so we can be notified of attachments and removals\r\n\tfunction elementAttached(element) {\r\n\t\tvar Class = element.constructor\r\n\t\tif (Class.create) {\r\n/*\t\t\tif (Class.attachedInstances) {\r\n\t\t\t\tClass.attachedInstances.push(element)\r\n\t\t\t\tif (Class.attachedInstances.length === 1 && Class.needsRestart) {\r\n\t\t\t\t\trestart(Class)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tClass.attachedInstances = [element]\r\n\t\t\t}*/\r\n\t\t\tif (element.attached) {\r\n\t\t\t\telement.attached()\r\n\t\t\t}\r\n\t\t\tif (element.needsRestart) {\r\n\t\t\t\trestart(element)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfunction elementDetached(element) {\r\n\t\t/*var attachedInstances = element.constructor.attachedInstances\r\n\t\tif (attachedInstances) {\r\n\t\t\tvar index = attachedInstances.indexOf(element)\r\n\t\t\tif (index > -1) {\r\n\t\t\t\tattachedInstances.splice(index, 1)\r\n\t\t\t\tif (attachedInstances.length === 0) {\r\n\t\t\t\t\tcleanup(Class)\r\n\t\t\t\t}\r\n\t\t\t}*/\r\n\t\t\tif (element.detached) {\r\n\t\t\t\telement.detached()\r\n\t\t\t}\r\n\t\t\tcleanup(element)\r\n\t\t//}\r\n\t}\r\n\tif (typeof MutationObserver === 'function') {\r\n\t\tvar lifeStates = [{\r\n\t\t\tname: 'detached',\r\n\t\t\tnodes: 'removedNodes',\r\n\t\t\taction: elementDetached\r\n\t\t}, {\r\n\t\t\tname: 'attached',\r\n\t\t\tnodes: 'addedNodes',\r\n\t\t\taction: elementAttached\r\n\t\t}]\r\n\t\tfunction firstVisit(node, state) {\r\n\t\t\tif (state.name === 'attached') {\r\n\t\t\t\tif (node.__alkaliAttached__) {\r\n\t\t\t\t\treturn false\r\n\t\t\t\t} else {\r\n\t\t\t\t\tnode.__alkaliAttached__ = true\r\n\t\t\t\t\tstate.action(node)\r\n\t\t\t\t\treturn true\r\n\t\t\t\t}\r\n\t\t\t} else if (node.__alkaliAttached__) {\r\n\t\t\t\tif (doc.body.contains(node)) {\r\n\t\t\t\t\t// detached event, but it is actually still attached (will get attached in a later mutation record)\r\n\t\t\t\t\t// so don't get through the detached/attached lifecycle\r\n\t\t\t\t\treturn false\r\n\t\t\t\t}\r\n\t\t\t\tnode.__alkaliAttached__ = false\r\n\t\t\t\tstate.action(node)\r\n\t\t\t}\r\n\t\t\treturn true\r\n\t\t}\r\n\t\tvar observer = new MutationObserver(function(mutations) {\r\n\t\t\tfor (var i = 0, il = mutations.length; i < il; i++) {\r\n\t\t\t\tvar mutation = mutations[i]\r\n\t\t\t\t// invoke action on element if we haven't already\r\n\t\t\t\tactionIteration:\r\n\t\t\t\tfor (var j = 0, jl = lifeStates.length; j < jl; j++) { // two steps, removed nodes and added nodes\r\n\t\t\t\t\tvar state = lifeStates[j]\r\n\t\t\t\t\tvar nodes = mutation[state.nodes]\r\n\t\t\t\t\t// iterate over node list\r\n\t\t\t\t\tnodeIteration:\r\n\t\t\t\t\tfor (var k = 0, kl = nodes.length; k < kl; k++) {\r\n\t\t\t\t\t\tvar baseNode = nodes[k]\r\n\t\t\t\t\t\tif (firstVisit(baseNode, state)) {\r\n\t\t\t\t\t\t\t// start traversal with child, if it exists\r\n\t\t\t\t\t\t\tvar currentNode = baseNode.firstChild\r\n\t\t\t\t\t\t\tif (currentNode) {\r\n\t\t\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\t\t\tvar nextNode\r\n\t\t\t\t\t\t\t\t\tif (currentNode.nodeType === 1 && firstVisit(currentNode, state)) {\r\n\t\t\t\t\t\t\t\t\t\t// depth-first search\r\n\t\t\t\t\t\t\t\t\t\tnextNode = currentNode.firstChild\r\n\t\t\t\t\t\t\t\t\t\tif (!nextNode) {\r\n\t\t\t\t\t\t\t\t\t\t\tnextNode = currentNode.nextSibling\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\tnextNode = currentNode.nextSibling\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tif (!nextNode) {\r\n\t\t\t\t\t\t\t\t\t\t// come back out to parents\r\n\t\t\t\t\t\t\t\t\t\t// TODO: try keeping a stack to make this faster\r\n\t\t\t\t\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\t\t\t\t\tcurrentNode = currentNode.parentNode\r\n\t\t\t\t\t\t\t\t\t\t\tif (currentNode === baseNode) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tcontinue nodeIteration\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t} while (!(nextNode = currentNode.nextSibling))\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tcurrentNode = nextNode\r\n\t\t\t\t\t\t\t\t} while (true)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// if (options.moveLiveElementsEnabled) {\r\n\t\t\t\t\t\t// TODO: any options that we can really do here?\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t\tobserver.observe(doc.body || doc, {\r\n\t\t\tchildList: true,\r\n\t\t\tsubtree: true\r\n\t\t})\r\n\t}\r\n\r\n\tlang.copy(Variable.Context.prototype, {\r\n\t\tspecify: function(Variable) {\r\n\t\t\tvar element = this.subject\r\n\t\t\tvar distinctive = true\r\n\t\t\t;(this.generics || (this.generics = [])).push(Variable)\r\n\t\t\tdo {\r\n\t\t\t\tif (this.distinctSubject === element) {\r\n\t\t\t\t\tdistinctive = false\r\n\t\t\t\t}\r\n\t\t\t\tvar subjectMap = element.constructor.ownedClasses\r\n\t\t\t\tif (subjectMap) {\r\n\t\t\t\t\tvar instanceMap = subjectMap.get(Variable)\r\n\t\t\t\t\tif (instanceMap) {\r\n\t\t\t\t\t\tif (distinctive) {\r\n\t\t\t\t\t\t\tthis.distinctSubject = element\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tspecifiedInstance = instanceMap.get(element)\r\n\t\t\t\t\t\tif (!specifiedInstance) {\r\n\t\t\t\t\t\t\tinstanceMap.set(element, specifiedInstance = instanceMap.createInstance ?\r\n\t\t\t\t\t\t\t\tinstanceMap.createInstance(element) : new Variable())\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn specifiedInstance\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} while ((element = element.parentNode || presumptiveParentMap.get(element)))\r\n\t\t\t// else if no specific context is found, return default instance\r\n\t\t\treturn Variable.defaultInstance\r\n\t\t},\r\n\r\n\t\tgetContextualized: function(variable) {\r\n\t\t\t// returns a variable that has already been contextualized\r\n\t\t\tvar element = this.subject\r\n\t\t\tif (!element) {\r\n\t\t\t\t// no element, just use the default variable\r\n\t\t\t\treturn variable\r\n\t\t\t}\r\n\t\t\tif (variable._contextMap) {\r\n\t\t\t\tdo {\r\n\t\t\t\t\tvar instance = variable._contextMap.get(element)\r\n\t\t\t\t\tif (instance && instance.context.matches(element)) {\r\n\t\t\t\t\t\treturn instance\r\n\t\t\t\t\t}\r\n\t\t\t\t} while ((element = element.parentNode || presumptiveParentMap.get(element)))\r\n\t\t\t}\r\n\t\t\tif (variable.context && variable.context.matches(this.subject)) {\r\n\t\t\t\t// check if the default variable is allowed\r\n\t\t\t\treturn variable\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tmerge: function(childContext) {\r\n\t\t\tif (!this.distinctSubject || this.distinctSubject.contains(childContext.distinctSubject)) {\r\n\t\t\t\tthis.distinctSubject = childContext.distinctSubject\r\n\t\t\t}\r\n\t\t\t[].push.apply(this.generics || (this.generics = []), childContext.generics)\r\n\t\t},\r\n\t\tgetDistinctElement: function(Variable, element) {\r\n\t\t\tdo {\r\n\t\t\t\tvar subjectMap = element.constructor.ownedClasses\r\n\t\t\t\tif (subjectMap) {\r\n\t\t\t\t\tvar instanceMap = subjectMap.get(Variable)\r\n\t\t\t\t\tif (instanceMap && instanceMap.has(element)) {\r\n\t\t\t\t\t\treturn element\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} while ((element = element.parentNode || presumptiveParentMap.get(element)))\r\n\t\t},\r\n\t\tmatches: function(element) {\r\n\t\t\tvar generics = this.generics\r\n\t\t\tif (generics) {\r\n\t\t\t\tfor (var i = 0, l = generics.length; i < l; i++) {\r\n\t\t\t\t\tif (this.getDistinctElement(generics[i], element) !== this.distinctSubject) {\r\n\t\t\t\t\t\treturn false\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn true\r\n\t\t}\r\n\t})\r\n\r\n\r\n\r\n\treturn Element\r\n}))\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./Element.js\n ** module id = 1\n ** module chunks = 0\n **/","(function (root, factory) { if (typeof define === 'function' && define.amd) {\r\n\tdefine([], factory) } else if (typeof module === 'object' && module.exports) {        \r\n  module.exports = factory() // Node\r\n}}(this, function () {\r\n\tvar getPrototypeOf = Object.getPrototypeOf || (function(base) { return base.__proto__ })\r\n\tvar setPrototypeOf = Object.setPrototypeOf || (function(base, proto) { base.__proto__ = proto})\r\n\tvar hasFeatures = {\r\n\t\trequestAnimationFrame: typeof requestAnimationFrame != 'undefined',\r\n\t\tdefineProperty: Object.defineProperty && (function() {\r\n\t\t\ttry{\r\n\t\t\t\tObject.defineProperty({}, 't', {})\r\n\t\t\t\treturn true\r\n\t\t\t}catch(e) {\r\n\t\t\t}\r\n\t\t})(),\r\n\t\tpromise: typeof Promise !== 'undefined',\r\n\t\tMutationObserver: typeof MutationObserver !== 'undefined',\r\n\t\t'WeakMap': typeof WeakMap === 'function'\r\n\t}\r\n\tfunction has(feature) {\r\n\t\treturn hasFeatures[feature]\r\n\t}\r\n\t// This is an polyfill for Object.observe with just enough functionality\r\n\t// for what Variables need\r\n\t// An observe function, with polyfile\r\n\tvar observe =\r\n\t\thas('defineProperty') ? \r\n\t\tfunction observe(target, listener) {\r\n\t\t\t/*for(var i in target) {\r\n\t\t\t\taddKey(i)\r\n\t\t\t}*/\r\n\t\t\tlistener.addKey = addKey\r\n\t\t\tlistener.remove = function() {\r\n\t\t\t\tlistener = null\r\n\t\t\t}\r\n\t\t\treturn listener\r\n\t\t\tfunction addKey(key) {\r\n\t\t\t\tvar keyFlag = 'key' + key\r\n\t\t\t\tif(this[keyFlag]) {\r\n\t\t\t\t\treturn\r\n\t\t\t\t}else{\r\n\t\t\t\t\tthis[keyFlag] = true\r\n\t\t\t\t}\r\n\t\t\t\tvar currentValue = target[key]\r\n\t\t\t\tvar targetAncestor = target\r\n\t\t\t\tvar descriptor\r\n\t\t\t\tdo {\r\n\t\t\t\t\tdescriptor = Object.getOwnPropertyDescriptor(targetAncestor, key)\r\n\t\t\t\t} while(!descriptor && (targetAncestor = getPrototypeOf(targetAncestor)))\r\n\r\n\t\t\t\tif(descriptor && descriptor.set) {\r\n\t\t\t\t\tvar previousSet = descriptor.set\r\n\t\t\t\t\tvar previousGet = descriptor.get\r\n\t\t\t\t\tObject.defineProperty(target, key, {\r\n\t\t\t\t\t\tget: function() {\r\n\t\t\t\t\t\t\treturn (currentValue = previousGet.call(this))\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tset: function(value) {\r\n\t\t\t\t\t\t\tpreviousSet.call(this, value)\r\n\t\t\t\t\t\t\tif(currentValue !== value) {\r\n\t\t\t\t\t\t\t\tcurrentValue = value\r\n\t\t\t\t\t\t\t\tif(listener) {\r\n\t\t\t\t\t\t\t\t\tlistener([{target: this, name: key}])\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tenumerable: descriptor.enumerable\r\n\t\t\t\t\t})\r\n\t\t\t\t}else{\r\n\t\t\t\t\tObject.defineProperty(target, key, {\r\n\t\t\t\t\t\tget: function() {\r\n\t\t\t\t\t\t\treturn currentValue\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tset: function(value) {\r\n\t\t\t\t\t\t\tif(currentValue !== value) {\r\n\t\t\t\t\t\t\t\tcurrentValue = value\r\n\t\t\t\t\t\t\t\tif(listener) {\r\n\t\t\t\t\t\t\t\t\tlistener([{target: this, name: key}])\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tenumerable: !descriptor || descriptor.enumerable\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} :\r\n\t\t// and finally a polling-based solution, for the really old browsers\r\n\t\tfunction(target, listener) {\r\n\t\t\tif(!timerStarted) {\r\n\t\t\t\ttimerStarted = true\r\n\t\t\t\tsetInterval(function() {\r\n\t\t\t\t\tfor(var i = 0, l = watchedObjects.length; i < l; i++) {\r\n\t\t\t\t\t\tdiff(watchedCopies[i], watchedObjects[i], listeners[i])\r\n\t\t\t\t\t}\r\n\t\t\t\t}, 20)\r\n\t\t\t}\r\n\t\t\tvar copy = {}\r\n\t\t\tfor(var i in target) {\r\n\t\t\t\tif(target.hasOwnProperty(i)) {\r\n\t\t\t\t\tcopy[i] = target[i]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\twatchedObjects.push(target)\r\n\t\t\twatchedCopies.push(copy)\r\n\t\t\tlisteners.push(listener)\r\n\t\t}\r\n\tvar queuedListeners\r\n\tfunction queue(listener, object, name) {\r\n\t\tif(queuedListeners) {\r\n\t\t\tif(queuedListeners.indexOf(listener) === -1) {\r\n\t\t\t\tqueuedListeners.push(listener)\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\tqueuedListeners = [listener]\r\n\t\t\tlang.nextTurn(function() {\r\n\t\t\t\tqueuedListeners.forEach(function(listener) {\r\n\t\t\t\t\tvar events = []\r\n\t\t\t\t\tlistener.properties.forEach(function(property) {\r\n\t\t\t\t\t\tevents.push({target: listener.object, name: property})\r\n\t\t\t\t\t})\r\n\t\t\t\t\tlistener(events)\r\n\t\t\t\t\tlistener.object = null\r\n\t\t\t\t\tlistener.properties = null\r\n\t\t\t\t})\r\n\t\t\t\tqueuedListeners = null\r\n\t\t\t}, 0)\r\n\t\t}\r\n\t\tlistener.object = object\r\n\t\tvar properties = listener.properties || (listener.properties = [])\r\n\t\tif(properties.indexOf(name) === -1) {\r\n\t\t\tproperties.push(name)\r\n\t\t}\r\n\t}\r\n\tvar unobserve = has('observe') ? Object.unobserve :\r\n\t\tfunction(target, listener) {\r\n\t\t\tif(listener.remove) {\r\n\t\t\t\tlistener.remove()\r\n\t\t\t}\r\n\t\t\tfor(var i = 0, l = watchedObjects.length; i < l; i++) {\r\n\t\t\t\tif(watchedObjects[i] === target && listeners[i] === listener) {\r\n\t\t\t\t\twatchedObjects.splice(i, 1)\r\n\t\t\t\t\twatchedCopies.splice(i, 1)\r\n\t\t\t\t\tlisteners.splice(i, 1)\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\tvar watchedObjects = []\r\n\tvar watchedCopies = []\r\n\tvar listeners = []\r\n\tvar timerStarted = false\r\n\tfunction diff(previous, current, callback) {\r\n\t\t// TODO: keep an array of properties for each watch for faster iteration\r\n\t\tvar queued\r\n\t\tfor(var i in previous) {\r\n\t\t\tif(previous.hasOwnProperty(i) && previous[i] !== current[i]) {\r\n\t\t\t\t// a property has changed\r\n\t\t\t\tprevious[i] = current[i]\r\n\t\t\t\t(queued || (queued = [])).push({name: i})\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor(var i in current) {\r\n\t\t\tif(current.hasOwnProperty(i) && !previous.hasOwnProperty(i)) {\r\n\t\t\t\t// a property has been added\r\n\t\t\t\tprevious[i] = current[i]\r\n\t\t\t\t(queued || (queued = [])).push({name: i})\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(queued) {\r\n\t\t\tcallback(queued)\r\n\t\t}\r\n\t}\r\n\r\n\tvar id = 1\r\n\t// a function that returns a function, to stop JSON serialization of an\r\n\t// object\r\n\tfunction toJSONHidden() {\r\n\t\treturn toJSONHidden\r\n\t}\r\n\t// An object that will be hidden from JSON serialization\r\n\tvar Hidden = function () {\r\n\t}\r\n\tHidden.prototype.toJSON = toJSONHidden\r\n\r\n\tvar lang = {\r\n\t\trequestAnimationFrame: has('requestAnimationFrame') ? requestAnimationFrame :\r\n\t\t\t(function() {\r\n\t\t\t\tvar toRender = []\r\n\t\t\t\tvar queued = false\r\n\t\t\t\tfunction processAnimationFrame() {\r\n\t\t\t\t\tfor (var i = 0; i < toRender.length; i++) {\r\n\t\t\t\t\t\ttoRender[i]()\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttoRender = []\r\n\t\t\t\t\tqueued = false\r\n\t\t\t\t}\r\n\t\t\t\tfunction requestAnimationFrame(renderer) {\r\n\t\t\t\t \tif (!queued) {\r\n\t\t\t\t\t\tsetTimeout(processAnimationFrame)\r\n\t\t\t\t\t\tqueued = true\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttoRender.push(renderer)\r\n\t\t\t\t}\r\n\t\t\t\treturn requestAnimationFrame\r\n\t\t\t})(),\r\n\t\tPromise: has('promise') ? Promise : (function() {\r\n\t\t\tfunction Promise(execute) {\r\n\t\t\t\tvar isResolved, resolution, errorResolution\r\n\t\t\t\tvar queue = 0\r\n\t\t\t\tfunction resolve(value) {\r\n\t\t\t\t\t// resolve function\r\n\t\t\t\t\tif(value && value.then) {\r\n\t\t\t\t\t\t// received a promise, wait for it\r\n\t\t\t\t\t\tvalue.then(resolve, reject)\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tresolution = value\r\n\t\t\t\t\t\tfinished()\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tfunction reject(error) {\r\n\t\t\t\t\t// reject function\r\n\t\t\t\t\terrorResolution = error\r\n\t\t\t\t\tfinished()\r\n\t\t\t\t}\r\n\t\t\t\texecute(resolve, reject)\r\n\t\t\t\tfunction finished() {\r\n\t\t\t\t\tisResolved = true\r\n\t\t\t\t\tfor(var i = 0, l = queue.length; i < l; i++) {\r\n\t\t\t\t\t\tqueue[i]()\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// clean out the memory\r\n\t\t\t\t\tqueue = 0\r\n\t\t\t\t}\r\n\t\t\t\treturn {\r\n\t\t\t\t\tthen: function(callback, errback) {\r\n\t\t\t\t\t\treturn new Promise(function(resolve, reject) {\r\n\t\t\t\t\t\t\tfunction handle() {\r\n\t\t\t\t\t\t\t\t// promise fulfilled, call the appropriate callback\r\n\t\t\t\t\t\t\t\ttry{\r\n\t\t\t\t\t\t\t\t\tif(errorResolution && !errback) {\r\n\t\t\t\t\t\t\t\t\t\t// errors without a handler flow through\r\n\t\t\t\t\t\t\t\t\t\treject(errorResolution)\r\n\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t// resolve to the callback's result\r\n\t\t\t\t\t\t\t\t\t\tresolve(errorResolution ?\r\n\t\t\t\t\t\t\t\t\t\t\terrback(errorResolution) :\r\n\t\t\t\t\t\t\t\t\t\t\tcallback ?\r\n\t\t\t\t\t\t\t\t\t\t\t\tcallback(resolution) : resolution)\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}catch(newError) {\r\n\t\t\t\t\t\t\t\t\t// caught an error, reject the returned promise\r\n\t\t\t\t\t\t\t\t\treject(newError)\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif(isResolved) {\r\n\t\t\t\t\t\t\t\t// already resolved, immediately handle\r\n\t\t\t\t\t\t\t\thandle()\r\n\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t(queue || (queue = [])).push(handle)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn Promise\r\n\t\t}()),\r\n\r\n\t\tWeakMap: has('WeakMap') ? WeakMap :\r\n\t \tfunction (values, name) {\r\n\t \t\tvar mapProperty = '__' + (name || '') + id++\r\n\t \t\treturn has('defineProperty') ?\r\n\t \t\t{\r\n\t \t\t\tget: function (key) {\r\n\t \t\t\t\treturn key[mapProperty]\r\n\t \t\t\t},\r\n\t \t\t\tset: function (key, value) {\r\n\t \t\t\t\tObject.defineProperty(key, mapProperty, {\r\n\t \t\t\t\t\tvalue: value,\r\n\t \t\t\t\t\tenumerable: false\r\n\t \t\t\t\t})\r\n\t \t\t\t}\r\n\t \t\t} :\r\n\t \t\t{\r\n\t \t\t\tget: function (key) {\r\n\t \t\t\t\tvar intermediary = key[mapProperty]\r\n\t \t\t\t\treturn intermediary && intermediary.value\r\n\t \t\t\t},\r\n\t \t\t\tset: function (key, value) {\r\n\t \t\t\t\t// we use an intermediary that is hidden from JSON serialization, at least\r\n\t \t\t\t\tvar intermediary = key[mapProperty] || (key[mapProperty] = new Hidden())\r\n\t \t\t\t\tintermediary.value = value\r\n\t \t\t\t}\r\n\t \t\t}\r\n\t \t},\r\n\r\n\t\tobserve: observe,\r\n\t\tunobserve: unobserve,\r\n\t\twhen: function(value, callback, errorHandler) {\r\n\t\t\treturn value && value.then ?\r\n\t\t\t\t(value.then(callback, errorHandler) || value) : callback(value)\r\n\t\t},\r\n\t\twhenAll: function(inputs, callback) {\r\n\t\t\tvar promiseInvolved\r\n\t\t\tfor(var i = 0, l = inputs.length; i < l; i++) {\r\n\t\t\t\tif(inputs[i] && inputs[i].then) {\r\n\t\t\t\t\tpromiseInvolved = true\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(promiseInvolved) {\r\n\t\t\t\t// we have asynch inputs, do lazy loading\r\n\t\t\t\treturn {\r\n\t\t\t\t\tthen: function(onResolve, onError) {\r\n\t\t\t\t\t\tvar remaining = 1\r\n\t\t\t\t\t\tvar result\r\n\t\t\t\t\t\tvar readyInputs = []\r\n\t\t\t\t\t\tvar lastPromiseResult\r\n\t\t\t\t\t\tfor(var i = 0; i < inputs.length; i++) {\r\n\t\t\t\t\t\t\tvar input = inputs[i]\r\n\t\t\t\t\t\t\tremaining++\r\n\t\t\t\t\t\t\tif(input && input.then) {\r\n\t\t\t\t\t\t\t\t(function(i, previousPromiseResult) {\r\n\t\t\t\t\t\t\t\t\tlastPromiseResult = input.then(function(value) {\r\n\t\t\t\t\t\t\t\t\t\treadyInputs[i] = value\r\n\t\t\t\t\t\t\t\t\t\tonEach()\r\n\t\t\t\t\t\t\t\t\t\tif(!remaining) {\r\n\t\t\t\t\t\t\t\t\t\t\treturn result\r\n\t\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t\treturn previousPromiseResult\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}, onError)\r\n\t\t\t\t\t\t\t\t})(i, lastPromiseResult)\r\n\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\treadyInputs[i] = input\r\n\t\t\t\t\t\t\t\tonEach()\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tonEach()\r\n\t\t\t\t\t\tfunction onEach() {\r\n\t\t\t\t\t\t\tremaining--\r\n\t\t\t\t\t\t\tif(!remaining) {\r\n\t\t\t\t\t\t\t\tresult = onResolve(callback(readyInputs))\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn lastPromiseResult\r\n\t\t\t\t\t},\r\n\t\t\t\t\tinputs: inputs\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// just sync inputs\r\n\t\t\treturn callback(inputs)\r\n\r\n\t\t},\r\n\t\tcompose: function(Base, constructor, properties) {\r\n\t\t\tvar prototype = constructor.prototype = Object.create(Base.prototype)\r\n\t\t\tsetPrototypeOf(constructor, Base)\r\n\t\t\tfor(var i in properties) {\r\n\t\t\t\tprototype[i] = properties[i]\r\n\t\t\t}\r\n\t\t\tprototype.constructor = constructor\r\n\t\t\treturn constructor\r\n\t\t},\r\n\t\tnextTurn: has('MutationObserver') ?\r\n\t\t\tfunction (callback) {\r\n\t\t\t\t// promises don't resolve consistently on the next micro turn (Edge doesn't do it right),\r\n\t\t\t\t// so use mutation observer\r\n\t\t\t\t// TODO: make a faster mode that doesn't recreate each time\r\n\t\t\t\tvar div = document.createElement('div')\r\n\t\t\t\tvar observer = new MutationObserver(callback)\r\n\t\t\t\tobserver.observe(div, {\r\n\t\t\t\t\tattributes: true\r\n\t\t\t\t})\r\n\t\t\t\tdiv.setAttribute('a', id++)\r\n\t\t\t} :\r\n\t\t\tfunction (callback) {\r\n\t\t\t\t// TODO: we can do better for other, older browsers\r\n\t\t\t\tsetTimeout(callback, 0)\r\n\t\t\t},\r\n\t\tcopy: Object.assign || function(target, source) {\r\n\t\t\tfor(var i in source) {\r\n\t\t\t\ttarget[i] = source[i]\r\n\t\t\t}\r\n\t\t\treturn target\r\n\t\t}\r\n\t}\r\n\tfunction isGenerator(func) {\r\n\t\tif (typeof func === 'function') {\r\n\t\t\tvar constructor = func.constructor\r\n\t\t\t// this is used to handle both native generators and transpiled generators\r\n\t\t\treturn (constructor.displayName || constructor.name) === 'GeneratorFunction'\r\n\t\t}\r\n\t}\r\n\tlang.isGenerator = isGenerator\r\n\treturn lang\r\n}))\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./util/lang.js\n ** module id = 2\n ** module chunks = 0\n **/","(function (root, factory) { if (typeof define === 'function' && define.amd) {\r\n\tdefine(['./util/lang', './Variable'], factory) } else if (typeof module === 'object' && module.exports) {        \r\n  module.exports = factory(require('./util/lang'), require('./Variable')) // Node\r\n}}(this, function (lang, Variable) {\r\n\tvar doc = typeof document !== 'undefined' && document\r\n\tvar invalidatedElements\r\n\tvar queued\r\n\tvar toRender = []\r\n\tvar nextId = 1\r\n\tvar requestAnimationFrame = lang.requestAnimationFrame\r\n\tvar Context = Variable.Context\r\n\r\n\tfunction Renderer(options) {\r\n\t\tvar variable = options.variable\r\n\r\n\t\tthis.variable = variable\r\n\t\tif (options.selector) {\r\n\t\t\tthis.selector = options.selector\r\n\t\t}\r\n\t\tif (options.elements) {\r\n\t\t\tthis.elements = options.elements\r\n\t\t\tthis.element = this.elements[0]\r\n\t\t\tfor(var i = 0, l = this.elements.length; i < l; i++) {\r\n\t\t\t\t(this.elements[i].alkaliRenderers || (this.elements[i].alkaliRenderers = [])).push(this)\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (options.element) {\r\n\t\t\tvar element = this.element = options.element;\r\n\t\t\t(element.alkaliRenderers || (element.alkaliRenderers = [])).push(this)\r\n\t\t} else {\r\n\t\t\tthrow new Error('No element provided to Renderer')\r\n\t\t}\r\n\t\tif (options.update) {\r\n\t\t\tthis.updateRendering = options.update\r\n\t\t}\r\n\t\tif (options.shouldRender) {\r\n\t\t\tthis.shouldRender = options.shouldRender\r\n\t\t}\r\n\t\tif (options.renderUpdate) {\r\n\t\t\tthis.renderUpdate = options.renderUpdate\r\n\t\t}\r\n\t\tif (options.alwaysUpdate) {\r\n\t\t\tthis.alwaysUpdate = options.alwaysUpdate\r\n\t\t}\r\n\t\tif (!variable.updated) {\r\n\t\t\t// baconjs-esqe API\r\n\t\t\tvar renderer = this\r\n\t\t\tvariable.subscribe(function (event) {\r\n\t\t\t\t// replace the variable with an object\r\n\t\t\t\t// that returns the value from the event\r\n\t\t\t\trenderer.variable = {\r\n\t\t\t\t\tvalueOf: function () {\r\n\t\t\t\t\t\treturn event.value()\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\trenderer.updated()\r\n\t\t\t})\r\n\t\t}\r\n\t\tif (options.updateOnStart === false){\r\n\t\t\t// even if we don't render on start, we still need to compute the value so we can depend on the computed variables\r\n\t\t\tthis.variable.valueOf(this)\r\n\t\t\tvar contextualized = this.contextualized || this.variable\r\n\t\t\t// TODO: we may need to handle recontextualization if it returns a promise\r\n\t\t\tcontextualized.notifies(this)\r\n\t\t} else {\r\n\t\t\tthis.updateRendering(true)\r\n\t\t}\r\n\t}\r\n\tRenderer.prototype = {\r\n\t\tconstructor: Renderer,\r\n\t\tupdateRendering: function () {\r\n\t\t\tthrow new Error ('updateRendering must be implemented by sub class of Renderer')\r\n\t\t},\r\n\t\tupdated: function (updateEvent, by, context) {\r\n\t\t\tif (!this.invalidated) {\r\n\t\t\t\tif (!context || this.contextMatches(context)) {\r\n\t\t\t\t\t// do this only once, until we render again\r\n\t\t\t\t\tthis.invalidated = true\r\n\t\t\t\t\tvar renderer = this\r\n\t\t\t\t\trequestAnimationFrame(function(){\r\n\t\t\t\t\t\tinvalidatedElements = null\r\n\t\t\t\t\t\trenderer.updateRendering(renderer.alwaysUpdate)\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tnewContext: function() {\r\n\t\t\treturn new Variable.Context(this.element)\r\n\t\t},\r\n\t\taddInput: function(variable) {\r\n\t\t\tthis.contextualized = variable\r\n\t\t},\r\n\t\tgetContextualized: function() {\r\n\t\t\treturn this.contextualized\r\n\t\t},\r\n\t\tspecify: function(Variable) {\r\n\t\t\t// a new context to get thsi\r\n\t\t\treturn this.newContext().specify(Variable)\r\n\t\t},\r\n\t\tmerge: function(){\r\n\t\t\t// noop\r\n\t\t},\r\n\t\tcontextMatches: function(context) {\r\n\t\t\treturn true\r\n\t\t},\r\n\t\tinvalidateElement: function(element) {\r\n\t\t\tif(!invalidatedElements){\r\n\t\t\t\tinvalidatedElements = new WeakMap(null, 'invalidated')\r\n\t\t\t}\r\n\t\t\tvar invalidatedParts = invalidatedElements.get(element)\r\n\t\t\tinvalidatedElements.set(element, invalidatedParts = {})\r\n\t\t\tif (!invalidatedParts[id]) {\r\n\t\t\t\tinvalidatedParts[id] = true\r\n\t\t\t}\r\n\t\t\tif (!queued) {\r\n\t\t\t\tlang.queueTask(processQueue)\r\n\t\t\t\tqueued = true\r\n\t\t\t}\r\n\t\t\tvar renderer = this\r\n\t\t\ttoRender.push(function(){\r\n\t\t\t\trenderer.invalidated = false\r\n\t\t\t\trenderer.updateElement(element)\r\n\t\t\t})\r\n\t\t},\r\n\t\tgetId: function(){\r\n\t\t\treturn this.id || (this.id = nextId++)\r\n\t\t},\r\n\t\tstop: function() {\r\n\t\t\tvar contextualized = this.contextualized || this.variable\r\n\t\t\tcontextualized.stopNotifies(this)\r\n\t\t}\r\n\t}\r\n\r\n\tfunction ElementRenderer(options) {\r\n\t\tRenderer.call(this, options)\r\n\t}\r\n\tElementRenderer.prototype = Object.create(Renderer.prototype)\r\n\tElementRenderer.prototype.shouldRender = function (element) {\r\n\t\treturn document.body.contains(element)\r\n\t}\r\n\tElementRenderer.prototype.getSubject = function () {\r\n\t\treturn this.element\r\n\t}\r\n\tElementRenderer.prototype.updateRendering = function (always, element) {\r\n\t\tif (!element && this.elements) {\r\n\t\t\tvar elements = this.elements\r\n\t\t\tif(!elements.length){\r\n\t\t\t\tif(this.selector){\r\n\t\t\t\t\telements = document.querySelectorAll(this.selector)\r\n\t\t\t\t}else{\r\n\t\t\t\t\tthrow new Error('No element or selector was provided to the Renderer')\r\n\t\t\t\t}\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tfor(var i = 0, l = elements.length; i < l; i++){\r\n\t\t\t\tthis.updateRendering(always, elements[i])\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvar thisElement = element || this.element\r\n\r\n\t\t\tif(always || this.shouldRender(thisElement)){\r\n\t\t\t\t// it is connected\r\n\t\t\t\tthis.updateElement(thisElement)\r\n\t\t\t} else {\r\n\t\t\t\tvar id = this.getId()\r\n\t\t\t\tvar renderers = thisElement.renderersOnShow\r\n\t\t\t\tif(!renderers){\r\n\t\t\t\t\trenderers = thisElement.renderersOnShow = []\r\n\t\t\t\t\tthisElement.className += ' needs-rerendering'\r\n\t\t\t\t}\r\n\t\t\t\tif (!renderers[id]) {\r\n\t\t\t\t\trenderers[id] = this\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tElementRenderer.prototype.addElement = function (element) {\r\n\t\tif (this.selector) {\r\n\t\t\telement.renderersOnShow = [this]\r\n\t\t} else {\r\n\t\t\tthis.elements.push(element)\r\n\t\t}\r\n\t\t// and immediately do an update\r\n\t\tthis.updateElement(element)\r\n\t}\r\n\tElementRenderer.prototype.updateElement = function(element) {\r\n\t\tthis.invalidated = false\r\n\t\ttry {\r\n\t\t\tif (!this.omitValueOf) {\r\n\t\t\t\tvar value = this.variable.valueOf(this)\r\n\t\t\t\tvar contextualized = this.contextualized || this.variable\r\n\t\t\t\t// TODO: we may need to handle recontextualization if it returns a promise\r\n\t\t\t\tcontextualized.notifies(this)\r\n\t\t\t}\r\n\t\t} catch (error) {\r\n\t\t\telement.appendChild(document.createTextNode(error))\r\n\t\t}\r\n\t\tif(value !== undefined || this.started || this.omitValueOf){\r\n\t\t\tthis.started = true\r\n\t\t\tif(value && value.then){\r\n\t\t\t\tif(this.renderLoading){\r\n\t\t\t\t\tthis.renderLoading(value, element)\r\n\t\t\t\t}\r\n\t\t\t\tvar renderer = this\r\n\t\t\t\tvalue.then(function (value) {\r\n\t\t\t\t\trenderer.renderUpdate(value, element)\r\n\t\t\t\t})\r\n\t\t\t}else{\r\n\t\t\t\tthis.renderUpdate(value, element)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tElementRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\tthrow new Error('renderUpdate(newValue) must be implemented')\r\n\t}\r\n\tRenderer.Renderer = Renderer\r\n\tRenderer.ElementRenderer = ElementRenderer\r\n\r\n\tfunction AttributeRenderer(options) {\r\n\t\tif(options.name){\r\n\t\t\tthis.name = options.name\r\n\t\t}\r\n\t\tElementRenderer.apply(this, arguments)\r\n\t}\r\n\tAttributeRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\tAttributeRenderer.prototype.type = 'AttributeRenderer'\r\n\tAttributeRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\telement.setAttribute(this.name, newValue)\r\n\t}\r\n\tRenderer.AttributeRenderer = AttributeRenderer\r\n\r\n\tfunction PropertyRenderer(options) {\r\n\t\tif (options.name) {\r\n\t\t\tthis.name = options.name\r\n\t\t}\r\n\t\tElementRenderer.apply(this, arguments)\r\n\t}\r\n\tPropertyRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\tPropertyRenderer.prototype.type = 'PropertyRenderer'\r\n\tPropertyRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\telement[this.name] = newValue\r\n\t}\r\n\tRenderer.PropertyRenderer = PropertyRenderer\r\n\r\n\tfunction InputPropertyRenderer(options) {\r\n\t\tif (options.element && options.element.tagName === 'SELECT' && options.name === 'value') {\r\n\t\t\t// use the deferred value assignment for <select>\r\n\t\t\tthis.renderUpdate = this.renderSelectValueUpdate\r\n\t\t}\r\n\t\tPropertyRenderer.apply(this, arguments)\r\n\t}\r\n\tInputPropertyRenderer.prototype = Object.create(PropertyRenderer.prototype)\r\n\tInputPropertyRenderer.prototype.type = 'InputPropertyRenderer'\r\n\tInputPropertyRenderer.prototype.renderUpdate = function(newValue, element) {\r\n\t\tif (newValue == null || (element.type === 'number' && isNaN(newValue))) {\r\n\t\t\tnewValue = ''\r\n\t\t}\r\n\t\telement[this.name] = newValue\r\n\t}\r\n\tInputPropertyRenderer.prototype.renderSelectValueUpdate = function (newValue, element) {\r\n\t\telement.value = newValue\r\n\t\tif (element.value != newValue && !element.value) {\r\n\t\t\t// if we didn't successfully set the value of a <select>, we may need to wait until the children are constructed\r\n\t\t\telement.eventualValue = newValue\r\n\t\t\tlang.nextTurn(function() {\r\n\t\t\t\tif (element.eventualValue) {\r\n\t\t\t\t\telement.value = element.eventualValue\r\n\t\t\t\t\telement.eventualValue = undefined\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t} else {\r\n\t\t\telement.eventualValue = undefined\r\n\t\t}\r\n\t}\r\n\tRenderer.InputPropertyRenderer = InputPropertyRenderer\r\n\r\n\tfunction StyleRenderer(options) {\r\n\t\tif(options.name){\r\n\t\t\tthis.name = options.name\r\n\t\t}\r\n\t\tElementRenderer.apply(this, arguments)\r\n\t}\r\n\tStyleRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\tStyleRenderer.prototype.type = 'StyleRenderer'\r\n\tStyleRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\telement.style[this.name] = newValue\r\n\t}\r\n\tRenderer.StyleRenderer = StyleRenderer\r\n\r\n\tfunction ContentRenderer(options) {\r\n\t\tElementRenderer.apply(this, arguments)\r\n\t}\r\n\tContentRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\tContentRenderer.prototype.type = 'ContentRenderer'\r\n\tContentRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\telement.innerHTML = ''\r\n\t\tif (newValue === undefined){\r\n\t\t\tnewValue = ''\r\n\t\t}\r\n\t\telement.appendChild(document.createTextNode(newValue))\r\n\t}\r\n\tRenderer.ContentRenderer = ContentRenderer\r\n\r\n\tfunction TextRenderer(options) {\r\n\t\tthis.position = options.position\r\n\t\tthis.textNode = options.textNode\r\n\t\tElementRenderer.apply(this, arguments)\r\n\t}\r\n\tTextRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\tTextRenderer.prototype.type = 'TextRenderer'\r\n\tTextRenderer.prototype.updated = function (updateEvent, context) {\r\n\t\tif (this.builtList) {\r\n\t\t\tif (updateEvent.type === 'refresh') {\r\n\t\t\t\tthis.builtList = false\r\n\t\t\t\tthis.omitValueOf = false\r\n\t\t\t} else {\r\n\t\t\t\t(this.updates || (this.updates = [])).push(updateEvent)\r\n\t\t\t}\r\n\t\t}\r\n\t\tElementRenderer.prototype.updated.call(this, updateEvent, context)\r\n\t}\r\n\tTextRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\tif (newValue == null){\r\n\t\t\tnewValue = ''\r\n\t\t}\r\n\t\tif (newValue.nodeType) {\r\n\t\t\tif (this.textNode && this.textNode.parentNode == element) {\r\n\t\t\t\t// text node is attached, we can replace it with the node\r\n\t\t\t\telement.replaceChild(newValue, this.textNode)\r\n\t\t\t} else {\r\n\t\t\t\telement.appendChild(newValue)\r\n\t\t\t}\r\n\t\t\tthis.textNode = newValue\r\n\t\t} else if (newValue instanceof Array) {\r\n\t\t\tthis.renderUpdate = ListRenderer.prototype.renderUpdate\r\n\t\t\tthis.omitValueOf = true\r\n\t\t\tthis.renderUpdate(newValue, element)\r\n\t\t} else {\r\n\t\t\t(this.textNode || element.childNodes[this.position]).nodeValue = newValue\r\n\t\t}\r\n\t}\r\n\tRenderer.TextRenderer = TextRenderer\r\n\r\n\tfunction ListRenderer(options) {\r\n\t\tif (options.each) {\r\n\t\t\tthis.each = options.each\r\n\t\t}\r\n\t\tElementRenderer.apply(this, arguments)\r\n\t}\r\n\tListRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\tListRenderer.prototype.updated = function (updateEvent, context) {\r\n\t\tif (this.builtList) {\r\n\t\t\tif (updateEvent.type === 'refresh') {\r\n\t\t\t\tthis.builtList = false\r\n\t\t\t\tthis.omitValueOf = false\r\n\t\t\t} else {\r\n\t\t\t\t(this.updates || (this.updates = [])).push(updateEvent)\r\n\t\t\t}\r\n\t\t}\r\n\t\tElementRenderer.prototype.updated.call(this, updateEvent, context)\r\n\t}\r\n\tListRenderer.prototype.type = 'ListRenderer'\r\n\tListRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\tvar container\r\n\t\tvar each = this.each || function(item) { // TODO: make a single identity function\r\n\t\t\treturn item\r\n\t\t}\r\n\t\tvar thisElement = this.element\r\n\t\tvar renderer = this\r\n\t\tif (!this.builtList) {\r\n\t\t\tthis.builtList = true\r\n\t\t\tthis.omitValueOf = true\r\n\t\t\telement.innerHTML = ''\r\n\t\t\tcontainer = document.createDocumentFragment()\r\n\t\t\tvar childElements = this.childElements = []\r\n\t\t\tif (each.defineHasOwn) {\r\n\t\t\t\teach.defineHasOwn()\r\n\t\t\t}\r\n\t\t\tnewValue.forEach(function(item) {\r\n\t\t\t\teachItem(item)\r\n\t\t\t})\r\n\t\t\tvar contextualized = this.contextualized || this.variable\r\n\t\t\tcontextualized.notifies(this)\r\n\r\n\t\t\tthisElement.appendChild(container)\r\n\t\t} else {\r\n\t\t\tvar childElements = this.childElements\r\n\t\t\tvar updates = this.updates\r\n\t\t\tcontainer = thisElement\r\n\t\t\tupdates.forEach(function(update) {\r\n\t\t\t\tif (update.type === 'refresh') {\r\n\t\t\t\t\trenderer.builtList = false\r\n\t\t\t\t\tfor (var i = 0, l = childElements.length; i < l; i++) {\r\n\t\t\t\t\t\tthisElement.removeChild(childElements[i])\r\n\t\t\t\t\t}\r\n\t\t\t\t\trenderer.renderUpdate()\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (update.previousIndex > -1) {\r\n\t\t\t\t\t\tthisElement.removeChild(childElements[update.previousIndex])\r\n\t\t\t\t\t\tchildElements.splice(update.previousIndex, 1)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (update.index > -1) {\r\n\t\t\t\t\t\tvar nextChild = childElements[update.index] || null\r\n\t\t\t\t\t\teachItem(update.value, update.index, nextChild)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\tthis.updates = [] // clear the updates\r\n\t\t}\r\n\t\tfunction eachItem(item, index, nextChild) {\r\n\t\t\tvar childElement\r\n\t\t\tif (each.create) {\r\n\t\t\t\tchildElement = each.create({parent: thisElement, _item: item}) // TODO: make a faster object here potentially\r\n\t\t\t} else {\r\n\t\t\t\tchildElement = each(item, thisElement)\r\n\t\t\t\tif (childElement.create) {\r\n\t\t\t\t\tchildElement = childElement.create({parent: thisElement, _item: item})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (nextChild) {\r\n\t\t\t\tcontainer.insertBefore(childElement, nextChild)\r\n\t\t\t\tchildElements.splice(index, 0, childElement)\r\n\t\t\t} else {\r\n\t\t\t\tcontainer.appendChild(childElement)\r\n\t\t\t\tchildElements.push(childElement)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tRenderer.ListRenderer = ListRenderer\r\n\r\n\tRenderer.onShowElement = function(shownElement){\r\n\t\trequestAnimationFrame(function(){\r\n\t\t\tinvalidatedElements = null\r\n\t\t\tvar elements = [].slice.call(shownElement.getElementsByClassName('needs-rerendering'))\r\n\t\t\tif (shownElement.className.indexOf('needs-rerendering') > 0){\r\n\t\t\t\tvar includingTop = [shownElement]\r\n\t\t\t\tincludingTop.push.apply(includingTop, elements)\r\n\t\t\t\telements = includingTop\r\n\t\t\t}\r\n\t\t\tfor (var i = 0, l = elements.length; i < l; i++){\r\n\t\t\t\tvar element = elements[i]\r\n\t\t\t\tvar renderers = element.renderersOnShow\r\n\t\t\t\tif(renderers){\r\n\t\t\t\t\telement.renderersOnShow = null\r\n\t\t\t\t\t// remove needs-rerendering class\r\n\t\t\t\t\telement.className = element.className.replace(/\\s?needs\\-rerendering\\s?/g, '')\r\n\t\t\t\t\tfor (var id in renderers) {\r\n\t\t\t\t\t\tvar renderer = renderers[id]\r\n\t\t\t\t\t\trenderer.updateElement(element)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n\r\n\tfunction onElementRemoval(element){\r\n\t\t// cleanup element renderers\r\n\t\tif(element.alkaliRenderers){\r\n\t\t\tvar renderers = element.alkaliRenderers\r\n\t\t\tfor(var i = 0; i < renderers.length; i++){\r\n\t\t\t\tvar renderer = renderers[i]\r\n\t\t\t\trenderer.variable.stopNotifies(renderer)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tRenderer.onElementRemoval = function(element, onlyChildren){\r\n\t\tif(!onlyChildren){\r\n\t\t\tonElementRemoval(element)\r\n\t\t}\r\n\t\tvar children = element.getElementsByTagName('*')\r\n\t\tfor(var i = 0, l = children.length; i < l; i++){\r\n\t\t\tvar child = children[i]\r\n\t\t\tif(child.alkaliRenderers){\r\n\t\t\t\tonElementRemoval(child)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn Renderer\r\n}))\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./Renderer.js\n ** module id = 3\n ** module chunks = 0\n **/","(function (root, factory) { if (typeof define === 'function' && define.amd) {\r\n\tdefine(['./util/lang'], factory) } else if (typeof module === 'object' && module.exports) {        \r\n  module.exports = factory(require('./util/lang')) // Node\r\n}}(this, function (lang) {\r\n\tvar deny = {}\r\n\tvar noChange = {}\r\n\tvar WeakMap = lang.WeakMap\r\n\tvar setPrototypeOf = Object.setPrototypeOf || (function(base, proto) { base.__proto__ = proto})\r\n\tvar getPrototypeOf = Object.getPrototypeOf || (function(base) { return base.__proto__ })\r\n\tvar isGenerator = lang.isGenerator\r\n\t// update types\r\n\tvar RequestChange = 3\r\n\tvar RequestSet = 4\r\n\r\n\tvar nextId = 1\r\n\tvar propertyListenersMap = new WeakMap(null, 'propertyListenersMap')\r\n\r\n\tvar CacheEntry = lang.compose(WeakMap, function() {\r\n\t},{\r\n\t\t_propertyChange: function(propertyName) {\r\n\t\t\tthis.variable._propertyChange(propertyName, contextFromCache(this))\r\n\t\t}\r\n\t})\r\n\tvar listenerId = 1\r\n\r\n\tfunction when(value, callback) {\r\n\t\tif (value && value.then) {\r\n\t\t\treturn value.then(callback)\r\n\t\t}\r\n\t\treturn callback(value)\r\n\t}\r\n\r\n\tfunction Context(subject){\r\n\t\tthis.subject = subject\r\n\t\tthis.inputs = []\r\n\t}\r\n\tContext.prototype = {\r\n\t\tconstructor: Context,\r\n\t\tnewContext: function(variable) {\r\n\t\t\treturn new Context(this.subject)\r\n\t\t},\r\n\t\tcontextualize: function(variable, parentContext) {\r\n\t\t\t// resolve the contextualization of a variable, and updates this context to be aware of what distinctive aspect of the context has\r\n\t\t\t// been used for resolution\r\n\t\t\tvar contextualized\r\n\t\t\tif (this.distinctSubject) {\r\n\t\t\t\tvar contextMap = variable._contextMap || (variable._contextMap = new WeakMap())\r\n\t\t\t\tcontextualized = contextMap.get(this.distinctSubject)\r\n\t\t\t\tif (!contextualized) {\r\n\t\t\t\t\tcontextMap.set(this.distinctSubject, contextualized = Object.create(variable))\r\n\t\t\t\t\tcontextualized.listeners = false\r\n\t\t\t\t\tcontextualized.context = this\r\n\t\t\t\t\tvar inputs = this.inputs\r\n\t\t\t\t\tfor (var i = 0, l = inputs.length; i < l; i++) {\r\n\t\t\t\t\t\tcontextualized[inputs[i]] = inputs[++i]\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tthis.contextualized = contextualized\r\n\t\t\t\t// do the merge\r\n\t\t\t\tif (parentContext) {\r\n\t\t\t\t\tparentContext.merge(this)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tcontextualized = variable\r\n\t\t\t}\r\n\t\t\t//if (this.contextualized && this.contextualized !== contextualized) {\r\n\t\t\t\t// TOOD: if it has previously been contextualized to a different context (can happen in a promise/async situation), stop previous notifiers and start new ones\r\n\t\t\t//}\r\n\t\t\tparentContext.addInput(contextualized)\r\n\t\t\treturn contextualized\r\n\t\t},\r\n\t\tmerge: function(childContext) {\r\n\t\t\tif (!this.distinctSubject) {\r\n\t\t\t\tthis.distinctSubject = childContext.distinctSubject\r\n\t\t\t}\r\n\t\t},\r\n\t\tspecify: function(Variable) {\r\n\t\t\t// specify a particular instance of a generic variable\r\n\t\t\tvar subject = this.subject\r\n\t\t\tvar subjectMap = subject.constructor.ownedClasses\r\n\t\t\tvar specifiedInstance\r\n\t\t\tif (subjectMap) {\r\n\t\t\t\tif (!this.distinctSubject) {\r\n\t        this.distinctSubject = subject\r\n\t\t\t\t}\r\n\t\t\t\tvar instanceMap = subjectMap.get(Variable)\r\n\t\t\t\tif (instanceMap) {\r\n\t\t\t\t\tspecifiedInstance = instanceMap.get(subject)\r\n\t\t\t\t\tif (!specifiedInstance) {\r\n\t\t\t\t\t\tinstanceMap.set(subject, specifiedInstance = instanceMap.createInstance ? instanceMap.createInstance(subject) : new Variable())\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn specifiedInstance\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// else if no specific context is found, return default instance\r\n\t\t\treturn Variable.defaultInstance\r\n\t\t},\r\n\t\tgetContextualized: function(variable) {\r\n\r\n\t\t\t// returns a variable that has already been contextualized\r\n\t\t\tvar instance = variable._contextMap && this.subject && variable._contextMap.get(this.subject)\r\n\t\t\tif (instance && instance.context && instance.context.matches(this)) {\r\n\t\t\t\treturn instance\r\n\t\t\t}\r\n\t\t},\r\n\t\taddInput: function(inputVariable) {\r\n\t\t\tthis.inputs.push(this.nextProperty, inputVariable)\r\n\t\t},\r\n\t\tmatches: function(context) {\r\n\t\t\t// does another context match the resolution of this one?\r\n\t\t\treturn context.subject === this.subject\r\n\t\t}\r\n\t}\r\n\r\n\tfunction NotifyingContext(listener, subject){\r\n\t\tthis.subject = subject\r\n\t\tthis.listener = listener\r\n\t}\r\n\tNotifyingContext.prototype = Object.create(Context.prototype)\r\n\tNotifyingContext.prototype.constructor = NotifyingContext\r\n\tNotifyingContext.prototype.addInput = function(contextualized) {\r\n\t\tcontextualized.notifies(this.listener)\r\n\t}\r\n\r\n\tfunction whenAll(inputs, callback){\r\n\t\tvar promiseInvolved\r\n\t\tfor (var i = 0, l = inputs.length; i < l; i++) {\r\n\t\t\tif (inputs[i] && inputs[i].then) {\r\n\t\t\t\tpromiseInvolved = true\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (promiseInvolved) {\r\n\t\t\treturn lang.whenAll(inputs, callback)\r\n\t\t}\r\n\t\treturn callback(inputs)\r\n\t}\r\n\r\n\tfunction registerListener(value, listener) {\r\n\t\tvar listeners = propertyListenersMap.get(value)\r\n\t\tvar id = listener.listenerId || (listener.listenerId = ('-' + listenerId++))\r\n\t\tif (listeners) {\r\n\t\t\tif (listeners[id] === undefined) {\r\n\t\t\t\tlisteners[id] = listeners.push(listener) - 1\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\tpropertyListenersMap.set(value, listeners = [listener])\r\n\t\t\tlisteners[id] = 0\r\n\t\t\tif (Variable.autoObserveObjects) {\r\n\t\t\t\tobserve(value)\r\n\t\t\t}\r\n\t\t}\r\n\t\tlistener.listeningToObject = value\r\n\t}\r\n\tfunction deregisterListener(listener) {\r\n\t\tif (listener.listeningToObject) {\r\n\t\t\tvar value = listener.listeningToObject\r\n\t\t\tlistener.listeningToObject = null\r\n\t\t\tvar listeners = propertyListenersMap.get(value)\r\n\t\t\tif (listeners) {\r\n\t\t\t\tvar index = listeners[listener.listenerId]\r\n\t\t\t\tif (index > -1) {\r\n\t\t\t\t\tlisteners.splice(index, 1)\r\n\t\t\t\t\tdelete listeners[listener.listenerId]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction RefreshEvent() {\r\n\t\tthis.visited = new Set()\r\n\t}\r\n\tRefreshEvent.prototype.type = 'refresh'\r\n\r\n\tfunction PropertyChangeEvent(key, childEvent, parent) {\r\n\t\tthis.key = key\r\n\t\tthis.childEvent = childEvent\r\n\t\tthis.parent = parent\r\n\t\tthis.visited = childEvent.visited\r\n\t}\r\n\tPropertyChangeEvent.prototype.type = 'update'\r\n\r\n\tfunction AddEvent(args) {\r\n\t\tthis.visited = new Set()\r\n\t\tfor (var key in args) {\r\n\t\t\tthis[key] = args[key]\r\n\t\t}\r\n\t}\r\n\tAddEvent.prototype.type = 'add'\r\n\tfunction DeleteEvent(args) {\r\n\t\tthis.visited = new Set()\r\n\t\tfor (var key in args) {\r\n\t\t\tthis[key] = args[key]\r\n\t\t}\r\n\t}\r\n\tDeleteEvent.prototype.type = 'delete'\r\n\r\n\tfunction forPropertyNotifyingValues(properties, callback) {\r\n\t\tfor (var key in properties) {\r\n\t\t\tvar property = properties[key]\r\n\t\t\tif (property.returnedVariable) {\r\n\t\t\t\tcallback(property.returnedVariable)\r\n\t\t\t}\r\n\t\t\tif (property.hasChildNotifiers) {\r\n\t\t\t\tvar subProperties = property._properties\r\n\t\t\t\tif (subProperties) {\r\n\t\t\t\t\tforPropertyNotifyingValues(subProperties, callback)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction Variable(value) {\r\n\t\tif (this instanceof Variable) {\r\n\t\t\t// new call, may eventually use new.target\r\n\t\t\tif (value === undefined) {\r\n\t\t\t\tif (this.default !== undefined) {\r\n\t\t\t\t\tthis.value = this.default\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tthis.value = value\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\treturn Variable.extend(value)\r\n\t\t}\r\n\t}\r\n\tvar VariablePrototype = Variable.prototype = {\r\n\t\t// for debugging use\r\n\t\tget _currentValue() {\r\n\t\t\treturn this.valueOf()\r\n\t\t},\r\n\t\tset _currentValue(value) {\r\n\t\t\tthis.put(value)\r\n\t\t},\r\n\t\tconstructor: Variable,\r\n\t\tvalueOf: function(context) {\r\n\t\t\tvar valueContext\r\n\t\t\tif (this.parent) {\r\n\t\t\t\tif (context) {\r\n\t\t\t\t\tvalueContext = context.newContext()\r\n\t\t\t\t\tvalueContext.nextProperty = 'parent'\r\n\t\t\t\t}\r\n\t\t\t\tvar key = this.key\r\n\t\t\t\tvar property = this\r\n\t\t\t\tvar object = this.parent.valueOf(valueContext)\r\n\t\t\t\tvar gotValueAndListen = function(object) {\r\n\t\t\t\t\tvar value = property.gotValue(object == null ? undefined : typeof object.get === 'function' ? object.get(key) : object[key], context, valueContext)\r\n\t\t\t\t\tif (property.listeners) {\r\n\t\t\t\t\t\tvar listeners = propertyListenersMap.get(object)\r\n\t\t\t\t\t\tif (listeners && listeners.observer && listeners.observer.addKey) {\r\n\t\t\t\t\t\t\tlisteners.observer.addKey(key)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn value\r\n\t\t\t\t}\r\n\t\t\t\tif (object && object.then) {\r\n\t\t\t\t\t// call it initially so the dependencies can be registered\r\n\t\t\t\t\tthis.gotValue(null, context, valueContext)\r\n\t\t\t\t\treturn when(object, gotValueAndListen)\r\n\t\t\t\t}\r\n\t\t\t\treturn gotValueAndListen(object)\r\n\t\t\t}\r\n\t\t\treturn this.gotValue(this.getValue ?\r\n\t\t\t\tthis.getValue(context && (valueContext = context.newContext())) :\r\n\t\t\t\tthis.value, context, valueContext)\r\n\t\t},\r\n\t\tgotValue: function(value, parentContext, context) {\r\n\t\t\tvar previousNotifyingValue = this.returnedVariable\r\n\t\t\tvar variable = this\r\n\t\t\tif (previousNotifyingValue) {\r\n\t\t\t\tif (value === previousNotifyingValue) {\r\n\t\t\t\t\t// nothing changed, immediately return valueOf (or ownObject if we have it)\r\n\t\t\t\t\tif (variable.ownObject) {\r\n\t\t\t\t\t\treturn variable.ownObject\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (parentContext) {\r\n\t\t\t\t\t\tif (!context) {\r\n\t\t\t\t\t\t\tcontext = parentContext.newContext()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcontext.contextualize(this, parentContext)\r\n\t\t\t\t\t\tcontext.nextProperty = 'returnedVariable'\r\n\t\t\t\t\t\treturn value.valueOf(context)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn value.valueOf()\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// if there was a another value that we were dependent on before, stop listening to it\r\n\t\t\t\t// TODO: we may want to consider doing cleanup after the next rendering turn\r\n\t\t\t\tif (variable.listeners) {\r\n\t\t\t\t\tpreviousNotifyingValue.stopNotifies(variable)\r\n\t\t\t\t}\r\n\t\t\t\tvariable.returnedVariable = null\r\n\t\t\t}\r\n\t\t\tif (value && value.notifies) {\r\n\t\t\t\tvariable.returnedVariable = value\r\n\t\t\t\tif (variable.listeners) {\r\n\t\t\t\t\tvalue.notifies(variable)\r\n\t\t\t\t}\r\n\t\t\t\t/*var parent = variable\r\n\t\t\t\tdo {\r\n\t\t\t\t\tif (parent.listeners) {\r\n\t\t\t\t\t\t// the value is another variable, start receiving notifications, if we, or any parent is live\r\n\t\t\t\t\t\tvariable.returnedVariable.notifies(variable)\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\t}\r\n\t\t\t\t\tparent.hasNotifyingChild = true\r\n\t\t\t\t} while((parent = parent.parent))*/\r\n\t\t\t\tcontext = context || parentContext && (context = parentContext.newContext())\r\n\t\t\t\tif (context) {\r\n\t\t\t\t\tcontext.nextProperty = 'returnedVariable'\r\n\t\t\t\t}\r\n\t\t\t\tvalue = value.valueOf(context)\r\n\t\t\t\tif (variable.ownObject) {\r\n\t\t\t\t\tif (getPrototypeOf(variable.ownObject) !== value) {\r\n\t\t\t\t\t\tsetPrototypeOf(variable.ownObject, value)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvalue = variable.ownObject\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (value === undefined) {\r\n\t\t\t\tvalue = variable.default\r\n\t\t\t}\r\n\t\t\tif (context) {\r\n\t\t\t\tcontext.contextualize(this, parentContext)\r\n\t\t\t}\r\n\t\t\tif (parentContext) {\r\n\r\n\t\t\t\t/*if (!contextualized.listeners) {\r\n\t\t\t\t\t// mark it as initialized, since we have already recursively dependended on inputs\r\n\t\t\t\t\tcontextualized.listeners = []\r\n\t\t\t\t}*/\r\n\r\n\t\t\t\tif (!context) {\r\n\t\t\t\t\tparentContext.addInput(this)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (value && value.then) {\r\n\t\t\t\treturn when(value, function(value) {\r\n\t\t\t\t\treturn Variable.prototype.gotValue.call(variable, value, context)\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\treturn value\r\n\t\t},\r\n\t\tisMap: function() {\r\n\t\t\treturn this.value instanceof Map\r\n\t\t},\r\n\t\tPropertyClass: Variable,\r\n\t\tproperty: function(key, PropertyClass) {\r\n\t\t\tvar isMap = this.isMap()\r\n\t\t\tvar properties = this._properties || (this._properties = isMap ? new Map() : {})\r\n\t\t\tvar propertyVariable = isMap ? properties.get(key) : properties[key]\r\n\t\t\tif (!propertyVariable) {\r\n\t\t\t\t// create the property variable\r\n\t\t\t\tpropertyVariable = new (PropertyClass || this.PropertyClass)()\r\n\t\t\t\tpropertyVariable.key = key\r\n\t\t\t\tpropertyVariable.parent = this\r\n\t\t\t\tif (isMap) {\r\n\t\t\t\t\tproperties.set(key, propertyVariable)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tproperties[key] = propertyVariable\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn propertyVariable\r\n\t\t},\r\n\t\tfor: function(subject) {\r\n\t\t\tif (subject && subject.target && !subject.constructor.getForClass) {\r\n\t\t\t\t// makes HTML events work\r\n\t\t\t\tsubject = subject.target\r\n\t\t\t}\r\n\t\t\tif (this.parent) {\r\n\t\t\t\treturn this.parent.for(subject).property(this.key)\r\n\t\t\t}\r\n\t\t\treturn new ContextualizedVariable(this, subject || defaultContext)\r\n\t\t},\r\n\t\t_changeValue: function(context, type, newValue) {\r\n\t\t\tvar key = this.key\r\n\t\t\tvar parent = this.parent\r\n\t\t\tvar variable = this\r\n\t\t\tparent._willModify(context)\r\n\t\t\treturn when(parent.valueOf(context), function(object) {\r\n\t\t\t\tif (object == null) {\r\n\t\t\t\t\t// nothing there yet, create an object to hold the new property\r\n\t\t\t\t\tparent.put(object = typeof key == 'number' ? [] : {}, context)\r\n\t\t\t\t} else if (typeof object != 'object') {\r\n\t\t\t\t\t// if the parent is not an object, we can't set anything (that will be retained)\r\n\t\t\t\t\treturn deny\r\n\t\t\t\t}\r\n\t\t\t\tvar oldValue = typeof object.get === 'function' ? object.get(key) : object[key]\r\n\t\t\t\tif (oldValue === newValue) {\r\n\t\t\t\t\t// no actual change to make\r\n\t\t\t\t\treturn noChange\r\n\t\t\t\t}\r\n\t\t\t\tif (typeof object.set === 'function') {\r\n\t\t\t\t\tobject.set(key, newValue)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (type == RequestChange && oldValue && oldValue.put) {\r\n\t\t\t\t\t\t// if a put and the property value is a variable, assign it to that.\r\n\t\t\t\t\t\toldValue.put(newValue)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tobject[key] = newValue\r\n\t\t\t\t\t\t// or set the setter/getter\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tvar event = new RefreshEvent()\r\n\t\t\t\tevent.oldValue = oldValue\r\n\t\t\t\tevent.target = variable\r\n\t\t\t\tvariable.updated(event, variable, context)\r\n\r\n\t\t\t\t// now notify any object listeners\r\n\t\t\t\tvar listeners = propertyListenersMap.get(object)\r\n\t\t\t\t// we need to do it before the other listeners, so we can update it before\r\n\t\t\t\t// we trigger a full clobbering of the object\r\n\t\t\t\tif (listeners) {\r\n\t\t\t\t\tlisteners = listeners.slice(0)\r\n\t\t\t\t\tfor (var i = 0, l = listeners.length; i < l; i++) {\r\n\t\t\t\t\t\tvar listener = listeners[i]\r\n\t\t\t\t\t\tif (listener !== parent) {\r\n\t\t\t\t\t\t\t// now go ahead and actually trigger the other listeners (but make sure we don't do the parent again)\r\n\t\t\t\t\t\t\tlistener._propertyChange(key, object, context, type)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t},\r\n\r\n\t\t_propertyChange: function(propertyName, object, context, type) {\r\n\t\t\tif (this.onPropertyChange) {\r\n\t\t\t\tthis.onPropertyChange(propertyName, object, context)\r\n\t\t\t}\r\n\t\t\tthis.updated(new PropertyChangeEvent(propertyName, new RefreshEvent(), this), null, context)\r\n\t\t},\r\n\t\teachKey: function(callback) {\r\n\t\t\tfor (var i in this._properties) {\r\n\t\t\t\tcallback(i)\r\n\t\t\t}\r\n\t\t},\r\n\t\tapply: function(instance, args) {\r\n\t\t\treturn new Call(this, args)\r\n\t\t},\r\n\t\tcall: function(instance) {\r\n\t\t\treturn this.apply(instance, Array.prototype.slice.call(arguments, 1))\r\n\t\t},\r\n\t\tforDependencies: function(callback) {\r\n\t\t\tif (this.returnedVariable) {\r\n\t\t\t\tcallback(this.returnedVariable)\r\n\t\t\t}\r\n\t\t\tif (this.hasNotifyingChild) {\r\n\t\t\t\tvar properties = this._properties\r\n\t\t\t\tif (properties) {\r\n\t\t\t\t\tforPropertyNotifyingValues(properties, callback)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (this.parent) {\r\n\t\t\t\tcallback(this.parent)\r\n\t\t\t}\r\n\t\t},\r\n\t\tinit: function() {\r\n\t\t\tvar variable = this\r\n\t\t\tthis.forDependencies(function(dependency) {\r\n\t\t\t\tdependency.notifies(variable)\r\n\t\t\t})\r\n\r\n\t\t\tif (this.listeningToObject === null) {\r\n\t\t\t\t// we were previously listening to an object, but it needs to be restored\r\n\t\t\t\t// calling valueOf will cause the listening object to be restored\r\n\t\t\t\tthis.valueOf()\r\n\t\t\t}\r\n\t\t},\r\n\t\tcleanup: function() {\r\n\t\t\tthis.listeners = false\r\n\t\t\tvar handles = this.handles\r\n\t\t\tif (handles) {\r\n\t\t\t\tfor (var i = 0; i < handles.length; i++) {\r\n\t\t\t\t\thandles[i].remove()\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.handles = null\r\n\t\t\tvar returnedVariable = this.returnedVariable\r\n\t\t\tif (returnedVariable) {\r\n\t\t\t\t// TODO: move this into the caching class\r\n\t\t\t\tthis.computedVariable = null\r\n\t\t\t}\r\n\t\t\tvar variable = this\r\n\t\t\tthis.forDependencies(function(dependency) {\r\n\t\t\t\tdependency.stopNotifies(variable)\r\n\t\t\t})\r\n\t\t},\r\n\r\n\t\tupdateVersion: function(version) {\r\n\t\t\tthis.version = nextId++\r\n\t\t},\r\n\r\n\t\tgetVersion: function(context) {\r\n\t\t\treturn Math.max(this.version || 0, this.returnedVariable && this.returnedVariable.getVersion ? this.returnedVariable.getVersion(context) : 0)\r\n\t\t},\r\n\r\n\t\tgetSubject: function(selectVariable) {\r\n\t\t\treturn this.subject\r\n\t\t},\r\n\r\n\t\tgetUpdates: function(since) {\r\n\t\t\tvar updates = []\r\n\t\t\tvar nextUpdateMap = this.nextUpdateMap\r\n\t\t\tif (nextUpdateMap && since) {\r\n\t\t\t\twhile ((since = nextUpdateMap.get(since))) {\r\n\t\t\t\t\tif (since.type === 'refresh') {\r\n\t\t\t\t\t\t// if it was refresh, we can clear any prior entries\r\n\t\t\t\t\t\tupdates = []\r\n\t\t\t\t\t}\r\n\t\t\t\t\tupdates.push(since)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn updates\r\n\t\t},\r\n\r\n\t\tupdated: function(updateEvent, by, context) {\r\n\t\t\tif (!updateEvent) {\r\n\t\t\t\tupdateEvent = new RefreshEvent()\r\n\t\t\t}\r\n\t\t\tif (updateEvent.visited.has(this)){\r\n\t\t\t\t// if this event has already visited this variable, skip it\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tupdateEvent.visited.add(this)\r\n\t\t\tif (this.__debug) {\r\n\t\t\t\t// debug is on\r\n\t\t\t\tconsole.log('Variable changed at')\r\n\t\t\t\tconsole.log((new Error().stack || '').replace(/Error/, ''))\r\n\t\t\t}\r\n\r\n\t\t\tvar contextualInstance = context ? context.getContextualized(this) : this\r\n\t\t\tif (contextualInstance) {\r\n\t\t\t\tcontextualInstance.updated(updateEvent, this, context)\r\n\t\t\t}\r\n\t\t\t/*\r\n\t\t\t// at some point we could do an update list so that we could incrementally update\r\n\t\t\t// lists in non-live situations\r\n\t\t\tif (this.lastUpdate) {\r\n\t\t\t\tvar nextUpdateMap = this.nextUpdateMap\r\n\t\t\t\tif (!nextUpdateMap) {\r\n\t\t\t\t\tnextUpdateMap = this.nextUpdateMap = new WeakMap()\r\n\t\t\t\t}\r\n\t\t\t\tnextUpdateMap.set(this.lastUpdate, updateEvent)\r\n\t\t\t}\r\n\r\n\t\t\tthis.lastUpdate = updateEvent */\r\n\t\t\tthis.updateVersion()\r\n\r\n\t\t\tvar listeners = this.listeners\r\n\t\t\tif (listeners) {\r\n\t\t\t\tvar variable = this\r\n\t\t\t\t// make a copy, in case they change\r\n\t\t\t\tlisteners.forEach(function(dependent) {\r\n\t\t\t\t\tif ((updateEvent instanceof PropertyChangeEvent) &&\r\n\t\t\t\t\t\t\tdependent.parent) {\r\n\t\t\t\t\t\tif (dependent.key === updateEvent.key) {\r\n\t\t\t\t\t\t\tdependent.updated(updateEvent.childEvent, variable, context)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tdependent.updated(updateEvent, variable, context)\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tif (updateEvent instanceof PropertyChangeEvent) {\r\n\t\t\t\tif (this.returnedVariable && this.fixed) {\r\n\t\t\t\t\tthis.returnedVariable.updated(updateEvent, this, context)\r\n\t\t\t\t}\r\n\t\t\t\tif (this.constructor.collection) {\r\n\t\t\t\t\tthis.constructor.collection.updated(updateEvent, this, context)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (this.parent) {\r\n\t\t\t\t\tthis.parent.updated(new PropertyChangeEvent(this.key, updateEvent, this.parent), this, context)\r\n\t\t\t}\r\n\t\t\treturn updateEvent\r\n\t\t},\r\n\r\n\t\tinvalidate: function() {\r\n\t\t\t// for back-compatibility for now\r\n\t\t\tthis.updated()\r\n\t\t},\r\n\r\n\t\tnotifies: function(target) {\r\n\t\t\tvar listeners = this.listeners\r\n\t\t\tif (!listeners || !this.hasOwnProperty('listeners')) {\r\n\t\t\t\tthis.listeners = listeners = new Set()\r\n\t\t\t\tthis.init()\r\n\t\t\t}\r\n\t\t\tlisteners.add(target)\r\n\t\t},\r\n\t\tsubscribe: function(listener) {\r\n\t\t\t// ES7 Observable (and baconjs) compatible API\r\n\t\t\tvar updated\r\n\t\t\tvar updateQueued\r\n\t\t\tvar variable = this\r\n\t\t\t// it is important to make sure you register for notifications before getting the value\r\n\t\t\tif (typeof listener === 'function') {\r\n\t\t\t\t// BaconJS compatible API\r\n\t\t\t\tvar variable = this\r\n\t\t\t\tvar event = {\r\n\t\t\t\t\tvalue: function() {\r\n\t\t\t\t\t\treturn variable.valueOf()\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tupdated = function() {\r\n\t\t\t\t\tupdateQueued = false\r\n\t\t\t\t\tlistener(event)\r\n\t\t\t\t}\r\n\t\t\t}\telse if (listener.next) {\r\n\t\t\t\t// Assuming ES7 Observable API. It is actually a streaming API, this pretty much violates all principles of reactivity, but we will support it\r\n\t\t\t\tupdated = function() {\r\n\t\t\t\t\tupdateQueued = false\r\n\t\t\t\t\tlistener.next(variable.valueOf())\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tthrow new Error('Subscribing to an invalid listener, the listener must be a function, or have an update or next method')\r\n\t\t\t}\r\n\t\t\tvar updateReceiver = {\r\n\t\t\t\tupdated: function() {\r\n\t\t\t\t\tif (updateQueued) {\r\n\t\t\t\t\t\treturn\r\n\t\t\t\t\t}\r\n\t\t\t\t\tupdateQueued = true\r\n\t\t\t\t\tlang.nextTurn(updated)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tupdated()\r\n\t\t\tthis.notifies(updateReceiver)\r\n\t\t\treturn {\r\n\t\t\t\tunsubscribe: function() {\r\n\t\t\t\t\tvariable.stopNotifies(updateReceiver)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tstopNotifies: function(dependent) {\r\n\t\t\tvar listeners = this.listeners\r\n\t\t\tif (listeners) {\r\n\t\t\t\tlisteners.delete(dependent)\r\n\t\t\t\tif (listeners.size === 0) {\r\n\t\t\t\t\t// clear the listeners so it will be reinitialized if it has\r\n\t\t\t\t\t// listeners again\r\n\t\t\t\t\tthis.cleanup()\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tput: function(value, context) {\r\n\t\t\tvar variable = this\r\n\t\t\tif (this.parent) {\r\n\t\t\t\treturn this._changeValue(context, RequestChange, value)\r\n\t\t\t}\r\n\t\t\tif (this.ownObject) {\r\n\t\t\t\tthis.ownObject = false\r\n\t\t\t}\r\n\t\t\treturn when(this.getValue ? this.getValue(context) : this.value, function(oldValue) {\r\n\t\t\t\tif (oldValue === value) {\r\n\t\t\t\t\treturn noChange\r\n\t\t\t\t}\r\n\t\t\t\tif (variable.fixed &&\r\n\t\t\t\t\t\t// if it is set to fixed, we see we can put in the current variable\r\n\t\t\t\t\t\toldValue && oldValue.put) {\r\n\t\t\t\t\treturn oldValue.put(value)\r\n\t\t\t\t}\r\n\t\t\t\treturn when(variable.setValue(value, context), function(value) {\r\n\t\t\t\t\tvar event = new RefreshEvent()\r\n\t\t\t\t\tevent.oldValue = oldValue\r\n\t\t\t\t\tevent.target = variable\r\n\t\t\t\t\tvariable.updated(event, variable, context)\r\n\t\t\t\t})\r\n\t\t\t})\r\n\t\t},\r\n\t\tget: function(key) {\r\n\t\t\tif (this._properties && this._properties[key]) {\r\n\t\t\t\treturn this.property(key).valueOf()\r\n\t\t\t}\r\n\t\t\treturn when(this.valueOf(), function(object) {\r\n\t\t\t\tvar value = object && (typeof object.get === 'function' ? object.get(key) : object[key])\r\n\t\t\t\tif (value && value.notifies) {\r\n\t\t\t\t\t// nested variable situation, get underlying value\r\n\t\t\t\t\treturn value.valueOf()\r\n\t\t\t\t}\r\n\t\t\t\treturn value\r\n\t\t\t})\r\n\t\t},\r\n\t\tset: function(key, value) {\r\n\t\t\t// TODO: create an optimized route when the property doesn't exist yet\r\n\t\t\tthis.property(key)._changeValue(null, RequestSet, value)\r\n\t\t},\r\n\t\tundefine: function(key, context) {\r\n\t\t\tthis.set(key, undefined, context)\r\n\t\t},\r\n\t\tproxy: function(proxiedVariable) {\r\n\t\t\tvar thisVariable = this\r\n\t\t\tthis.fixed = true\r\n\t\t\treturn when(this.setValue(proxiedVariable), function(value) {\r\n\t\t\t\tthisVariable.updated(new RefreshEvent(), thisVariable)\r\n\t\t\t\treturn thisVariable\r\n\t\t\t})\r\n\t\t},\r\n\t\tnext: function(value) {\r\n\t\t\t// for ES7 observable compatibility\r\n\t\t\tthis.put(value)\r\n\t\t},\r\n\t\terror: function(error) {\r\n\t\t\t// for ES7 observable compatibility\r\n\t\t\tvar listeners = this.listeners\r\n\t\t\tif (listeners) {\r\n\t\t\t\t// make a copy, in case they change\r\n\t\t\t\tlisteners.forEach(function(dependent) {\r\n\t\t\t\t\t// skip notifying property listeners if we are headed up the parent chain\r\n\t\t\t\t\tdependent.error(error)\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t},\r\n\t\tcomplete: function(value) {\r\n\t\t\t// for ES7 observable compatibility\r\n\t\t\tthis.put(value)\r\n\t\t},\r\n\t\tsetValue: function(value) {\r\n\t\t\tthis.value = value\r\n\t\t},\r\n\t\tonValue: function(listener) {\r\n\t\t\treturn this.subscribe(function(event) {\r\n\t\t\t\tlang.when(event.value(), function(value) {\r\n\t\t\t\t\tlistener(value)\r\n\t\t\t\t})\r\n\t\t\t})\r\n\t\t},\r\n\t\ttoJSON: function() {\r\n\t\t\treturn this.valueOf()\r\n\t\t},\r\n\t\ttoString: function() {\r\n\t\t\treturn this.valueOf()\r\n\t\t},\r\n\t\tforEach: function(callbackOrItemClass, callbackOrContext, context) {\r\n\t\t\t// iterate through current value of variable\r\n\t\t\tif (callbackOrItemClass.notifies) {\r\n\t\t\t\treturn this.forEach(function(item) {\r\n\t\t\t\t\tvar itemVariable = callbackOrItemClass.from(item)\r\n\t\t\t\t\tcallbackOrContext.call(this, itemVariable)\r\n\t\t\t\t}, context)\r\n\t\t\t}\r\n\t\t\treturn when(this.valueOf(callbackOrContext), function(value) {\r\n\t\t\t\tif (value && value.forEach) {\r\n\t\t\t\t\tvalue.forEach(callbackOrItemClass)\r\n\t\t\t\t}else{\r\n\t\t\t\t\tfor (var i in value) {\r\n\t\t\t\t\t\tcallbackOrItemClass.call(value, value[i], i)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t},\r\n\r\n\t\tto: function (transformFunction, reverse) {\r\n\t\t\tif (typeof transformFunction !== 'function') {\r\n\t\t\t\tif (typeof transformFunction === 'object') {\r\n\t\t\t\t\tthis.to(transformFunction.get, transformFunction.set)\r\n\t\t\t\t}\r\n\t\t\t\tthrow new Error('No function provided to transform')\r\n\t\t\t}\r\n\t\t\tif (reverse) {\r\n\t\t\t\ttransformFunction.reverse = function(value, args, context) {\r\n\t\t\t\t\t// for direct to, we can just use the first argument\r\n\t\t\t\t\treverse.call(this, args[0], context)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn new Call(transformFunction, [this])\r\n\t\t},\r\n\t\tget schema() {\r\n\t\t\t// default schema is the constructor\r\n\t\t\tif (this.parent) {\r\n\t\t\t\tvar parentSchemaProperties = this.parent.schema.properties\r\n\t\t\t\treturn parentSchemaProperties && parentSchemaProperties[this.key]\r\n\t\t\t}\r\n\t\t\treturn this.returnedVariable ? this.returnedVariable.schema : this.constructor\r\n\t\t},\r\n\t\tset schema(schema) {\r\n\t\t\t// but allow it to be overriden\r\n\t\t\tObject.defineProperty(this, 'schema', {\r\n\t\t\t\tvalue: schema\r\n\t\t\t})\r\n\t\t},\r\n\t\tvalidate: function(target, schema) {\r\n\t\t\tif (this.returnedVariable) {\r\n\t\t\t\treturn this.returnedVariable.validate(target, schema)\r\n\t\t\t}\r\n\t\t\tif (this.parent) {\r\n\t\t\t\treturn this.parent.validate(target.valueOf(), schema)\r\n\t\t\t}\r\n\t\t\tif (schema && schema.type && (schema.type !== typeof target)) {\r\n\t\t\t\treturn ['Target type of ' + typeof target + ' does not match schema type of ' + schema.type]\r\n\t\t\t}\r\n\t\t\tvar valid = []\r\n\t\t\tvalid.isValid = true\r\n\t\t\treturn valid\r\n\t\t},\r\n\r\n\t\tget validation() {\r\n\t\t\tvar validation = new Validating(this)\r\n\t\t\tObject.defineProperty(this, 'validation', {\r\n\t\t\t\tvalue: validation\r\n\t\t\t})\r\n\t\t\treturn validation\r\n\t\t},\r\n\t\tset validation(validation) {\r\n\t\t\t// but allow it to be overriden\r\n\t\t\tObject.defineProperty(this, 'validation', {\r\n\t\t\t\tvalue: validation\r\n\t\t\t})\r\n\t\t},\r\n\t\tset structured(structure) {\r\n\t\t\t// find any variable properties and attaches them as a property\r\n\t\t\tvar keys = Object.keys(this)\r\n\t\t\tvar properties = keys.length > 1 && this._properties || (this._properties = {})\r\n\t\t\tfor(var i = 0, l = keys.length; i < l; i++) {\r\n\t\t\t\tvar key = keys[i]\r\n\t\t\t\tvar value = this[key]\r\n\t\t\t\tif (value instanceof Variable) {\r\n\t\t\t\t\tvar existing = properties[key]\r\n\t\t\t\t\tif (existing) {\r\n\t\t\t\t\t\tif (existing !== value) {\r\n\t\t\t\t\t\t\t// an existing property exists, put in it\r\n\t\t\t\t\t\t\texisting.put(value)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (value.parent) {\r\n\t\t\t\t\t\t\tif (value.parent === this) {\r\n\t\t\t\t\t\t\t\tcontinue // just being assigned to another property\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// property already exists with different parent, make a proxy\r\n\t\t\t\t\t\t\t\tvar newValue = new Variable()\r\n\t\t\t\t\t\t\t\tnewValue.proxy(value)\r\n\t\t\t\t\t\t\t\tvalue = newValue\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvalue.key = key\r\n\t\t\t\t\t\tvalue.parent = this\r\n\t\t\t\t\t\tproperties[key] = value\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tgetId: function() {\r\n\t\t\treturn this.id || (this.id = nextId++)\r\n\t\t},\r\n\t\tobserveObject: function() {\r\n\t\t\tvar variable = this\r\n\t\t\treturn when(this.valueOf(), function(object) {\r\n\t\t\t\tvar listeners = propertyListenersMap.get(object)\r\n\t\t\t\tif (!listeners) {\r\n\t\t\t\t\tpropertyListenersMap.set(object, listeners = [])\r\n\t\t\t\t}\r\n\t\t\t\tif (listeners.observerCount) {\r\n\t\t\t\t\tlisteners.observerCount++\r\n\t\t\t\t}else{\r\n\t\t\t\t\tlisteners.observerCount = 1\r\n\t\t\t\t\tvar observer = listeners.observer = lang.observe(object, function(events) {\r\n\t\t\t\t\t\tfor (var i = 0, l = listeners.length; i < l; i++) {\r\n\t\t\t\t\t\t\tvar listener = listeners[i]\r\n\t\t\t\t\t\t\tfor (var j = 0, el = events.length; j < el; j++) {\r\n\t\t\t\t\t\t\t\tvar event = events[j]\r\n\t\t\t\t\t\t\t\tlistener._propertyChange(event.name, object)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t\tif (observer.addKey) {\r\n\t\t\t\t\t\tfor (var i = 0, l = listeners.length; i < l; i++) {\r\n\t\t\t\t\t\t\tvar listener = listeners[i]\r\n\t\t\t\t\t\t\tlistener.eachKey(function(key) {\r\n\t\t\t\t\t\t\t\tobserver.addKey(key)\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tregisterListener(object, variable)\r\n\t\t\t\treturn {\r\n\t\t\t\t\tremove: function() {\r\n\t\t\t\t\t\tderegisterListener(object, variable)\r\n\t\t\t\t\t\tif (!(--listeners.observerCount)) {\r\n\t\t\t\t\t\t\tlisteners.observer.remove()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t},\r\n\t\t\t\t\tdone: function() {\r\n\t\t\t\t\t\t// deliver changes\r\n\t\t\t\t\t\tlang.deliverChanges(observer)\r\n\t\t\t\t\t\tthis.remove()\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t},\r\n\t\tgetCollectionOf: function() {\r\n\t\t\treturn this.constructor.collectionOf\r\n\t\t},\r\n\t\t_willModify: function(context) {\r\n\t\t\t// an intent to modify, so we need to make sure we have our own copy\r\n\t\t\t// of an object when necessary\r\n\t\t\tif (this.fixed) {\r\n\t\t\t\tif (this.value && this.value._willModify) {\r\n\t\t\t\t\treturn this.value._willModify(context)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!this.ownObject && this.value && this.value.notifies) {\r\n\t\t\t\tvar variable = this\r\n\t\t\t\treturn when(this.valueOf(context), function(value) {\r\n\t\t\t\t\tif (value && typeof value === 'object') {\r\n\t\t\t\t\t\tif (value instanceof Array) {\r\n\t\t\t\t\t\t\tvariable.ownObject = value.slice(0)\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tvariable.ownObject = Object.create(value)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t} else if (this.parent) {\r\n\t\t\t\tthis.parent._willModify()\r\n\t\t\t}\r\n\t\t},\r\n\t\t_sN: function(name) {\r\n\t\t\t// for compilers to set a name\r\n\t\t\tthis.name = name\r\n\t\t\treturn this\r\n\t\t},\r\n\t\tget _debug() {\r\n\t\t\tif (this.__debug === undefined) {\r\n\t\t\t\tthis.__debug = true\r\n\t\t\t}\r\n\t\t\treturn this.__debug\r\n\t\t},\r\n\t\tset _debug(_debug) {\r\n\t\t\tthis.__debug = _debug\r\n\t\t},\r\n\t\t// TODO: Move these to VArray\r\n\t\tsplice: function(startingIndex, removalCount) {\r\n\t\t\tvar args = arguments\r\n\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\tvar results = array.splice.apply(array, args)\r\n\t\t\t\tremovedAt(this, results, startingIndex, removalCount, array.length)\r\n\t\t\t\tinsertedAt(this, [].slice.call(args, 2), startingIndex, array.length)\r\n\t\t\t\treturn results\r\n\t\t\t})\r\n\t\t},\r\n\t\tpush: function() {\r\n\t\t\tvar args = arguments\r\n\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\tvar results = array.push.apply(array, args)\r\n\t\t\t\tinsertedAt(this, args, array.length - args.length, array.length)\r\n\t\t\t\treturn results\r\n\t\t\t})\r\n\t\t},\r\n\t\tunshift: function() {\r\n\t\t\tvar args = arguments\r\n\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\tvar results = array.unshift.apply(array, args)\r\n\t\t\t\tinsertedAt(this, args, 0, array.length)\r\n\t\t\t\treturn results\r\n\t\t\t})\r\n\t\t},\r\n\t\tpop: function() {\r\n\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\tvar results = array.pop()\r\n\t\t\t\tremovedAt(this, [results], array.length, 1)\r\n\t\t\t\treturn results\r\n\t\t\t})\r\n\t\t},\r\n\t\tshift: function() {\r\n\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\tvar results = array.shift()\r\n\t\t\t\tremovedAt(this, [results], 0, 1, array.length)\r\n\t\t\t\treturn results\r\n\t\t\t})\r\n\t\t}\r\n\t}\r\n\r\n\tfunction arrayToModify(variable, callback) {\r\n\t\tvariable._willModify()\r\n\t\t// TODO: switch this to allow promises\r\n\t\twhen(variable.cachedValue || variable.valueOf(), function(array) {\r\n\t\t\tif (!array) {\r\n\t\t\t\tvariable.put(array = [])\r\n\t\t\t}\r\n\t\t\tvariable.updateVersion()\r\n\t\t\tvar results = callback.call(variable, array)\r\n\t\t\tvariable.cachedVersion = variable.version // update the cached version so it doesn't need to be recomputed\r\n\t\t\treturn results\r\n\t\t})\r\n\t}\r\n\r\n\tfunction insertedAt(variable, added, startingIndex, arrayLength) {\r\n\t\tvar addedCount = added.length\r\n\t\t// adjust the key positions of any index properties after splice\r\n\t\tif (addedCount > 0) {\r\n\t\t\tif (variable._properties) {\r\n\t\t\t\tvar arrayPosition\r\n\t\t\t\tfor (var i = arrayLength - addedCount; i > startingIndex;) {\r\n\t\t\t\t\tvar arrayPosition = variable._properties[--i]\r\n\t\t\t\t\tif (arrayPosition) {\r\n\t\t\t\t\t\tvariable._properties[i] = undefined\r\n\t\t\t\t\t\tarrayPosition.key += addedCount\r\n\t\t\t\t\t\tvariable._properties[arrayPosition.key] = arrayPosition\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// send out updates\r\n\t\t\tfor (var i = 0, l = added.length; i < l; i++) {\r\n\t\t\t\tvariable.updated(new AddEvent({\r\n\t\t\t\t\tvalue: added[i],\r\n\t\t\t\t\tindex: i + startingIndex,\r\n\t\t\t\t\tmodifier: variable\r\n\t\t\t\t}), variable)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction removedAt(variable, removed, startingIndex, removalCount, arrayLength) {\r\n\t\t// adjust the properties\r\n\t\tvar i = startingIndex + removalCount\r\n\t\tvar arrayPosition\r\n\t\tif (removalCount > 0) {\r\n\t\t\tif (variable._properties) {\r\n\t\t\t\tfor (var i = startingIndex + removalCount; i < arrayLength + removalCount; i++) {\r\n\t\t\t\t\tvar arrayPosition = variable._properties[i]\r\n\t\t\t\t\tif (arrayPosition) {\r\n\t\t\t\t\t\tvariable._properties[i] = undefined\r\n\t\t\t\t\t\tarrayPosition.key -= removalCount\r\n\t\t\t\t\t\tvariable._properties[arrayPosition.key] = arrayPosition\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// send out updates\r\n\t\t\tfor (var i = 0; i < removalCount; i++) {\r\n\t\t\t\tvariable.updated(new DeleteEvent({\r\n\t\t\t\t\tpreviousIndex: startingIndex,\r\n\t\t\t\t\toldValue: removed[i],\r\n\t\t\t\t\tmodifier: variable\r\n\t\t\t\t}), variable)\r\n\t\t\t}\r\n\t\t\tvariable.cachedVersion = variable.version // update the cached version so it doesn't need to be recomputed\r\n\t\t}\r\n\t}\r\n\r\n\tif (typeof Symbol !== 'undefined') {\r\n\t\tVariable.prototype[Symbol.iterator] = function() {\r\n\t\t\treturn this.valueOf()[Symbol.iterator]()\r\n\t\t}\r\n\t}\r\n\r\n\tVariable.VMap = lang.compose(Variable, function(value){\r\n\t\tthis.value = typeof value === 'undefined' ? this.default : value\r\n\t}, {\r\n\t\t// TODO: Move all the get and set functionality for maps out of Variable\r\n\t\tproperty: function(key, PropertyClass) {\r\n\t\t\tvar properties = this._properties || (this._properties = new Map())\r\n\t\t\tvar propertyVariable = properties.get(key)\r\n\t\t\tif (!propertyVariable) {\r\n\t\t\t\t// create the property variable\r\n\t\t\t\tpropertyVariable = new (PropertyClass || this.PropertyClass)()\r\n\t\t\t\tpropertyVariable.key = key\r\n\t\t\t\tpropertyVariable.parent = this\r\n\t\t\t\tproperties.set(key, propertyVariable)\r\n\t\t\t}\r\n\t\t\treturn propertyVariable\r\n\t\t}\r\n\t})\r\n\r\n\tvar Caching = Variable.Caching = lang.compose(Variable, function Caching(getValue, setValue) {\r\n\t\tif (getValue) {\r\n\t\t\tthis.getValue = getValue\r\n\t\t}\r\n\t\tif (setValue) {\r\n\t\t\tthis.setValue = setValue\r\n\t\t}\r\n\t}, {\r\n\t\tvalueOf: function(context) {\r\n\t\t\t// first check to see if we have the variable already computed\r\n\t\t\tvar contextualizedVariable = this\r\n\t\t\tif (context) {\r\n\t\t\t\tcontextualizedVariable = context.getContextualized(this)\r\n\t\t\t\tif (!contextualizedVariable && this.context && this.context.matches(context)) {\r\n\t\t\t\t\tcontextualizedVariable = this\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (contextualizedVariable && contextualizedVariable.cachedVersion === contextualizedVariable.getVersion()) {\r\n\t\t\t\tif (context) {\r\n\t\t\t\t\tcontext.addInput(contextualizedVariable)\r\n\t\t\t\t}\r\n\t\t\t\treturn contextualizedVariable.cachedValue\r\n\t\t\t}\r\n\r\n\t\t\tvar variable = this\r\n\t\t\tfunction withComputedValue(computedValue) {\r\n\t\t\t\tif (computedValue && computedValue.notifies && variable.listeners) {\r\n\t\t\t\t\tvariable.computedVariable = computedValue\r\n\t\t\t\t}\r\n\t\t\t\tcomputedValue = variable.gotValue(computedValue, context, transformContext)\r\n\t\t\t\tvar contextualizedVariable = transformContext && transformContext.contextualized || variable\r\n\t\t\t\tcontextualizedVariable.cachedVersion = newVersion\r\n\t\t\t\tcontextualizedVariable.cachedValue = computedValue\r\n\t\t\t\tcontextualizedVariable.context = transformContext\r\n\t\t\t\treturn computedValue\r\n\t\t\t}\r\n\r\n\t\t\tvar transformContext\r\n\t\t\tif (context) {\r\n\t\t\t\ttransformContext = context.newContext()\r\n\t\t\t}\r\n\t\t\tvar newVersion = this.getVersion()\r\n\t\t\tvar computedValue = this.getValue(transformContext)\r\n\t\t\tif (computedValue && computedValue.then) {\r\n\t\t\t\t// call it initially so the dependencies can be registered\r\n\t\t\t\tthis.gotValue(null, context, transformContext)\r\n\t\t\t\treturn computedValue.then(withComputedValue)\r\n\t\t\t} else {\r\n\t\t\t\treturn withComputedValue(computedValue)\r\n\t\t\t}\r\n\t\t}\r\n\t})\r\n\r\n\tvar Item = Variable.Item = lang.compose(Variable, function Item(value, content) {\r\n\t\tthis.value = value\r\n\t\tthis.collection = content\r\n\t}, {})\r\n\r\n\tvar Composite = Variable.Composite = lang.compose(Caching, function Composite(args) {\r\n\t\tfor (var i = 0, l = args.length; i < l; i++) {\r\n\t\t\tthis[i > 0 ? 'input' + i : 'input'] = args[i]\r\n\t\t}\r\n\t}, {\r\n\t\tforDependencies: function(callback) {\r\n\t\t\t// depend on the args\r\n\t\t\tCaching.prototype.forDependencies.call(this, callback)\r\n\t\t\tvar argument, argumentName\r\n\t\t\tfor (var i = 0; (argument = this[argumentName = i > 0 ? 'input' + i : 'input']) || argumentName in this; i++) {\r\n\t\t\t\tif (argument && argument.notifies) {\r\n\t\t\t\t\tcallback(argument)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tupdated: function(updateEvent, by, context) {\r\n\t\t\tif (by !== this.returnedVariable && updateEvent && updateEvent.type !== 'refresh') {\r\n\t\t\t\t// search for the output in the inputs\r\n\t\t\t\tvar argument, argumentName\r\n\t\t\t\tfor (var i = 0; (argument = this[argumentName = i > 0 ? 'input' + i : 'input']) || argumentName in this; i++) {\r\n\t\t\t\t\tif (argument === by) {\r\n\t\t\t\t\t\t// if one of the args was updated, we need to do a full refresh (we can't compute differential events without knowledge of how the mapping function works)\r\n\t\t\t\t\t\tupdateEvent = new RefreshEvent()\r\n\t\t\t\t\t\tcontinue\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn Caching.prototype.updated.call(this, updateEvent, by, context)\r\n\t\t},\r\n\r\n\t\tgetUpdates: function(since) {\r\n\t\t\t// this always issues updates, nothing incremental can flow through it\r\n\t\t\tif (!since || since.version < getVersion()) {\r\n\t\t\t\treturn [new RefreshEvent()]\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tgetVersion: function(context) {\r\n\t\t\tvar version = Variable.prototype.getVersion.call(this, context)\r\n\t\t\tvar argument, argumentName\r\n\t\t\tfor (var i = 0; (argument = this[argumentName = i > 0 ? 'input' + i : 'input']) || argumentName in this; i++) {\r\n\t\t\t\tif (argument && argument.getVersion) {\r\n\t\t\t\t\tversion = Math.max(version, argument.getVersion(context))\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn version\r\n\t\t},\r\n\r\n\t\tgetValue: function(context) {\r\n\t\t\tvar results = []\r\n\t\t\tvar argument, argumentName\r\n\t\t\tfor (var i = 0; (argument = this[argumentName = i > 0 ? 'input' + i : 'input']) || argumentName in this; i++) {\r\n\t\t\t\tif (context) {\r\n\t\t\t\t\tcontext.nextProperty = argumentName\r\n\t\t\t\t}\r\n\t\t\t\tresults[i] = argument && argument.valueOf(context)\r\n\t\t\t}\r\n\t\t\treturn whenAll(results, function(resolved) {\r\n\t\t\t\treturn resolved\r\n\t\t\t})\r\n\t\t},\r\n\t\tgetArguments: function() {\r\n\t\t\tvar args = []\r\n\t\t\tvar argument, argumentName\r\n\t\t\tfor (var i = 0; (argument = this[argumentName = i > 0 ? 'input' + i : 'input']) || argumentName in this; i++) {\r\n\t\t\t\targs.push(argument)\r\n\t\t\t}\r\n\t\t\treturn args\r\n\t\t}\r\n\t})\r\n\r\n\t// a call variable is the result of a call\r\n\tvar Call = lang.compose(Composite, function Transform(transform, args) {\r\n\t\tif (transform) {\r\n\t\t\tthis.transform = transform\r\n\t\t\tfor (var i = 0, l = args.length; i < l; i++) {\r\n\t\t\t\tthis[i > 0 ? 'input' + i : 'input'] = args[i]\r\n\t\t\t}\r\n\t\t}\r\n\t}, {\r\n\t\tfixed: true,\r\n\t\tforDependencies: function(callback) {\r\n\t\t\t// depend on the args\r\n\t\t\tComposite.prototype.forDependencies.call(this, callback)\r\n\t\t\tif (this.transform.notifies) {\r\n\t\t\t\tcallback(this.transform)\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tgetValue: function(context) {\r\n\t\t\tif (context) {\r\n\t\t\t\tcontext.nextProperty = 'transform'\r\n\t\t\t}\r\n\t\t\tvar functionValue = this.transform.valueOf(context)\r\n\t\t\tif (functionValue.then) {\r\n\t\t\t\tvar call = this\r\n\t\t\t\treturn functionValue.then(function(functionValue) {\r\n\t\t\t\t\treturn call.invoke(functionValue, context)\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\treturn this.invoke(functionValue, context)\r\n\t\t},\r\n\r\n\t\tgetVersion: function(context) {\r\n\t\t\t// TODO: shortcut if we are live and since equals this.lastUpdate\r\n\t\t\tvar argsVersion = Composite.prototype.getVersion.call(this, context)\r\n\t\t\tif (this.transform.getVersion) {\r\n\t\t\t\treturn Math.max(argsVersion, this.transform.getVersion(context))\r\n\t\t\t}\r\n\t\t\treturn argsVersion\r\n\t\t},\r\n\r\n\t\texecute: function(context) {\r\n\t\t\tvar call = this\r\n\t\t\treturn when(this.transform.valueOf(context), function(functionValue) {\r\n\t\t\t\treturn call.invoke(functionValue, context, true)\r\n\t\t\t})\r\n\t\t},\r\n\r\n\t\tput: function(value, context) {\r\n\t\t\tvar call = this\r\n\t\t\treturn when(this.valueOf(context), function(originalValue) {\r\n\t\t\t\tif (originalValue === value) {\r\n\t\t\t\t\treturn noChange\r\n\t\t\t\t}\r\n\t\t\t\treturn when(call.transform.valueOf(context), function(functionValue) {\r\n\t\t\t\t\treturn call.invoke(function() {\r\n\t\t\t\t\t\tif (functionValue.reverse) {\r\n\t\t\t\t\t\t\tfunctionValue.reverse.call(call, value, call.getArguments(), context)\r\n\t\t\t\t\t\t\treturn Variable.prototype.put.call(call, value, context)\r\n\t\t\t\t\t\t} else if (originalValue && originalValue.put) {\r\n\t\t\t\t\t\t\treturn originalValue.put(value)\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\treturn deny\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}, context)\r\n\t\t\t\t});\r\n\t\t\t})\r\n\t\t},\r\n\t\tinvoke: function(functionValue, context, observeArguments) {\r\n\t\t\tvar instance = this.transform.parent\r\n\t\t\tvar variable = this\r\n\t\t\tif (functionValue.handlesVariables || functionValue.property) {\r\n\t\t\t\treturn functionValue.apply(instance, this.getArguments(), context)\r\n\t\t\t}else{\r\n\t\t\t\tvar results = []\r\n\t\t\t\tvar argument, argumentName\r\n\t\t\t\tfor (var i = 0; (argument = this[argumentName = i > 0 ? 'input' + i : 'input']) || argumentName in this; i++) {\r\n\t\t\t\t\tif (context) {\r\n\t\t\t\t\t\tcontext.nextProperty = argumentName\r\n\t\t\t\t\t}\r\n\t\t\t\t\tresults[i] = argument && argument.valueOf(context)\r\n\t\t\t\t}\r\n\t\t\t\tinstance = instance && instance.valueOf(context)\r\n\t\t\t\tif (functionValue.handlesPromises) {\r\n\t\t\t\t\treturn functionValue.apply(instance, results, context)\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// include the instance in whenAll\r\n\t\t\t\t\tresults.push(instance)\r\n\t\t\t\t\t// wait for the values to be received\r\n\t\t\t\t\treturn whenAll(results, function(inputs) {\r\n\t\t\t\t\t\tif (observeArguments) {\r\n\t\t\t\t\t\t\tvar handles = []\r\n\t\t\t\t\t\t\tfor (var i = 0, l = inputs.length; i < l; i++) {\r\n\t\t\t\t\t\t\t\tvar input = inputs[i]\r\n\t\t\t\t\t\t\t\tif (input && typeof input === 'object') {\r\n\t\t\t\t\t\t\t\t\thandles.push(observe(input))\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tvar instance = inputs.pop()\r\n\t\t\t\t\t\t\ttry{\r\n\t\t\t\t\t\t\t\tvar result = functionValue.apply(instance || variable, inputs, context)\r\n\t\t\t\t\t\t\t}finally{\r\n\t\t\t\t\t\t\t\twhen(result, function() {\r\n\t\t\t\t\t\t\t\t\tfor (var i = 0; i < l; i++) {\r\n\t\t\t\t\t\t\t\t\t\thandles[i].done()\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn result\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar instance = inputs.pop()\r\n\t\t\t\t\t\treturn functionValue.apply(instance || variable, inputs, context)\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tsetReverse: function(reverse) {\r\n\t\t\tthis.transform.valueOf().reverse = reverse\r\n\t\t\treturn this\r\n\t\t},\r\n\t\tgetCollectionOf: function() {\r\n\t\t\treturn this.returnedVariable && this.returnedVariable.getCollectionOf()\r\n\t\t}\r\n\t})\r\n\tVariable.Call = Call\r\n\r\n\tvar ContextualizedVariable = lang.compose(Variable, function ContextualizedVariable(generic, subject) {\r\n\t\tthis.generic = generic\r\n\t\tthis.subject = subject\r\n\t}, {\r\n\t\tvalueOf: function() {\r\n\t\t\t// TODO: Lookup Context type for all of these using registry or something\r\n\t\t\tvar subject = this.subject\r\n\t\t\treturn this.generic.valueOf(subject.getContextualized ? subject : new Context(subject))\r\n\t\t},\r\n\r\n\t\tforDependencies: function(callback) {\r\n\t\t\tthis.inputs && this.inputs.forEach(callback)\r\n\t\t},\r\n\r\n\t\tgetVersion: function() {\r\n\t\t\tvar version = Variable.prototype.getVersion.call(this)\r\n\t\t\tvar inputs = this.inputs || 0\r\n\t\t\tfor (var i = 0, l = inputs.length; i < l; i++) {\r\n\t\t\t\tvar input = inputs[i]\r\n\t\t\t\tif (input.getVersion) {\r\n\t\t\t\t\tversion = Math.max(version, input.getVersion())\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn version\r\n\t\t},\r\n\r\n\t\tput: function(value) {\r\n\t\t\tvar subject = this.subject\r\n\t\t\treturn this.generic.put(value, subject.getContextualized ? subject : new Context(subject))\r\n\t\t}\r\n\t})\r\n\r\n\tvar IterativeMethod = lang.compose(Composite, function(source, method, args) {\r\n\t\tthis.source = source\r\n\t\t// source.interestWithin = true\r\n\t\tthis.method = method\r\n\t\tthis.arguments = args\r\n\t}, {\r\n\t\tgetValue: function(context) {\r\n\t\t\tvar method = this.method\r\n\t\t\tvar args = this.arguments\r\n\t\t\tvar variable = this\r\n\t\t\tif (context) {\r\n\t\t\t\tcontext.nextProperty = 'source'\r\n\t\t\t}\r\n\t\t\treturn when(this.source.valueOf(context), function(array) {\r\n\t\t\t\tif (array && array.forEach) {\r\n\t\t\t\t\tif (context && context.notify) {\r\n\t\t\t\t\t\tvar contextualizedVariable\r\n\t\t\t\t\t\tif (context.distinctSubject) {\r\n\t\t\t\t\t\t\tvar contextMap = variable._contextMap || (variable._contextMap = new WeakMap())\r\n\t\t\t\t\t\t\tif (contextMap.has(context.distinctSubject)) {\r\n\t\t\t\t\t\t\t\tcontextualizedVariable = contextMap.get(context.distinctSubject)\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tcontextMap.set(context.distinctSubject, contextualizedVariable = Object.create(variable))\r\n\t\t\t\t\t\t\t\tcontextualizedVariable.listeners = false\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tcontextualizedVariable = variable\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvariable.notifies(contextualizedVariable)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (method === 'map'){\r\n\t\t\t\t\t\t// fast path, and special behavior for map\r\n\t\t\t\t\t\treturn args[0](array)\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// if not an array convert to an array\r\n\t\t\t\t\tarray = [array]\r\n\t\t\t\t}\r\n\t\t\t\tif (typeof method === 'string') {\r\n\t\t\t\t\t// apply method\r\n\t\t\t\t\treturn array[method].apply(array, args)\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn method(array, args)\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t},\r\n\t\t// TODO: Create specialized updated handlers for faster recomputation of other array derivatives\r\n\t\tforDependencies: function(callback) {\r\n\t\t\t// depend on the args\r\n\t\t\tComposite.prototype.forDependencies.call(this, callback)\r\n\t\t\tcallback(this.source)\r\n\t\t},\r\n\t\tgetVersion: function(context) {\r\n\t\t\treturn Math.max(Composite.prototype.getVersion.call(this, context), this.source.getVersion(context))\r\n\t\t},\r\n\t\tgetCollectionOf: function(){\r\n\t\t\treturn this.source.getCollectionOf()\r\n\t\t}\r\n\t})\r\n\r\n\tfunction defineArrayMethod(method, constructor, properties) {\r\n\t\tvar IterativeResults = lang.compose(IterativeMethod, constructor, properties)\r\n\t\tIterativeResults.prototype.method || (IterativeResults.prototype.method = method)\r\n\t\tObject.defineProperty(IterativeResults.prototype, 'isIterable', {value: true});\r\n\t\tVariable.prototype[method] = function() {\r\n\t\t\tvar results = new IterativeResults()\r\n\t\t\tresults.source = this\r\n\t\t\tresults.arguments = arguments\r\n\t\t\treturn results\r\n\t\t}\r\n\t}\r\n\r\n\tdefineArrayMethod('filter', function Filtered() {}, {\r\n\t\tupdated: function(event, by, context) {\r\n\t\t\tif (!event || event.modifier === this || (event.modifier && event.modifier.constructor === this)) {\r\n\t\t\t\treturn Composite.prototype.updated.call(this, event, by, context)\r\n\t\t\t}\r\n\t\t\tvar contextualizedVariable = context ? context.getContextualized(this) : this\r\n\t\t\tif (event.type === 'delete') {\r\n\t\t\t\tvar index = contextualizedVariable.cachedValue.indexOf(event.oldValue)\r\n\t\t\t\tif (index > -1) {\r\n\t\t\t\t\tcontextualizedVariable.splice(index, 1)\r\n\t\t\t\t}\r\n\t\t\t} else if (event.type === 'add') {\r\n\t\t\t\tif ([event.value].filter(this.arguments[0]).length > 0) {\r\n\t\t\t\t\tcontextualizedVariable.push(event.value)\r\n\t\t\t\t}\r\n\t\t\t} else if (event.type === 'update') {\r\n\t\t\t\tvar object = event.parent.valueOf(context)\r\n\t\t\t\tvar index = contextualizedVariable.cachedValue.indexOf(object)\r\n\t\t\t\tvar matches = [object].filter(this.arguments[0]).length > 0\r\n\t\t\t\tif (index > -1) {\r\n\t\t\t\t\tif (matches) {\r\n\t\t\t\t\t\treturn new PropertyChangeEvent(index, event, contextualizedVariable.cachedValue,\r\n\t\t\t\t\t\t\t// might need to do something with this\r\n\t\t\t\t\t\t\tobject)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tcontextualizedVariable.splice(index, 1)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\telse {\r\n\t\t\t\t\tif (matches) {\r\n\t\t\t\t\t\tcontextualizedVariable.push(object)\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// else nothing mactches\r\n\t\t\t\t}\r\n\t\t\t\treturn\r\n\t\t\t} else {\r\n\t\t\t\treturn Composite.prototype.updated.call(this, event, by, context)\r\n\t\t\t}\r\n\t\t}\r\n\t})\r\n\tdefineArrayMethod('map', function Mapped() {}, {\r\n\t\tupdated: function(event, by, context) {\r\n\t\t\tif (!event || event.modifier === this || (event.modifier && event.modifier.constructor === this)) {\r\n\t\t\t\treturn Composite.prototype.updated.call(this, event, by, context)\r\n\t\t\t}\r\n\t\t\tvar contextualizedVariable = context ? context.getContextualized(this) : this\r\n\t\t\tif (event.type === 'delete') {\r\n\t\t\t\tcontextualizedVariable.splice(event.previousIndex, 1)\r\n\t\t\t} else if (event.type === 'add') {\r\n\t\t\t\tcontextualizedVariable.push(this.arguments[0].call(this.arguments[1], event.value))\r\n\t\t\t} else if (event.type === 'update') {\r\n\t\t\t\tvar object = event.parent.valueOf(context)\r\n\t\t\t\tvar array = contextualizedVariable.cachedValue\r\n\t\t\t\tif (array && array.map) {\r\n\t\t\t\t\tvar index = array.indexOf(object)\r\n\t\t\t\t\tcontextualizedVariable.splice(index, 1, this.arguments[0].call(this.arguments[1], event.value))\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn Composite.prototype.updated.call(this, event, by, context)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\treturn Composite.prototype.updated.call(this, event, by, context)\r\n\t\t\t}\r\n\t\t}\r\n\t})\r\n\tdefineArrayMethod('reduce', function Reduced() {})\r\n\tdefineArrayMethod('reduceRight', function Reduced() {})\r\n\tdefineArrayMethod('some', function Aggregated() {})\r\n\tdefineArrayMethod('every', function Aggregated() {})\r\n\tdefineArrayMethod('slice', function Aggregated() {})\r\n\tdefineArrayMethod('keyBy', function UniqueIndex(source, args) {}, {\r\n\t\tisMap: function () {\r\n\t\t\treturn true\r\n\t\t},\r\n\t\tmethod: function(array, args) {\r\n\t\t\tvar index = new Map()\r\n\t\t\tvar keyGenerator = args[0]\r\n\t\t\tvar valueGenerator = args[1]\r\n\t\t\tvar hasKeyFunction = typeof keyGenerator === 'function'\r\n\t\t\tvar hasValueFunction = typeof valueGenerator === 'function'\r\n\t\t\tvar hasKey = !!keyGenerator\r\n\t\t\tfor (var i = 0, l = array.length; i < l; i++) {\r\n\t\t\t\tvar element = array[i]\r\n\t\t\t\tindex.set(\r\n\t\t\t\t\thasKeyFunction ? keyGenerator(element, emit) :\r\n\t\t\t\t\t\thasKey ? element[keyGenerator] : element,\r\n\t\t\t\t\thasValueFunction ? valueGenerator(element) : element)\r\n\t\t\t}\r\n\t\t\tfunction emit(key, value) {\r\n\t\t\t\tindex.set(key, value)\r\n\t\t\t}\r\n\t\t\treturn index\r\n\t\t}\r\n\t})\r\n\r\n\tdefineArrayMethod('groupBy', function UniqueIndex(source, args) {}, {\r\n\t\tisMap: function () {\r\n\t\t\treturn true\r\n\t\t},\r\n\t\tmethod: function(array, args) {\r\n\t\t\tvar index = new Map()\r\n\t\t\tvar keyGenerator = args[0]\r\n\t\t\tvar valueGenerator = args[1]\r\n\t\t\tvar hasKeyFunction = typeof keyGenerator === 'function'\r\n\t\t\tvar hasValueFunction = typeof valueGenerator === 'function'\r\n\t\t\tvar hasKey = !!keyGenerator\r\n\t\t\tfor (var i = 0, l = array.length; i < l; i++) {\r\n\t\t\t\tvar element = array[i]\r\n\t\t\t\tvar key = hasKeyFunction ? keyGenerator(element) :\r\n\t\t\t\t\t\thasKey ? element[keyGenerator] : element\r\n\t\t\t\tvar group = index.get(key)\r\n\t\t\t\tif (!group) {\r\n\t\t\t\t\tindex.set(key, group = [])\r\n\t\t\t\t}\r\n\t\t\t\tgroup.push(hasValueFunction ? valueGenerator(element) : element)\r\n\t\t\t}\r\n\t\t\tfunction emit(key, value) {\r\n\t\t\t\tvar group = index.get(key)\r\n\t\t\t\tif (!group) {\r\n\t\t\t\t\tindex.set(key, group = [])\r\n\t\t\t\t}\r\n\t\t\t\tgroup.push(value)\r\n\t\t\t}\r\n\t\t\treturn index\r\n\t\t}\r\n\t})\r\n\r\n\r\n\tvar getValue\r\n\tvar GeneratorVariable = Variable.GeneratorVariable = lang.compose(Variable.Composite, function ReactiveGenerator(generator){\r\n\t\tthis.generator = generator\r\n\t}, {\r\n\t\tgetValue: getValue = function(context, resuming) {\r\n\t\t\tvar lastValue\r\n\t\t\tvar i\r\n\t\t\tvar generatorIterator\r\n\t\t\tvar isThrowing\r\n\t\t\tif (resuming) {\r\n\t\t\t\t// resuming from a promise\r\n\t\t\t\tgeneratorIterator = resuming.iterator\r\n\t\t\t\ti = resuming.i\r\n\t\t\t\tlastValue = resuming.value\r\n\t\t\t\tisThrowing = resuming.isThrowing\r\n\t\t\t} else {\r\n\t\t\t\t// a fresh start\r\n\t\t\t\ti = 0\r\n\t\t\t\tgeneratorIterator = this.generator()\r\n\t\t\t}\r\n\r\n\t\t\tdo {\r\n\t\t\t\tvar stepReturn = generatorIterator[isThrowing ? 'throw' : 'next'](lastValue)\r\n\t\t\t\tif (stepReturn.done) {\r\n\t\t\t\t\treturn stepReturn.value\r\n\t\t\t\t}\r\n\t\t\t\tvar nextVariable = stepReturn.value\r\n\t\t\t\t// compare with the arguments from the last\r\n\t\t\t\t// execution to see if they are the same\r\n\t\t\t\tvar argumentName = i > 0 ? 'input' + i : 'input'\r\n\t\t\t\tif (this[argumentName] !== nextVariable) {\r\n\t\t\t\t\tif (this[argumentName]) {\r\n\t\t\t\t\t\tthis[argumentName].stopNotifies(this)\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// subscribe if it is a variable\r\n\t\t\t\t\tif (nextVariable && nextVariable.notifies) {\r\n\t\t\t\t\t\tif (this.listeners) {\r\n\t\t\t\t\t\t\tnextVariable.notifies(this)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tthis[argumentName] = nextVariable\r\n\t\t\t\t\t} else if (typeof nextVariable === 'function' && isGenerator(nextVariable)) {\r\n\t\t\t\t\t\tvar delegatedGenerator\r\n\t\t\t\t\t\tgetValue.call(this, context, delegatedGenerator = {\r\n\t\t\t\t\t\t\ti: i,\r\n\t\t\t\t\t\t\titerator: nextVariable()\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t\ti = delegatedGenerator.i\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis[argumentName] = null\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\ti++\r\n\t\t\t\tif (resuming) {\r\n\t\t\t\t\tresuming.i = i\r\n\t\t\t\t}\r\n\t\t\t\tif (context) {\r\n\t\t\t\t\tcontext.nextProperty = argumentName\r\n\t\t\t\t}\r\n\t\t\t\tlastValue = nextVariable && nextVariable.valueOf(context)\r\n\t\t\t\tif (lastValue && lastValue.then) {\r\n\t\t\t\t\t// if it is a promise, we will wait on it\r\n\t\t\t\t\tvar variable = this\r\n\t\t\t\t\t// and return the promise so that the getValue caller can wait on this\r\n\t\t\t\t\treturn lastValue.then(function(value) {\r\n\t\t\t\t\t\treturn getValue.call(variable, context, {\r\n\t\t\t\t\t\t\ti: i,\r\n\t\t\t\t\t\t\titerator: generatorIterator,\r\n\t\t\t\t\t\t\tvalue: value\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}, function(error) {\r\n\t\t\t\t\t\treturn getValue.call(variable, context, {\r\n\t\t\t\t\t\t\ti: i,\r\n\t\t\t\t\t\t\titerator: generatorIterator,\r\n\t\t\t\t\t\t\tvalue: error,\r\n\t\t\t\t\t\t\tisThrowing: true\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t} while(true)\r\n\t\t}\r\n\t})\r\n\r\n\tvar Validating = lang.compose(Caching, function(target) {\r\n\t\tthis.target = target\r\n\t}, {\r\n\t\tforDependencies: function(callback) {\r\n\t\t\tCaching.prototype.forDependencies.call(this, callback)\r\n\t\t\tcallback(this.target)\r\n\t\t},\r\n\t\tgetVersion: function(context) {\r\n\t\t\treturn Math.max(Variable.prototype.getVersion.call(this, context), this.target.getVersion(context))\r\n\t\t},\r\n\t\tgetValue: function(context) {\r\n\t\t\tvar target = this.target\r\n\t\t\t// need to actually access the target value, so it can be evaluated in case it\r\n\t\t\t// there is a returned variable that we should delegate to.\r\n\t\t\ttarget.valueOf(context)\r\n\t\t\treturn target.validate(target, target.schema)\r\n\t\t}\r\n\t})\r\n\r\n\tVariable.VArray = Variable\r\n\tVariable.VPromised = Variable\r\n\tVariable.deny = deny\r\n\tVariable.noChange = noChange\r\n\tfunction addFlag(name) {\r\n\t\tVariable[name] = function(functionValue) {\r\n\t\t\tfunctionValue[name] = true\r\n\t\t}\r\n\t}\r\n\taddFlag(Variable, 'handlesContext')\r\n\taddFlag(Variable, 'handlesPromises')\r\n\r\n\tfunction objectUpdated(object) {\r\n\t\t// simply notifies any subscribers to an object, that it has changed\r\n\t\tvar listeners = propertyListenersMap.get(object)\r\n\t\tif (listeners) {\r\n\t\t\tfor (var i = 0, l = listeners.length; i < l; i++) {\r\n\t\t\t\tlisteners[i]._propertyChange(null, object)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction all(array, transform) {\r\n\t\t// This is intended to mirror Promise.all. It actually takes\r\n\t\t// an iterable, but for now we are just looking for array-like\r\n\t\tif (array.length > -1) {\r\n\t\t\treturn typeof transform === 'function' ? new Call(transform, array) : new Composite(array)\r\n\t\t}\r\n\t\tif (arguments.length > 1) {\r\n\t\t\t// support multiple arguments as an array\r\n\t\t\treturn new Composite(arguments)\r\n\t\t}\r\n\t\tif (typeof array === 'object') {\r\n\t\t\t// allow an object as a hash to be mapped\r\n\t\t\tvar keyMapping = []\r\n\t\t\tvar valueArray = []\r\n\t\t\tfor (var key in array) {\r\n\t\t\t\tkeyMapping.push(key)\r\n\t\t\t\tvalueArray.push(array[key])\r\n\t\t\t}\r\n\t\t\treturn new Variable(function(results) {\r\n\t\t\t\tvar resultObject = {}\r\n\t\t\t\tfor (var i = 0; i < results.length; i++) {\r\n\t\t\t\t\tresultObject[keyMapping[i]] = results[i]\r\n\t\t\t\t}\r\n\t\t\t\treturn resultObject\r\n\t\t\t}).apply(null, valueArray)\r\n\t\t}\r\n\t\tthrow new TypeError('Variable.all requires an array')\r\n\t}\r\n\r\n\tfunction hasOwn(Target, createForInstance) {\r\n\r\n\t\tvar ownedClasses = this.ownedClasses || (this.ownedClasses = new WeakMap())\r\n\t\t// TODO: assign to super classes\r\n\t\tvar Class = this\r\n\t\townedClasses.set(Target, createForInstance || function() { return new Target() })\r\n\t\treturn this\r\n\t}\r\n\tfunction generalizeClass() {\r\n\t\tvar prototype = this.prototype\r\n\t\tvar prototypeNames = Object.getOwnPropertyNames(prototype)\r\n\t\tfor(var i = 0, l = prototypeNames.length; i < l; i++) {\r\n\t\t\tvar name = prototypeNames[i]\r\n\t\t\tObject.defineProperty(this, name, getGeneralizedDescriptor(Object.getOwnPropertyDescriptor(prototype, name), name, this))\r\n\t\t}\r\n\t}\r\n\tfunction getGeneralizedDescriptor(descriptor, name, Class) {\r\n\t\tif (typeof descriptor.value === 'function') {\r\n\t\t\treturn {\r\n\t\t\t\tvalue: generalizeMethod(Class, name)\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\treturn descriptor\r\n\t\t}\r\n\t}\r\n\tfunction generalizeMethod(Class, name) {\r\n\t\t// I think we can just rely on `this`, but we could use the argument:\r\n\t\t// function(possibleEvent) {\r\n\t\t// \tvar target = possibleEvent && possibleEvent.target\r\n\t\tvar method = Class[name] = function() {\r\n\t\t\tvar instance = Class.for(this)\r\n\t\t\treturn instance[name].apply(instance, arguments)\r\n\t\t}\r\n\t\tmethod.for = function(context) {\r\n\t\t\tvar instance = Class.for(context)\r\n\t\t\treturn function() {\r\n\t\t\t\treturn instance[name].apply(instance, arguments)\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn method\r\n\t}\r\n\r\n\tvar defaultContext = {\r\n\t\tname: 'Default context',\r\n\t\tdescription: 'This object is the default context for classes, corresponding to a singleton instance of that class',\r\n\t\tconstructor: {\r\n\t\t\tgetForClass: function(subject, Class) {\r\n\t\t\t\treturn Class.defaultInstance\r\n\t\t\t}\r\n\t\t},\r\n\t\tcontains: function() {\r\n\t\t\treturn true // contains everything\r\n\t\t}\r\n\t}\r\n\tfunction instanceForContext(Class, context) {\r\n\t\tif (!context) {\r\n\t\t\treturn Class.defaultInstance\r\n\t\t}\r\n\t\treturn context.specify(Class)\r\n//\t\tvar instance = context.subject.constructor.getForClass && context.subject.constructor.getForClass(context.subject, Class) || Class.defaultInstance\r\n//\t\tcontext.distinctSubject = mergeSubject(context.distinctSubject, instance.subject)\r\n//\t\treturn instance\r\n\t}\r\n\t// a variable inheritance change goes through its own prototype, so classes/constructor\r\n\t// can be used as variables as well\r\n\tfor (var key in VariablePrototype) {\r\n\t\tObject.defineProperty(Variable, key, Object.getOwnPropertyDescriptor(VariablePrototype, key))\r\n\t}\r\n\tVariable.valueOf = function(context) {\r\n\t\t// contextualized getValue\r\n\t\treturn instanceForContext(this, context).valueOf(context)\r\n\t}\r\n\tVariable.put = function(value, context) {\r\n\t\t// contextualized setValue\r\n\t\treturn instanceForContext(this, context).put(value, context)\r\n\t}\r\n\tVariable.for = function(subject) {\r\n\t\tif (subject != null) {\r\n\t\t\tif (subject.target && !subject.constructor.getForClass) {\r\n\t\t\t\t// makes HTML events work\r\n\t\t\t\tsubject = subject.target\r\n\t\t\t}\r\n\t\t\tvar instance\r\n\t\t\tinstance = new Context(subject).specify(this)\r\n\t\t\tif (instance && !instance.subject) {\r\n\t\t\t\tinstance.subject = subject\r\n\t\t\t}\r\n\t\t\t// TODO: Do we have a global context that we set on defaultInstance?\r\n\t\t\treturn instance || this.defaultInstance\r\n\t\t} else {\r\n\t\t\treturn this.defaultInstance\r\n\t\t}\r\n\t}\r\n\tVariable.from = function(value) {\r\n\t\tif (value && typeof value === 'object') {\r\n\t\t\t// a plain object, we use our own map to retrieve the instance (or create one)\r\n\t\t\tvar instanceMap = this.instanceMap || (this.instanceMap = new WeakMap())\r\n\t\t\tvar instance = instanceMap.get(value)\r\n\t\t\tif (!instance) {\r\n\t\t\t\tinstanceMap.set(value, instance = new this(value))\r\n\t\t\t}\r\n\t\t\treturn instance\r\n\t\t} else {\r\n\t\t\t// a primitive, just unconditionally create a new variable for it\r\n\t\t\treturn new this(value)\r\n\t\t}\r\n\t}\r\n\tVariable.notifies = function(target) {\r\n\t\tthis.defaultInstance.notifies(target)\r\n\t}\r\n\tVariable.stopNotifies = function(target) {\r\n\t\tthis.defaultInstance.stopNotifies(target)\r\n\t}\r\n\tVariable.getCollectionOf = function () {\r\n\t\treturn this.collectionOf\r\n\t}\r\n\tVariable.updated = function(updateEvent, by, context) {\r\n\t\treturn instanceForContext(this, context).updated(updateEvent, by, context)\r\n\t}\r\n\tObject.defineProperty(Variable, 'collectionOf', {\r\n\t\tget: function() {\r\n\t\t\treturn this._collectionOf\r\n\t\t},\r\n\t\tset: function(ItemClass) {\r\n\t\t\tif (this._collectionOf != ItemClass) {\r\n\t\t\t\tthis._collectionOf = ItemClass\r\n\t\t\t\tItemClass.collection = this\r\n\t\t\t}\r\n\t\t}\r\n\t})\r\n\tObject.defineProperty(Variable, 'collection', {\r\n\t\tget: function() {\r\n\t\t\treturn this._collection\r\n\t\t},\r\n\t\tset: function(Collection) {\r\n\t\t\tif (this._collection != Collection) {\r\n\t\t\t\tthis._collection = Collection\r\n\t\t\t\tCollection.collectionOf = this\r\n\t\t\t}\r\n\t\t}\r\n\t})\r\n\tVariable.Context = Context\r\n\tVariable.NotifyingContext = NotifyingContext\r\n\tVariable.generalize = generalizeClass\r\n\tVariable.call = Function.prototype.call // restore these\r\n\tVariable.apply = Function.prototype.apply\r\n\tVariable.extend = function(properties) {\r\n\t\t// TODO: handle arguments\r\n\t\tvar Base = this\r\n\t\tfunction ExtendedVariable() {\r\n\t\t\tif (this instanceof ExtendedVariable) {\r\n\t\t\t\tBase.apply(this, arguments)\r\n\t\t\t} else {\r\n\t\t\t\treturn ExtendedVariable.extend(properties)\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar prototype = ExtendedVariable.prototype = Object.create(this.prototype)\r\n\t\tExtendedVariable.prototype.constructor = ExtendedVariable\r\n\t\tsetPrototypeOf(ExtendedVariable, this)\r\n\t\tfor (var key in properties) {\r\n\t\t\tvar descriptor = Object.getOwnPropertyDescriptor(properties, key)\r\n\t\t\tObject.defineProperty(prototype, key, descriptor)\r\n\t\t\tObject.defineProperty(ExtendedVariable, key, getGeneralizedDescriptor(descriptor, key, ExtendedVariable))\r\n\t\t}\r\n\t\tif (properties && properties.hasOwn) {\r\n\t\t\thasOwn.call(ExtendedVariable, properties.hasOwn)\r\n\t\t}\r\n\t\treturn ExtendedVariable\r\n\t}\r\n\tObject.defineProperty(Variable, 'defaultInstance', {\r\n\t\tget: function() {\r\n\t\t\treturn this.hasOwnProperty('_defaultInstance') ?\r\n\t\t\t\tthis._defaultInstance : (\r\n\t\t\t\t\tthis._defaultInstance = new this(),\r\n\t\t\t\t\tthis._defaultInstance.subject = defaultContext,\r\n\t\t\t\t\tthis._defaultInstance)\r\n\t\t}\r\n\t})\r\n\tVariable.hasOwn = function(Target, createInstance) {\r\n\t\tvar instanceMap = new WeakMap()\r\n\t\tinstanceMap.createInstance = createInstance\r\n\t\tvar subjectMap = this.ownedClasses || (this.ownedClasses = new WeakMap())\r\n\t\tsubjectMap.set(Target, instanceMap)\r\n\t}\r\n\r\n\tVariable.all = all\r\n\tVariable.objectUpdated = objectUpdated\r\n\r\n\treturn Variable\r\n}))\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./Variable.js\n ** module id = 4\n ** module chunks = 0\n **/","(function (root, factory) { if (typeof define === 'function' && define.amd) {\r\n  define(['./util/lang', './operators', './Variable'], factory) } else if (typeof module === 'object' && module.exports) {        \r\n  module.exports = factory(require('./util/lang'), require('./operators'), require('./Variable')) // Node\r\n}}(this, function (lang, operators, Variable) {\r\n\r\n  var isGenerator = lang.isGenerator\r\n  var ObjectTransform = lang.compose(Variable.Call, function ObjectTransform(transform, inputs) {\r\n    this.inputs = inputs\r\n    Variable.Call.apply(this, arguments)\r\n  }, {\r\n    _getAsObject: function() {\r\n      return this.transform.apply(this, preserveObjects(this.inputs))\r\n    }\r\n  })\r\n  function preserveObjects(inputs) {\r\n    for (var i = 0, l = inputs.length; i < l; i++) {\r\n      var input = inputs[i]\r\n      if (input && input._getAsObject) {\r\n        inputs[i] = input._getAsObject()\r\n      }\r\n    }\r\n    return inputs\r\n  }\r\n\tfunction react(generator, options) {\r\n    if (typeof generator !== 'function') {\r\n      throw new Error('react() must be called with a generator. You need to use the babel-plugin-transform-alkali plugin if you want to use reactive expressions')\r\n    }\r\n\t\tif (options && options.reverse) {\r\n\t\t\tgenerator.reverse = options.reverse\r\n\t\t}\r\n\t\treturn new Variable.GeneratorVariable(generator)\r\n\t}\r\n  Object.assign(react, operators)\r\n  react.from = function(value, options) {\r\n    if (value && value.property) {\r\n      return value\r\n    }\r\n    if (typeof value === 'function' && isGenerator(value)) {\r\n      return react(value, options)\r\n    }\r\n    return Variable.from(value)\r\n  }\r\n  react.prop = function(object, property) {\r\n    if (object) {\r\n      // TODO: Use a static set of public methods/properties that can be accessed\r\n      if (object.property) {\r\n        // it is a variable already, but check to see if we are using a method/property directly on the variable\r\n        var directPropertyValue = object[property]\r\n        return directPropertyValue !== undefined ? directPropertyValue : object.property(property)\r\n      }\r\n      return object[property]\r\n    }\r\n    // not even truthy, return undefined\r\n  }\r\n  react.cond = function(test, consequent, alternate) {\r\n    return operators.if(test, operators.choose(consequent, alternate))\r\n  }\r\n  react.fcall = function(target, args) {\r\n    if (target.property && typeof target === 'function') {\r\n      return target.apply(null, preserveObjects(args))\r\n    }\r\n    return new Variable.Call(target, args)\r\n  }\r\n  react.mcall = function(target, key, args) {\r\n    var method = target[key]\r\n    if (typeof method === 'function' && method.property || key === 'bind') {\r\n      // for now we check to see if looks like it could handle a variable, or is a bind call\r\n      return method.apply(target, preserveObjects(args))\r\n    }\r\n    return new Variable.Call(target[key].bind(target), args)\r\n  }\r\n  react.ncall = function(target, args) {\r\n    if (target.property && typeof target === 'function') {\r\n      return new (target.bind.apply(target, [null].concat(preserveObjects(args))))()\r\n    }\r\n    return new Variable.Call(function() {\r\n      return new (target.bind.apply(target, [null].concat(arguments)))()\r\n    }, args)\r\n  }\r\n\r\n  react.obj = function(transform, inputs) {\r\n    return new ObjectTransform(transform, inputs)\r\n  }\r\n\r\n\treturn react\r\n}))\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./react.js\n ** module id = 5\n ** module chunks = 0\n **/","(function (root, factory) { if (typeof define === 'function' && define.amd) {\r\n\tdefine(['./Variable'], factory) } else if (typeof module === 'object' && module.exports) {        \r\n  module.exports = factory(require('./Variable')) // Node\r\n}}(this, function (Variable) {\r\n\r\n\tvar deny = Variable.deny;\r\n\tvar operatingFunctions = {};\r\n\tvar operators = {};\r\n\tfunction getOperatingFunction(expression){\r\n\t\t// jshint evil: true\r\n\t\treturn operatingFunctions[expression] ||\r\n\t\t\t(operatingFunctions[expression] =\r\n\t\t\t\tnew Function('a', 'b', 'deny', 'return ' + expression));\r\n\t}\r\n\tfunction operator(operator, name, precedence, forward, reverseA, reverseB){\r\n\t\t// defines the standard operators\r\n\t\tvar reverse = function(output, inputs){\r\n\t\t\tvar a = inputs[0],\r\n\t\t\t\tb = inputs[1];\r\n\t\t\tif(a && a.put){\r\n\t\t\t\tvar result = reverseA(output, b && b.valueOf());\r\n\t\t\t\tif(result !== deny){\r\n\t\t\t\t\ta.put(result);\r\n\t\t\t\t}\r\n\t\t\t}else if(b && b.put){\r\n\t\t\t\tb.put(reverseB(output, a && a.valueOf()));\r\n\t\t\t}else{\r\n\t\t\t\treturn deny;\r\n\t\t\t}\r\n\t\t};\r\n\t\t// define a function that can lazily ensure the operating function\r\n\t\t// is available\r\n\t\tvar operatorHandler = {\r\n\t\t\tapply: function(instance, args){\r\n\t\t\t\tforward = getOperatingFunction(forward);\r\n\t\t\t\treverseA = reverseA && getOperatingFunction(reverseA);\r\n\t\t\t\treverseB = reverseB && getOperatingFunction(reverseB);\r\n\t\t\t\tforward.reverse = reverse;\r\n\t\t\t\toperators[operator] = operatorHandler = new Variable(forward);\r\n\r\n\t\t\t\taddFlags(operatorHandler);\r\n\t\t\t\targs = Array.prototype.slice.call(args);\r\n\t\t\t\targs.push(deny)\r\n\t\t\t\treturn operatorHandler.apply(instance, args);\r\n\t\t\t}\r\n\t\t};\r\n\t\tfunction addFlags(operatorHandler){\r\n\t\t\toperatorHandler.precedence = precedence;\r\n\t\t\toperatorHandler.infix = reverseB !== false;\r\n\t\t}\r\n\t\taddFlags(operatorHandler);\r\n\t\toperators[operator] = operatorHandler;\r\n\t\toperators[name] = function() {\r\n\t\t\treturn operatorHandler.apply(null, arguments)\r\n\t\t}\r\n\t}\r\n\t// using order precedence from:\r\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence\r\n\toperator('+', 'add', 6, 'a+b', 'a-b', 'a-b');\r\n\toperator('-', 'subtract', 6, 'a-b', 'a+b', 'b-a');\r\n\toperator('*', 'multiply', 5, 'a*b', 'a/b', 'a/b');\r\n\toperator('/', 'divide', 5, 'a/b', 'a*b', 'b/a');\r\n//\toperator('^', 7, 'a^b', 'a^(-b)', 'Math.log(a)/Math.log(b)');\r\n\toperator('?', 'if', 16, 'b[a?0:1]', 'a===b[0]||(a===b[1]?false:deny)', '[a,b]');\r\n\toperator(':', 'choose', 15, '[a,b]', 'a[0]?a[1]:deny', 'a[1]');\r\n\toperator('!', 'not', 4, '!a', '!a', false);\r\n\toperator('%', 'remainder', 5, 'a%b');\r\n\toperator('>', 'greater', 8, 'a>b');\r\n\toperator('>=', 'greaterOrEqual', 8, 'a>=b');\r\n\toperator('<', 'less', 8, 'a<b');\r\n\toperator('<=', 'lessOrEqual', 8, 'a<=b');\r\n\toperator('===', 'strictEqual', 9, 'a===b');\r\n\toperator('==', 'equal', 9, 'a==b');\r\n\toperator('&', 'and', 8, 'a&&b');\r\n\toperator('|', 'or', 8, 'a||b');\r\n\toperator('round', 'round', 8, 'Math.round(a*Math.pow(10,b||1))/Math.pow(10,b||1)', 'a', 'a');\r\n\treturn operators;\r\n}))\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./operators.js\n ** module id = 6\n ** module chunks = 0\n **/","(function (root, factory) { if (typeof define === 'function' && define.amd) {\r\n\tdefine(['./util/lang', './Variable'], factory) } else if (typeof module === 'object' && module.exports) {        \r\n  module.exports = factory(require('./util/lang'), require('./Variable')) // Node\r\n}}(this, function (lang, Variable) {\r\n\r\n\tfunction deepCopy(source, target, derivativeMap) {\r\n\t\tif (source && typeof source == 'object') {\r\n\t\t\tif (source instanceof Array) {\r\n\t\t\t\ttarget = [] // always create a new array for array targets\r\n\t\t\t\tfor(var i = 0, l = source.length; i < l; i++) {\r\n\t\t\t\t\ttarget[i] = deepCopy(source[i], null, derivativeMap)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (!target || typeof target !== 'object') {\r\n\t\t\t\t\ttarget = derivativeMap && derivativeMap.get(source)\r\n\t\t\t\t\tif (!target) {\r\n\t\t\t\t\t\ttarget = {}\r\n\t\t\t\t\t\tderivativeMap && derivativeMap.set(source, target)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tfor (var i in source) {\r\n\t\t\t\t\ttarget[i] = deepCopy(source[i], target[i], derivativeMap)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn target\r\n\t\t}\r\n\t\treturn source\r\n\t}\r\n\r\n\tvar Copy = lang.compose(Variable, function(copiedFrom) {\r\n\t\t// this is the variable that we derive from\r\n\t\tthis.copiedFrom = copiedFrom\r\n\t\tthis.derivativeMap = new lang.WeakMap(null, 'derivative')\r\n\t\tthis.isDirty = new Variable(false)\r\n\t}, {\r\n\t\tvalueOf: function(context) {\r\n\t\t\tif(this.state) {\r\n\t\t\t\tthis.state = null\r\n\t\t\t}\r\n\t\t\tvar value = this.copiedFrom.valueOf(context)\r\n\t\t\tif(value && typeof value == 'object') {\r\n\t\t\t\tvar derivative = this.derivativeMap.get(value)\r\n\t\t\t\tif (derivative == null) {\r\n\t\t\t\t\tthis.derivativeMap.set(value, derivative = deepCopy(value, undefined, this.derivativeMap))\r\n\t\t\t\t\tthis.setValue(derivative, context)\r\n\t\t\t\t}\r\n\t\t\t\treturn derivative\r\n\t\t\t}\r\n\t\t\tvar thisValue = this.getValue ? this.getValue(context) : this.value\r\n\t\t\tif(thisValue === undefined) {\r\n\t\t\t\treturn value\r\n\t\t\t}\r\n\t\t\treturn thisValue\r\n\t\t},\r\n\t\tgetCopyOf: function(value) {\r\n\t\t\tvar derivative = this.derivativeMap.get(value)\r\n\t\t\tif (derivative == null) {\r\n\t\t\t\tthis.derivativeMap.set(value, derivative = deepCopy(value, undefined, this.derivativeMap))\r\n\t\t\t}\r\n\t\t\treturn derivative\r\n\t\t},\r\n\t\tsave: function() {\r\n\t\t\t// copy back to the original object\r\n\t\t\tvar original = this.copiedFrom.valueOf()\r\n\t\t\tvar newCopiedFrom = deepCopy(this.valueOf(), original)\r\n\t\t\tif (original !== newCopiedFrom) {\r\n\t\t\t\t// if we have replaced it with a new object/value, put it\r\n\t\t\t\tthis.copiedFrom.put && this.copiedFrom.put(newCopiedFrom)\r\n\t\t\t} else {\r\n\t\t\t\t// else we have modified an existing object, but we still need to notify\r\n\t\t\t\tif (this.copiedFrom.notifies && this.copiedFrom.updated) { // copiedFrom doesn't have to be a variable, it can be a plain object\r\n\t\t\t\t\tthis.copiedFrom.updated()\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.isDirty.put(false)\r\n\t\t\tthis.onSave && this.onSave()\r\n\t\t},\r\n\t\trevert: function() {\r\n\t\t\tvar original = this.copiedFrom.valueOf()\r\n\t\t\tthis.put(deepCopy(original, this.derivativeMap.get(original), this.derivativeMap))\r\n\t\t\tthis.isDirty.put(false)\r\n\t\t},\r\n\t\tupdated: function() {\r\n\t\t\tthis.isDirty.put(true)\r\n\t\t\treturn Variable.prototype.updated.apply(this, arguments)\r\n\t\t}\r\n\t})\r\n\treturn Copy\r\n}))\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./Copy.js\n ** module id = 7\n ** module chunks = 0\n **/"],"sourceRoot":""}