{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///index.js","webpack:///webpack/bootstrap efdc711a6aa3e5948bde","webpack:///./index.js","webpack:///./Element.js","webpack:///./Variable.js","webpack:///./util/lang.js","webpack:///./Renderer.js","webpack:///./react.js","webpack:///./operators.js","webpack:///./Copy.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","Element","Variable","react","Renderer","operators","Copy","main","Object","create","VMap","VArray","VPromised","all","spawn","func","valueOf","assign","apply","undefined","lang","booleanStyle","options","element","value","key","style","defaultStyle","directStyle","layoutChildren","parent","children","container","prepend","fragment","length","doc","createDocumentFragment","i","l","childNode","child","currentParent","appendChild","isContentNode","contentNode","notifies","variableAsContent","Array","nodeType","Error","createTextNode","insertBefore","firstChild","content","textNode","TextRenderer","variable","bidirectionalHandler","InputPropertyRenderer","name","inputs","tagName","bindChanges","prototype","renderSelectValueUpdate","type","isNaN","noop","applyAttribute","AttributeRenderer","setAttribute","applySubProperties","renderer","SubPropertyRenderer","compose","PropertyRenderer","arguments","renderUpdate","subKey","subValue","assignProperties","properties","styleDefinition","styleDefinitions","propertyHandlers","StyleRenderer","slice","addEventListener","buildContent","each","defineHasOwn","ItemClass","getCollectionOf","Item","hasOwn","itemVariable","from","_item","ListRenderer","forEach","item","childElement","buildInputContent","conversion","nextTurn","inputEvents","event","result","put","Context","deny","parseFloat","inputType","inputProperty","date","datetime","time","applyToClass","applyOnCreate","_applyOnCreate","classHandlers","TypeError","getApplySet","Class","hasOwnProperty","getForClass","parentApplySet","getPrototypeOf","keys","getOwnPropertyNames","isGenerator","defineProperty","toLowerCase","renderDescriptor","renderMethod","map","WeakMap","get","has","set","makeElementConstructor","selector","constructor","withProperties","forTarget","property","propertyForElement","superConstructor","selectorMatch","match","SELECTOR_REGEX","operator","className","remaining","createElement","presumptiveParentMap","setPrototypeOf","ElementApplyOnCreate","argument","created","ready","append","registerTag","registerElement","getConstructor","tags","setTag","generate","elements","elementName","ElementClass","generateInputs","HTMLInputElement","target","From","Target","createInstance","instanceMap","elementMap","ownedClasses","parentNode","ownedInstances","instance","subject","ThisElementVariable","_Variable","variableProperties","alkaliRenderers","elementOverlay","cleanup","renderers","stop","needsRestart","restart","elementAttached","attached","elementDetached","detached","firstVisit","node","state","__alkaliAttached__","action","docBody","contains","knownElementProperties","newValue","definition","ClassNameRenderer","ElementRenderer","currentClassName","changingClassName","removed","replace","document","tag","INPUT","TEXTAREA","display","visibility","color","opacity","zoom","minZoom","maxZoom","fontWeight","position","textDecoration","base","proto","__proto__","classes","flag","class","for","role","render","GeneratorVariable","bind","valueAsNumber","valueAsDate","checked","dataset","attributes","elment","styleObjectHandler","radios","querySelectorAll","radio","dispatchEvent","Event","HTMLElement","within","aliases","Anchor","Paragraph","Textarea","DList","UList","OList","ListItem","Text","TextInput","TableRow","TableCell","TableHeaderCell","TableHeader","TableBody","alias","to","refresh","moveLiveElementsEnabled","extend","ExtendedElement","descriptor","getOwnPropertyDescriptor","MutationObserver","body","lifeStates","nodes","observer","mutations","il","mutation","j","jl","nodeIteration","k","kl","baseNode","currentNode","nextNode","nextSibling","observe","childList","subtree","copy","specify","distinctive","generics","push","distinctSubject","subjectMap","specifiedInstance","defaultInstance","getContextualized","_contextMap","context","matches","merge","childContext","getDistinctElement","when","callback","then","NotifyingContext","listener","whenAll","promiseInvolved","registerListener","listeners","propertyListenersMap","listenerId","autoObserveObjects","listeningToObject","deregisterListener","index","splice","RefreshEvent","visited","Set","PropertyChangeEvent","childEvent","AddEvent","args","DeleteEvent","forPropertyNotifyingValues","returnedVariable","hasChildNotifiers","subProperties","_properties","arrayToModify","_willModify","cachedValue","array","updateVersion","results","cachedVersion","version","insertedAt","added","startingIndex","arrayLength","addedCount","arrayPosition","updated","modifier","removedAt","removalCount","previousIndex","oldValue","iterateMethod","method","IterativeMethod","addFlag","functionValue","objectUpdated","object","_propertyChange","Composite","keyMapping","valueArray","resultObject","createForInstance","generalizeClass","prototypeNames","getGeneralizedDescriptor","generalizeMethod","instanceForContext","noChange","RequestChange","RequestSet","nextId","freeze","propertyName","contextFromCache","newContext","contextualize","parentContext","contextualized","contextMap","addInput","inputVariable","nextProperty","VariablePrototype","_currentValue","valueContext","gotValue","getValue","previousNotifyingValue","ownObject","stopNotifies","isMap","Map","propertyVariable","Property","ContextualizedVariable","defaultContext","onPropertyChange","eachKey","Call","forDependencies","hasNotifyingChild","init","dependency","handles","remove","computedVariable","getVersion","Math","max","getSubject","selectVariable","getUpdates","since","updates","nextUpdateMap","updateEvent","by","add","contextualInstance","dependent","fixed","collection","invalidate","subscribe","updateQueued","next","updateReceiver","unsubscribe","size","__debug","console","log","stack","setValue","_changeValue","undefine","proxy","proxiedVariable","thisVariable","error","complete","onValue","toJSON","toString","callbackOrItemClass","callbackOrContext","transformFunction","reverse","schema","validate","valid","isValid","validation","Validating","getId","observeObject","observerCount","events","el","addKey","done","deliverChanges","collectionOf","_sN","_debug","unshift","pop","shift","Symbol","iterator","Caching","withComputedValue","computedValue","transformContext","contextualizedVariable","newVersion","gotValueAndListen","propertyContext","parentUpdated","parentSchemaProperties","argumentName","resolved","getArguments","transform","invoke","argsVersion","execute","originalValue","observeArguments","handlesVariables","handlesPromises","input","setReverse","generic","source","notify","propagatedEvent","filterUpdated","indexOf","filter","mapUpdated","generator","resuming","lastValue","generatorIterator","isThrowing","stepReturn","nextVariable","description","_collectionOf","_collection","Collection","generalize","Function","ExtendedVariable","Base","_defaultInstance","feature","hasFeatures","diff","previous","current","queued","toJSONHidden","displayName","queuedListeners","requestAnimationFrame","e","promise","Promise","keyFlag","currentValue","targetAncestor","previousSet","previousGet","enumerable","timerStarted","setInterval","watchedObjects","watchedCopies","unobserve","Hidden","processAnimationFrame","toRender","setTimeout","resolve","reject","resolution","finished","errorResolution","isResolved","queue","errback","handle","newError","values","mapProperty","intermediary","errorHandler","onResolve","onError","onEach","readyInputs","lastPromiseResult","previousPromiseResult","div","update","updateRendering","shouldRender","alwaysUpdate","updateOnStart","ContentRenderer","onElementRemoval","invalidatedElements","invalidated","contextMatches","invalidateElement","invalidatedParts","queueTask","processQueue","updateElement","always","thisElement","renderersOnShow","addElement","omitValueOf","started","renderLoading","eventualValue","innerHTML","builtList","replaceChild","childNodes","nodeValue","eachItem","nextChild","childElements","removeChild","onShowElement","shownElement","getElementsByClassName","includingTop","onlyChildren","getElementsByTagName","preserveObjects","_getAsObject","ObjectTransform","prop","directPropertyValue","cond","test","consequent","alternate","choose","fcall","mcall","ncall","concat","obj","getOperatingFunction","expression","operatingFunctions","precedence","forward","reverseA","reverseB","addFlags","operatorHandler","infix","output","a","b","deepCopy","derivativeMap","copiedFrom","isDirty","derivative","thisValue","getCopyOf","save","original","newCopiedFrom","onSave","revert"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"alkali\"] = factory();\n\telse\n\t\troot[\"alkali\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"alkali\"] = factory();\n\telse\n\t\troot[\"alkali\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/// <reference path=\"./index.d.ts\" />\r\n\tif (true) {\r\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1), __webpack_require__(2), __webpack_require__(5), __webpack_require__(4), __webpack_require__(6), __webpack_require__(7)], __WEBPACK_AMD_DEFINE_RESULT__ = function(Element, Variable, react, Renderer, operators, Copy) {\r\n\t\tvar main = Object.create(Element)\r\n\t\tmain.Copy = Copy\r\n\t\tmain.Element = Element\r\n\t\tmain.Variable = Variable\r\n\t\tmain.VMap = Variable.VMap\r\n\t\tmain.VArray = Variable.VArray\r\n\t\tmain.VPromised = Variable.VPromised\r\n\t\tmain.all = Variable.all\r\n\t\tmain.react = react\r\n\t\tmain.spawn = function(func) {\r\n\t\t\treturn react(func).valueOf()\r\n\t\t}\r\n\t\tmain.Renderer = Renderer\r\n\t\tObject.assign(main, Renderer)\r\n\t\tObject.assign(main, operators)\r\n\t\treturn main\r\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\r\n\t} else if (typeof module === 'object' && module.exports) {\r\n\t\t// delegate to the built UMD file, if loaded in node\r\n\t\tmodule.exports = (require)('./dist/index')\r\n\t}\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(4), __webpack_require__(3)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Variable, Renderer, lang) {\r\n\t\tvar knownElementProperties = {};\r\n\t\t['textContent', 'innerHTML', 'title', 'href', 'value', 'valueAsNumber', 'role', 'render'].forEach(function(property) {\r\n\t\t\tknownElementProperties[property] = true\r\n\t\t})\r\n\t\r\n\t\tvar SELECTOR_REGEX = /(\\.|#)([-\\w]+)(.+)?/\r\n\t\tvar isGenerator = lang.isGenerator\r\n\t\tvar Context = Variable.Context\r\n\t\tvar PropertyRenderer = Renderer.PropertyRenderer\r\n\t\tvar InputPropertyRenderer = Renderer.InputPropertyRenderer\r\n\t\tvar AttributeRenderer = Renderer.AttributeRenderer\r\n\t\tvar StyleRenderer = lang.compose(Renderer.StyleRenderer, function StyleRenderer() {\r\n\t\t\tRenderer.StyleRenderer.apply(this, arguments)\r\n\t\t}, {\r\n\t\t\trenderUpdate: function(newValue, element) {\r\n\t\t\t\tvar definition = styleDefinitions[this.name]\r\n\t\t\t\tif (definition) {\r\n\t\t\t\t\tdefinition(element, newValue, this.name)\r\n\t\t\t\t} else {\r\n\t\t\t\t\telement.style[this.name] = newValue\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\tvar ClassNameRenderer = lang.compose(Renderer.ElementRenderer, function ClassNameRenderer(options) {\r\n\t\t\tthis.className = options.className\r\n\t\t\tRenderer.apply(this, arguments)\r\n\t\t}, {\r\n\t\t\trenderUpdate: function(newValue, element) {\r\n\t\t\t\tvar currentClassName = element.className\r\n\t\t\t\tvar changingClassName = this.className\r\n\t\t\t\t// remove the className (needed for addition or removal)\r\n\t\t\t\t// see http://jsperf.com/remove-class-name-algorithm/2 for some tests on this\r\n\t\t\t\tvar removed = currentClassName && (' ' + currentClassName + ' ').replace(' ' + changingClassName + ' ', ' ')\r\n\t\t\t\tif (newValue) {\r\n\t\t\t\t\t// addition, add the className\r\n\t\t\t\t\tchangingClassName = currentClassName ? (removed + changingClassName).slice(1) : changingClassName;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// we already have removed the class, just need to trim\r\n\t\t\t\t\tchangingClassName = removed.slice(1, removed.length - 1)\r\n\t\t\t\t}\r\n\t\t\t\t// only assign if it changed, this can save a lot of time\r\n\t\t\t\tif (changingClassName != currentClassName) {\r\n\t\t\t\t\telement.className = changingClassName\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\t// TODO: check for renderContent with text updater\r\n\t\tvar TextRenderer = Renderer.TextRenderer\r\n\t\tvar ListRenderer = Renderer.ListRenderer\r\n\t\t\r\n\t\tvar toAddToElementPrototypes = []\r\n\t\tvar createdBaseElements = []\r\n\t\tvar doc = typeof document !== 'undefined' ? document : {\r\n\t\t\tcreateElement: function(tag) {\r\n\t\t\t\treturn {}\r\n\t\t\t},\r\n\t\t\taddEventListener: function() {\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tvar testStyle = doc.createElement('div').style\r\n\t\tvar childTagForParent = {\r\n\t\t\tTABLE: ['tr','td'],\r\n\t\t\tTBODY: ['tr','td'],\r\n\t\t\tTR: 'td',\r\n\t\t\tUL: 'li',\r\n\t\t\tOL: 'li',\r\n\t\t\tSELECT: 'option'\r\n\t\t}\r\n\t\tvar inputs = {\r\n\t\t\tINPUT: 1,\r\n\t\t\tTEXTAREA: 1\r\n\t\t\t// SELECT: 1, we exclude this, so the default \"content\" of the element can be the options\r\n\t\t}\r\n\t\r\n\t\tfunction booleanStyle(options) {\r\n\t\t\treturn function(element, value, key) {\r\n\t\t\t\tif (typeof value === 'boolean') {\r\n\t\t\t\t\t// has a boolean conversion\r\n\t\t\t\t\tvalue = options[value ? 0 : 1]\r\n\t\t\t\t}\r\n\t\t\t\telement.style[key] = value\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction defaultStyle(element, value, key) {\r\n\t\t\tif (typeof value === 'number') {\r\n\t\t\t\tvalue = value + 'px'\r\n\t\t\t}\r\n\t\t\telement.style[key] = value\r\n\t\t}\r\n\t\tfunction directStyle(element, value, key) {\r\n\t\t\telement.style[key] = value\r\n\t\t}\r\n\t\r\n\t\tvar styleDefinitions = {\r\n\t\t\tdisplay: booleanStyle(['', 'none']),\r\n\t\t\tvisibility: booleanStyle(['visible', 'hidden']),\r\n\t\t\tcolor: directStyle,\r\n\t\t\topacity: directStyle,\r\n\t\t\tzoom: directStyle,\r\n\t\t\tminZoom: directStyle,\r\n\t\t\tmaxZoom: directStyle,\r\n\t\t\tfontWeight: directStyle,\r\n\t\t\tposition: booleanStyle(['absolute', '']),\r\n\t\t\ttextDecoration: booleanStyle(['underline', '']),\r\n\t\t\tfontWeight: booleanStyle(['bold', 'normal'])\r\n\t\t}\r\n\t\t;[\"alignContent\",\"alignItems\",\"alignSelf\",\"animation\",\"animationDelay\",\"animationDirection\",\"animationDuration\",\"animationFillMode\",\"animationIterationCount\",\"animationName\",\"animationPlayState\",\"animationTimingFunction\",\"backfaceVisibility\",\"background\",\"backgroundAttachment\",\"backgroundBlendMode\",\"backgroundClip\",\"backgroundColor\",\"backgroundImage\",\"backgroundOrigin\",\"backgroundPosition\",\"backgroundPositionX\",\"backgroundPositionY\",\"backgroundRepeat\",\"backgroundRepeatX\",\"backgroundRepeatY\",\"backgroundSize\",\"baselineShift\",\"border\",\"borderBottom\",\"borderBottomColor\",\"borderBottomLeftRadius\",\"borderBottomRightRadius\",\"borderBottomStyle\",\"borderBottomWidth\",\"borderCollapse\",\"borderColor\",\"borderImage\",\"borderImageOutset\",\"borderImageRepeat\",\"borderImageSlice\",\"borderImageSource\",\"borderImageWidth\",\"borderLeft\",\"borderLeftColor\",\"borderLeftStyle\",\"borderLeftWidth\",\"borderRadius\",\"borderRight\",\"borderRightColor\",\"borderRightStyle\",\"borderRightWidth\",\"borderSpacing\",\"borderStyle\",\"borderTop\",\"borderTopColor\",\"borderTopLeftRadius\",\"borderTopRightRadius\",\"borderTopStyle\",\"borderTopWidth\",\"borderWidth\",\"bottom\",\"boxShadow\",\"boxSizing\",\"bufferedRendering\",\"captionSide\",\"clear\",\"clip\",\"clipPath\",\"clipRule\",\"color\",\"colorInterpolation\",\"colorInterpolationFilters\",\"colorRendering\",\"counterIncrement\",\"counterReset\",\"cursor\",\"direction\",\"display\",\"emptyCells\",\"fill\",\"fillOpacity\",\"fillRule\",\"filter\",\"flex\",\"flexBasis\",\"flexDirection\",\"flexFlow\",\"flexGrow\",\"flexShrink\",\"flexWrap\",\"float\",\"floodColor\",\"floodOpacity\",\"font\",\"fontFamily\",\"fontFeatureSettings\",\"fontKerning\",\"fontSize\",\"fontStretch\",\"fontStyle\",\"fontVariant\",\"fontVariantLigatures\",\"fontWeight\",\"height\",\"imageRendering\",\"isolation\",\"justifyContent\",\"left\",\"letterSpacing\",\"lightingColor\",\"lineHeight\",\"listStyle\",\"listStyleImage\",\"listStylePosition\",\"listStyleType\",\"margin\",\"marginBottom\",\"marginLeft\",\"marginRight\",\"marginTop\",\"marker\",\"markerEnd\",\"markerMid\",\"markerStart\",\"mask\",\"maskType\",\"maxHeight\",\"maxWidth\",\"maxZoom\",\"minHeight\",\"minWidth\",\"minZoom\",\"mixBlendMode\",\"motion\",\"motionOffset\",\"motionPath\",\"motionRotation\",\"objectFit\",\"objectPosition\",\"opacity\",\"order\",\"orientation\",\"orphans\",\"outline\",\"outlineColor\",\"outlineOffset\",\"outlineStyle\",\"outlineWidth\",\"overflow\",\"overflowWrap\",\"overflowX\",\"overflowY\",\"padding\",\"paddingBottom\",\"paddingLeft\",\"paddingRight\",\"paddingTop\",\"page\",\"pageBreakAfter\",\"pageBreakBefore\",\"pageBreakInside\",\"paintOrder\",\"perspective\",\"perspectiveOrigin\",\"pointerEvents\",\"position\",\"quotes\",\"resize\",\"right\",\"shapeImageThreshold\",\"shapeMargin\",\"shapeOutside\",\"shapeRendering\",\"size\",\"speak\",\"src\",\"stopColor\",\"stopOpacity\",\"stroke\",\"strokeDasharray\",\"strokeDashoffset\",\"strokeLinecap\",\"strokeLinejoin\",\"strokeMiterlimit\",\"strokeOpacity\",\"strokeWidth\",\"tabSize\",\"tableLayout\",\"textAlign\",\"textAlignLast\",\"textAnchor\",\"textCombineUpright\",\"textDecoration\",\"textIndent\",\"textOrientation\",\"textOverflow\",\"textRendering\",\"textShadow\",\"textTransform\",\"top\",\"touchAction\",\"transform\",\"transformOrigin\",\"transformStyle\",\"transition\",\"transitionDelay\",\"transitionDuration\",\"transitionProperty\",\"transitionTimingFunction\",\"unicodeBidi\",\"unicodeRange\",\"userZoom\",\"vectorEffect\",\"verticalAlign\",\"visibility\",\"whiteSpace\",\"widows\",\"width\",\"willChange\",\"wordBreak\",\"wordSpacing\",\"wordWrap\",\"writingMode\",\"zIndex\",\"zoom\"].forEach(function(property) {\r\n\t\t\tstyleDefinitions[property] = styleDefinitions[property] || defaultStyle\r\n\t\t})\r\n\t\tvar styleSheet\r\n\t\tvar presumptiveParentMap = new WeakMap()\r\n\t\r\n\t\tvar setPrototypeOf = Object.setPrototypeOf || (function(base, proto) { base.__proto__ = proto})\r\n\t\tvar getPrototypeOf = Object.getPrototypeOf || (function(base) { return base.__proto__ })\r\n\t\tfunction createCssRule(selector) {\r\n\t\t\tif (!styleSheet) {\r\n\t\t\t\tvar styleSheetElement = doc.createElement(\"style\")\r\n\t\t\t\tstyleSheetElement.setAttribute(\"type\", \"text/css\")\r\n\t//\t\t\tstyleSheet.appendChild(doc.createTextNode(css))\r\n\t\t\t\tdoc.head.insertBefore(styleSheetElement, doc.head.firstChild)\r\n\t\t\t\tstyleSheet = styleSheetElement.sheet\r\n\t\t\t}\r\n\t\t\tvar cssRules = styleSheet.cssRules || styleSheet.rules\r\n\t\t\treturn cssRules[styleSheet.addRule(selector, ' ', cssRules.length)]\r\n\t\t}\r\n\t\tvar invalidatedElements = new WeakMap(null, 'invalidated')\r\n\t\tvar queued\r\n\t\r\n\t\tvar toRender = []\r\n\t\tfunction flatten(target, part) {\r\n\t\t\tvar base = target.base\r\n\t\t\tif (base) {\r\n\t\t\t\tvar basePart = base[part]\r\n\t\t\t\tif (basePart) {\r\n\t\t\t\t\ttarget[part] || target[part]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction layoutChildren(parent, children, container, prepend) {\r\n\t\t\tvar fragment = (children.length > 3 || prepend) ? doc.createDocumentFragment() : parent\r\n\t\t\tfor(var i = 0, l = children.length; i < l; i++) {\r\n\t\t\t\tvar child = children[i]\r\n\t\t\t\tvar childNode\r\n\t\t\t\tif (child != null) { // we just skip nulls and undefined, helps make it easier to write conditional element logic\r\n\t\t\t\t\tif (child.create) {\r\n\t\t\t\t\t\t// an element constructor\r\n\t\t\t\t\t\tcurrentParent = parent\r\n\t\t\t\t\t\tchildNode = child.create()\r\n\t\t\t\t\t\tfragment.appendChild(childNode)\r\n\t\t\t\t\t\tif (child.isContentNode) {\r\n\t\t\t\t\t\t\tcontainer.contentNode = childNode\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (child.notifies) {\r\n\t\t\t\t\t\t// a variable\r\n\t\t\t\t\t\tfragment.appendChild(childNode = variableAsContent(parent, child))\r\n\t\t\t\t\t} else if (typeof child == 'object') {\r\n\t\t\t\t\t\tif (child instanceof Array) {\r\n\t\t\t\t\t\t\t// array of sub-children\r\n\t\t\t\t\t\t\tcontainer = container || parent\r\n\t\t\t\t\t\t\tchildNode = childNode || parent\r\n\t\t\t\t\t\t\tlayoutChildren(childNode.contentNode || childNode, child, container)\r\n\t\t\t\t\t\t} else if (child.nodeType) {\r\n\t\t\t\t\t\t\t// an element itself\r\n\t\t\t\t\t\t\tfragment.appendChild(childNode = child)\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// TODO: apply properties to last child, but with binding to the parent (for events)\r\n\t\t\t\t\t\t\tthrow new Error('Unknown child type ' + child)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// a primitive value\r\n\t\t\t\t\t\tchildNode = doc.createTextNode(child)\r\n\t\t\t\t\t\tfragment.appendChild(childNode)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (fragment != parent) {\r\n\t\t\t\tif (prepend) {\r\n\t\t\t\t\tparent.insertBefore(fragment, parent.firstChild)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tparent.appendChild(fragment)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn childNode\r\n\t\t}\r\n\t\tfunction variableAsContent(parent, content) {\r\n\t\t\tif (content == null) {\r\n\t\t\t\treturn doc.createTextNode('')\r\n\t\t\t}\r\n\t\t\tvar textNode\r\n\t\t\tif (content.notifies) {\r\n\t\t\t\ttextNode = doc.createTextNode('')\r\n\t\t\t\tnew TextRenderer({\r\n\t\t\t\t\telement: parent,\r\n\t\t\t\t\ttextNode: textNode,\r\n\t\t\t\t\tvariable: content\r\n\t\t\t\t})\r\n\t\t\t} else {\r\n\t\t\t\ttextNode = doc.createTextNode(content)\r\n\t\t\t}\r\n\t\t\treturn textNode\r\n\t\t}\r\n\t\r\n\t\tfunction bidirectionalHandler(element, value, key) {\r\n\t\t\tif (value && value.notifies) {\r\n\t\t\t\tnew InputPropertyRenderer({\r\n\t\t\t\t\tname: key,\r\n\t\t\t\t\tvariable: value,\r\n\t\t\t\t\telement: element\r\n\t\t\t\t})\r\n\t\t\t\tif (inputs[element.tagName] || element.tagName === 'SELECT') {\r\n\t\t\t\t\tbindChanges(element, value, key)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (element.tagName === 'SELECT' && key === 'value') {\r\n\t\t\t\t\t// use the deferred <select> value assignment\r\n\t\t\t\t\tInputPropertyRenderer.prototype.renderSelectValueUpdate(value, element)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (element.type === 'number') {\r\n\t\t\t\t\t\tif (isNaN(value)) {\r\n\t\t\t\t\t\t\tvalue = ''\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telement[key] = value\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction noop() {}\r\n\t\tvar propertyHandlers = {\r\n\t\t\tcontent: noop, // content and children have special handling in create\r\n\t\t\tchildren: noop,\r\n\t\t\ttagName: noop,\r\n\t\t\teach: noop, // just used by content, doesn't need to be recorded on the element\r\n\t\t\tclasses: function(element, classes) {\r\n\t\t\t\tif (!(classes.length > -1)) {\r\n\t\t\t\t\t// index the classes, if necessary\r\n\t\t\t\t\tvar i = 0\r\n\t\t\t\t\tfor (var key in classes) {\r\n\t\t\t\t\t\tif (!classes[i]) {\r\n\t\t\t\t\t\t\tclasses[i] = key\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ti++\r\n\t\t\t\t\t}\r\n\t\t\t\t\tclasses.length = i\r\n\t\t\t\t}\r\n\t\t\t\tfor (var i = 0, l = classes.length; i < l; i++) {\r\n\t\t\t\t\t// find each class name\r\n\t\t\t\t\tvar className = classes[i]\r\n\t\t\t\t\tvar flag = classes[className]\r\n\t\t\t\t\tif (flag && flag.notifies) {\r\n\t\t\t\t\t\t// if it is a variable, we react to it\r\n\t\t\t\t\t\tnew ClassNameRenderer({\r\n\t\t\t\t\t\t\telement: element,\r\n\t\t\t\t\t\t\tclassName: className,\r\n\t\t\t\t\t\t\tvariable: flag\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t} else if (flag || flag === undefined) {\r\n\t\t\t\t\t\telement.className += ' ' + className\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tclass: applyAttribute,\r\n\t\t\tfor: applyAttribute,\r\n\t\t\trole: applyAttribute,\r\n\t\t\trender: function(element, value, key, properties) {\r\n\t\t\t\t// TODO: This doesn't need to be a property updater\r\n\t\t\t\t// we should also verify it is a generator\r\n\t\t\t\t// and maybe, at some point, find an optimization to eliminate the bind()\r\n\t\t\t\tnew PropertyRenderer({\r\n\t\t\t\t\tname: key,\r\n\t\t\t\t\tvariable: new Variable.GeneratorVariable(value.bind(element, properties)),\r\n\t\t\t\t\telement: element\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tvalue: bidirectionalHandler,\r\n\t\t\tvalueAsNumber: bidirectionalHandler,\r\n\t\t\tvalueAsDate: bidirectionalHandler,\r\n\t\t\tchecked: bidirectionalHandler,\r\n\t\t\tdataset: applySubProperties(function(newValue, element, key) {\r\n\t\t\t\telement.dataset[key || this.name] = newValue\r\n\t\t\t}),\r\n\t\t\tattributes: applySubProperties(function(newValue, element, key) {\r\n\t\t\t\telement.setAttribute(key || this.name, newValue)\r\n\t\t\t}),\r\n\t\t\tstyle: function(element, value, key) {\r\n\t\t\t\tif (typeof value === 'string') {\r\n\t\t\t\t\telement.setAttribute('style', value)\r\n\t\t\t\t} else if (value && value.notifies) {\r\n\t\t\t\t\tnew AttributeRenderer({\r\n\t\t\t\t\t\tname: 'style',\r\n\t\t\t\t\t\tvariable: value,\r\n\t\t\t\t\t\telment: element\r\n\t\t\t\t\t})\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstyleObjectHandler(element, value, key)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction applyAttribute(element, value, key) {\r\n\t\t\tif (value && value.notifies) {\r\n\t\t\t\tnew AttributeRenderer({\r\n\t\t\t\t\tname: key,\r\n\t\t\t\t\tvariable: value,\r\n\t\t\t\t\telement: element\r\n\t\t\t\t})\r\n\t\t\t} else {\r\n\t\t\t\telement.setAttribute(key, value)\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tvar styleObjectHandler = applySubProperties(function(newValue, element, key) {\r\n\t\t\telement.style[key || this.name] = newValue\r\n\t\t})\r\n\t\r\n\t\tfunction applySubProperties(renderer) {\r\n\t\t\tvar SubPropertyRenderer = lang.compose(PropertyRenderer, function SubPropertyRenderer(options) {\r\n\t\t\t\tPropertyRenderer.apply(this, arguments)\r\n\t\t\t}, {\r\n\t\t\t\trenderUpdate: renderer\r\n\t\t\t})\t\r\n\t\t\treturn function(element, value, key) {\r\n\t\t\t\tvar target = element[key]\r\n\t\t\t\tfor (var subKey in value) {\r\n\t\t\t\t\tvar subValue = value[subKey]\r\n\t\t\t\t\tif (subValue && subValue.notifies) {\r\n\t\t\t\t\t\tnew SubPropertyRenderer({\r\n\t\t\t\t\t\t\tname: subKey,\r\n\t\t\t\t\t\t\tvariable: subValue,\r\n\t\t\t\t\t\t\telement: element\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\trenderer(subValue, element, subKey)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction assignProperties(element, properties) {\r\n\t\t\tfor (var key in properties) {\r\n\t\t\t\tvar value = properties[key]\r\n\t\t\t\tvar styleDefinition = styleDefinitions[key]\r\n\t\t\t\tif (propertyHandlers[key]) {\r\n\t\t\t\t\tpropertyHandlers[key](element, value, key, properties)\r\n\t\t\t\t} else if ((styleDefinition = styleDefinitions[key]) && element[key] === undefined) {\r\n\t\t\t\t\tif (value && value.notifies) {\r\n\t\t\t\t\t\tnew StyleRenderer({\r\n\t\t\t\t\t\t\tname: key,\r\n\t\t\t\t\t\t\tvariable: value,\r\n\t\t\t\t\t\t\telement: element\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tstyleDefinition(element, value, key)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (value && value.notifies) {\r\n\t\t\t\t\tnew PropertyRenderer({\r\n\t\t\t\t\t\tname: key,\r\n\t\t\t\t\t\tvariable: value,\r\n\t\t\t\t\t\telement: element\r\n\t\t\t\t\t})\r\n\t\t\t\t} else if (typeof value === 'function' && key.slice(0, 2) === 'on') {\r\n\t\t\t\t\telement.addEventListener(key.slice(2), value)\r\n\t\t\t\t} else {\r\n\t\t\t\t\telement[key] = value\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction applySelector(element, selector) {\r\n\t\t\tselector.replace(/(\\.|#)?(\\w+)/g, function(t, operator, name) {\r\n\t\t\t\tif (operator == '.') {\r\n\t\t\t\t\telement._class = (element._class ? element._class + ' ' : '') + name\r\n\t\t\t\t} else if (operator == '#') {\r\n\t\t\t\t\telement._id = name\r\n\t\t\t\t} else {\r\n\t\t\t\t\telement._tag = name\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t}\r\n\t\r\n\t\tfunction buildContent(element, content, key, properties) {\r\n\t\t\tvar each = element.each || properties.each\r\n\t\t\tif (each && content) {\r\n\t\t\t\t// render as list\r\n\t\t\t\tif (each.create) {\r\n\t\t\t\t\teach.defineHasOwn = function () {\r\n\t\t\t\t\t\tvar ItemClass = content.getCollectionOf && content.getCollectionOf() || Item\r\n\t\t\t\t\t\thasOwn(each, ItemClass, function (element) {\r\n\t\t\t\t\t\t\tvar itemVariable = ItemClass.from(element._item)\r\n\t\t\t\t\t\t\treturn itemVariable\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (content.notifies) {\r\n\t\t\t\t\tnew ListRenderer({\r\n\t\t\t\t\t\teach: each,\r\n\t\t\t\t\t\tvariable: content,\r\n\t\t\t\t\t\telement: element\r\n\t\t\t\t\t})\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar fragment = doc.createDocumentFragment()\r\n\t\t\t\t\tif (each.defineHasOwn) {\r\n\t\t\t\t\t\teach.defineHasOwn()\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcontent.forEach(function(item) {\r\n\t\t\t\t\t\tif (each.create) {\r\n\t\t\t\t\t\t\tchildElement = each.create({parent: element, _item: item}) // TODO: make a faster object here potentially\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tchildElement = each(item, element)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfragment.appendChild(childElement)\r\n\t\t\t\t\t})\r\n\t\t\t\t\telement.appendChild(fragment)\r\n\t\t\t\t}\r\n\t\t\t} else if (inputs[element.tagName]) {\r\n\t\t\t\t// render into input\r\n\t\t\t\tbuildInputContent(element, content)\r\n\t\t\t} else if (content instanceof Array) {\r\n\t\t\t\t// treat array as children (potentially of the content node)\r\n\t\t\t\telement = element.contentNode || element\r\n\t\t\t\tlayoutChildren(element, content, element)\r\n\t\t\t} else {\r\n\t\t\t\t// render as string\r\n\t\t\t\telement.appendChild(variableAsContent(element, content))\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction bindChanges(element, variable, key, conversion) {\r\n\t\t\tlang.nextTurn(function() { // wait for next turn in case inputChanges isn't set yet\r\n\t\t\t\tvar inputEvents = element.inputEvents || ['change', 'alkali-change']\r\n\t\t\t\tfor (var i = 0, l = inputEvents.length; i < l; i++) {\r\n\t\t\t\t\telement.addEventListener(inputEvents[i], function (event) {\r\n\t\t\t\t\t\tvar value = element[key]\r\n\t\t\t\t\t\tvar result = variable.put(conversion ? conversion(value, element) : value, new Context(element))\r\n\t\t\t\t\t\tif (result === Variable.deny) {\r\n\t\t\t\t\t\t\tthrow new Error('Variable change denied')\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t}\r\n\t\r\n\t\tdoc.addEventListener('click', function(event) {\r\n\t\t\tvar target = event.target\r\n\t\t\tif (target.type === 'radio') {\r\n\t\t\t\tvar radios = doc.querySelectorAll('input[type=radio]')\r\n\t\t\t\tfor (var i = 0, l = radios.length; i < l; i++) {\r\n\t\t\t\t\tvar radio = radios[i]\r\n\t\t\t\t\tif (radio.name === target.name && radio !== target) {\r\n\t\t\t\t\t\tradio.dispatchEvent(new Event('alkali-change', {}))\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\tfunction conversion(value, element) {\r\n\t\t\tif (element.type == 'number') {\r\n\t\t\t\treturn parseFloat(value)\r\n\t\t\t}\r\n\t\t\treturn value\r\n\t\t}\r\n\t\r\n\t\tfunction buildInputContent(element, content) {\r\n\t\t\tvar inputType = element.type\r\n\t\t\tvar inputProperty = inputType in {date: 1, datetime: 1, time: 1} ?\r\n\t\t\t\t\t'valueAsDate' : (inputType === 'checkbox' || inputType === 'radio') ?\r\n\t\t\t\t\t\t'checked' : 'value'\r\n\t\r\n\t\t\tif (content && content.notifies) {\r\n\t\t\t\t// a variable, respond to changes\r\n\t\t\t\tnew InputPropertyRenderer({\r\n\t\t\t\t\tvariable: content,\r\n\t\t\t\t\tname: inputProperty,\r\n\t\t\t\t\telement: element\r\n\t\t\t\t})\r\n\t\t\t\t// and bind the other way as well, updating the variable in response to input changes\r\n\t\t\t\tbindChanges(element, content, inputProperty, conversion)\r\n\t\t\t} else {\r\n\t\t\t\t// primitive\r\n\t\t\t\telement[inputProperty] = content\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar classHandlers = {\r\n\t\t\thasOwn: function(Element, value) {\r\n\t\t\t\thasOwn(Element, value)\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction applyToClass(value, Element) {\r\n\t\t\tvar applyOnCreate = Element._applyOnCreate\r\n\t\t\tvar prototype = Element.prototype\r\n\t\t\tif (value && typeof value === 'object') {\r\n\t\t\t\tif (value instanceof Array || value.notifies) {\r\n\t\t\t\t\tapplyOnCreate.content = value\r\n\t\t\t\t} else {\r\n\t\t\t\t\tfor (var key in value) {\r\n\t\t\t\t\t// TODO: eventually we want to be able to set these as rules statically per element\r\n\t\t\t\t\t/*if (styleDefinitions[key]) {\r\n\t\t\t\t\t\tvar styles = Element.styles || (Element.styles = [])\r\n\t\t\t\t\t\tstyles.push(key)\r\n\t\t\t\t\t\tstyles[key] = descriptor.value\r\n\t\t\t\t\t} else {*/\r\n\t\t\t\t\t\tif (classHandlers[key]) {\r\n\t\t\t\t\t\t\thasOwn(Element, value[key])\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// TODO: do deep merging of styles and classes, but not variables\r\n\t\t\t\t\t\t\tapplyOnCreate[key] = value[key]\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else if (typeof value === 'function' && !value.for) {\r\n\t\t\t\tthrow new TypeError('Function as argument not supported')\r\n\t\t\t} else {\r\n\t\t\t\tapplyOnCreate.content = value\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction getApplySet(Class) {\r\n\t\t\tif (Class.hasOwnProperty('_applyOnCreate')) {\r\n\t\t\t\treturn Class._applyOnCreate\r\n\t\t\t}\r\n\t\t\t// this means we didn't extend and evaluate the prototype yet\r\n\t\t\tif (Class.getForClass) {\r\n\t\t\t\t// we are extending an alkali constructor\r\n\t\t\t\t// if this class is inheriting from an alkali constructor, work our way up the chain\r\n\t\t\t\tapplyOnCreate = Class._applyOnCreate = {}\r\n\t\t\t\tvar parentApplySet = getApplySet(getPrototypeOf(Class))\r\n\t\t\t\tfor (var key in parentApplySet) {\r\n\t\t\t\t\tapplyOnCreate[key] = parentApplySet[key]\r\n\t\t\t\t}\r\n\t\t\t\t// we need to check the prototype for event handlers\r\n\t\t\t\tvar prototype = Class.prototype\r\n\t\t\t\tvar keys = Object.getOwnPropertyNames(prototype)\r\n\t\t\t\tfor (var i = 0, l = keys.length; i < l; i++) {\r\n\t\t\t\t\tvar key = keys[i]\r\n\t\t\t\t\tif (key.slice(0, 2) === 'on' || (key === 'render' && isGenerator(prototype[key]))) {\r\n\t\t\t\t\t\tapplyOnCreate[key] = prototype[key]\r\n\t\t\t\t\t} else if (key.slice(0, 6) === 'render') {\r\n\t\t\t\t\t\tObject.defineProperty(prototype, key[6].toLowerCase() + key.slice(7), renderDescriptor(key))\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn applyOnCreate\r\n\t\t\t}\r\n\t\t\treturn null\r\n\t\t}\r\n\t\r\n\t\tfunction renderDescriptor(renderMethod) {\r\n\t\t\tvar map = new WeakMap()\r\n\t\t\treturn {\r\n\t\t\t\tget: function() {\r\n\t\t\t\t\treturn map.has(this) ? map.get(this) : null\r\n\t\t\t\t},\r\n\t\t\t\tset: function(value) {\r\n\t\t\t\t\tmap.set(this, value)\r\n\t\t\t\t\tthis[renderMethod](value)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction makeElementConstructor() {\r\n\t\t\tfunction Element(selector, properties) {\r\n\t\t\t\tif (this instanceof Element){\r\n\t\t\t\t\t// create DOM element\r\n\t\t\t\t\t// Need to detect if we have registered the element and `this` is actually already the correct instance\r\n\t\t\t\t\treturn create.apply(Element.prototype === getPrototypeOf(this) ? Element :// this means it is from this constructor\r\n\t\t\t\t\t\tthis.constructor, // this means it was constructed from a subclass\r\n\t\t\t\t\t\targuments)\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// extend to create new class\r\n\t\t\t\t\treturn withProperties.apply(Element, arguments)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tElement.create = create\r\n\t\t\tElement.with = withProperties\r\n\t\t\tElement.for = forTarget\r\n\t\t\tElement.property = propertyForElement\r\n\t\t\tElement.getForClass = getForClass\r\n\t\t\treturn Element\r\n\t\t}\r\n\t\r\n\t\tfunction withProperties(selector, properties) {\r\n\t\t\tvar Element = makeElementConstructor()\r\n\t\t\tElement.superConstructor = this\r\n\t\t\tElement.tagName = this.tagName\r\n\t\t\tif (this.children) {\r\n\t\t\t\t// just copy this property\r\n\t\t\t\tElement.children = this.children\r\n\t\t\t}\r\n\t\t\tvar prototype = Element.prototype = this.prototype\r\n\t\r\n\t\t\tvar hasOwnApplySet\r\n\t\t\tvar applyOnCreate = Element._applyOnCreate = {}\r\n\t\t\tvar parentApplySet = getApplySet(this)\r\n\t\t\t// copy parent properties\r\n\t\t\tfor (var key in parentApplySet) {\r\n\t\t\t\tapplyOnCreate[key] = parentApplySet[key]\r\n\t\t\t}\r\n\t\r\n\t\t\tvar i = 0 // for arguments\r\n\t\t\tif (typeof selector === 'string') {\r\n\t\t\t\tvar selectorMatch = selector.match(SELECTOR_REGEX)\r\n\t\t\t\tif (selectorMatch) {\r\n\t\t\t\t\tdo {\r\n\t\t\t\t\t\tvar operator = selectorMatch[1]\r\n\t\t\t\t\t\tvar name = selectorMatch[2]\r\n\t\t\t\t\t\tif (operator == '.') {\r\n\t\t\t\t\t\t\tif (applyOnCreate.className) {\r\n\t\t\t\t\t\t\t\tapplyOnCreate.className += ' ' + name\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tapplyOnCreate.className = name\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tapplyOnCreate.id = name\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar remaining = selectorMatch[3]\r\n\t\t\t\t\t\tselectorMatch = remaining && remaining.match(SELECTOR_REGEX)\r\n\t\t\t\t\t} while (selectorMatch)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tapplyOnCreate.content = selector\r\n\t\t\t\t}\r\n\t\t\t\ti++ // skip the first argument\r\n\t\t\t}\r\n\t\r\n\t\t\tfor (var l = arguments.length; i < l; i++) {\r\n\t\t\t\tapplyToClass(arguments[i], Element)\r\n\t\t\t}\r\n\t\t\treturn Element\r\n\t\t}\r\n\t\tvar currentParent\r\n\t\tfunction create(selector, properties) {\r\n\t\t\t// TODO: make this a symbol\r\n\t\t\tvar applyOnCreate = getApplySet(this)\r\n\t\t\tif (currentParent) {\r\n\t\t\t\tvar parent = currentParent\r\n\t\t\t\tcurrentParent = null\r\n\t\t\t}\r\n\t/*\t\tif (this._initialized != this) {\r\n\t\t\t\tthis._initialized = this\r\n\t\t\t\tthis.initialize && this.initialize()\r\n\t\t\t\tvar styles = this.styles\r\n\t\t\t\tif (styles) {\r\n\t\t\t\t\tvar rule = createCssRule(getUniqueSelector(this))\r\n\t\t\t\t\tfor (var i = 0, l = styles.length; i < l; i++) {\r\n\t\t\t\t\t\tvar key = styles[i]\r\n\t\t\t\t\t\tvar value = styles[key]\r\n\t\t\t\t\t\t// TODO: if it is a contextualized variable, do this on the element\r\n\t\t\t\t\t\tvar styleDefinition = styleDefinitions[key]\r\n\t\t\t\t\t\tif (styleDefinition) {\r\n\t\t\t\t\t\t\tstyleDefinition(rule, value, key)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (!this.hasOwnProperty('_applyOnCreate')) {\r\n\t\t\t\t\tapplyOnCreate = getApplySet(this)\r\n\t\t\t\t}\r\n\t\t\t}*/\r\n\t\t\tvar element = doc.createElement(this.tagName)\r\n\t\t\tif (selector && selector.parent) {\r\n\t\t\t\tparent = selector.parent\r\n\t\t\t}\r\n\t\t\tif (parent) {\r\n\t\t\t\tpresumptiveParentMap.set(element, parent)\r\n\t\t\t}\r\n\t\t\tif (!(element instanceof this)) {\r\n\t\t\t\t// ideally we want to avoid this call, as it is expensive, but for classes that\r\n\t\t\t\t// don't register a tag name, we have to make sure the prototype chain is correct\r\n\t\t\t\tsetPrototypeOf(element, this.prototype)\r\n\t\t\t}\r\n\t\t\tif (element.constructor != this) {\r\n\t\t\t\telement.constructor = this // need to do this for hasOwn contextualization to work\r\n\t\t\t}\r\n\t\t\tif (arguments.length > 0) {\r\n\t\t\t\t// copy applyOnCreate when we have arguments\r\n\t\t\t\tvar ElementApplyOnCreate = applyOnCreate\r\n\t\t\t\tapplyOnCreate = {}\r\n\t\t\t\tfor (var key in ElementApplyOnCreate) {\r\n\t\t\t\t\tapplyOnCreate[key] = ElementApplyOnCreate[key]\r\n\t\t\t\t}\r\n\t\t\t\tvar i = 0\r\n\t\t\t\tif (typeof selector == 'string') {\r\n\t\t\t\t\ti++\r\n\t\t\t\t\tvar selectorMatch = selector.match(SELECTOR_REGEX)\r\n\t\t\t\t\tif (selectorMatch) {\r\n\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\tvar operator = selectorMatch[1]\r\n\t\t\t\t\t\t\tvar name = selectorMatch[2]\r\n\t\t\t\t\t\t\tif (operator == '.') {\r\n\t\t\t\t\t\t\t\tif (applyOnCreate.className) {\r\n\t\t\t\t\t\t\t\t\tapplyOnCreate.className += ' ' + name\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tif (element.className) {\r\n\t\t\t\t\t\t\t\t\t    element.className += ' ' + name\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t    element.className = name\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tif (applyOnCreate.id) {\r\n\t\t\t\t\t\t\t\t\tapplyOnCreate.id = name\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t// just skip right to the element\r\n\t\t\t\t\t\t\t\t\telement.id = name\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tvar remaining = selectorMatch[3]\r\n\t\t\t\t\t\t\tselectorMatch = remaining && remaining.match(SELECTOR_REGEX)\r\n\t\t\t\t\t\t} while (selectorMatch)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tapplyOnCreate.content = selector\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (selector && selector._item) {\r\n\t\t\t\t\t// this is kind of hack, to get the Item available before the properties, eventually we may want to\r\n\t\t\t\t\t// order static properties before variable binding applications, but for now.\r\n\t\t\t\t\telement._item = selector._item\r\n\t\t\t\t}\r\n\t\t\t\tfor (var l = arguments.length; i < l; i++) {\r\n\t\t\t\t\tvar argument = arguments[i]\r\n\t\t\t\t\tif (argument && typeof argument === 'object') {\r\n\t\t\t\t\t\tif (argument instanceof Array || argument.notifies) {\r\n\t\t\t\t\t\t\tapplyOnCreate.content = argument\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tfor (var key in argument) {\r\n\t\t\t\t\t\t\t\t// TODO: do deep merging of styles and classes, but not variables\r\n\t\t\t\t\t\t\t\tapplyOnCreate[key] = argument[key]\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (typeof argument === 'function' && argument.for) {\r\n\t\t\t\t\t\tapplyOnCreate.content = argument.for(element)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tapplyOnCreate.content = argument\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (element.created) {\r\n\t\t\t\tapplyOnCreate = element.created(applyOnCreate) || applyOnCreate\r\n\t\t\t}\r\n\t\t\t// TODO: inline this for better performance, possibly\r\n\t\t\tassignProperties(element, applyOnCreate)\r\n\t\t\tif (this.children) {\r\n\t\t\t\tlayoutChildren(element, this.children, element)\r\n\t\t\t}\r\n\t\t\t// always do this last, so it can be properly inserted inside the children\r\n\t\t\tif (applyOnCreate.content) {\r\n\t\t\t\tbuildContent(element, applyOnCreate.content, 'content', applyOnCreate)\r\n\t\t\t}\r\n\t\t\telement.ready && element.ready(applyOnCreate)\r\n\t\t\treturn element\r\n\t\t}\r\n\t\r\n\t\tvar slice = [].slice\r\n\t\tfunction append(parent){\r\n\t\t\treturn this.nodeType ?\r\n\t\t\t\tlayoutChildren(this, arguments, this) : // called as a method\r\n\t\t\t\tlayoutChildren(parent, slice.call(arguments, 1), parent) // called as a function\r\n\t\t}\r\n\t\r\n\t\tfunction prepend(parent){\r\n\t\t\treturn this.nodeType ?\r\n\t\t\t\tlayoutChildren(this, arguments, this, true) : // called as a method\r\n\t\t\t\tlayoutChildren(parent, slice.call(arguments, 1), parent, true) // called as a function\r\n\t\t}\r\n\t\r\n\t\tfunction registerTag(tagName) {\r\n\t\t\tthis.tagName = tagName\r\n\t\t\tif (doc.registerElement && this.prototype.constructor === this) {\r\n\t\t\t\tdoc.registerElement(tagName, this)\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tvar Element = withProperties.call(typeof HTMLElement !== 'undefined' ? HTMLElement : function() {})\r\n\t\r\n\t\tElement.registerTag = registerTag\r\n\t\tElement.assign = assignProperties\r\n\t\r\n\t\tElement.within = function(element){\r\n\t\t\t// find closest child\r\n\t\t}\r\n\t\r\n\t\tgenerate([\r\n\t\t\t'Video',\r\n\t\t\t'Source',\r\n\t\t\t'Media',\r\n\t\t\t'Audio',\r\n\t\t\t'UL',\r\n\t\t\t'Track',\r\n\t\t\t'Title',\r\n\t\t\t'TextArea',\r\n\t\t\t'Template',\r\n\t\t\t'TBody',\r\n\t\t\t'THead',\r\n\t\t\t'TFoot',\r\n\t\t\t'TR',\r\n\t\t\t'Table',\r\n\t\t\t'Col',\r\n\t\t\t'ColGroup',\r\n\t\t\t'TH',\r\n\t\t\t'TD',\r\n\t\t\t'Caption',\r\n\t\t\t'Style',\r\n\t\t\t'Span',\r\n\t\t\t'Shadow',\r\n\t\t\t'Select',\r\n\t\t\t'Script',\r\n\t\t\t'Quote',\r\n\t\t\t'Progress',\r\n\t\t\t'Pre',\r\n\t\t\t'Picture',\r\n\t\t\t'Param',\r\n\t\t\t'P',\r\n\t\t\t'Output',\r\n\t\t\t'Option',\r\n\t\t\t'Optgroup',\r\n\t\t\t'Object',\r\n\t\t\t'OL',\r\n\t\t\t'Ins',\r\n\t\t\t'Del',\r\n\t\t\t'Meter',\r\n\t\t\t'Meta',\r\n\t\t\t'Menu',\r\n\t\t\t'Map',\r\n\t\t\t'Link',\r\n\t\t\t'Legend',\r\n\t\t\t'Label',\r\n\t\t\t'LI',\r\n\t\t\t'KeyGen',\r\n\t\t\t'Input',\r\n\t\t\t'Image',\r\n\t\t\t'IFrame',\r\n\t\t\t'H1',\r\n\t\t\t'H2',\r\n\t\t\t'H3',\r\n\t\t\t'H4',\r\n\t\t\t'H5',\r\n\t\t\t'H6',\r\n\t\t\t'Hr',\r\n\t\t\t'FrameSet',\r\n\t\t\t'Frame',\r\n\t\t\t'Form',\r\n\t\t\t'Font',\r\n\t\t\t'Embed',\r\n\t\t\t'Article',\r\n\t\t\t'Aside',\r\n\t\t\t'Footer',\r\n\t\t\t'Figure',\r\n\t\t\t'FigCaption',\r\n\t\t\t'Header',\r\n\t\t\t'Main',\r\n\t\t\t'Mark',\r\n\t\t\t'MenuItem',\r\n\t\t\t'Nav',\r\n\t\t\t'Section',\r\n\t\t\t'Summary',\r\n\t\t\t'WBr',\r\n\t\t\t'Div',\r\n\t\t\t'Dialog',\r\n\t\t\t'Details',\r\n\t\t\t'DataList',\r\n\t\t\t'DL',\r\n\t\t\t'Canvas',\r\n\t\t\t'Button',\r\n\t\t\t'Base',\r\n\t\t\t'Br',\r\n\t\t\t'Area',\r\n\t\t\t'A'\r\n\t\t])\r\n\t\tgenerateInputs([\r\n\t\t\t'Checkbox',\r\n\t\t\t'Password',\r\n\t\t\t'Submit',\r\n\t\t\t'Radio',\r\n\t\t\t'Color',\r\n\t\t\t'Date',\r\n\t\t\t'DateTime',\r\n\t\t\t'Email',\r\n\t\t\t'Month',\r\n\t\t\t'Number',\r\n\t\t\t'Range',\r\n\t\t\t'Search',\r\n\t\t\t'Tel',\r\n\t\t\t'Time',\r\n\t\t\t'Url',\r\n\t\t\t'Week'])\r\n\t\r\n\t\tvar tags = {}\r\n\t\tfunction getConstructor(tagName) {\r\n\t\t\ttagName = tagName.toLowerCase()\r\n\t\t\treturn tags[tagName] ||\r\n\t\t\t\t(tags[tagName] =\r\n\t\t\t\t\tsetTag(withProperties.call(doc.createElement(tagName).constructor), tagName))\r\n\t\t}\r\n\t\r\n\t\tfunction setTag(Element, tagName) {\r\n\t\t\tElement.tagName = tagName\r\n\t\t\treturn Element\r\n\t\t}\r\n\t\tfunction generate(elements) {\r\n\t\t\telements.forEach(function(elementName) {\r\n\t\t\t\tvar ElementClass\r\n\t\t\t\tObject.defineProperty(Element, elementName, {\r\n\t\t\t\t\tget: function() {\r\n\t\t\t\t\t\treturn ElementClass || (ElementClass = getConstructor(elementName))\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t})\r\n\t\t}\r\n\t\tfunction generateInputs(elements) {\r\n\t\t\telements.forEach(function(inputType) {\r\n\t\t\t\tvar ElementClass\r\n\t\t\t\tObject.defineProperty(Element, inputType, {\r\n\t\t\t\t\tget: function() {\r\n\t\t\t\t\t\t// TODO: make all inputs extend from input generated from generate\r\n\t\t\t\t\t\treturn ElementClass || (ElementClass = setTag(withProperties.call(HTMLInputElement, {\r\n\t\t\t\t\t\t\ttype: inputType.toLowerCase()\r\n\t\t\t\t\t\t}), 'input'))\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t\t// alias all the inputs with an Input suffix\r\n\t\t\t\tObject.defineProperty(Element, inputType + 'Input', {\r\n\t\t\t\t\tget: function() {\r\n\t\t\t\t\t\treturn this[inputType]\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t})\r\n\t\t}\r\n\t\r\n\t\tvar aliases = {\r\n\t\t\tAnchor: 'A',\r\n\t\t\tParagraph: 'P',\r\n\t\t\tTextarea: 'TextArea',\r\n\t\t\tDList: 'DL',\r\n\t\t\tUList: 'UL',\r\n\t\t\tOList: 'OL',\r\n\t\t\tListItem: 'LI',\r\n\t\t\tText: 'Input',\r\n\t\t\tTextInput: 'Input',\r\n\t\t\tTableRow: 'TR',\r\n\t\t\tTableCell: 'TD',\r\n\t\t\tTableHeaderCell: 'TH',\r\n\t\t\tTableHeader: 'THead',\r\n\t\t\tTableBody: 'TBody'\r\n\t\t}\r\n\t\tfor (var alias in aliases) {\r\n\t\t\t(function(alias, to) {\r\n\t\t\t\tObject.defineProperty(Element, alias, {\r\n\t\t\t\t\tget: function() {\r\n\t\t\t\t\t\treturn this[to]\r\n\t\t\t\t\t}\r\n\t\t\t\t})\t\t\t\r\n\t\t\t})(alias, aliases[alias])\r\n\t\t}\r\n\t\r\n\t\tElement.append = append\r\n\t\tElement.prepend = prepend\r\n\t\tElement.refresh = Renderer.refresh\r\n\t\tvar options = Element.options = {\r\n\t\t\tmoveLiveElementsEnabled: true,\r\n\t\t}\r\n\t\tElement.content = function(element){\r\n\t\t\t// container marker\r\n\t\t\treturn {\r\n\t\t\t\tisContentNode: true,\r\n\t\t\t\tcreate: element.create.bind(element)\r\n\t\t\t}\r\n\t\t}\r\n\t\t// TODO: unify this in lang\r\n\t\tElement.extend = function(Class, properties) {\r\n\t\t\tfunction ExtendedElement() {\r\n\t\t\t\treturn Class.apply(this, arguments)\r\n\t\t\t}\r\n\t\t\tsetPrototypeOf(ExtendedElement, Class)\r\n\t\t\tvar prototype = ExtendedElement.prototype = Object.create(Class.prototype)\r\n\t\t\tprototype.constructor = ExtendedElement\r\n\t\t\tObject.getOwnPropertyNames(properties).forEach(function(key) {\r\n\t\t\t\tvar descriptor = Object.getOwnPropertyDescriptor(properties, key)\r\n\t\t\t\tif (classHandlers[key]) {\r\n\t\t\t\t\tclassHandlers[key](ExtendedElement, descriptor.value)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tObject.defineProperty(prototype, key, descriptor)\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\treturn ExtendedElement\r\n\t\t}\r\n\t\r\n\t\tfunction forTarget(target) {\r\n\t\t\treturn target.constructor.getForClass(target, this)\r\n\t\t}\r\n\t\r\n\t\tfunction hasOwn(From, Target, createInstance) {\r\n\t\t\tif (typeof Target === 'object' && Target.Class) {\r\n\t\t\t\treturn hasOwn(From, Target.Class, Target.createInstance)\r\n\t\t\t}\r\n\t\t\tif (Target instanceof Array) {\r\n\t\t\t\treturn Target.forEach(function(Target) {\r\n\t\t\t\t\thasOwn(From, Target)\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tvar instanceMap = new WeakMap()\r\n\t\t\tinstanceMap.createInstance = createInstance\r\n\t\t\tvar elementMap = From.ownedClasses || (From.ownedClasses = new WeakMap())\r\n\t\t\telementMap.set(Target, instanceMap)\r\n\t\t\treturn From\r\n\t\t}\r\n\t\r\n\t\tvar globalInstances = {}\r\n\t\tfunction getForClass(element, Target) {\r\n\t\t\tvar createInstance\r\n\t\t\twhile (element && !(createInstance = element.constructor.ownedClasses && element.constructor.ownedClasses.get(Target))) {\r\n\t\t\t\telement = element.parentNode || presumptiveParentMap.get(element)\r\n\t\t\t}\r\n\t\t\tif (createInstance) {\r\n\t\t\t\tvar ownedInstances = element.ownedInstances || (element.ownedInstances = new WeakMap())\r\n\t\t\t\tvar instance = ownedInstances.get(Target)\r\n\t\t\t\tif (instance === undefined) {\r\n\t\t\t\t\townedInstances.set(Target, instance = createInstance(element))\r\n\t\t\t\t\tinstance.subject = element\r\n\t\t\t\t}\r\n\t\t\t\treturn instance\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction propertyForElement(key) {\r\n\t\t\t// we just need to establish one Variable class for each element, so we cache it\r\n\t\t\tThisElementVariable = this._Variable\r\n\t\t\tif (!ThisElementVariable) {\r\n\t\t\t\t// need our own branded variable class for this element class\r\n\t\t\t\tThisElementVariable = this._Variable = Variable()\r\n\t\r\n\t\t\t\thasOwn(this, ThisElementVariable, function(element) {\r\n\t\t\t\t\t// TODO: we might want to do this in init instead\r\n\t\t\t\t\tvar variableProperties = {}\r\n\t\t\t\t\tfor (var i = 0; i < element.alkaliRenderers.length; i++){\r\n\t\t\t\t\t\tvar renderer = element.alkaliRenderers[i]\r\n\t\t\t\t\t\tif (renderer.name) {\r\n\t\t\t\t\t\t\tvariableProperties[renderer.name] = {value: renderer.variable}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tvar elementOverlay = Object.create(element, variableProperties)\r\n\t\t\t\t\tvar instance = new ThisElementVariable(elementOverlay)\r\n\t\t\t\t\t// we are not observing, because you can't delegate getters and setters in safari\r\n\t\t\t\t\t// instance.observeObject()\r\n\t\t\t\t\treturn instance\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\t// now actually get the property class\r\n\t\t\treturn ThisElementVariable.property(key)\r\n\t\t}\r\n\t\r\n\t\tvar Item = Element.Item = Variable.Item\r\n\t\r\n\t\tfunction enterRenderer(Renderer, options/*, target*/) {\r\n\t\t\t// this will be used for optimized class-level variables\r\n\t\t\t/*if (target.started) { // TODO: Might want to pass in started as a parameter\r\n\t\t\t\t// this means that the renderer has already been created, so we just need to add this instance\r\n\t\t\t\tRenderer.prototype.renderUpdate.call(options, element)\r\n\t\t\t} else {*/\r\n\t\t\tnew Renderer(options)\r\n\t\t\t//}\r\n\t\t}\r\n\t\r\n\t\tfunction cleanup(target) {\r\n\t\t\tvar renderers = target.alkaliRenderers\r\n\t\t\tif (renderers) {\r\n\t\t\t\tfor (var i = 0, l = renderers.length; i < l; i++) {\r\n\t\t\t\t\trenderers[i].stop()\r\n\t\t\t\t}\r\n\t\t\t\ttarget.needsRestart = true\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction restart(target) {\r\n\t\t\tvar renderers = target.alkaliRenderers\r\n\t\t\tif (renderers) {\r\n\t\t\t\tfor (var i = 0, l = renderers.length; i < l; i++) {\r\n\t//\t\t\t\tupdaters[i].start()\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t// setup the mutation observer so we can be notified of attachments and removals\r\n\t\tfunction elementAttached(element) {\r\n\t\t\tvar Class = element.constructor\r\n\t\t\tif (Class.create) {\r\n\t/*\t\t\tif (Class.attachedInstances) {\r\n\t\t\t\t\tClass.attachedInstances.push(element)\r\n\t\t\t\t\tif (Class.attachedInstances.length === 1 && Class.needsRestart) {\r\n\t\t\t\t\t\trestart(Class)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tClass.attachedInstances = [element]\r\n\t\t\t\t}*/\r\n\t\t\t\tif (element.attached) {\r\n\t\t\t\t\telement.attached()\r\n\t\t\t\t}\r\n\t\t\t\tif (element.needsRestart) {\r\n\t\t\t\t\trestart(element)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction elementDetached(element) {\r\n\t\t\t/*var attachedInstances = element.constructor.attachedInstances\r\n\t\t\tif (attachedInstances) {\r\n\t\t\t\tvar index = attachedInstances.indexOf(element)\r\n\t\t\t\tif (index > -1) {\r\n\t\t\t\t\tattachedInstances.splice(index, 1)\r\n\t\t\t\t\tif (attachedInstances.length === 0) {\r\n\t\t\t\t\t\tcleanup(Class)\r\n\t\t\t\t\t}\r\n\t\t\t\t}*/\r\n\t\t\t\tif (element.detached) {\r\n\t\t\t\t\telement.detached()\r\n\t\t\t\t}\r\n\t\t\t\tcleanup(element)\r\n\t\t\t//}\r\n\t\t}\r\n\t\tif (typeof MutationObserver === 'function') {\r\n\t\t\tvar docBody = doc.body\r\n\t\t\tvar lifeStates = [{\r\n\t\t\t\tname: 'detached',\r\n\t\t\t\tnodes: 'removedNodes',\r\n\t\t\t\taction: elementDetached\r\n\t\t\t}, {\r\n\t\t\t\tname: 'attached',\r\n\t\t\t\tnodes: 'addedNodes',\r\n\t\t\t\taction: elementAttached\r\n\t\t\t}]\r\n\t\t\tfunction firstVisit(node, state) {\r\n\t\t\t\tif (state.name === 'attached') {\r\n\t\t\t\t\tif (node.__alkaliAttached__) {\r\n\t\t\t\t\t\treturn false\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tnode.__alkaliAttached__ = true\r\n\t\t\t\t\t\tstate.action(node)\r\n\t\t\t\t\t\treturn true\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (node.__alkaliAttached__) {\r\n\t\t\t\t\tif (docBody.contains(node)) {\r\n\t\t\t\t\t\t// detached event, but it is actually still attached (will get attached in a later mutation record)\r\n\t\t\t\t\t\t// so don't get through the detached/attached lifecycle\r\n\t\t\t\t\t\treturn false\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnode.__alkaliAttached__ = false\r\n\t\t\t\t\tstate.action(node)\r\n\t\t\t\t}\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\t\t\tvar observer = new MutationObserver(function(mutations) {\r\n\t\t\t\tfor (var i = 0, il = mutations.length; i < il; i++) {\r\n\t\t\t\t\tvar mutation = mutations[i]\r\n\t\t\t\t\t// invoke action on element if we haven't already\r\n\t\t\t\t\tactionIteration:\r\n\t\t\t\t\tfor (var j = 0, jl = lifeStates.length; j < jl; j++) { // two steps, removed nodes and added nodes\r\n\t\t\t\t\t\tvar state = lifeStates[j]\r\n\t\t\t\t\t\tvar nodes = mutation[state.nodes]\r\n\t\t\t\t\t\t// iterate over node list\r\n\t\t\t\t\t\tnodeIteration:\r\n\t\t\t\t\t\tfor (var k = 0, kl = nodes.length; k < kl; k++) {\r\n\t\t\t\t\t\t\tvar baseNode = nodes[k]\r\n\t\t\t\t\t\t\tif (firstVisit(baseNode, state)) {\r\n\t\t\t\t\t\t\t\t// start traversal with child, if it exists\r\n\t\t\t\t\t\t\t\tvar currentNode = baseNode.firstChild\r\n\t\t\t\t\t\t\t\tif (currentNode) {\r\n\t\t\t\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\t\t\t\tvar nextNode\r\n\t\t\t\t\t\t\t\t\t\tif (currentNode.nodeType === 1 && firstVisit(currentNode, state)) {\r\n\t\t\t\t\t\t\t\t\t\t\t// depth-first search\r\n\t\t\t\t\t\t\t\t\t\t\tnextNode = currentNode.firstChild\r\n\t\t\t\t\t\t\t\t\t\t\tif (!nextNode) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tnextNode = currentNode.nextSibling\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\tnextNode = currentNode.nextSibling\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tif (!nextNode) {\r\n\t\t\t\t\t\t\t\t\t\t\t// come back out to parents\r\n\t\t\t\t\t\t\t\t\t\t\t// TODO: try keeping a stack to make this faster\r\n\t\t\t\t\t\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentNode = currentNode.parentNode\r\n\t\t\t\t\t\t\t\t\t\t\t\tif (currentNode === baseNode) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tcontinue nodeIteration\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t} while (!(nextNode = currentNode.nextSibling))\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tcurrentNode = nextNode\r\n\t\t\t\t\t\t\t\t\t} while (true)\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// if (options.moveLiveElementsEnabled) {\r\n\t\t\t\t\t\t\t// TODO: any options that we can really do here?\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\tobserver.observe(docBody, {\r\n\t\t\t\tchildList: true,\r\n\t\t\t\tsubtree: true\r\n\t\t\t})\r\n\t\t}\r\n\t\t\r\n\t\tlang.copy(Variable.Context.prototype, {\r\n\t\t\tspecify: function(Variable) {\r\n\t\t\t\tvar element = this.subject\r\n\t\t\t  var distinctive = true\r\n\t\t\t  ;(this.generics || (this.generics = [])).push(Variable)\r\n\t\t\t  do {\r\n\t\t\t    if (this.distinctSubject === element) {\r\n\t\t\t      distinctive = false\r\n\t\t\t    }\r\n\t\t\t    var subjectMap = element.constructor.ownedClasses\r\n\t\t\t    if (subjectMap) {\r\n\t\t\t\t\t\tvar instanceMap = subjectMap.get(Variable)\r\n\t\t\t\t\t\tif (instanceMap) {\r\n\t\t\t\t      if (distinctive) {\r\n\t\t\t\t        this.distinctSubject = element\r\n\t\t\t\t      }\r\n\t\t\t\t\t\t\tspecifiedInstance = instanceMap.get(element)\r\n\t\t\t\t\t\t\tif (!specifiedInstance) {\r\n\t\t\t\t\t\t\t\tinstanceMap.set(element, specifiedInstance = instanceMap.createInstance ?\r\n\t\t\t\t\t\t\t\t\tinstanceMap.createInstance(element) : new Variable())\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn specifiedInstance\r\n\t\t\t\t\t\t}\r\n\t\t\t    }\r\n\t\t\t  } while ((element = element.parentNode || presumptiveParentMap.get(element)))\r\n\t\t\t\t// else if no specific context is found, return default instance\r\n\t\t\t\treturn Variable.defaultInstance\r\n\t\t\t},\r\n\t\r\n\t\t\tgetContextualized: function(variable) {\r\n\t\t\t\t// returns a variable that has already been contextualized\r\n\t\t\t\tvar element = this.subject\r\n\t\t\t\tif (!element) {\r\n\t\t\t\t\t// no element, just use the default variable\r\n\t\t\t\t\treturn variable\r\n\t\t\t\t}\r\n\t\t\t\tif (variable._contextMap) {\r\n\t\t\t\t\tdo {\r\n\t\t\t\t\t\tvar instance = variable._contextMap.get(element)\r\n\t\t\t\t\t\tif (instance && instance.context.matches(element)) {\r\n\t\t\t\t\t\t\treturn instance\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} while ((element = element.parentNode || presumptiveParentMap.get(element)))\r\n\t\t\t\t}\r\n\t\t\t\tif (variable.context && variable.context.matches(this.subject)) {\r\n\t\t\t\t\t// check if the default variable is allowed\r\n\t\t\t\t\treturn variable\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\r\n\t\t\tmerge: function(childContext) {\r\n\t\t\t  if (!this.distinctSubject || this.distinctSubject.contains(childContext.distinctSubject)) {\r\n\t\t\t    this.distinctSubject = childContext.distinctSubject\r\n\t\t\t  }\r\n\t\t\t  [].push.apply(this.generics || (this.generics = []), childContext.generics)\r\n\t\t\t},\r\n\t\t\tgetDistinctElement: function(Variable, element) {\r\n\t\t\t  do {\r\n\t\t\t    var subjectMap = element.constructor.ownedClasses\r\n\t\t\t    if (subjectMap) {\r\n\t\t\t\t\t\tvar instanceMap = subjectMap.get(Variable)\r\n\t\t\t\t\t\tif (instanceMap && instanceMap.has(element)) {\r\n\t\t\t\t\t\t\treturn element\r\n\t\t\t\t\t\t}\r\n\t\t\t    }\r\n\t\t\t  } while ((element = element.parentNode || presumptiveParentMap.get(element)))\r\n\t\t\t},\r\n\t\t\tmatches: function(element) {\r\n\t\t\t\tvar generics = this.generics\r\n\t\t\t\tif (generics) {\r\n\t\t\t\t\tfor (var i = 0, l = generics.length; i < l; i++) {\r\n\t\t\t\t\t\tif (this.getDistinctElement(generics[i], element) !== this.distinctSubject) {\r\n\t\t\t\t\t\t\treturn false\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\t\t})\r\n\t\t\r\n\t\r\n\t\r\n\t\treturn Element\r\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\r\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(3)], __WEBPACK_AMD_DEFINE_RESULT__ = function (lang) {\r\n\t\tvar deny = {}\r\n\t\tvar noChange = {}\r\n\t\tvar WeakMap = lang.WeakMap\r\n\t\tvar setPrototypeOf = Object.setPrototypeOf || (function(base, proto) { base.__proto__ = proto})\r\n\t\tvar getPrototypeOf = Object.getPrototypeOf || (function(base) { return base.__proto__ })\r\n\t\t// update types\r\n\t\tvar ToParent = 2\r\n\t\tvar RequestChange = 3\r\n\t\tvar RequestSet = 4\r\n\t\t\r\n\t\tvar ToChild = Object.freeze({\r\n\t\t\ttype: 'refresh'\r\n\t\t})\r\n\t\tvar nextId = 1\r\n\t\tvar propertyListenersMap = new WeakMap(null, 'propertyListenersMap')\r\n\t\r\n\t\tvar CacheEntry = lang.compose(WeakMap, function() {\r\n\t\t},{\r\n\t\t\t_propertyChange: function(propertyName) {\r\n\t\t\t\tthis.variable._propertyChange(propertyName, contextFromCache(this))\r\n\t\t\t}\r\n\t\t})\r\n\t\tvar listenerId = 1\r\n\t\r\n\t\tfunction when(value, callback) {\r\n\t\t\tif (value && value.then) {\r\n\t\t\t\treturn value.then(callback)\r\n\t\t\t}\r\n\t\t\treturn callback(value)\r\n\t\t}\r\n\t\r\n\t\tfunction Context(subject){\r\n\t\t\tthis.subject = subject\r\n\t\t\tthis.inputs = []\r\n\t\t}\r\n\t\tContext.prototype = {\r\n\t\t\tconstructor: Context,\r\n\t\t\tnewContext: function(variable) {\r\n\t\t\t\treturn new Context(this.subject)\r\n\t\t\t},\r\n\t\t\tcontextualize: function(variable, parentContext) {\r\n\t\t\t\t// resolve the contextualization of a variable, and updates this context to be aware of what distinctive aspect of the context has\r\n\t\t\t\t// been used for resolution\r\n\t\t\t\tvar contextualized\r\n\t\t\t\tif (this.distinctSubject) {\r\n\t\t\t\t\tvar contextMap = variable._contextMap || (variable._contextMap = new WeakMap())\r\n\t\t\t\t\tcontextualized = contextMap.get(this.distinctSubject)\r\n\t\t\t\t\tif (!contextualized) {\r\n\t\t\t\t\t\tcontextMap.set(this.distinctSubject, contextualized = Object.create(variable))\r\n\t\t\t\t\t\tcontextualized.listeners = false\r\n\t\t\t\t\t\tcontextualized.context = this\r\n\t\t\t\t\t\tvar inputs = this.inputs\r\n\t\t\t\t\t\tfor (var i = 0, l = inputs.length; i < l; i++) {\r\n\t\t\t\t\t\t\tcontextualized[inputs[i]] = inputs[++i]\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.contextualized = contextualized\r\n\t\t\t\t\t// do the merge\r\n\t\t\t\t\tif (parentContext) {\r\n\t\t\t\t\t\tparentContext.merge(this)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcontextualized = variable\r\n\t\t\t\t}\r\n\t\t\t\t//if (this.contextualized && this.contextualized !== contextualized) {\r\n\t\t\t\t\t// TOOD: if it has previously been contextualized to a different context (can happen in a promise/async situation), stop previous notifiers and start new ones\r\n\t\t\t\t//}\r\n\t\t\t\tparentContext.addInput(contextualized)\r\n\t\t\t\treturn contextualized\r\n\t\t\t},\r\n\t\t\tmerge: function(childContext) {\r\n\t\t\t\tif (!this.distinctSubject) {\r\n\t\t\t\t\tthis.distinctSubject = childContext.distinctSubject\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tspecify: function(Variable) {\r\n\t\t\t\t// specify a particular instance of a generic variable\r\n\t\t\t\tvar subject = this.subject\r\n\t\t\t\tvar subjectMap = subject.constructor.ownedClasses\r\n\t\t\t\tvar specifiedInstance\r\n\t\t\t\tif (subjectMap) {\r\n\t\t\t\t\tif (!this.distinctSubject) {\r\n\t\t        this.distinctSubject = subject\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar instanceMap = subjectMap.get(Variable)\r\n\t\t\t\t\tif (instanceMap) {\r\n\t\t\t\t\t\tspecifiedInstance = instanceMap.get(subject)\r\n\t\t\t\t\t\tif (!specifiedInstance) {\r\n\t\t\t\t\t\t\tinstanceMap.set(subject, specifiedInstance = instanceMap.createInstance ? instanceMap.createInstance(subject) : new Variable())\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn specifiedInstance\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// else if no specific context is found, return default instance\r\n\t\t\t\treturn Variable.defaultInstance\r\n\t\t\t},\r\n\t\t\tgetContextualized: function(variable) {\r\n\t\r\n\t\t\t\t// returns a variable that has already been contextualized\r\n\t\t\t\tvar instance = variable._contextMap && this.subject && variable._contextMap.get(this.subject)\r\n\t\t\t\tif (instance && instance.context && instance.context.matches(this)) {\r\n\t\t\t\t\treturn instance\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\taddInput: function(inputVariable) {\r\n\t\t\t\tthis.inputs.push(this.nextProperty, inputVariable)\r\n\t\t\t},\r\n\t\t\tmatches: function(context) {\r\n\t\t\t\t// does another context match the resolution of this one?\r\n\t\t\t\treturn context.subject === this.subject\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction NotifyingContext(listener, subject){\r\n\t\t\tthis.subject = subject\r\n\t\t\tthis.listener = listener\r\n\t\t}\r\n\t\tNotifyingContext.prototype = Object.create(Context.prototype)\r\n\t\tNotifyingContext.prototype.constructor = NotifyingContext\r\n\t\tNotifyingContext.prototype.addInput = function(contextualized) {\r\n\t\t\tcontextualized.notifies(this.listener)\r\n\t\t}\r\n\t\r\n\t\tfunction whenAll(inputs, callback){\r\n\t\t\tvar promiseInvolved\r\n\t\t\tfor (var i = 0, l = inputs.length; i < l; i++) {\r\n\t\t\t\tif (inputs[i] && inputs[i].then) {\r\n\t\t\t\t\tpromiseInvolved = true\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (promiseInvolved) {\r\n\t\t\t\treturn lang.whenAll(inputs, callback)\r\n\t\t\t}\r\n\t\t\treturn callback(inputs)\r\n\t\t}\r\n\t\r\n\t\tfunction registerListener(value, listener) {\r\n\t\t\tvar listeners = propertyListenersMap.get(value)\r\n\t\t\tvar id = listener.listenerId || (listener.listenerId = ('-' + listenerId++))\r\n\t\t\tif (listeners) {\r\n\t\t\t\tif (listeners[id] === undefined) {\r\n\t\t\t\t\tlisteners[id] = listeners.push(listener) - 1\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\tpropertyListenersMap.set(value, listeners = [listener])\r\n\t\t\t\tlisteners[id] = 0\r\n\t\t\t\tif (Variable.autoObserveObjects) {\r\n\t\t\t\t\tobserve(value)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tlistener.listeningToObject = value\r\n\t\t}\r\n\t\tfunction deregisterListener(listener) {\r\n\t\t\tif (listener.listeningToObject) {\r\n\t\t\t\tvar value = listener.listeningToObject\r\n\t\t\t\tlistener.listeningToObject = null\r\n\t\t\t\tvar listeners = propertyListenersMap.get(value)\r\n\t\t\t\tif (listeners) {\r\n\t\t\t\t\tvar index = listeners[listener.listenerId]\r\n\t\t\t\t\tif (index > -1) {\r\n\t\t\t\t\t\tlisteners.splice(index, 1)\r\n\t\t\t\t\t\tdelete listeners[listener.listenerId]\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction RefreshEvent() {\r\n\t\t\tthis.visited = new Set()\r\n\t\t}\r\n\t\tRefreshEvent.prototype.type = 'refresh'\r\n\t\r\n\t\tfunction PropertyChangeEvent(key, childEvent, parent) {\r\n\t\t\tthis.key = key\r\n\t\t\tthis.childEvent = childEvent\r\n\t\t\tthis.parent = parent\r\n\t\t\tthis.visited = childEvent.visited\r\n\t\t}\r\n\t\tPropertyChangeEvent.prototype.type = 'update'\r\n\t\r\n\t\tfunction AddEvent(args) {\r\n\t\t\tthis.visited = new Set()\r\n\t\t\tfor (var key in args) {\r\n\t\t\t\tthis[key] = args[key]\r\n\t\t\t}\r\n\t\t}\r\n\t\tAddEvent.prototype.type = 'add'\r\n\t\tfunction DeleteEvent(args) {\r\n\t\t\tthis.visited = new Set()\r\n\t\t\tfor (var key in args) {\r\n\t\t\t\tthis[key] = args[key]\r\n\t\t\t}\r\n\t\t}\r\n\t\tDeleteEvent.prototype.type = 'delete'\r\n\t\r\n\t\tfunction forPropertyNotifyingValues(properties, callback) {\r\n\t\t\tfor (var key in properties) {\r\n\t\t\t\tvar property = properties[key]\r\n\t\t\t\tif (property.returnedVariable) {\r\n\t\t\t\t\tcallback(property.returnedVariable)\r\n\t\t\t\t}\r\n\t\t\t\tif (property.hasChildNotifiers) {\r\n\t\t\t\t\tvar subProperties = property._properties\r\n\t\t\t\t\tif (subProperties) {\r\n\t\t\t\t\t\tforPropertyNotifyingValues(subProperties, callback)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction Variable(value) {\r\n\t\t\tif (this instanceof Variable) {\r\n\t\t\t\t// new call, may eventually use new.target\r\n\t\t\t\tthis.value = typeof value === 'undefined' ? this.default : value\r\n\t\t\t} else {\r\n\t\t\t\treturn Variable.extend(value)\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar VariablePrototype = Variable.prototype = {\r\n\t\t\t// for debugging use\r\n\t\t\tget _currentValue() {\r\n\t\t\t\treturn this.valueOf()\r\n\t\t\t},\r\n\t\t\tset _currentValue(value) {\r\n\t\t\t\tthis.put(value)\r\n\t\t\t},\r\n\t\t\tconstructor: Variable,\r\n\t\t\tvalueOf: function(context) {\r\n\t\t\t\tvar valueContext\r\n\t\t\t\treturn this.gotValue(this.getValue ?\r\n\t\t\t\t\tthis.getValue(context && (valueContext = context.newContext())) :\r\n\t\t\t\t\tthis.value, context, valueContext)\r\n\t\t\t},\r\n\t\t\tgotValue: function(value, parentContext, context) {\r\n\t\t\t\tvar previousNotifyingValue = this.returnedVariable\r\n\t\t\t\tvar variable = this\r\n\t\t\t\tif (previousNotifyingValue) {\r\n\t\t\t\t\tif (value === previousNotifyingValue) {\r\n\t\t\t\t\t\t// nothing changed, immediately return valueOf (or ownObject if we have it)\r\n\t\t\t\t\t\tif (variable.ownObject) {\r\n\t\t\t\t\t\t\treturn variable.ownObject\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (parentContext) {\r\n\t\t\t\t\t\t\tif (!context) {\r\n\t\t\t\t\t\t\t\tcontext = parentContext.newContext()\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tcontext.contextualize(this, parentContext)\r\n\t\t\t\t\t\t\tcontext.nextProperty = 'returnedVariable'\r\n\t\t\t\t\t\t\treturn value.valueOf(context)\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\treturn value.valueOf()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// if there was a another value that we were dependent on before, stop listening to it\r\n\t\t\t\t\t// TODO: we may want to consider doing cleanup after the next rendering turn\r\n\t\t\t\t\tif (variable.listeners) {\r\n\t\t\t\t\t\tpreviousNotifyingValue.stopNotifies(variable)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvariable.returnedVariable = null\r\n\t\t\t\t}\r\n\t\t\t\tif (value && value.notifies) {\r\n\t\t\t\t\tvariable.returnedVariable = value\r\n\t\t\t\t\tif (variable.listeners) {\r\n\t\t\t\t\t\tvalue.notifies(variable)\r\n\t\t\t\t\t}\r\n\t\t\t\t\t/*var parent = variable\r\n\t\t\t\t\tdo {\r\n\t\t\t\t\t\tif (parent.listeners) {\r\n\t\t\t\t\t\t\t// the value is another variable, start receiving notifications, if we, or any parent is live\r\n\t\t\t\t\t\t\tvariable.returnedVariable.notifies(variable)\r\n\t\t\t\t\t\t\tbreak\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tparent.hasNotifyingChild = true\r\n\t\t\t\t\t} while((parent = parent.parent))*/\r\n\t\t\t\t\tcontext = context || parentContext && (context = parentContext.newContext())\r\n\t\t\t\t\tif (context) {\r\n\t\t\t\t\t\tcontext.nextProperty = 'returnedVariable'\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvalue = value.valueOf(context)\r\n\t\t\t\t\tif (variable.ownObject) {\r\n\t\t\t\t\t\tif (getPrototypeOf(variable.ownObject) !== value) {\r\n\t\t\t\t\t\t\tsetPrototypeOf(variable.ownObject, value)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvalue = variable.ownObject\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (value === undefined) {\r\n\t\t\t\t\tvalue = variable.default\r\n\t\t\t\t}\r\n\t\t\t\tif (context) {\r\n\t\t\t\t\tcontext.contextualize(this, parentContext)\r\n\t\t\t\t}\r\n\t\t\t\tif (parentContext) {\r\n\t\r\n\t\t\t\t\t/*if (!contextualized.listeners) {\r\n\t\t\t\t\t\t// mark it as initialized, since we have already recursively dependended on inputs\r\n\t\t\t\t\t\tcontextualized.listeners = []\r\n\t\t\t\t\t}*/\r\n\t\r\n\t\t\t\t\tif (!context) {\r\n\t\t\t\t\t\tparentContext.addInput(this)\r\n\t\t\t\t\t}\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\tif (value && value.then) {\r\n\t\t\t\t\treturn when(value, function(value) {\r\n\t\t\t\t\t\treturn Variable.prototype.gotValue.call(variable, value, context)\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t\treturn value\r\n\t\t\t},\r\n\t\t\tisMap: function() {\r\n\t\t\t\treturn this.value instanceof Map\r\n\t\t\t},\r\n\t\t\tproperty: function(key) {\r\n\t\t\t\tvar isMap = this.isMap()\r\n\t\t\t\tvar properties = this._properties || (this._properties = isMap ? new Map() : {})\r\n\t\t\t\tvar propertyVariable = isMap ? properties.get(key) : properties[key]\r\n\t\t\t\tif (!propertyVariable) {\r\n\t\t\t\t\t// create the property variable\r\n\t\t\t\t\tpropertyVariable = new Property(this, key)\r\n\t\t\t\t\tif (isMap) {\r\n\t\t\t\t\t\tproperties.set(key, propertyVariable)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tproperties[key] = propertyVariable\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn propertyVariable\r\n\t\t\t},\r\n\t\t\tfor: function(subject) {\r\n\t\t\t\tif (subject && subject.target && !subject.constructor.getForClass) {\r\n\t\t\t\t\t// makes HTML events work\r\n\t\t\t\t\tsubject = subject.target\r\n\t\t\t\t}\r\n\t\t\t\treturn new ContextualizedVariable(this, subject || defaultContext)\r\n\t\t\t},\r\n\t\t\t_propertyChange: function(propertyName, object, context, type) {\r\n\t\t\t\tif (this.onPropertyChange) {\r\n\t\t\t\t\tthis.onPropertyChange(propertyName, object, context)\r\n\t\t\t\t}\r\n\t\t\t\tthis.updated(new PropertyChangeEvent(propertyName, new RefreshEvent(), this), null, context)\r\n\t\t\t},\r\n\t\t\teachKey: function(callback) {\r\n\t\t\t\tfor (var i in this._properties) {\r\n\t\t\t\t\tcallback(i)\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tapply: function(instance, args) {\r\n\t\t\t\treturn new Call(this, args)\r\n\t\t\t},\r\n\t\t\tcall: function(instance) {\r\n\t\t\t\treturn this.apply(instance, Array.prototype.slice.call(arguments, 1))\r\n\t\t\t},\r\n\t\t\tforDependencies: function(callback) {\r\n\t\t\t\tif (this.returnedVariable) {\r\n\t\t\t\t\tcallback(this.returnedVariable)\r\n\t\t\t\t}\r\n\t\t\t\tif (this.hasNotifyingChild) {\r\n\t\t\t\t\tvar properties = this._properties\r\n\t\t\t\t\tif (properties) {\r\n\t\t\t\t\t\tforPropertyNotifyingValues(properties, callback)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tinit: function() {\r\n\t\t\t\tvar variable = this\r\n\t\t\t\tthis.forDependencies(function(dependency) {\r\n\t\t\t\t\tdependency.notifies(variable)\r\n\t\t\t\t})\r\n\t\r\n\t\t\t\tif (this.listeningToObject === null) {\r\n\t\t\t\t\t// we were previously listening to an object, but it needs to be restored\r\n\t\t\t\t\t// calling valueOf will cause the listening object to be restored\r\n\t\t\t\t\tthis.valueOf()\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tcleanup: function() {\r\n\t\t\t\tthis.listeners = false\r\n\t\t\t\tvar handles = this.handles\r\n\t\t\t\tif (handles) {\r\n\t\t\t\t\tfor (var i = 0; i < handles.length; i++) {\r\n\t\t\t\t\t\thandles[i].remove()\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tthis.handles = null\r\n\t\t\t\tvar returnedVariable = this.returnedVariable\r\n\t\t\t\tif (returnedVariable) {\r\n\t\t\t\t\t// TODO: move this into the caching class\r\n\t\t\t\t\tthis.computedVariable = null\r\n\t\t\t\t}\r\n\t\t\t\tvar variable = this\r\n\t\t\t\tthis.forDependencies(function(dependency) {\r\n\t\t\t\t\tdependency.stopNotifies(variable)\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\r\n\t\t\tupdateVersion: function(version) {\r\n\t\t\t\tthis.version = nextId++\r\n\t\t\t},\r\n\t\r\n\t\t\tgetVersion: function(context) {\r\n\t\t\t\treturn Math.max(this.version || 0, this.returnedVariable && this.returnedVariable.getVersion ? this.returnedVariable.getVersion(context) : 0)\r\n\t\t\t},\r\n\t\r\n\t\t\tgetSubject: function(selectVariable) {\r\n\t\t\t\treturn this.subject\r\n\t\t\t},\r\n\t\r\n\t\t\tgetUpdates: function(since) {\r\n\t\t\t\tvar updates = []\r\n\t\t\t\tvar nextUpdateMap = this.nextUpdateMap\r\n\t\t\t\tif (nextUpdateMap && since) {\r\n\t\t\t\t\twhile ((since = nextUpdateMap.get(since))) {\r\n\t\t\t\t\t\tif (since.type === 'refresh') {\r\n\t\t\t\t\t\t\t// if it was refresh, we can clear any prior entries\r\n\t\t\t\t\t\t\tupdates = []\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tupdates.push(since)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn updates\r\n\t\t\t},\r\n\t\r\n\t\t\tupdated: function(updateEvent, by, context) {\r\n\t\t\t\tif (!updateEvent) {\r\n\t\t\t\t\tupdateEvent = new RefreshEvent()\r\n\t\t\t\t}\r\n\t\t\t\tif (updateEvent.visited.has(this)){\r\n\t\t\t\t\t// if this event has already visited this variable, skip it\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t\tupdateEvent.visited.add(this)\r\n\t\t\t\tvar contextualInstance = context ? context.getContextualized(this) : this\r\n\t\t\t\tif (contextualInstance) {\r\n\t\t\t\t\tcontextualInstance.updated(updateEvent, this, context)\r\n\t\t\t\t}\r\n\t\t\t\t/*\r\n\t\t\t\t// at some point we could do an update list so that we could incrementally update\r\n\t\t\t\t// lists in non-live situations\r\n\t\t\t\tif (this.lastUpdate) {\r\n\t\t\t\t\tvar nextUpdateMap = this.nextUpdateMap\r\n\t\t\t\t\tif (!nextUpdateMap) {\r\n\t\t\t\t\t\tnextUpdateMap = this.nextUpdateMap = new WeakMap()\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnextUpdateMap.set(this.lastUpdate, updateEvent)\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.lastUpdate = updateEvent */\r\n\t\t\t\tthis.updateVersion()\r\n\t\t\t\tvar value = this.value\r\n\t\r\n\t\t\t\tvar listeners = this.listeners\r\n\t\t\t\tif (listeners) {\r\n\t\t\t\t\tvar variable = this\r\n\t\t\t\t\t// make a copy, in case they change\r\n\t\t\t\t\tlisteners.forEach(function(dependent) {\r\n\t\t\t\t\t\tif ((updateEvent instanceof PropertyChangeEvent) &&\r\n\t\t\t\t\t\t\t\t(dependent instanceof Property)) {\r\n\t\t\t\t\t\t\tif (dependent.key === updateEvent.key) {\r\n\t\t\t\t\t\t\t\tdependent.updated(updateEvent.childEvent, variable, context)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tdependent.updated(updateEvent, variable, context)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t\tif (updateEvent instanceof PropertyChangeEvent) {\r\n\t\t\t\t\tif (this.returnedVariable && this.fixed) {\r\n\t\t\t\t\t\tthis.returnedVariable.updated(updateEvent, this, context)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (this.constructor.collection) {\r\n\t\t\t\t\t\tthis.constructor.collection.updated(updateEvent, this, context)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn updateEvent\r\n\t\t\t},\r\n\t\r\n\t\t\tinvalidate: function() {\r\n\t\t\t\t// for back-compatibility for now\r\n\t\t\t\tthis.updated()\r\n\t\t\t},\r\n\t\r\n\t\t\tnotifies: function(target) {\r\n\t\t\t\tvar listeners = this.listeners\r\n\t\t\t\tif (!listeners || !this.hasOwnProperty('listeners')) {\r\n\t\t\t\t\tthis.listeners = listeners = new Set()\r\n\t\t\t\t\tthis.init()\r\n\t\t\t\t}\r\n\t\t\t\tlisteners.add(target)\r\n\t\t\t},\r\n\t\t\tsubscribe: function(listener) {\r\n\t\t\t\t// ES7 Observable (and baconjs) compatible API\r\n\t\t\t\tvar updated\r\n\t\t\t\tvar updateQueued\r\n\t\t\t\tvar variable = this\r\n\t\t\t\t// it is important to make sure you register for notifications before getting the value\r\n\t\t\t\tif (typeof listener === 'function') {\r\n\t\t\t\t\t// BaconJS compatible API\r\n\t\t\t\t\tvar variable = this\r\n\t\t\t\t\tvar event = {\r\n\t\t\t\t\t\tvalue: function() {\r\n\t\t\t\t\t\t\treturn variable.valueOf()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tupdated = function() {\r\n\t\t\t\t\t\tupdateQueued = false\r\n\t\t\t\t\t\tlistener(event)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\telse if (listener.next) {\r\n\t\t\t\t\t// Assuming ES7 Observable API. It is actually a streaming API, this pretty much violates all principles of reactivity, but we will support it\r\n\t\t\t\t\tupdated = function() {\r\n\t\t\t\t\t\tupdateQueued = false\r\n\t\t\t\t\t\tlistener.next(variable.valueOf())\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow new Error('Subscribing to an invalid listener, the listener must be a function, or have an update or next method')\r\n\t\t\t\t}\r\n\t\t\t\tvar updateReceiver = {\r\n\t\t\t\t\tupdated: function() {\r\n\t\t\t\t\t\tif (updateQueued) {\r\n\t\t\t\t\t\t\treturn\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tupdateQueued = true\r\n\t\t\t\t\t\tlang.nextTurn(updated)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tupdated()\r\n\t\t\t\tthis.notifies(updateReceiver)\r\n\t\t\t\treturn {\r\n\t\t\t\t\tunsubscribe: function() {\r\n\t\t\t\t\t\tvariable.stopNotifies(updateReceiver)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tstopNotifies: function(dependent) {\r\n\t\t\t\tvar listeners = this.listeners\r\n\t\t\t\tif (listeners) {\r\n\t\t\t\t\tlisteners.delete(dependent)\r\n\t\t\t\t\tif (listeners.size === 0) {\r\n\t\t\t\t\t\t// clear the listeners so it will be reinitialized if it has\r\n\t\t\t\t\t\t// listeners again\r\n\t\t\t\t\t\tthis.cleanup()\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tput: function(value, context) {\r\n\t\t\t\tvar variable = this\r\n\t\t\t\tif (this.ownObject) {\r\n\t\t\t\t\tthis.ownObject = false\r\n\t\t\t\t}\t\t\r\n\t\t\t\treturn when(this.getValue ? this.getValue(context) : this.value, function(oldValue) {\r\n\t\t\t\t\tif (variable.__debug) {\r\n\t\t\t\t\t\t// _debug _debug is on\r\n\t\t\t\t\t\tconsole.log('Variable changed from', oldValue, newValue, 'at')\r\n\t\t\t\t\t\tconsole.log((new Error().stack || '').replace(/Error/, ''))\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (oldValue === value) {\r\n\t\t\t\t\t\treturn noChange\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (variable.fixed &&\r\n\t\t\t\t\t\t\t// if it is set to fixed, we see we can put in the current variable\r\n\t\t\t\t\t\t\toldValue && oldValue.put) {\r\n\t\t\t\t\t\treturn oldValue.put(value)\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn when(variable.setValue(value, context), function(value) {\r\n\t\t\t\t\t\tvariable.updated(new RefreshEvent(), variable, context)\r\n\t\t\t\t\t})\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tget: function(key) {\r\n\t\t\t\tif (this._properties && this._properties[key]) {\r\n\t\t\t\t\treturn this.property(key).valueOf()\r\n\t\t\t\t}\r\n\t\t\t\treturn when(this.valueOf(), function(object) {\r\n\t\t\t\t\tvar value = object && (typeof object.get === 'function' ? object.get(key) : object[key])\r\n\t\t\t\t\tif (value && value.notifies) {\r\n\t\t\t\t\t\t// nested variable situation, get underlying value\r\n\t\t\t\t\t\treturn value.valueOf()\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn value\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tset: function(key, value) {\r\n\t\t\t\t// TODO: create an optimized route when the property doesn't exist yet\r\n\t\t\t\tthis.property(key)._changeValue(null, RequestSet, value)\r\n\t\t\t},\r\n\t\t\tundefine: function(key, context) {\r\n\t\t\t\tthis.set(key, undefined, context)\r\n\t\t\t},\r\n\t\t\tproxy: function(proxiedVariable) {\r\n\t\t\t\tvar thisVariable = this\r\n\t\t\t\tthis.fixed = true\r\n\t\t\t\treturn when(this.setValue(proxiedVariable), function(value) {\r\n\t\t\t\t\tthisVariable.updated(new RefreshEvent(), thisVariable)\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tnext: function(value) {\r\n\t\t\t\t// for ES7 observable compatibility\r\n\t\t\t\tthis.put(value)\r\n\t\t\t},\r\n\t\t\terror: function(error) {\r\n\t\t\t\t// for ES7 observable compatibility\r\n\t\t\t\tvar listeners = this.listeners\r\n\t\t\t\tif (listeners) {\r\n\t\t\t\t\t// make a copy, in case they change\r\n\t\t\t\t\tlisteners.forEach(function(dependent) {\r\n\t\t\t\t\t\t// skip notifying property listeners if we are headed up the parent chain\r\n\t\t\t\t\t\tdependent.error(error)\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tcomplete: function(value) {\r\n\t\t\t\t// for ES7 observable compatibility\r\n\t\t\t\tthis.put(value)\r\n\t\t\t},\r\n\t\t\tsetValue: function(value) {\r\n\t\t\t\tthis.value = value\r\n\t\t\t},\r\n\t\t\tonValue: function(listener) {\r\n\t\t\t\treturn this.subscribe(function(event) {\r\n\t\t\t\t\tlang.when(event.value(), function(value) {\r\n\t\t\t\t\t\tlistener(value)\r\n\t\t\t\t\t})\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\ttoJSON: function() {\r\n\t\t\t\treturn this.valueOf()\r\n\t\t\t},\r\n\t\t\ttoString: function() {\r\n\t\t\t\treturn this.valueOf()\r\n\t\t\t},\r\n\t\t\tforEach: function(callbackOrItemClass, callbackOrContext, context) {\r\n\t\t\t\t// iterate through current value of variable\r\n\t\t\t\tif (callbackOrItemClass.notifies) {\r\n\t\t\t\t\tvar collectionVariable = this\r\n\t\t\t\t\treturn this.forEach(function(item) {\r\n\t\t\t\t\t\tvar itemVariable = callbackOrItemClass.from(item)\r\n\t\t\t\t\t\tcallbackOrContext.call(this, itemVariable)\r\n\t\t\t\t\t}, context)\r\n\t\t\t\t}\r\n\t\t\t\treturn when(this.valueOf(callbackOrContext), function(value) {\r\n\t\t\t\t\tif (value && value.forEach) {\r\n\t\t\t\t\t\tvalue.forEach(callbackOrItemClass)\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tfor (var i in value) {\r\n\t\t\t\t\t\t\tcallbackOrItemClass.call(value, value[i], i)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\r\n\t\t\tto: function (transformFunction, reverse) {\r\n\t\t\t\tif (typeof transformFunction !== 'function') {\r\n\t\t\t\t\tif (typeof transformFunction === 'object') {\r\n\t\t\t\t\t\tthis.to(transformFunction.get, transformFunction.set)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthrow new Error('No function provided to transform')\r\n\t\t\t\t}\r\n\t\t\t\tif (reverse) {\r\n\t\t\t\t\ttransformFunction.reverse = function(value, args, context) {\r\n\t\t\t\t\t\t// for direct to, we can just use the first argument\r\n\t\t\t\t\t\treverse.call(this, args[0], context)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn new Call(transformFunction, [this])\r\n\t\t\t},\r\n\t\t\tget schema() {\r\n\t\t\t\t// default schema is the constructor\r\n\t\t\t\treturn this.returnedVariable ? this.returnedVariable.schema : this.constructor\r\n\t\t\t},\r\n\t\t\tset schema(schema) {\r\n\t\t\t\t// but allow it to be overriden\r\n\t\t\t\tObject.defineProperty(this, 'schema', {\r\n\t\t\t\t\tvalue: schema\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tvalidate: function(target, schema) {\r\n\t\t\t\tif (this.returnedVariable) {\r\n\t\t\t\t\treturn this.returnedVariable.validate(target, schema)\r\n\t\t\t\t}\r\n\t\t\t\tif (schema.type && (schema.type !== typeof target)) {\r\n\t\t\t\t\treturn ['Target type of ' + typeof target + ' does not match schema type of ' + schema.type]\r\n\t\t\t\t}\r\n\t\t\t\tvar valid = []\r\n\t\t\t\tvalid.isValid = true\r\n\t\t\t\treturn valid\r\n\t\t\t},\r\n\t\r\n\t\t\tget validation() {\r\n\t\t\t\tvar validation = new Validating(this)\r\n\t\t\t\tObject.defineProperty(this, 'validation', {\r\n\t\t\t\t\tvalue: validation\r\n\t\t\t\t})\r\n\t\t\t\treturn validation\r\n\t\t\t},\r\n\t\t\tset validation(validation) {\r\n\t\t\t\t// but allow it to be overriden\r\n\t\t\t\tObject.defineProperty(this, 'validation', {\r\n\t\t\t\t\tvalue: validation\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tgetId: function() {\r\n\t\t\t\treturn this.id || (this.id = nextId++)\r\n\t\t\t},\r\n\t\t\tobserveObject: function() {\r\n\t\t\t\tvar variable = this\r\n\t\t\t\treturn when(this.valueOf(), function(object) {\r\n\t\t\t\t\tvar listeners = propertyListenersMap.get(object)\r\n\t\t\t\t\tif (!listeners) {\r\n\t\t\t\t\t\tpropertyListenersMap.set(object, listeners = [])\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (listeners.observerCount) {\r\n\t\t\t\t\t\tlisteners.observerCount++\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tlisteners.observerCount = 1\r\n\t\t\t\t\t\tvar observer = listeners.observer = lang.observe(object, function(events) {\r\n\t\t\t\t\t\t\tfor (var i = 0, l = listeners.length; i < l; i++) {\r\n\t\t\t\t\t\t\t\tvar listener = listeners[i]\r\n\t\t\t\t\t\t\t\tfor (var j = 0, el = events.length; j < el; j++) {\r\n\t\t\t\t\t\t\t\t\tvar event = events[j]\r\n\t\t\t\t\t\t\t\t\tlistener._propertyChange(event.name, object)\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t\tif (observer.addKey) {\r\n\t\t\t\t\t\t\tfor (var i = 0, l = listeners.length; i < l; i++) {\r\n\t\t\t\t\t\t\t\tvar listener = listeners[i]\r\n\t\t\t\t\t\t\t\tlistener.eachKey(function(key) {\r\n\t\t\t\t\t\t\t\t\tobserver.addKey(key)\r\n\t\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tregisterListener(object, variable)\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tremove: function() {\r\n\t\t\t\t\t\t\tderegisterListener(object, variable)\r\n\t\t\t\t\t\t\tif (!(--listeners.observerCount)) {\r\n\t\t\t\t\t\t\t\tlisteners.observer.remove()\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tdone: function() {\r\n\t\t\t\t\t\t\t// deliver changes\r\n\t\t\t\t\t\t\tlang.deliverChanges(observer)\r\n\t\t\t\t\t\t\tthis.remove()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tgetCollectionOf: function() {\r\n\t\t\t\treturn this.constructor.collectionOf\r\n\t\t\t},\r\n\t\t\t_willModify: function(context) {\r\n\t\t\t\t// an intent to modify, so we need to make sure we have our own copy\r\n\t\t\t\t// of an object when necessary\r\n\t\t\t\tif (this.fixed) {\r\n\t\t\t\t\tif (this.value && this.value._willModify) {\r\n\t\t\t\t\t\treturn this.value._willModify(context)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (!this.ownObject && this.value && this.value.notifies) {\r\n\t\t\t\t\tvar variable = this\r\n\t\t\t\t\treturn when(this.valueOf(context), function(value) {\r\n\t\t\t\t\t\tif (value && typeof value === 'object') {\r\n\t\t\t\t\t\t\tif (value instanceof Array) {\r\n\t\t\t\t\t\t\t\tvariable.ownObject = value.slice(0)\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tvariable.ownObject = Object.create(value)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\t_sN: function(name) {\r\n\t\t\t\t// for compilers to set a name\r\n\t\t\t\tthis.name = name\r\n\t\t\t\treturn this\r\n\t\t\t},\r\n\t\t\tget _debug() {\r\n\t\t\t\tif (this.__debug === undefined) {\r\n\t\t\t\t\tthis.__debug = true\r\n\t\t\t\t}\r\n\t\t\t\treturn this.__debug\r\n\t\t\t},\r\n\t\t\tset _debug(_debug) {\r\n\t\t\t\tthis.__debug = _debug\r\n\t\t\t},\r\n\t\t\t// TODO: Move these to VArray\r\n\t\t\tsplice: function(startingIndex, removalCount) {\r\n\t\t\t\tvar args = arguments\r\n\t\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\t\tvar results = array.splice.apply(array, args)\r\n\t\t\t\t\tremovedAt(this, results, startingIndex, removalCount, array.length)\r\n\t\t\t\t\tinsertedAt(this, [].slice.call(args, 2), startingIndex, array.length)\r\n\t\t\t\t\treturn results\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tpush: function() {\r\n\t\t\t\tvar args = arguments\r\n\t\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\t\tvar results = array.push.apply(array, args)\r\n\t\t\t\t\tinsertedAt(this, args, array.length - args.length, array.length)\r\n\t\t\t\t\treturn results\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tunshift: function() {\r\n\t\t\t\tvar args = arguments\r\n\t\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\t\tvar results = array.unshift.apply(array, args)\r\n\t\t\t\t\tinsertedAt(this, args, 0, array.length)\r\n\t\t\t\t\treturn results\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tpop: function() {\r\n\t\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\t\tvar results = array.pop()\r\n\t\t\t\t\tremovedAt(this, [results], array.length, 1)\r\n\t\t\t\t\treturn results\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tshift: function() {\r\n\t\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\t\tvar results = array.shift()\r\n\t\t\t\t\tremovedAt(this, [results], 0, 1, array.length)\r\n\t\t\t\t\treturn results\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction arrayToModify(variable, callback) {\r\n\t\t\tvariable._willModify()\r\n\t\t\t// TODO: switch this to allow promises\r\n\t\t\twhen(variable.cachedValue || variable.valueOf(), function(array) {\r\n\t\t\t\tif (!array) {\r\n\t\t\t\t\tvariable.put(array = [])\r\n\t\t\t\t}\r\n\t\t\t\tvariable.updateVersion()\r\n\t\t\t\tvar results = callback.call(variable, array)\r\n\t\t\t\tvariable.cachedVersion = variable.version // update the cached version so it doesn't need to be recomputed\r\n\t\t\t\treturn results\r\n\t\t\t})\r\n\t\t}\r\n\t\r\n\t\tfunction insertedAt(variable, added, startingIndex, arrayLength) {\r\n\t\t\tvar addedCount = added.length\r\n\t\t\t// adjust the key positions of any index properties after splice\r\n\t\t\tif (addedCount > 0) {\r\n\t\t\t\tif (variable._properties) {\r\n\t\t\t\t\tvar arrayPosition\r\n\t\t\t\t\tfor (var i = arrayLength - addedCount; i > startingIndex;) {\r\n\t\t\t\t\t\tvar arrayPosition = variable._properties[--i]\r\n\t\t\t\t\t\tif (arrayPosition) {\r\n\t\t\t\t\t\t\tvariable._properties[i] = undefined\r\n\t\t\t\t\t\t\tarrayPosition.key += addedCount\r\n\t\t\t\t\t\t\tvariable._properties[arrayPosition.key] = arrayPosition\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// send out updates\r\n\t\t\t\tfor (var i = 0, l = added.length; i < l; i++) {\r\n\t\t\t\t\tvariable.updated(new AddEvent({\r\n\t\t\t\t\t\tvalue: added[i],\r\n\t\t\t\t\t\tindex: i + startingIndex,\r\n\t\t\t\t\t\tmodifier: variable\r\n\t\t\t\t\t}), variable)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction removedAt(variable, removed, startingIndex, removalCount, arrayLength) {\r\n\t\t\t// adjust the properties\r\n\t\t\tvar i = startingIndex + removalCount\r\n\t\t\tvar arrayPosition\r\n\t\t\tif (removalCount > 0) {\r\n\t\t\t\tif (variable._properties) {\r\n\t\t\t\t\tfor (var i = startingIndex + removalCount; i < arrayLength + removalCount; i++) {\r\n\t\t\t\t\t\tvar arrayPosition = variable._properties[i]\r\n\t\t\t\t\t\tif (arrayPosition) {\r\n\t\t\t\t\t\t\tvariable._properties[i] = undefined\r\n\t\t\t\t\t\t\tarrayPosition.key -= removalCount\r\n\t\t\t\t\t\t\tvariable._properties[arrayPosition.key] = arrayPosition\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// send out updates\r\n\t\t\t\tfor (var i = 0; i < removalCount; i++) {\r\n\t\t\t\t\tvariable.updated(new DeleteEvent({\r\n\t\t\t\t\t\tpreviousIndex: startingIndex,\r\n\t\t\t\t\t\toldValue: removed[i],\r\n\t\t\t\t\t\tmodifier: variable\r\n\t\t\t\t\t}), variable)\r\n\t\t\t\t}\r\n\t\t\t\tvariable.cachedVersion = variable.version // update the cached version so it doesn't need to be recomputed\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tif (typeof Symbol !== 'undefined') {\r\n\t\t\tVariable.prototype[Symbol.iterator] = function() {\r\n\t\t\t\treturn this.valueOf()[Symbol.iterator]()\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tVariable.VMap = lang.compose(Variable, function(value){\r\n\t\t\tthis.value = typeof value === 'undefined' ? this.default : value\r\n\t\t}, {\r\n\t\t\t// TODO: Move all the get and set functionality for maps out of Variable\r\n\t\t\tproperty: function(key) {\r\n\t\t\t\tvar properties = this._properties || (this._properties = new Map())\r\n\t\t\t\tvar propertyVariable = properties.get(key)\r\n\t\t\t\tif (!propertyVariable) {\r\n\t\t\t\t\t// create the property variable\r\n\t\t\t\t\tpropertyVariable = new Property(this, key)\r\n\t\t\t\t\tproperties.set(key, propertyVariable)\r\n\t\t\t\t}\r\n\t\t\t\treturn propertyVariable\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\tvar cacheNotFound = {}\r\n\t\tvar Caching = Variable.Caching = lang.compose(Variable, function(getValue, setValue) {\r\n\t\t\tif (getValue) {\r\n\t\t\t\tthis.getValue = getValue\r\n\t\t\t}\r\n\t\t\tif (setValue) {\r\n\t\t\t\tthis.setValue = setValue\r\n\t\t\t}\r\n\t\t}, {\r\n\t\t\tvalueOf: function(context) {\r\n\t\t\t\t// first check to see if we have the variable already computed\r\n\t\t\t\tvar contextualizedVariable = this\r\n\t\t\t\tif (context) {\r\n\t\t\t\t\tcontextualizedVariable = context.getContextualized(this)\r\n\t\t\t\t\tif (!contextualizedVariable && this.context && this.context.matches(context)) {\r\n\t\t\t\t\t\tcontextualizedVariable = this\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (contextualizedVariable && contextualizedVariable.cachedVersion === contextualizedVariable.getVersion()) {\r\n\t\t\t\t\tif (context) {\r\n\t\t\t\t\t\tcontext.addInput(contextualizedVariable)\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn contextualizedVariable.cachedValue\r\n\t\t\t\t}\t\t\t\r\n\t\r\n\t\t\t\tvar variable = this\r\n\t\t\t\tfunction withComputedValue(computedValue) {\r\n\t\t\t\t\tif (computedValue && computedValue.notifies && variable.listeners) {\r\n\t\t\t\t\t\tvariable.computedVariable = computedValue\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcomputedValue = variable.gotValue(computedValue, context, transformContext)\r\n\t\t\t\t\tvar contextualizedVariable = transformContext && transformContext.contextualized || variable\r\n\t\t\t\t\tcontextualizedVariable.cachedVersion = newVersion\r\n\t\t\t\t\tcontextualizedVariable.cachedValue = computedValue\r\n\t\t\t\t\tcontextualizedVariable.context = transformContext\r\n\t\t\t\t\treturn computedValue\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar transformContext\r\n\t\t\t\tif (context) {\r\n\t\t\t\t\ttransformContext = context.newContext()\r\n\t\t\t\t}\r\n\t\t\t\tvar newVersion = this.getVersion()\r\n\t\t\t\tvar computedValue = this.getValue(transformContext)\r\n\t\t\t\tif (computedValue && computedValue.then) {\r\n\t\t\t\t\t// call it initially so the dependencies can be registered\r\n\t\t\t\t\tthis.gotValue(null, context, transformContext)\r\n\t\t\t\t\treturn computedValue.then(withComputedValue)\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn withComputedValue(computedValue)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\tfunction GetCache() {\r\n\t\t}\r\n\t\r\n\t\tvar Property = lang.compose(Variable, function Property(parent, key) {\r\n\t\t\tthis.parent = parent\r\n\t\t\tthis.key = key\r\n\t\t},\r\n\t\t{\r\n\t\t\tforDependencies: function(callback) {\r\n\t\t\t\tVariable.prototype.forDependencies.call(this, callback)\r\n\t\t\t\tcallback(this.parent)\r\n\t\t\t},\r\n\t\t\tvalueOf: function(context) {\r\n\t\t\t\tif (context) {\r\n\t\t\t\t\tvar propertyContext = context.newContext()\r\n\t\t\t\t\tpropertyContext.nextProperty = 'parent'\r\n\t\t\t\t}\r\n\t\t\t\tvar key = this.key\r\n\t\t\t\tvar property = this\r\n\t\t\t\tvar object = this.parent.valueOf(propertyContext)\r\n\t\t\t\tfunction gotValueAndListen(object) {\r\n\t\t\t\t\tvar value = property.gotValue(object == null ? undefined : typeof object.get === 'function' ? object.get(key) : object[key], context, propertyContext)\r\n\t\t\t\t\tif (property.listeners) {\r\n\t\t\t\t\t\tvar listeners = propertyListenersMap.get(object)\r\n\t\t\t\t\t\tif (listeners && listeners.observer && listeners.observer.addKey) {\r\n\t\t\t\t\t\t\tlisteners.observer.addKey(key)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn value\r\n\t\t\t\t}\r\n\t\t\t\tif (object && object.then) {\r\n\t\t\t\t\t// call it initially so the dependencies can be registered\r\n\t\t\t\t\tthis.gotValue(null, context, propertyContext)\r\n\t\t\t\t\treturn when(object, gotValueAndListen)\r\n\t\t\t\t}\r\n\t\t\t\treturn gotValueAndListen(object)\r\n\t\t\t},\r\n\t\t\tput: function(value, context) {\r\n\t\t\t\treturn this._changeValue(context, RequestChange, value)\r\n\t\t\t},\r\n\t\t\tparentUpdated: function(updateEvent, context) {\r\n\t\t\t\treturn Variable.prototype.updated.call(this, updateEvent, this.parent, context)\r\n\t\t\t},\r\n\t\t\tupdated: function(updateEvent, by, context) {\r\n\t\t\t\tif (updateEvent = Variable.prototype.updated.call(this, updateEvent, by, context)) {\r\n\t\t\t\t\tthis.parent.updated(new PropertyChangeEvent(this.key, updateEvent, this.parent), this, context)\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tfor: function(subject) {\r\n\t\t\t\treturn this.parent.for(subject).property(this.key)\r\n\t\t\t},\r\n\t\t\t_changeValue: function(context, type, newValue) {\r\n\t\t\t\tvar key = this.key\r\n\t\t\t\tvar parent = this.parent\r\n\t\t\t\tvar variable = this\r\n\t\t\t\tparent._willModify(context)\r\n\t\t\t\treturn when(parent.valueOf(context), function(object) {\r\n\t\t\t\t\tif (object == null) {\r\n\t\t\t\t\t\t// nothing there yet, create an object to hold the new property\r\n\t\t\t\t\t\tvar response = parent.put(object = typeof key == 'number' ? [] : {}, context)\r\n\t\t\t\t\t} else if (typeof object != 'object') {\r\n\t\t\t\t\t\t// if the parent is not an object, we can't set anything (that will be retained)\r\n\t\t\t\t\t\treturn deny\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar oldValue = typeof object.get === 'function' ? object.get(key) : object[key]\r\n\t\t\t\t\tif (oldValue === newValue) {\r\n\t\t\t\t\t\t// no actual change to make\r\n\t\t\t\t\t\treturn noChange\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (variable.__debug) {\r\n\t\t\t\t\t\t// debug is on\r\n\t\t\t\t\t\tconsole.log('Variable changed from', oldValue, newValue, 'at')\r\n\t\t\t\t\t\tconsole.log((new Error().stack || '').replace(/Error/, ''))\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (typeof object.set === 'function') {\r\n\t\t\t\t\t\tobject.set(key, newValue)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (type == RequestChange && oldValue && oldValue.put) {\r\n\t\t\t\t\t\t\t// if a put and the property value is a variable, assign it to that.\r\n\t\t\t\t\t\t\toldValue.put(newValue)\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tobject[key] = newValue\r\n\t\t\t\t\t\t\t// or set the setter/getter\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvariable.updated(null, variable, context)\r\n\t\r\n\t\t\t\t\t// now notify any object listeners\r\n\t\t\t\t\tvar listeners = propertyListenersMap.get(object)\r\n\t\t\t\t\t// we need to do it before the other listeners, so we can update it before\r\n\t\t\t\t\t// we trigger a full clobbering of the object\r\n\t\t\t\t\tif (listeners) {\r\n\t\t\t\t\t\tlisteners = listeners.slice(0)\r\n\t\t\t\t\t\tfor (var i = 0, l = listeners.length; i < l; i++) {\r\n\t\t\t\t\t\t\tvar listener = listeners[i]\r\n\t\t\t\t\t\t\tif (listener !== parent) {\r\n\t\t\t\t\t\t\t\t// now go ahead and actually trigger the other listeners (but make sure we don't do the parent again)\r\n\t\t\t\t\t\t\t\tlistener._propertyChange(key, object, context, type)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\t_willModify: function() {\r\n\t\t\t\tthis.parent._willModify()\r\n\t\t\t\treturn Variable.prototype._willModify.call(this)\r\n\t\t\t},\r\n\t\t\tvalidate: function(target, schema) {\r\n\t\t\t\treturn this.parent.validate(target.valueOf(), schema)\r\n\t\t\t}\r\n\t\t})\r\n\t\tObject.defineProperty(Property.prototype, 'schema', {\r\n\t\t\tget: function() {\r\n\t\t\t\tvar parentSchemaProperties = this.parent.schema.properties\r\n\t\t\t\treturn parentSchemaProperties && parentSchemaProperties[this.key]\r\n\t\t\t},\r\n\t\t\tset: function(schema) {\r\n\t\t\t\t// have to repeat the override\r\n\t\t\t\tObject.defineProperty(this, 'schema', {\r\n\t\t\t\t\tvalue: schema\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t})\r\n\t\tVariable.Property = Property\r\n\t\r\n\t\tvar Item = Variable.Item = lang.compose(Variable, function Item(value, content) {\r\n\t\t\tthis.value = value\r\n\t\t\tthis.collection = content\r\n\t\t}, {})\r\n\t\r\n\t\tvar Composite = Variable.Composite = lang.compose(Caching, function Composite(args) {\r\n\t\t\tfor (var i = 0, l = args.length; i < l; i++) {\r\n\t\t\t\tthis['argument' + i] = args[i]\r\n\t\t\t}\r\n\t\t}, {\r\n\t\t\tforDependencies: function(callback) {\r\n\t\t\t\t// depend on the args\r\n\t\t\t\tCaching.prototype.forDependencies.call(this, callback)\r\n\t\t\t\tvar argument, argumentName\r\n\t\t\t\tfor (var i = 0; (argument = this[argumentName = 'argument' + i]) || argumentName in this; i++) {\r\n\t\t\t\t\tif (argument && argument.notifies) {\r\n\t\t\t\t\t\tcallback(argument)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\r\n\t\t\tupdated: function(updateEvent, by, context) {\r\n\t\t\t\tif (by !== this.returnedVariable && updateEvent && updateEvent.type !== 'refresh') {\r\n\t\t\t\t\t// search for the output in the inputs\r\n\t\t\t\t\tvar argument, argumentName\r\n\t\t\t\t\tfor (var i = 0; (argument = this[argumentName = 'argument' + i]) || argumentName in this; i++) {\r\n\t\t\t\t\t\tif (argument === by) {\r\n\t\t\t\t\t\t\t// if one of the args was updated, we need to do a full refresh (we can't compute differential events without knowledge of how the mapping function works)\r\n\t\t\t\t\t\t\tupdateEvent = new RefreshEvent()\r\n\t\t\t\t\t\t\tcontinue\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn Caching.prototype.updated.call(this, updateEvent, by, context)\r\n\t\t\t},\r\n\t\r\n\t\t\tgetUpdates: function(since) {\r\n\t\t\t\t// this always issues updates, nothing incremental can flow through it\r\n\t\t\t\tif (!since || since.version < getVersion()) {\r\n\t\t\t\t\treturn [new RefreshEvent()]\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\r\n\t\t\tgetVersion: function(context) {\r\n\t\t\t\tvar version = Variable.prototype.getVersion.call(this, context)\r\n\t\t\t\tvar argument, argumentName\r\n\t\t\t\tfor (var i = 0; (argument = this[argumentName = 'argument' + i]) || argumentName in this; i++) {\r\n\t\t\t\t\tif (argument && argument.getVersion) {\r\n\t\t\t\t\t\tversion = Math.max(version, argument.getVersion(context))\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn version\r\n\t\t\t},\r\n\t\r\n\t\t\tgetValue: function(context) {\r\n\t\t\t\tvar results = []\r\n\t\t\t\tvar argument, argumentName\r\n\t\t\t\tfor (var i = 0; (argument = this[argumentName = 'argument' + i]) || argumentName in this; i++) {\r\n\t\t\t\t\tif (context) {\r\n\t\t\t\t\t\tcontext.nextProperty = argumentName\r\n\t\t\t\t\t}\r\n\t\t\t\t\tresults[i] = argument && argument.valueOf(context)\r\n\t\t\t\t}\r\n\t\t\t\treturn whenAll(results, function(resolved) {\r\n\t\t\t\t\treturn resolved\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tgetArguments: function() {\r\n\t\t\t\tvar args = []\r\n\t\t\t\tvar argument, argumentName\r\n\t\t\t\tfor (var i = 0; (argument = this[argumentName = 'argument' + i]) || argumentName in this; i++) {\r\n\t\t\t\t\targs.push(argument)\r\n\t\t\t\t}\r\n\t\t\t\treturn args\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\t// a call variable is the result of a call\r\n\t\tvar Call = lang.compose(Composite, function Transform(transform, args) {\r\n\t\t\tthis.transform = transform\r\n\t\t\tfor (var i = 0, l = args.length; i < l; i++) {\r\n\t\t\t\tthis['argument' + i] = args[i]\r\n\t\t\t}\r\n\t\t}, {\r\n\t\t\tfixed: true,\r\n\t\t\tforDependencies: function(callback) {\r\n\t\t\t\t// depend on the args\r\n\t\t\t\tComposite.prototype.forDependencies.call(this, callback)\r\n\t\t\t\tif (this.transform.notifies) {\r\n\t\t\t\t\tcallback(this.transform)\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\r\n\t\t\tgetValue: function(context) {\r\n\t\t\t\tif (context) {\r\n\t\t\t\t\tcontext.nextProperty = 'transform'\r\n\t\t\t\t}\r\n\t\t\t\tvar functionValue = this.transform.valueOf(context)\r\n\t\t\t\tif (functionValue.then) {\r\n\t\t\t\t\tvar call = this\r\n\t\t\t\t\treturn functionValue.then(function(functionValue) {\r\n\t\t\t\t\t\treturn call.invoke(functionValue, context)\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t\treturn this.invoke(functionValue, context)\r\n\t\t\t},\r\n\t\r\n\t\t\tgetVersion: function(context) {\r\n\t\t\t\t// TODO: shortcut if we are live and since equals this.lastUpdate\r\n\t\t\t\tvar argsVersion = Composite.prototype.getVersion.call(this, context)\r\n\t\t\t\tif (this.transform.getVersion) {\r\n\t\t\t\t\treturn Math.max(argsVersion, this.transform.getVersion(context))\r\n\t\t\t\t}\r\n\t\t\t\treturn argsVersion\r\n\t\t\t},\r\n\t\r\n\t\t\texecute: function(context) {\r\n\t\t\t\tvar call = this\r\n\t\t\t\treturn when(this.transform.valueOf(context), function(functionValue) {\r\n\t\t\t\t\treturn call.invoke(functionValue, context, true)\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\r\n\t\t\tput: function(value, context) {\r\n\t\t\t\tvar call = this\r\n\t\t\t\treturn when(this.valueOf(context), function(originalValue) {\r\n\t\t\t\t\tif (originalValue === value) {\r\n\t\t\t\t\t\treturn noChange\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn when(call.transform.valueOf(context), function(functionValue) {\r\n\t\t\t\t\t\treturn call.invoke(function() {\r\n\t\t\t\t\t\t\tif (functionValue.reverse) {\r\n\t\t\t\t\t\t\t\tfunctionValue.reverse.call(call, value, call.getArguments(), context)\r\n\t\t\t\t\t\t\t\treturn Variable.prototype.put.call(call, value, context)\r\n\t\t\t\t\t\t\t} else if (originalValue && originalValue.put) {\r\n\t\t\t\t\t\t\t\treturn originalValue.put(value)\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\treturn deny\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}, context)\r\n\t\t\t\t\t});\t\t\t\t\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tinvoke: function(functionValue, context, observeArguments) {\r\n\t\t\t\tvar instance = this.transform.parent\r\n\t\t\t\tif (functionValue.handlesVariables || functionValue.property) {\r\n\t\t\t\t\treturn functionValue.apply(instance, this.getArguments(), context)\r\n\t\t\t\t}else{\r\n\t\t\t\t\tvar results = []\r\n\t\t\t\t\tvar argument, argumentName\r\n\t\t\t\t\tfor (var i = 0; (argument = this[argumentName = 'argument' + i]) || argumentName in this; i++) {\r\n\t\t\t\t\t\tif (context) {\r\n\t\t\t\t\t\t\tcontext.nextProperty = argumentName\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tresults[i] = argument && argument.valueOf(context)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tinstance = instance && instance.valueOf(context)\r\n\t\t\t\t\tif (functionValue.handlesPromises) {\r\n\t\t\t\t\t\treturn functionValue.apply(instance, results, context)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// include the instance in whenAll\r\n\t\t\t\t\t\tresults.push(instance)\r\n\t\t\t\t\t\t// wait for the values to be received\r\n\t\t\t\t\t\treturn whenAll(results, function(inputs) {\r\n\t\t\t\t\t\t\tif (observeArguments) {\r\n\t\t\t\t\t\t\t\tvar handles = []\r\n\t\t\t\t\t\t\t\tfor (var i = 0, l = inputs.length; i < l; i++) {\r\n\t\t\t\t\t\t\t\t\tvar input = inputs[i]\r\n\t\t\t\t\t\t\t\t\tif (input && typeof input === 'object') {\r\n\t\t\t\t\t\t\t\t\t\thandles.push(observe(input))\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tvar instance = inputs.pop()\r\n\t\t\t\t\t\t\t\ttry{\r\n\t\t\t\t\t\t\t\t\tvar result = functionValue.apply(instance, inputs, context)\r\n\t\t\t\t\t\t\t\t}finally{\r\n\t\t\t\t\t\t\t\t\twhen(result, function() {\r\n\t\t\t\t\t\t\t\t\t\tfor (var i = 0; i < l; i++) {\r\n\t\t\t\t\t\t\t\t\t\t\thandles[i].done()\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\treturn result\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tvar instance = inputs.pop()\r\n\t\t\t\t\t\t\treturn functionValue.apply(instance, inputs, context)\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tsetReverse: function(reverse) {\r\n\t\t\t\tthis.transform.valueOf().reverse = reverse\r\n\t\t\t\treturn this\r\n\t\t\t},\r\n\t\t\tgetCollectionOf: function() {\r\n\t\t\t\treturn this.returnedVariable && this.returnedVariable.getCollectionOf()\r\n\t\t\t}\r\n\t\t})\r\n\t\tVariable.Call = Call\r\n\t\r\n\t\tvar ContextualizedVariable = lang.compose(Variable, function ContextualizedVariable(generic, subject) {\r\n\t\t\tthis.generic = generic\r\n\t\t\tthis.subject = subject\r\n\t\t}, {\r\n\t\t\tvalueOf: function() {\r\n\t\t\t\t// TODO: Lookup Context type for all of these using registry or something\r\n\t\t\t\tvar subject = this.subject\r\n\t\t\t\treturn this.generic.valueOf(subject.getContextualized ? subject : new Context(subject))\r\n\t\t\t},\r\n\t\r\n\t\t\tforDependencies: function(callback) {\r\n\t\t\t\tthis.inputs && this.inputs.forEach(callback)\r\n\t\t\t},\r\n\t\r\n\t\t\tgetVersion: function() {\r\n\t\t\t\tvar version = Variable.prototype.getVersion.call(this)\r\n\t\t\t\tvar inputs = this.inputs || 0\r\n\t\t\t\tfor (var i = 0, l = inputs.length; i < l; i++) {\r\n\t\t\t\t\tvar input = inputs[i]\r\n\t\t\t\t\tif (input.getVersion) {\r\n\t\t\t\t\t\tversion = Math.max(version, input.getVersion())\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn version\r\n\t\t\t},\r\n\t\r\n\t\t\tput: function(value) {\r\n\t\t\t\tvar subject = this.subject\r\n\t\t\t\treturn this.generic.put(value, subject.getContextualized ? subject : new Context(subject))\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\r\n\t\tfunction iterateMethod(method) {\r\n\t\t\tVariable.prototype[method] = function() {\r\n\t\t\t\treturn new IterativeMethod(this, method, arguments)\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\titerateMethod('filter')\r\n\t\titerateMethod('map')\r\n\t\titerateMethod('reduce')\r\n\t\titerateMethod('reduceRight')\r\n\t\titerateMethod('some')\r\n\t\titerateMethod('every')\r\n\t\titerateMethod('slice')\r\n\t\t\r\n\t\tvar IterativeMethod = lang.compose(Composite, function(source, method, args) {\r\n\t\t\tthis.source = source\r\n\t\t\t// source.interestWithin = true\r\n\t\t\tthis.method = method\r\n\t\t\tthis.arguments = args\r\n\t\t}, {\r\n\t\t\tgetValue: function(context) {\r\n\t\t\t\tvar method = this.method\r\n\t\t\t\tvar args = this.arguments\r\n\t\t\t\tvar variable = this\r\n\t\t\t\tif (context) {\r\n\t\t\t\t\tcontext.nextProperty = 'source'\r\n\t\t\t\t}\r\n\t\t\t\treturn when(this.source.valueOf(context), function(array) {\r\n\t\t\t\t\tif (array && array.forEach) {\r\n\t\t\t\t\t\tif (context && context.notify) {\r\n\t\t\t\t\t\t\tvar contextualizedVariable\r\n\t\t\t\t\t\t\tif (context.distinctSubject) {\r\n\t\t\t\t\t\t\t\tvar contextMap = variable._contextMap || (variable._contextMap = new WeakMap())\r\n\t\t\t\t\t\t\t\tif (contextMap.has(context.distinctSubject)) {\r\n\t\t\t\t\t\t\t\t\tcontextualizedVariable = contextMap.get(context.distinctSubject)\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tcontextMap.set(context.distinctSubject, contextualizedVariable = Object.create(variable))\r\n\t\t\t\t\t\t\t\t\tcontextualizedVariable.listeners = false\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tcontextualizedVariable = variable\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tvariable.notifies(contextualizedVariable)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (method === 'map'){\r\n\t\t\t\t\t\t\t// fast path, and special behavior for map\r\n\t\t\t\t\t\t\treturn args[0](array)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// if not an array convert to an array\r\n\t\t\t\t\t\tarray = [array]\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// apply method\r\n\t\t\t\t\treturn array[method].apply(array, args)\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tupdated: function(event, by, context) {\r\n\t\t\t\tif (!event || event.modifier === this || (event.modifier && event.modifier.constructor === this)) {\r\n\t\t\t\t\treturn Composite.prototype.updated.call(this, event, by, context)\r\n\t\t\t\t}\r\n\t\t\t\tvar propagatedEvent = event.type === 'refresh' ? event : // always propagate refreshes\r\n\t\t\t\t\tthis[this.method + 'Updated'] ? this[this.method + 'Updated'](event, context) : // if we have an updated handler, use it\r\n\t\t\t\t\tnew RefreshEvent() // else recompute the array method\r\n\t\t\t\t// TODO: make sure we normalize the event structure\r\n\t\t\t\tif (propagatedEvent) {\r\n\t\t\t\t\tComposite.prototype.updated.call(this, propagatedEvent, by, context)\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tfilterUpdated: function(event, context) {\r\n\t\t\t\tvar contextualizedVariable = context ? context.getContextualized(this) : this\r\n\t\t\t\tif (event.type === 'delete') {\r\n\t\t\t\t\tvar index = contextualizedVariable.cachedValue.indexOf(event.oldValue)\r\n\t\t\t\t\tif (index > -1) {\r\n\t\t\t\t\t\tcontextualizedVariable.splice(index, 1)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (event.type === 'add') {\r\n\t\t\t\t\tif ([event.value].filter(this.arguments[0]).length > 0) {\r\n\t\t\t\t\t\tcontextualizedVariable.push(event.value)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (event.type === 'update') {\r\n\t\t\t\t\tvar object = event.parent.valueOf(context)\r\n\t\t\t\t\tvar index = contextualizedVariable.cachedValue.indexOf(object)\r\n\t\t\t\t\tvar matches = [object].filter(this.arguments[0]).length > 0\r\n\t\t\t\t\tif (index > -1) {\r\n\t\t\t\t\t\tif (matches) {\r\n\t\t\t\t\t\t\treturn new PropertyChangeEvent(index, event, contextualizedVariable.cachedValue,\r\n\t\t\t\t\t\t\t\t// might need to do something with this\r\n\t\t\t\t\t\t\t\tobject)\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tcontextualizedVariable.splice(index, 1)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\telse {\r\n\t\t\t\t\t\tif (matches) {\r\n\t\t\t\t\t\t\tcontextualizedVariable.push(object)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// else nothing mactches\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn event\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tmapUpdated: function(event, context) {\r\n\t\t\t\tvar contextualizedVariable = context ? context.getContextualized(this) : this\r\n\t\t\t\tif (event.type === 'delete') {\r\n\t\t\t\t\tcontextualizedVariable.splice(event.previousIndex, 1)\r\n\t\t\t\t} else if (event.type === 'add') {\r\n\t\t\t\t\tcontextualizedVariable.push(this.arguments[0].call(this.arguments[1], event.value))\r\n\t\t\t\t} else if (event.type === 'update') {\r\n\t\t\t\t\tvar object = event.parent.valueOf(context)\r\n\t\t\t\t\tvar array = contextualizedVariable.cachedValue\r\n\t\t\t\t\tif (array && array.map) {\r\n\t\t\t\t\t\tvar index = array.indexOf(object)\r\n\t\t\t\t\t\tvar matches = [object].filter(this.arguments[0]).length > 0\r\n\t\t\t\t\t\tcontextualizedVariable.splice(index, 1, this.arguments[0].call(this.arguments[1], event.value))\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn event\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn event\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\t// TODO: Create specialized updated handlers for faster recomputation of other array derivatives\r\n\t\t\tforDependencies: function(callback) {\r\n\t\t\t\t// depend on the args\r\n\t\t\t\tComposite.prototype.forDependencies.call(this, callback)\r\n\t\t\t\tcallback(this.source)\r\n\t\t\t},\r\n\t\t\tgetVersion: function(context) {\r\n\t\t\t\treturn Math.max(Composite.prototype.getVersion.call(this, context), this.source.getVersion(context))\r\n\t\t\t},\r\n\t\t\tgetCollectionOf: function(){\r\n\t\t\t\treturn this.source.getCollectionOf()\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\r\n\t\tvar getValue\r\n\t\tvar GeneratorVariable = Variable.GeneratorVariable = lang.compose(Variable.Composite, function ReactiveGenerator(generator){\r\n\t\t\tthis.generator = generator\r\n\t\t}, {\r\n\t\t\tgetValue: getValue = function(context, resuming) {\r\n\t\t\t\tvar lastValue\r\n\t\t\t\tvar i\r\n\t\t\t\tvar generatorIterator\r\n\t\t\t\tvar isThrowing\r\n\t\t\t\tif (resuming) {\r\n\t\t\t\t\t// resuming from a promise\r\n\t\t\t\t\tgeneratorIterator = resuming.iterator\r\n\t\t\t\t\ti = resuming.i\r\n\t\t\t\t\tlastValue = resuming.value\r\n\t\t\t\t\tisThrowing = resuming.isThrowing\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// a fresh start\r\n\t\t\t\t\ti = 0\r\n\t\t\t\t\tgeneratorIterator = this.generator()\t\t\t\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tdo {\r\n\t\t\t\t\tvar stepReturn = generatorIterator[isThrowing ? 'throw' : 'next'](lastValue)\r\n\t\t\t\t\tif (stepReturn.done) {\r\n\t\t\t\t\t\treturn stepReturn.value\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar nextVariable = stepReturn.value\r\n\t\t\t\t\t// compare with the arguments from the last\r\n\t\t\t\t\t// execution to see if they are the same\r\n\t\t\t\t\tvar argumentName = 'argument' + i\r\n\t\t\t\t\tif (this[argumentName] !== nextVariable) {\r\n\t\t\t\t\t\tif (this[argumentName]) {\r\n\t\t\t\t\t\t\tthis[argumentName].stopNotifies(this)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// subscribe if it is a variable\r\n\t\t\t\t\t\tif (nextVariable && nextVariable.notifies) {\r\n\t\t\t\t\t\t\tif (this.listeners) {\r\n\t\t\t\t\t\t\t\tnextVariable.notifies(this)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tthis[argumentName] = nextVariable\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthis[argumentName] = null\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\ti++\r\n\t\t\t\t\tif (context) {\r\n\t\t\t\t\t\tcontext.nextProperty = argumentName\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlastValue = nextVariable && nextVariable.valueOf(context)\r\n\t\t\t\t\tif (lastValue && lastValue.then) {\r\n\t\t\t\t\t\t// if it is a promise, we will wait on it\r\n\t\t\t\t\t\tvar variable = this\r\n\t\t\t\t\t\t// and return the promise so that the getValue caller can wait on this\r\n\t\t\t\t\t\treturn lastValue.then(function(value) {\r\n\t\t\t\t\t\t\treturn getValue.call(variable, context, {\r\n\t\t\t\t\t\t\t\ti: i,\r\n\t\t\t\t\t\t\t\titerator: generatorIterator,\r\n\t\t\t\t\t\t\t\tvalue: value\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t}, function(error) {\r\n\t\t\t\t\t\t\treturn getValue.call(variable, context, {\r\n\t\t\t\t\t\t\t\ti: i,\r\n\t\t\t\t\t\t\t\titerator: generatorIterator,\r\n\t\t\t\t\t\t\t\tvalue: error,\r\n\t\t\t\t\t\t\t\tisThrowing: true\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}\r\n\t\t\t\t} while(true)\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\tvar Validating = lang.compose(Caching, function(target) {\r\n\t\t\tthis.target = target\r\n\t\t}, {\r\n\t\t\tforDependencies: function(callback) {\r\n\t\t\t\tCaching.prototype.forDependencies.call(this, callback)\r\n\t\t\t\tcallback(this.target)\r\n\t\t\t},\r\n\t\t\tgetVersion: function(context) {\r\n\t\t\t\treturn Math.max(Variable.prototype.getVersion.call(this, context), this.target.getVersion(context))\r\n\t\t\t},\r\n\t\t\tgetValue: function(context) {\r\n\t\t\t\tvar target = this.target\r\n\t\t\t\treturn target.validate(target, target.schema)\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\tfunction validate(target) {\r\n\t\t\tvar schemaForObject = schema(target)\r\n\t\t\treturn new Validating(target, schemaForObject)\r\n\t\t}\r\n\t\tVariable.VArray = Variable\r\n\t\tVariable.VPromised = Variable\r\n\t\tVariable.deny = deny\r\n\t\tVariable.noChange = noChange\r\n\t\tfunction addFlag(name) {\r\n\t\t\tVariable[name] = function(functionValue) {\r\n\t\t\t\tfunctionValue[name] = true\r\n\t\t\t}\r\n\t\t}\r\n\t\taddFlag(Variable, 'handlesContext')\r\n\t\taddFlag(Variable, 'handlesPromises')\r\n\t\r\n\t\tfunction objectUpdated(object) {\r\n\t\t\t// simply notifies any subscribers to an object, that it has changed\r\n\t\t\tvar listeners = propertyListenersMap.get(object)\r\n\t\t\tif (listeners) {\r\n\t\t\t\tfor (var i = 0, l = listeners.length; i < l; i++) {\r\n\t\t\t\t\tlisteners[i]._propertyChange(null, object)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction all(array) {\r\n\t\t\t// This is intended to mirror Promise.all. It actually takes\r\n\t\t\t// an iterable, but for now we are just looking for array-like\r\n\t\t\tif (array.length > -1) {\r\n\t\t\t\treturn new Composite(array)\r\n\t\t\t}\r\n\t\t\tif (arguments.length > 1) {\r\n\t\t\t\t// support multiple arguments as an array\r\n\t\t\t\treturn new Composite(arguments)\r\n\t\t\t}\r\n\t\t\tif (typeof array === 'object') {\r\n\t\t\t\t// allow an object as a hash to be mapped\r\n\t\t\t\tvar keyMapping = []\r\n\t\t\t\tvar valueArray = []\r\n\t\t\t\tfor (var key in array) {\r\n\t\t\t\t\tkeyMapping.push(key)\r\n\t\t\t\t\tvalueArray.push(array[key])\r\n\t\t\t\t}\r\n\t\t\t\treturn new Variable(function(results) {\r\n\t\t\t\t\tvar resultObject = {}\r\n\t\t\t\t\tfor (var i = 0; i < results.length; i++) {\r\n\t\t\t\t\t\tresultObject[keyMapping[i]] = results[i]\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn resultObject\r\n\t\t\t\t}).apply(null, valueArray)\r\n\t\t\t}\r\n\t\t\tthrow new TypeError('Variable.all requires an array')\r\n\t\t}\r\n\t\r\n\t\tfunction hasOwn(Target, createForInstance) {\r\n\t\r\n\t\t\tvar ownedClasses = this.ownedClasses || (this.ownedClasses = new WeakMap())\r\n\t\t\t// TODO: assign to super classes\r\n\t\t\tvar Class = this\r\n\t\t\townedClasses.set(Target, createForInstance || function() { return new Target() })\r\n\t\t\treturn this\r\n\t\t}\r\n\t\tfunction getForClass(subject, Target) {\r\n\t\t\tvar createInstance = subject.constructor.ownedClasses && subject.constructor.ownedClasses.get(Target)\r\n\t\t\tif (createInstance) {\r\n\t\t\t\tvar ownedInstances = subject.ownedInstances || (subject.ownedInstances = new WeakMap())\r\n\t\t\t\tvar instance = ownedInstances.get(Target)\r\n\t\t\t\tif (!instance) {\r\n\t\t\t\t\townedInstances.set(Target, instance = createInstance(subject))\r\n\t\t\t\t\tinstance.subject = subject\r\n\t\t\t\t}\r\n\t\t\t\treturn instance\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction generalizeClass() {\r\n\t\t\tvar prototype = this.prototype\r\n\t\t\tvar prototypeNames = Object.getOwnPropertyNames(prototype)\r\n\t\t\tfor(var i = 0, l = prototypeNames.length; i < l; i++) {\r\n\t\t\t\tvar name = prototypeNames[i]\r\n\t\t\t\tObject.defineProperty(this, name, getGeneralizedDescriptor(Object.getOwnPropertyDescriptor(prototype, name), name, this))\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction getGeneralizedDescriptor(descriptor, name, Class) {\r\n\t\t\tif (typeof descriptor.value === 'function') {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tvalue: generalizeMethod(Class, name)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\treturn descriptor\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction generalizeMethod(Class, name) {\r\n\t\t\t// I think we can just rely on `this`, but we could use the argument:\r\n\t\t\t// function(possibleEvent) {\r\n\t\t\t// \tvar target = possibleEvent && possibleEvent.target\r\n\t\t\tvar method = Class[name] = function() {\r\n\t\t\t\tvar instance = Class.for(this)\r\n\t\t\t\treturn instance[name].apply(instance, arguments)\r\n\t\t\t}\r\n\t\t\tmethod.for = function(context) {\r\n\t\t\t\tvar instance = Class.for(context)\r\n\t\t\t\treturn function() {\r\n\t\t\t\t\treturn instance[name].apply(instance, arguments)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn method\r\n\t\t}\r\n\t\r\n\t\tvar defaultContext = {\r\n\t\t\tname: 'Default context',\r\n\t\t\tdescription: 'This object is the default context for classes, corresponding to a singleton instance of that class',\r\n\t\t\tconstructor: {\r\n\t\t\t\tgetForClass: function(subject, Class) {\r\n\t\t\t\t\treturn Class.defaultInstance\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tcontains: function() {\r\n\t\t\t\treturn true // contains everything\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction instanceForContext(Class, context) {\r\n\t\t\tif (!context) {\r\n\t\t\t\treturn Class.defaultInstance\r\n\t\t\t}\r\n\t\t\treturn context.specify(Class)\r\n\t//\t\tvar instance = context.subject.constructor.getForClass && context.subject.constructor.getForClass(context.subject, Class) || Class.defaultInstance\r\n\t//\t\tcontext.distinctSubject = mergeSubject(context.distinctSubject, instance.subject)\r\n\t//\t\treturn instance\r\n\t\t}\r\n\t\t// a variable inheritance change goes through its own prototype, so classes/constructor\r\n\t\t// can be used as variables as well\r\n\t\tfor (var key in VariablePrototype) {\r\n\t\t\tObject.defineProperty(Variable, key, Object.getOwnPropertyDescriptor(VariablePrototype, key))\r\n\t\t}\r\n\t\tVariable.valueOf = function(context) {\r\n\t\t\t// contextualized getValue\r\n\t\t\treturn instanceForContext(this, context).valueOf(context)\r\n\t\t}\r\n\t\tVariable.put = function(value, context) {\r\n\t\t\t// contextualized setValue\r\n\t\t\treturn instanceForContext(this, context).put(value, context)\r\n\t\t}\r\n\t\tVariable.for = function(subject) {\r\n\t\t\tif (subject != null) {\r\n\t\t\t\tif (subject.target && !subject.constructor.getForClass) {\r\n\t\t\t\t\t// makes HTML events work\r\n\t\t\t\t\tsubject = subject.target\r\n\t\t\t\t}\r\n\t\t\t\tvar instance\r\n\t\t\t\tinstance = new Context(subject).specify(this)\r\n\t\t\t\tif (instance && !instance.subject) {\r\n\t\t\t\t\tinstance.subject = subject\r\n\t\t\t\t}\r\n\t\t\t\t// TODO: Do we have a global context that we set on defaultInstance?\r\n\t\t\t\treturn instance || this.defaultInstance\r\n\t\t\t} else {\r\n\t\t\t\treturn this.defaultInstance\r\n\t\t\t}\r\n\t\t}\r\n\t\tVariable.from = function(value) {\r\n\t\t\tif (value && typeof value === 'object') {\r\n\t\t\t\t// a plain object, we use our own map to retrieve the instance (or create one)\r\n\t\t\t\tvar instanceMap = this.instanceMap || (this.instanceMap = new WeakMap())\r\n\t\t\t\tvar instance = instanceMap.get(value)\r\n\t\t\t\tif (!instance) {\r\n\t\t\t\t\tinstanceMap.set(value, instance = new this(value))\r\n\t\t\t\t}\r\n\t\t\t\treturn instance\r\n\t\t\t} else {\r\n\t\t\t\t// a primitive, just unconditionally create a new variable for it\r\n\t\t\t\treturn new this(value)\r\n\t\t\t}\r\n\t\t}\r\n\t\tVariable.notifies = function(target) {\r\n\t\t\tthis.defaultInstance.notifies(target)\r\n\t\t}\r\n\t\tVariable.stopNotifies = function(target) {\r\n\t\t\tthis.defaultInstance.stopNotifies(target)\r\n\t\t}\r\n\t\tVariable.getCollectionOf = function () {\r\n\t\t\treturn this.collectionOf\r\n\t\t}\r\n\t\tVariable.updated = function(updateEvent, by, context) {\r\n\t\t\treturn instanceForContext(this, context).updated(updateEvent, by, context)\r\n\t\t}\r\n\t\tObject.defineProperty(Variable, 'collectionOf', {\r\n\t\t\tget: function() {\r\n\t\t\t\treturn this._collectionOf\r\n\t\t\t},\r\n\t\t\tset: function(ItemClass) {\r\n\t\t\t\tif (this._collectionOf != ItemClass) {\r\n\t\t\t\t\tthis._collectionOf = ItemClass\r\n\t\t\t\t\tItemClass.collection = this\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t\tObject.defineProperty(Variable, 'collection', {\r\n\t\t\tget: function() {\r\n\t\t\t\treturn this._collection\r\n\t\t\t},\r\n\t\t\tset: function(Collection) {\r\n\t\t\t\tif (this._collection != Collection) {\r\n\t\t\t\t\tthis._collection = Collection\r\n\t\t\t\t\tCollection.collectionOf = this\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t\tVariable.Context = Context\r\n\t\tVariable.NotifyingContext = NotifyingContext\r\n\t\tVariable.generalize = generalizeClass\r\n\t\tVariable.call = Function.prototype.call // restore these\r\n\t\tVariable.apply = Function.prototype.apply\r\n\t\tVariable.extend = function(properties) {\r\n\t\t\t// TODO: handle arguments\r\n\t\t\tvar Base = this\r\n\t\t\tfunction ExtendedVariable() {\r\n\t\t\t\tif (this instanceof ExtendedVariable) {\r\n\t\t\t\t\tBase.apply(this, arguments)\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn ExtendedVariable.extend(properties)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tvar prototype = ExtendedVariable.prototype = Object.create(this.prototype)\r\n\t\t\tExtendedVariable.prototype.constructor = ExtendedVariable\r\n\t\t\tsetPrototypeOf(ExtendedVariable, this)\r\n\t\t\tfor (var key in properties) {\r\n\t\t\t\tvar descriptor = Object.getOwnPropertyDescriptor(properties, key)\r\n\t\t\t\tObject.defineProperty(prototype, key, descriptor)\r\n\t\t\t\tObject.defineProperty(ExtendedVariable, key, getGeneralizedDescriptor(descriptor, key, ExtendedVariable))\r\n\t\t\t}\r\n\t\t\tif (properties && properties.hasOwn) {\r\n\t\t\t\thasOwn.call(ExtendedVariable, properties.hasOwn)\r\n\t\t\t}\r\n\t\t\treturn ExtendedVariable\r\n\t\t}\r\n\t\tObject.defineProperty(Variable, 'defaultInstance', {\r\n\t\t\tget: function() {\r\n\t\t\t\treturn this.hasOwnProperty('_defaultInstance') ?\r\n\t\t\t\t\tthis._defaultInstance : (\r\n\t\t\t\t\t\tthis._defaultInstance = new this(),\r\n\t\t\t\t\t\tthis._defaultInstance.subject = defaultContext,\r\n\t\t\t\t\t\tthis._defaultInstance)\r\n\t\t\t}\r\n\t\t})\r\n\t\tVariable.hasOwn = function(Target, createInstance) {\r\n\t\t\tvar instanceMap = new WeakMap()\r\n\t\t\tinstanceMap.createInstance = createInstance\r\n\t\t\tvar subjectMap = this.ownedClasses || (this.ownedClasses = new WeakMap())\r\n\t\t\tsubjectMap.set(Target, instanceMap)\r\n\t\t}\r\n\t\tVariable.all = all\r\n\t\tVariable.objectUpdated = objectUpdated\r\n\t\t\r\n\t\treturn Variable\r\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\r\n\t\tvar getPrototypeOf = Object.getPrototypeOf || (function(base) { return base.__proto__ })\r\n\t\tvar setPrototypeOf = Object.setPrototypeOf || (function(base, proto) { base.__proto__ = proto})\r\n\t\tvar hasFeatures = {\r\n\t\t\trequestAnimationFrame: typeof requestAnimationFrame != 'undefined',\r\n\t\t\tdefineProperty: Object.defineProperty && (function() {\r\n\t\t\t\ttry{\r\n\t\t\t\t\tObject.defineProperty({}, 't', {})\r\n\t\t\t\t\treturn true\r\n\t\t\t\t}catch(e) {\r\n\t\t\t\t}\r\n\t\t\t})(),\r\n\t\t\tpromise: typeof Promise !== 'undefined',\r\n\t\t\tMutationObserver: typeof MutationObserver !== 'undefined',\r\n\t\t\t'WeakMap': typeof WeakMap === 'function'\r\n\t\t}\r\n\t\tfunction has(feature) {\r\n\t\t\treturn hasFeatures[feature]\r\n\t\t}\r\n\t\t// This is an polyfill for Object.observe with just enough functionality\r\n\t\t// for what Variables need\r\n\t\t// An observe function, with polyfile\r\n\t\tvar observe =\r\n\t\t\thas('defineProperty') ? \r\n\t\t\tfunction observe(target, listener) {\r\n\t\t\t\t/*for(var i in target) {\r\n\t\t\t\t\taddKey(i)\r\n\t\t\t\t}*/\r\n\t\t\t\tlistener.addKey = addKey\r\n\t\t\t\tlistener.remove = function() {\r\n\t\t\t\t\tlistener = null\r\n\t\t\t\t}\r\n\t\t\t\treturn listener\r\n\t\t\t\tfunction addKey(key) {\r\n\t\t\t\t\tvar keyFlag = 'key' + key\r\n\t\t\t\t\tif(this[keyFlag]) {\r\n\t\t\t\t\t\treturn\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tthis[keyFlag] = true\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar currentValue = target[key]\r\n\t\t\t\t\tvar targetAncestor = target\r\n\t\t\t\t\tvar descriptor\r\n\t\t\t\t\tdo {\r\n\t\t\t\t\t\tdescriptor = Object.getOwnPropertyDescriptor(targetAncestor, key)\r\n\t\t\t\t\t} while(!descriptor && (targetAncestor = getPrototypeOf(targetAncestor)))\r\n\t\r\n\t\t\t\t\tif(descriptor && descriptor.set) {\r\n\t\t\t\t\t\tvar previousSet = descriptor.set\r\n\t\t\t\t\t\tvar previousGet = descriptor.get\r\n\t\t\t\t\t\tObject.defineProperty(target, key, {\r\n\t\t\t\t\t\t\tget: function() {\r\n\t\t\t\t\t\t\t\treturn (currentValue = previousGet.call(this))\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\tset: function(value) {\r\n\t\t\t\t\t\t\t\tpreviousSet.call(this, value)\r\n\t\t\t\t\t\t\t\tif(currentValue !== value) {\r\n\t\t\t\t\t\t\t\t\tcurrentValue = value\r\n\t\t\t\t\t\t\t\t\tif(listener) {\r\n\t\t\t\t\t\t\t\t\t\tlistener([{target: this, name: key}])\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\tenumerable: descriptor.enumerable\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tObject.defineProperty(target, key, {\r\n\t\t\t\t\t\t\tget: function() {\r\n\t\t\t\t\t\t\t\treturn currentValue\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\tset: function(value) {\r\n\t\t\t\t\t\t\t\tif(currentValue !== value) {\r\n\t\t\t\t\t\t\t\t\tcurrentValue = value\r\n\t\t\t\t\t\t\t\t\tif(listener) {\r\n\t\t\t\t\t\t\t\t\t\tlistener([{target: this, name: key}])\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\tenumerable: !descriptor || descriptor.enumerable\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} :\r\n\t\t\t// and finally a polling-based solution, for the really old browsers\r\n\t\t\tfunction(target, listener) {\r\n\t\t\t\tif(!timerStarted) {\r\n\t\t\t\t\ttimerStarted = true\r\n\t\t\t\t\tsetInterval(function() {\r\n\t\t\t\t\t\tfor(var i = 0, l = watchedObjects.length; i < l; i++) {\r\n\t\t\t\t\t\t\tdiff(watchedCopies[i], watchedObjects[i], listeners[i])\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}, 20)\r\n\t\t\t\t}\r\n\t\t\t\tvar copy = {}\r\n\t\t\t\tfor(var i in target) {\r\n\t\t\t\t\tif(target.hasOwnProperty(i)) {\r\n\t\t\t\t\t\tcopy[i] = target[i]\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\twatchedObjects.push(target)\r\n\t\t\t\twatchedCopies.push(copy)\r\n\t\t\t\tlisteners.push(listener)\r\n\t\t\t}\r\n\t\tvar queuedListeners\r\n\t\tfunction queue(listener, object, name) {\r\n\t\t\tif(queuedListeners) {\r\n\t\t\t\tif(queuedListeners.indexOf(listener) === -1) {\r\n\t\t\t\t\tqueuedListeners.push(listener)\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\tqueuedListeners = [listener]\r\n\t\t\t\tlang.nextTurn(function() {\r\n\t\t\t\t\tqueuedListeners.forEach(function(listener) {\r\n\t\t\t\t\t\tvar events = []\r\n\t\t\t\t\t\tlistener.properties.forEach(function(property) {\r\n\t\t\t\t\t\t\tevents.push({target: listener.object, name: property})\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t\tlistener(events)\r\n\t\t\t\t\t\tlistener.object = null\r\n\t\t\t\t\t\tlistener.properties = null\r\n\t\t\t\t\t})\r\n\t\t\t\t\tqueuedListeners = null\r\n\t\t\t\t}, 0)\r\n\t\t\t}\r\n\t\t\tlistener.object = object\r\n\t\t\tvar properties = listener.properties || (listener.properties = [])\r\n\t\t\tif(properties.indexOf(name) === -1) {\r\n\t\t\t\tproperties.push(name)\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar unobserve = has('observe') ? Object.unobserve :\r\n\t\t\tfunction(target, listener) {\r\n\t\t\t\tif(listener.remove) {\r\n\t\t\t\t\tlistener.remove()\r\n\t\t\t\t}\r\n\t\t\t\tfor(var i = 0, l = watchedObjects.length; i < l; i++) {\r\n\t\t\t\t\tif(watchedObjects[i] === target && listeners[i] === listener) {\r\n\t\t\t\t\t\twatchedObjects.splice(i, 1)\r\n\t\t\t\t\t\twatchedCopies.splice(i, 1)\r\n\t\t\t\t\t\tlisteners.splice(i, 1)\r\n\t\t\t\t\t\treturn\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\tvar watchedObjects = []\r\n\t\tvar watchedCopies = []\r\n\t\tvar listeners = []\r\n\t\tvar timerStarted = false\r\n\t\tfunction diff(previous, current, callback) {\r\n\t\t\t// TODO: keep an array of properties for each watch for faster iteration\r\n\t\t\tvar queued\r\n\t\t\tfor(var i in previous) {\r\n\t\t\t\tif(previous.hasOwnProperty(i) && previous[i] !== current[i]) {\r\n\t\t\t\t\t// a property has changed\r\n\t\t\t\t\tprevious[i] = current[i]\r\n\t\t\t\t\t(queued || (queued = [])).push({name: i})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor(var i in current) {\r\n\t\t\t\tif(current.hasOwnProperty(i) && !previous.hasOwnProperty(i)) {\r\n\t\t\t\t\t// a property has been added\r\n\t\t\t\t\tprevious[i] = current[i]\r\n\t\t\t\t\t(queued || (queued = [])).push({name: i})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(queued) {\r\n\t\t\t\tcallback(queued)\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tvar id = 1\r\n\t\t// a function that returns a function, to stop JSON serialization of an\r\n\t\t// object\r\n\t\tfunction toJSONHidden() {\r\n\t\t\treturn toJSONHidden\r\n\t\t}\r\n\t\t// An object that will be hidden from JSON serialization\r\n\t\tvar Hidden = function () {\r\n\t\t}\r\n\t\tHidden.prototype.toJSON = toJSONHidden\r\n\t\r\n\t\tvar lang = {\r\n\t\t\trequestAnimationFrame: has('requestAnimationFrame') ? requestAnimationFrame :\r\n\t\t\t\t(function() {\r\n\t\t\t\t\tvar toRender = []\r\n\t\t\t\t\tvar queued = false\r\n\t\t\t\t\tfunction processAnimationFrame() {\r\n\t\t\t\t\t\tfor (var i = 0; i < toRender.length; i++) {\r\n\t\t\t\t\t\t\ttoRender[i]()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttoRender = []\r\n\t\t\t\t\t\tqueued = false\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfunction requestAnimationFrame(renderer) {\r\n\t\t\t\t\t \tif (!queued) {\r\n\t\t\t\t\t\t\tsetTimeout(processAnimationFrame)\r\n\t\t\t\t\t\t\tqueued = true\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttoRender.push(renderer)\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn requestAnimationFrame\r\n\t\t\t\t})(),\r\n\t\t\tPromise: has('promise') ? Promise : (function() {\r\n\t\t\t\tfunction Promise(execute) {\r\n\t\t\t\t\tvar isResolved, resolution, errorResolution\r\n\t\t\t\t\tvar queue = 0\r\n\t\t\t\t\tfunction resolve(value) {\r\n\t\t\t\t\t\t// resolve function\r\n\t\t\t\t\t\tif(value && value.then) {\r\n\t\t\t\t\t\t\t// received a promise, wait for it\r\n\t\t\t\t\t\t\tvalue.then(resolve, reject)\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\tresolution = value\r\n\t\t\t\t\t\t\tfinished()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfunction reject(error) {\r\n\t\t\t\t\t\t// reject function\r\n\t\t\t\t\t\terrorResolution = error\r\n\t\t\t\t\t\tfinished()\r\n\t\t\t\t\t}\r\n\t\t\t\t\texecute(resolve, reject)\r\n\t\t\t\t\tfunction finished() {\r\n\t\t\t\t\t\tisResolved = true\r\n\t\t\t\t\t\tfor(var i = 0, l = queue.length; i < l; i++) {\r\n\t\t\t\t\t\t\tqueue[i]()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// clean out the memory\r\n\t\t\t\t\t\tqueue = 0\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tthen: function(callback, errback) {\r\n\t\t\t\t\t\t\treturn new Promise(function(resolve, reject) {\r\n\t\t\t\t\t\t\t\tfunction handle() {\r\n\t\t\t\t\t\t\t\t\t// promise fulfilled, call the appropriate callback\r\n\t\t\t\t\t\t\t\t\ttry{\r\n\t\t\t\t\t\t\t\t\t\tif(errorResolution && !errback) {\r\n\t\t\t\t\t\t\t\t\t\t\t// errors without a handler flow through\r\n\t\t\t\t\t\t\t\t\t\t\treject(errorResolution)\r\n\t\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t\t// resolve to the callback's result\r\n\t\t\t\t\t\t\t\t\t\t\tresolve(errorResolution ?\r\n\t\t\t\t\t\t\t\t\t\t\t\terrback(errorResolution) :\r\n\t\t\t\t\t\t\t\t\t\t\t\tcallback ?\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tcallback(resolution) : resolution)\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}catch(newError) {\r\n\t\t\t\t\t\t\t\t\t\t// caught an error, reject the returned promise\r\n\t\t\t\t\t\t\t\t\t\treject(newError)\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif(isResolved) {\r\n\t\t\t\t\t\t\t\t\t// already resolved, immediately handle\r\n\t\t\t\t\t\t\t\t\thandle()\r\n\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t(queue || (queue = [])).push(handle)\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn Promise\r\n\t\t\t}()),\r\n\t\r\n\t\t\tWeakMap: has('WeakMap') ? WeakMap :\r\n\t\t \tfunction (values, name) {\r\n\t\t \t\tvar mapProperty = '__' + (name || '') + id++\r\n\t\t \t\treturn has('defineProperty') ?\r\n\t\t \t\t{\r\n\t\t \t\t\tget: function (key) {\r\n\t\t \t\t\t\treturn key[mapProperty]\r\n\t\t \t\t\t},\r\n\t\t \t\t\tset: function (key, value) {\r\n\t\t \t\t\t\tObject.defineProperty(key, mapProperty, {\r\n\t\t \t\t\t\t\tvalue: value,\r\n\t\t \t\t\t\t\tenumerable: false\r\n\t\t \t\t\t\t})\r\n\t\t \t\t\t}\r\n\t\t \t\t} :\r\n\t\t \t\t{\r\n\t\t \t\t\tget: function (key) {\r\n\t\t \t\t\t\tvar intermediary = key[mapProperty]\r\n\t\t \t\t\t\treturn intermediary && intermediary.value\r\n\t\t \t\t\t},\r\n\t\t \t\t\tset: function (key, value) {\r\n\t\t \t\t\t\t// we use an intermediary that is hidden from JSON serialization, at least\r\n\t\t \t\t\t\tvar intermediary = key[mapProperty] || (key[mapProperty] = new Hidden())\r\n\t\t \t\t\t\tintermediary.value = value\r\n\t\t \t\t\t}\r\n\t\t \t\t}\r\n\t\t \t},\r\n\t\r\n\t\t\tobserve: observe,\r\n\t\t\tunobserve: unobserve,\r\n\t\t\twhen: function(value, callback, errorHandler) {\r\n\t\t\t\treturn value && value.then ?\r\n\t\t\t\t\t(value.then(callback, errorHandler) || value) : callback(value)\r\n\t\t\t},\r\n\t\t\twhenAll: function(inputs, callback) {\r\n\t\t\t\tvar promiseInvolved\r\n\t\t\t\tfor(var i = 0, l = inputs.length; i < l; i++) {\r\n\t\t\t\t\tif(inputs[i] && inputs[i].then) {\r\n\t\t\t\t\t\tpromiseInvolved = true\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif(promiseInvolved) {\r\n\t\t\t\t\t// we have asynch inputs, do lazy loading\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tthen: function(onResolve, onError) {\r\n\t\t\t\t\t\t\tvar remaining = 1\r\n\t\t\t\t\t\t\tvar result\r\n\t\t\t\t\t\t\tvar readyInputs = []\r\n\t\t\t\t\t\t\tvar lastPromiseResult\r\n\t\t\t\t\t\t\tfor(var i = 0; i < inputs.length; i++) {\r\n\t\t\t\t\t\t\t\tvar input = inputs[i]\r\n\t\t\t\t\t\t\t\tremaining++\r\n\t\t\t\t\t\t\t\tif(input && input.then) {\r\n\t\t\t\t\t\t\t\t\t(function(i, previousPromiseResult) {\r\n\t\t\t\t\t\t\t\t\t\tlastPromiseResult = input.then(function(value) {\r\n\t\t\t\t\t\t\t\t\t\t\treadyInputs[i] = value\r\n\t\t\t\t\t\t\t\t\t\t\tonEach()\r\n\t\t\t\t\t\t\t\t\t\t\tif(!remaining) {\r\n\t\t\t\t\t\t\t\t\t\t\t\treturn result\r\n\t\t\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t\t\treturn previousPromiseResult\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}, onError)\r\n\t\t\t\t\t\t\t\t\t})(i, lastPromiseResult)\r\n\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\treadyInputs[i] = input\r\n\t\t\t\t\t\t\t\t\tonEach()\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tonEach()\r\n\t\t\t\t\t\t\tfunction onEach() {\r\n\t\t\t\t\t\t\t\tremaining--\r\n\t\t\t\t\t\t\t\tif(!remaining) {\r\n\t\t\t\t\t\t\t\t\tresult = onResolve(callback(readyInputs))\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn lastPromiseResult\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tinputs: inputs\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// just sync inputs\r\n\t\t\t\treturn callback(inputs)\r\n\t\r\n\t\t\t},\r\n\t\t\tcompose: function(Base, constructor, properties) {\r\n\t\t\t\tvar prototype = constructor.prototype = Object.create(Base.prototype)\r\n\t\t\t\tsetPrototypeOf(constructor, Base)\r\n\t\t\t\tfor(var i in properties) {\r\n\t\t\t\t\tprototype[i] = properties[i]\r\n\t\t\t\t}\r\n\t\t\t\tprototype.constructor = constructor\r\n\t\t\t\treturn constructor\r\n\t\t\t},\r\n\t\t\tnextTurn: has('MutationObserver') ?\r\n\t\t\t\tfunction (callback) {\r\n\t\t\t\t\t// promises don't resolve consistently on the next micro turn (Edge doesn't do it right),\r\n\t\t\t\t\t// so use mutation observer\r\n\t\t\t\t\t// TODO: make a faster mode that doesn't recreate each time\r\n\t\t\t\t\tvar div = document.createElement('div')\r\n\t\t\t\t\tvar observer = new MutationObserver(callback)\r\n\t\t\t\t\tobserver.observe(div, {\r\n\t\t\t\t\t\tattributes: true\r\n\t\t\t\t\t})\r\n\t\t\t\t\tdiv.setAttribute('a', id++)\r\n\t\t\t\t} :\r\n\t\t\t\tfunction (callback) {\r\n\t\t\t\t\t// TODO: we can do better for other, older browsers\r\n\t\t\t\t\tsetTimeout(callback, 0)\r\n\t\t\t\t},\r\n\t\t\tcopy: Object.assign || function(target, source) {\r\n\t\t\t\tfor(var i in source) {\r\n\t\t\t\t\ttarget[i] = source[i]\r\n\t\t\t\t}\r\n\t\t\t\treturn target\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction isGenerator(func) {\r\n\t\t\tif (typeof func === 'function') {\r\n\t\t\t\tvar constructor = func.constructor\r\n\t\t\t\treturn (constructor.displayName || constructor.name) === 'GeneratorFunction'\r\n\t\t\t}\r\n\t\t}\r\n\t\tlang.isGenerator = isGenerator\r\n\t\treturn lang\r\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(3), __webpack_require__(2)], __WEBPACK_AMD_DEFINE_RESULT__ = function (lang, Variable) {\r\n\t\tvar doc = typeof document !== 'undefined' && document\r\n\t\tvar invalidatedElements\r\n\t\tvar queued\r\n\t\tvar toRender = []\r\n\t\tvar nextId = 1\r\n\t\tvar requestAnimationFrame = lang.requestAnimationFrame\r\n\t\tvar Context = Variable.Context\r\n\t\r\n\t\tfunction Renderer(options) {\r\n\t\t\tvar variable = options.variable\r\n\t\r\n\t\t\tthis.variable = variable\r\n\t\t\tif (options.selector) {\r\n\t\t\t\tthis.selector = options.selector\r\n\t\t\t}\r\n\t\t\tif (options.elements) {\r\n\t\t\t\tthis.elements = options.elements\r\n\t\t\t\tthis.element = this.elements[0]\r\n\t\t\t\tfor(var i = 0, l = this.elements.length; i < l; i++) {\r\n\t\t\t\t\t(this.elements[i].alkaliRenderers || (this.elements[i].alkaliRenderers = [])).push(this)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (options.element) {\r\n\t\t\t\tvar element = this.element = options.element;\r\n\t\t\t\t(element.alkaliRenderers || (element.alkaliRenderers = [])).push(this)\r\n\t\t\t} else {\r\n\t\t\t\tthrow new Error('No element provided to Renderer')\r\n\t\t\t}\r\n\t\t\tif (options.update) {\r\n\t\t\t\tthis.updateRendering = options.update\r\n\t\t\t}\r\n\t\t\tif (options.shouldRender) {\r\n\t\t\t\tthis.shouldRender = options.shouldRender\r\n\t\t\t}\r\n\t\t\tif (options.renderUpdate) {\r\n\t\t\t\tthis.renderUpdate = options.renderUpdate\r\n\t\t\t}\r\n\t\t\tif (options.alwaysUpdate) {\r\n\t\t\t\tthis.alwaysUpdate = options.alwaysUpdate\r\n\t\t\t}\r\n\t\t\tif (variable.updated) {\r\n\t\t\t\t// if it has update, we don't need to instantiate a closure\r\n\t\t\t\tif (options.updateOnStart === false) {\r\n\t\t\t\t\tvariable.notifies(this)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t// baconjs-esqe API\r\n\t\t\t\tvar renderer = this\r\n\t\t\t\tvariable.subscribe(function (event) {\r\n\t\t\t\t\t// replace the variable with an object\r\n\t\t\t\t\t// that returns the value from the event\r\n\t\t\t\t\trenderer.variable = {\r\n\t\t\t\t\t\tvalueOf: function () {\r\n\t\t\t\t\t\t\treturn event.value()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\trenderer.updated()\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tif (options.updateOnStart !== false){\r\n\t\t\t\tthis.updateRendering(true)\r\n\t\t\t}\r\n\t\t}\r\n\t\tRenderer.prototype = {\r\n\t\t\tconstructor: Renderer,\r\n\t\t\tupdateRendering: function () {\r\n\t\t\t\tthrow new Error ('updateRendering must be implemented by sub class of Renderer')\r\n\t\t\t},\r\n\t\t\tupdated: function (updateEvent, by, context) {\r\n\t\t\t\tif (!this.invalidated) {\r\n\t\t\t\t\tif (!context || this.contextMatches(context)) {\r\n\t\t\t\t\t\t// do this only once, until we render again\r\n\t\t\t\t\t\tthis.invalidated = true\r\n\t\t\t\t\t\tvar renderer = this\r\n\t\t\t\t\t\trequestAnimationFrame(function(){\r\n\t\t\t\t\t\t\tinvalidatedElements = null\r\n\t\t\t\t\t\t\trenderer.updateRendering(renderer.alwaysUpdate)\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tnewContext: function() {\r\n\t\t\t\treturn new Variable.Context(this.element)\r\n\t\t\t},\r\n\t\t\taddInput: function(variable) {\r\n\t\t\t\tthis.contextualized = variable\r\n\t\t\t},\r\n\t\t\tgetContextualized: function() {\r\n\t\t\t\treturn this.contextualized\r\n\t\t\t},\r\n\t\t\tspecify: function(Variable) {\r\n\t\t\t\t// a new context to get thsi\r\n\t\t\t\treturn this.newContext().specify(Variable)\r\n\t\t\t},\r\n\t\t\tmerge: function(){\r\n\t\t\t\t// noop\r\n\t\t\t},\r\n\t\t\tcontextMatches: function(context) {\r\n\t\t\t\treturn true\r\n\t\t\t},\r\n\t\t\tinvalidateElement: function(element) {\r\n\t\t\t\tif(!invalidatedElements){\r\n\t\t\t\t\tinvalidatedElements = new WeakMap(null, 'invalidated')\r\n\t\t\t\t}\r\n\t\t\t\tvar invalidatedParts = invalidatedElements.get(element)\r\n\t\t\t\tinvalidatedElements.set(element, invalidatedParts = {})\r\n\t\t\t\tif (!invalidatedParts[id]) {\r\n\t\t\t\t\tinvalidatedParts[id] = true\r\n\t\t\t\t}\r\n\t\t\t\tif (!queued) {\r\n\t\t\t\t\tlang.queueTask(processQueue)\r\n\t\t\t\t\tqueued = true\r\n\t\t\t\t}\r\n\t\t\t\tvar renderer = this\r\n\t\t\t\ttoRender.push(function(){\r\n\t\t\t\t\trenderer.invalidated = false\r\n\t\t\t\t\trenderer.updateElement(element)\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tgetId: function(){\r\n\t\t\t\treturn this.id || (this.id = nextId++)\r\n\t\t\t},\r\n\t\t\tstop: function() {\r\n\t\t\t\tvar contextualized = this.contextualized || this.variable\r\n\t\t\t\tcontextualized.stopNotifies(this)\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction ElementRenderer(options) {\r\n\t\t\tRenderer.call(this, options)\r\n\t\t}\r\n\t\tElementRenderer.prototype = Object.create(Renderer.prototype)\r\n\t\tElementRenderer.prototype.shouldRender = function (element) {\r\n\t\t\treturn document.body.contains(element)\r\n\t\t}\r\n\t\tElementRenderer.prototype.getSubject = function () {\r\n\t\t\treturn this.element\r\n\t\t}\r\n\t\tElementRenderer.prototype.updateRendering = function (always, element) {\r\n\t\t\tif (!element && this.elements) {\r\n\t\t\t\tvar elements = this.elements\r\n\t\t\t\tif(!elements.length){\r\n\t\t\t\t\tif(this.selector){\r\n\t\t\t\t\t\telements = document.querySelectorAll(this.selector)\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tthrow new Error('No element or selector was provided to the Renderer')\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t\tfor(var i = 0, l = elements.length; i < l; i++){\r\n\t\t\t\t\tthis.updateRendering(always, elements[i])\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tvar thisElement = element || this.element\r\n\t\r\n\t\t\t\tif(always || this.shouldRender(thisElement)){\r\n\t\t\t\t\t// it is connected\r\n\t\t\t\t\tthis.updateElement(thisElement)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar id = this.getId()\r\n\t\t\t\t\tvar renderers = thisElement.renderersOnShow\r\n\t\t\t\t\tif(!renderers){\r\n\t\t\t\t\t\trenderers = thisElement.renderersOnShow = []\r\n\t\t\t\t\t\tthisElement.className += ' needs-rerendering'\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!renderers[id]) {\r\n\t\t\t\t\t\trenderers[id] = this\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tElementRenderer.prototype.addElement = function (element) {\r\n\t\t\tif (this.selector) {\r\n\t\t\t\telement.renderersOnShow = [this]\r\n\t\t\t} else {\r\n\t\t\t\tthis.elements.push(element)\r\n\t\t\t}\r\n\t\t\t// and immediately do an update\r\n\t\t\tthis.updateElement(element)\r\n\t\t}\r\n\t\tElementRenderer.prototype.updateElement = function(element) {\r\n\t\t\tthis.invalidated = false\r\n\t\t\ttry {\r\n\t\t\t\tif (!this.omitValueOf) {\r\n\t\t\t\t\tvar value = this.variable.valueOf(this)\r\n\t\t\t\t\tvar contextualized = this.contextualized || this.variable\r\n\t\t\t\t\t// TODO: we may need to handle recontextualization if it returns a promise\r\n\t\t\t\t\tcontextualized.notifies(this)\r\n\t\t\t\t}\r\n\t\t\t} catch (error) {\r\n\t\t\t\telement.appendChild(document.createTextNode(error))\r\n\t\t\t}\r\n\t\t\tif(value !== undefined || this.started || this.omitValueOf){\r\n\t\t\t\tthis.started = true\r\n\t\t\t\tif(value && value.then){\r\n\t\t\t\t\tif(this.renderLoading){\r\n\t\t\t\t\t\tthis.renderLoading(value, element)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar renderer = this\r\n\t\t\t\t\tvalue.then(function (value) {\r\n\t\t\t\t\t\trenderer.renderUpdate(value, element)\r\n\t\t\t\t\t})\r\n\t\t\t\t}else{\r\n\t\t\t\t\tthis.renderUpdate(value, element)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tElementRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\t\tthrow new Error('renderUpdate(newValue) must be implemented')\r\n\t\t}\r\n\t\tRenderer.Renderer = Renderer\r\n\t\tRenderer.ElementRenderer = ElementRenderer\r\n\t\r\n\t\tfunction AttributeRenderer(options) {\r\n\t\t\tif(options.name){\r\n\t\t\t\tthis.name = options.name\r\n\t\t\t}\r\n\t\t\tElementRenderer.apply(this, arguments)\r\n\t\t}\r\n\t\tAttributeRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\t\tAttributeRenderer.prototype.type = 'AttributeRenderer'\r\n\t\tAttributeRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\t\telement.setAttribute(this.name, newValue)\r\n\t\t}\r\n\t\tRenderer.AttributeRenderer = AttributeRenderer\r\n\t\r\n\t\tfunction PropertyRenderer(options) {\r\n\t\t\tif (options.name) {\r\n\t\t\t\tthis.name = options.name\r\n\t\t\t}\r\n\t\t\tElementRenderer.apply(this, arguments)\r\n\t\t}\r\n\t\tPropertyRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\t\tPropertyRenderer.prototype.type = 'PropertyRenderer'\r\n\t\tPropertyRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\t\telement[this.name] = newValue\r\n\t\t}\r\n\t\tRenderer.PropertyRenderer = PropertyRenderer\r\n\t\r\n\t\tfunction InputPropertyRenderer(options) {\r\n\t\t\tif (options.element && options.element.tagName === 'SELECT' && options.name === 'value') {\r\n\t\t\t\t// use the deferred value assignment for <select>\r\n\t\t\t\tthis.renderUpdate = this.renderSelectValueUpdate\r\n\t\t\t}\r\n\t\t\tPropertyRenderer.apply(this, arguments)\r\n\t\t}\r\n\t\tInputPropertyRenderer.prototype = Object.create(PropertyRenderer.prototype)\r\n\t\tInputPropertyRenderer.prototype.type = 'InputPropertyRenderer'\r\n\t\tInputPropertyRenderer.prototype.renderUpdate = function(newValue, element) {\r\n\t\t\tif (newValue == null || (element.type === 'number' && isNaN(newValue))) {\r\n\t\t\t\tnewValue = ''\r\n\t\t\t}\r\n\t\t\telement[this.name] = newValue\r\n\t\t}\r\n\t\tInputPropertyRenderer.prototype.renderSelectValueUpdate = function (newValue, element) {\r\n\t\t\telement.value = newValue\r\n\t\t\tif (element.value != newValue && !element.value) {\r\n\t\t\t\t// if we didn't successfully set the value of a <select>, we may need to wait until the children are constructed\r\n\t\t\t\telement.eventualValue = newValue\r\n\t\t\t\tlang.nextTurn(function() {\r\n\t\t\t\t\tif (element.eventualValue) {\r\n\t\t\t\t\t\telement.value = element.eventualValue\r\n\t\t\t\t\t\telement.eventualValue = undefined\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t} else {\r\n\t\t\t\telement.eventualValue = undefined\r\n\t\t\t}\r\n\t\t}\r\n\t\tRenderer.InputPropertyRenderer = InputPropertyRenderer\r\n\t\r\n\t\tfunction StyleRenderer(options) {\r\n\t\t\tif(options.name){\r\n\t\t\t\tthis.name = options.name\r\n\t\t\t}\r\n\t\t\tElementRenderer.apply(this, arguments)\r\n\t\t}\r\n\t\tStyleRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\t\tStyleRenderer.prototype.type = 'StyleRenderer'\r\n\t\tStyleRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\t\telement.style[this.name] = newValue\r\n\t\t}\r\n\t\tRenderer.StyleRenderer = StyleRenderer\r\n\t\r\n\t\tfunction ContentRenderer(options) {\r\n\t\t\tElementRenderer.apply(this, arguments)\r\n\t\t}\r\n\t\tContentRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\t\tContentRenderer.prototype.type = 'ContentRenderer'\r\n\t\tContentRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\t\telement.innerHTML = ''\r\n\t\t\tif (newValue === undefined){\r\n\t\t\t\tnewValue = ''\r\n\t\t\t}\r\n\t\t\telement.appendChild(document.createTextNode(newValue))\r\n\t\t}\r\n\t\tRenderer.ContentRenderer = ContentRenderer\r\n\t\r\n\t\tfunction TextRenderer(options) {\r\n\t\t\tthis.position = options.position\r\n\t\t\tthis.textNode = options.textNode\r\n\t\t\tElementRenderer.apply(this, arguments)\r\n\t\t}\r\n\t\tTextRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\t\tTextRenderer.prototype.type = 'TextRenderer'\r\n\t\tTextRenderer.prototype.updated = function (updateEvent, context) {\r\n\t\t\tif (this.builtList) {\r\n\t\t\t\tif (updateEvent.type === 'refresh') {\r\n\t\t\t\t\tthis.builtList = false\r\n\t\t\t\t\tthis.omitValueOf = false\r\n\t\t\t\t} else {\r\n\t\t\t\t\t(this.updates || (this.updates = [])).push(updateEvent)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tElementRenderer.prototype.updated.call(this, updateEvent, context)\r\n\t\t}\r\n\t\tTextRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\t\tif (newValue == null){\r\n\t\t\t\tnewValue = ''\r\n\t\t\t}\r\n\t\t\tif (newValue.nodeType) {\r\n\t\t\t\tif (this.textNode && this.textNode.parentNode == element) {\r\n\t\t\t\t\t// text node is attached, we can replace it with the node\r\n\t\t\t\t\telement.replaceChild(newValue, this.textNode)\r\n\t\t\t\t} else {\r\n\t\t\t\t\telement.appendChild(newValue)\r\n\t\t\t\t}\r\n\t\t\t\tthis.textNode = newValue\r\n\t\t\t} else if (newValue instanceof Array) {\r\n\t\t\t\tthis.renderUpdate = ListRenderer.prototype.renderUpdate\r\n\t\t\t\tthis.omitValueOf = true\r\n\t\t\t\tthis.renderUpdate(newValue, element)\r\n\t\t\t} else {\r\n\t\t\t\t(this.textNode || element.childNodes[this.position]).nodeValue = newValue\r\n\t\t\t}\r\n\t\t}\r\n\t\tRenderer.TextRenderer = TextRenderer\r\n\t\r\n\t\tfunction ListRenderer(options) {\r\n\t\t\tif (options.each) {\r\n\t\t\t\tthis.each = options.each\r\n\t\t\t}\r\n\t\t\tElementRenderer.apply(this, arguments)\r\n\t\t}\r\n\t\tListRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\t\tListRenderer.prototype.updated = function (updateEvent, context) {\r\n\t\t\tif (this.builtList) {\r\n\t\t\t\tif (updateEvent.type === 'refresh') {\r\n\t\t\t\t\tthis.builtList = false\r\n\t\t\t\t\tthis.omitValueOf = false\r\n\t\t\t\t} else {\r\n\t\t\t\t\t(this.updates || (this.updates = [])).push(updateEvent)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tElementRenderer.prototype.updated.call(this, updateEvent, context)\r\n\t\t}\r\n\t\tListRenderer.prototype.type = 'ListRenderer'\r\n\t\tListRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\t\tvar container\r\n\t\t\tvar each = this.each || function(item) { // TODO: make a single identity function\r\n\t\t\t\treturn item\r\n\t\t\t}\r\n\t\t\tvar thisElement = this.element\r\n\t\t\tvar renderer = this\r\n\t\t\tif (!this.builtList) {\r\n\t\t\t\tthis.builtList = true\r\n\t\t\t\tthis.omitValueOf = true\r\n\t\t\t\telement.innerHTML = ''\r\n\t\t\t\tcontainer = document.createDocumentFragment()\r\n\t\t\t\tvar childElements = this.childElements = []\r\n\t\t\t\tif (each.defineHasOwn) {\r\n\t\t\t\t\teach.defineHasOwn()\r\n\t\t\t\t}\r\n\t\t\t\tnewValue.forEach(function(item) {\r\n\t\t\t\t\teachItem(item)\r\n\t\t\t\t})\r\n\t\t\t\tvar contextualized = this.contextualized || this.variable\r\n\t\t\t\tcontextualized.notifies(this)\r\n\t\r\n\t\t\t\tthisElement.appendChild(container)\r\n\t\t\t} else {\r\n\t\t\t\tvar childElements = this.childElements\r\n\t\t\t\tvar updates = this.updates\r\n\t\t\t\tcontainer = thisElement\r\n\t\t\t\tupdates.forEach(function(update) {\r\n\t\t\t\t\tif (update.type === 'refresh') {\r\n\t\t\t\t\t\trenderer.builtList = false\r\n\t\t\t\t\t\tfor (var i = 0, l = childElements.length; i < l; i++) {\r\n\t\t\t\t\t\t\tthisElement.removeChild(childElements[i])\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\trenderer.renderUpdate()\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (update.previousIndex > -1) {\r\n\t\t\t\t\t\t\tthisElement.removeChild(childElements[update.previousIndex])\r\n\t\t\t\t\t\t\tchildElements.splice(update.previousIndex, 1)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (update.index > -1) {\r\n\t\t\t\t\t\t\tvar nextChild = childElements[update.index] || null\r\n\t\t\t\t\t\t\teachItem(update.value, update.index, nextChild)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t\tthis.updates = [] // clear the updates\r\n\t\t\t}\r\n\t\t\tfunction eachItem(item, index, nextChild) {\r\n\t\t\t\tvar childElement\r\n\t\t\t\tif (each.create) {\r\n\t\t\t\t\tchildElement = each.create({parent: thisElement, _item: item}) // TODO: make a faster object here potentially\r\n\t\t\t\t} else {\r\n\t\t\t\t\tchildElement = each(item, thisElement)\r\n\t\t\t\t\tif (childElement.create) {\r\n\t\t\t\t\t\tchildElement = childElement.create({parent: thisElement, _item: item})\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (nextChild) {\r\n\t\t\t\t\tcontainer.insertBefore(childElement, nextChild)\r\n\t\t\t\t\tchildElements.splice(index, 0, childElement)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcontainer.appendChild(childElement)\r\n\t\t\t\t\tchildElements.push(childElement)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tRenderer.ListRenderer = ListRenderer\r\n\t\r\n\t\tRenderer.onShowElement = function(shownElement){\r\n\t\t\trequestAnimationFrame(function(){\r\n\t\t\t\tinvalidatedElements = null\r\n\t\t\t\tvar elements = [].slice.call(shownElement.getElementsByClassName('needs-rerendering'))\r\n\t\t\t\tif (shownElement.className.indexOf('needs-rerendering') > 0){\r\n\t\t\t\t\tvar includingTop = [shownElement]\r\n\t\t\t\t\tincludingTop.push.apply(includingTop, elements)\r\n\t\t\t\t\telements = includingTop\r\n\t\t\t\t}\r\n\t\t\t\tfor (var i = 0, l = elements.length; i < l; i++){\r\n\t\t\t\t\tvar element = elements[i]\r\n\t\t\t\t\tvar renderers = element.renderersOnShow\r\n\t\t\t\t\tif(renderers){\r\n\t\t\t\t\t\telement.renderersOnShow = null\r\n\t\t\t\t\t\t// remove needs-rerendering class\r\n\t\t\t\t\t\telement.className = element.className.replace(/\\s?needs\\-rerendering\\s?/g, '')\r\n\t\t\t\t\t\tfor (var id in renderers) {\r\n\t\t\t\t\t\t\tvar renderer = renderers[id]\r\n\t\t\t\t\t\t\trenderer.updateElement(element)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t}\r\n\t\r\n\t\tfunction onElementRemoval(element){\r\n\t\t\t// cleanup element renderers\r\n\t\t\tif(element.alkaliRenderers){\r\n\t\t\t\tvar renderers = element.alkaliRenderers\r\n\t\t\t\tfor(var i = 0; i < renderers.length; i++){\r\n\t\t\t\t\tvar renderer = renderers[i]\r\n\t\t\t\t\trenderer.variable.stopNotifies(renderer)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tRenderer.onElementRemoval = function(element, onlyChildren){\r\n\t\t\tif(!onlyChildren){\r\n\t\t\t\tonElementRemoval(element)\r\n\t\t\t}\r\n\t\t\tvar children = element.getElementsByTagName('*')\r\n\t\t\tfor(var i = 0, l = children.length; i < l; i++){\r\n\t\t\t\tvar child = children[i]\r\n\t\t\t\tif(child.alkaliRenderers){\r\n\t\t\t\t\tonElementRemoval(child)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn Renderer\r\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(3), __webpack_require__(2), __webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = function (lang, Variable, operators) {\r\n\t\r\n\t  var isGenerator = lang.isGenerator\r\n\t  var ObjectTransform = lang.compose(Variable.Call, function ObjectTransform(transform, inputs) {\r\n\t    this.inputs = inputs\r\n\t    Variable.Call.apply(this, arguments)\r\n\t  }, {\r\n\t    _getAsObject: function() {\r\n\t      return this.transform.apply(this, preserveObjects(this.inputs))\r\n\t    }\r\n\t  })\r\n\t  function preserveObjects(inputs) {\r\n\t    for (var i = 0, l = inputs.length; i < l; i++) {\r\n\t      var input = inputs[i]\r\n\t      if (input && input._getAsObject) {\r\n\t        inputs[i] = input._getAsObject()\r\n\t      }\r\n\t    }\r\n\t    return inputs\r\n\t  }\r\n\t\tfunction react(generator, options) {\r\n\t    if (typeof generator !== 'function') {\r\n\t      throw new Error('react() must be called with a generator. You need to use the babel-plugin-transform-alkali plugin if you want to use reactive expressions')\r\n\t    }\r\n\t\t\tif (options && options.reverse) {\r\n\t\t\t\tgenerator.reverse = options.reverse\r\n\t\t\t}\r\n\t\t\treturn new Variable.GeneratorVariable(generator)\r\n\t\t}\r\n\t  Object.assign(react, operators)\r\n\t  react.from = function(value, options) {\r\n\t    if (value && value.property) {\r\n\t      return value\r\n\t    }\r\n\t    if (typeof value === 'function' && isGenerator(value)) {\r\n\t      return react(value, options)\r\n\t    }\r\n\t    return Variable.from(value)\r\n\t  }\r\n\t  react.prop = function(object, property) {\r\n\t    if (object) {\r\n\t      // TODO: Use a static set of public methods/properties that can be accessed\r\n\t      if (object.property) {\r\n\t        // it is a variable already, but check to see if we are using a method/property directly on the variable\r\n\t        var directPropertyValue = object[property]\r\n\t        return directPropertyValue !== undefined ? directPropertyValue : object.property(property)\r\n\t      }\r\n\t      return object[property]\r\n\t    }\r\n\t    // not even truthy, return undefined\r\n\t  }\r\n\t  react.cond = function(test, consequent, alternate) {\r\n\t    return operators.if(test, operators.choose(consequent, alternate))\r\n\t  }\r\n\t  react.fcall = function(target, args) {\r\n\t    if (target.property && typeof target === 'function') {\r\n\t      return target.apply(null, preserveObjects(args))\r\n\t    }\r\n\t    return new Variable.Call(target, args)\r\n\t  }\r\n\t  react.mcall = function(target, key, args) {\r\n\t    var method = target[key]\r\n\t    if (typeof method === 'function' && method.property || key === 'bind') {\r\n\t      // for now we check to see if looks like it could handle a variable, or is a bind call\r\n\t      return method.apply(target, preserveObjects(args))\r\n\t    }\r\n\t    return new Variable.Call(target[key].bind(target), args)\r\n\t  }\r\n\t  react.ncall = function(target, args) {\r\n\t    if (target.property && typeof target === 'function') {\r\n\t      return new (target.bind.apply(target, [null].concat(preserveObjects(args))))()\r\n\t    }\r\n\t    return new Variable.Call(function() {\r\n\t      return new (target.bind.apply(target, [null].concat(arguments)))()\r\n\t    }, args)\r\n\t  }\r\n\t\r\n\t  react.obj = function(transform, inputs) {\r\n\t    return new ObjectTransform(transform, inputs)\r\n\t  }\r\n\t\r\n\t\treturn react\r\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Variable) {\r\n\t\tvar deny = Variable.deny;\r\n\t\tvar operatingFunctions = {};\r\n\t\tvar operators = {};\r\n\t\tfunction getOperatingFunction(expression){\r\n\t\t\t// jshint evil: true\r\n\t\t\treturn operatingFunctions[expression] ||\r\n\t\t\t\t(operatingFunctions[expression] =\r\n\t\t\t\t\tnew Function('a', 'b', 'deny', 'return ' + expression));\r\n\t\t}\r\n\t\tfunction operator(operator, name, precedence, forward, reverseA, reverseB){\r\n\t\t\t// defines the standard operators\r\n\t\t\tvar reverse = function(output, inputs){\r\n\t\t\t\tvar a = inputs[0],\r\n\t\t\t\t\tb = inputs[1];\r\n\t\t\t\tif(a && a.put){\r\n\t\t\t\t\tvar result = reverseA(output, b && b.valueOf());\r\n\t\t\t\t\tif(result !== deny){\r\n\t\t\t\t\t\ta.put(result);\r\n\t\t\t\t\t}\r\n\t\t\t\t}else if(b && b.put){\r\n\t\t\t\t\tb.put(reverseB(output, a && a.valueOf()));\r\n\t\t\t\t}else{\r\n\t\t\t\t\treturn deny;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\t// define a function that can lazily ensure the operating function\r\n\t\t\t// is available\r\n\t\t\tvar operatorHandler = {\r\n\t\t\t\tapply: function(instance, args){\r\n\t\t\t\t\tforward = getOperatingFunction(forward);\r\n\t\t\t\t\treverseA = reverseA && getOperatingFunction(reverseA);\r\n\t\t\t\t\treverseB = reverseB && getOperatingFunction(reverseB);\r\n\t\t\t\t\tforward.reverse = reverse;\r\n\t\t\t\t\toperators[operator] = operatorHandler = new Variable(forward);\r\n\t\r\n\t\t\t\t\taddFlags(operatorHandler);\r\n\t\t\t\t\targs = Array.prototype.slice.call(args);\r\n\t\t\t\t\targs.push(deny)\r\n\t\t\t\t\treturn operatorHandler.apply(instance, args);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\tfunction addFlags(operatorHandler){\r\n\t\t\t\toperatorHandler.precedence = precedence;\r\n\t\t\t\toperatorHandler.infix = reverseB !== false;\r\n\t\t\t}\r\n\t\t\taddFlags(operatorHandler);\r\n\t\t\toperators[operator] = operatorHandler;\r\n\t\t\toperators[name] = function() {\r\n\t\t\t\treturn operatorHandler.apply(null, arguments)\r\n\t\t\t}\r\n\t\t}\r\n\t\t// using order precedence from:\r\n\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence\r\n\t\toperator('+', 'add', 6, 'a+b', 'a-b', 'a-b');\r\n\t\toperator('-', 'subtract', 6, 'a-b', 'a+b', 'b-a');\r\n\t\toperator('*', 'multiply', 5, 'a*b', 'a/b', 'a/b');\r\n\t\toperator('/', 'divide', 5, 'a/b', 'a*b', 'b/a');\r\n\t//\toperator('^', 7, 'a^b', 'a^(-b)', 'Math.log(a)/Math.log(b)');\r\n\t\toperator('?', 'if', 16, 'b[a?0:1]', 'a===b[0]||(a===b[1]?false:deny)', '[a,b]');\r\n\t\toperator(':', 'choose', 15, '[a,b]', 'a[0]?a[1]:deny', 'a[1]');\r\n\t\toperator('!', 'not', 4, '!a', '!a', false);\r\n\t\toperator('%', 'remainder', 5, 'a%b');\r\n\t\toperator('>', 'greater', 8, 'a>b');\r\n\t\toperator('>=', 'greaterOrEqual', 8, 'a>=b');\r\n\t\toperator('<', 'less', 8, 'a<b');\r\n\t\toperator('<=', 'lessOrEqual', 8, 'a<=b');\r\n\t\toperator('===', 'looseEqual', 9, 'a===b');\r\n\t\toperator('==', 'equal', 9, 'a==b');\r\n\t\toperator('&', 'and', 8, 'a&&b');\r\n\t\toperator('|', 'or', 8, 'a||b');\r\n\t\toperator('round', 'round', 8, 'Math.round(a*Math.pow(10,b||1))/Math.pow(10,b||1)', 'a', 'a');\r\n\t\treturn operators;\r\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(3), __webpack_require__(2)], __WEBPACK_AMD_DEFINE_RESULT__ = function (lang, Variable) {\r\n\t\r\n\t\tfunction deepCopy(source, target, derivativeMap) {\r\n\t\t\tif (source && typeof source == 'object') {\r\n\t\t\t\tif (source instanceof Array) {\r\n\t\t\t\t\ttarget = [] // always create a new array for array targets\r\n\t\t\t\t\tfor(var i = 0, l = source.length; i < l; i++) {\r\n\t\t\t\t\t\ttarget[i] = deepCopy(source[i], null, derivativeMap)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (!target || typeof target !== 'object') {\r\n\t\t\t\t\t\ttarget = derivativeMap && derivativeMap.get(source)\r\n\t\t\t\t\t\tif (!target) {\r\n\t\t\t\t\t\t\ttarget = {}\r\n\t\t\t\t\t\t\tderivativeMap && derivativeMap.set(source, target)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfor (var i in source) {\r\n\t\t\t\t\t\ttarget[i] = deepCopy(source[i], target[i], derivativeMap)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn target\r\n\t\t\t}\r\n\t\t\treturn source\r\n\t\t}\r\n\t\r\n\t\tvar Copy = lang.compose(Variable, function(copiedFrom) {\r\n\t\t\t// this is the variable that we derive from\r\n\t\t\tthis.copiedFrom = copiedFrom\r\n\t\t\tthis.derivativeMap = new lang.WeakMap(null, 'derivative')\r\n\t\t\tthis.isDirty = new Variable(false)\r\n\t\t}, {\r\n\t\t\tvalueOf: function(context) {\r\n\t\t\t\tif(this.state) {\r\n\t\t\t\t\tthis.state = null\r\n\t\t\t\t}\r\n\t\t\t\tvar value = this.copiedFrom.valueOf(context)\r\n\t\t\t\tif(value && typeof value == 'object') {\r\n\t\t\t\t\tvar derivative = this.derivativeMap.get(value)\r\n\t\t\t\t\tif (derivative == null) {\r\n\t\t\t\t\t\tthis.derivativeMap.set(value, derivative = deepCopy(value, undefined, this.derivativeMap))\r\n\t\t\t\t\t\tthis.setValue(derivative, context)\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn derivative\r\n\t\t\t\t}\r\n\t\t\t\tvar thisValue = this.getValue ? this.getValue(context) : this.value\r\n\t\t\t\tif(thisValue === undefined) {\r\n\t\t\t\t\treturn value\r\n\t\t\t\t}\r\n\t\t\t\treturn thisValue\r\n\t\t\t},\r\n\t\t\tgetCopyOf: function(value) {\r\n\t\t\t\tvar derivative = this.derivativeMap.get(value)\r\n\t\t\t\tif (derivative == null) {\r\n\t\t\t\t\tthis.derivativeMap.set(value, derivative = deepCopy(value, undefined, this.derivativeMap))\r\n\t\t\t\t}\r\n\t\t\t\treturn derivative\r\n\t\t\t},\r\n\t\t\tsave: function() {\r\n\t\t\t\t// copy back to the original object\r\n\t\t\t\tvar original = this.copiedFrom.valueOf()\r\n\t\t\t\tvar newCopiedFrom = deepCopy(this.valueOf(), original)\r\n\t\t\t\tif (original !== newCopiedFrom) {\r\n\t\t\t\t\t// if we have replaced it with a new object/value, put it\r\n\t\t\t\t\tthis.copiedFrom.put && this.copiedFrom.put(newCopiedFrom)\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// else we have modified an existing object, but we still need to notify\r\n\t\t\t\t\tif (this.copiedFrom.notifies && this.copiedFrom.updated) { // copiedFrom doesn't have to be a variable, it can be a plain object\r\n\t\t\t\t\t\tthis.copiedFrom.updated()\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tthis.isDirty.put(false)\r\n\t\t\t\tthis.onSave && this.onSave()\r\n\t\t\t},\r\n\t\t\trevert: function() {\r\n\t\t\t\tvar original = this.copiedFrom.valueOf()\r\n\t\t\t\tthis.put(deepCopy(original, this.derivativeMap.get(original), this.derivativeMap))\r\n\t\t\t\tthis.isDirty.put(false)\r\n\t\t\t},\r\n\t\t\tupdated: function() {\r\n\t\t\t\tthis.isDirty.put(true)\r\n\t\t\t\treturn Variable.prototype.updated.apply(this, arguments)\r\n\t\t\t}\r\n\t\t})\r\n\t\treturn Copy\r\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** index.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap efdc711a6aa3e5948bde\n **/","/// <reference path=\"./index.d.ts\" />\r\nif (typeof define === 'function' && define.amd) {\r\ndefine(['./Element', './Variable', './react', './Renderer', './operators', './Copy'], function(Element, Variable, react, Renderer, operators, Copy) {\r\n\tvar main = Object.create(Element)\r\n\tmain.Copy = Copy\r\n\tmain.Element = Element\r\n\tmain.Variable = Variable\r\n\tmain.VMap = Variable.VMap\r\n\tmain.VArray = Variable.VArray\r\n\tmain.VPromised = Variable.VPromised\r\n\tmain.all = Variable.all\r\n\tmain.react = react\r\n\tmain.spawn = function(func) {\r\n\t\treturn react(func).valueOf()\r\n\t}\r\n\tmain.Renderer = Renderer\r\n\tObject.assign(main, Renderer)\r\n\tObject.assign(main, operators)\r\n\treturn main\r\n})\r\n} else if (typeof module === 'object' && module.exports) {\r\n\t// delegate to the built UMD file, if loaded in node\r\n\tmodule.exports = (require)('./dist/index')\r\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./index.js\n ** module id = 0\n ** module chunks = 0\n **/","define(['./Variable', './Renderer', './util/lang'], function (Variable, Renderer, lang) {\r\n\tvar knownElementProperties = {};\r\n\t['textContent', 'innerHTML', 'title', 'href', 'value', 'valueAsNumber', 'role', 'render'].forEach(function(property) {\r\n\t\tknownElementProperties[property] = true\r\n\t})\r\n\r\n\tvar SELECTOR_REGEX = /(\\.|#)([-\\w]+)(.+)?/\r\n\tvar isGenerator = lang.isGenerator\r\n\tvar Context = Variable.Context\r\n\tvar PropertyRenderer = Renderer.PropertyRenderer\r\n\tvar InputPropertyRenderer = Renderer.InputPropertyRenderer\r\n\tvar AttributeRenderer = Renderer.AttributeRenderer\r\n\tvar StyleRenderer = lang.compose(Renderer.StyleRenderer, function StyleRenderer() {\r\n\t\tRenderer.StyleRenderer.apply(this, arguments)\r\n\t}, {\r\n\t\trenderUpdate: function(newValue, element) {\r\n\t\t\tvar definition = styleDefinitions[this.name]\r\n\t\t\tif (definition) {\r\n\t\t\t\tdefinition(element, newValue, this.name)\r\n\t\t\t} else {\r\n\t\t\t\telement.style[this.name] = newValue\r\n\t\t\t}\r\n\t\t}\r\n\t})\r\n\r\n\tvar ClassNameRenderer = lang.compose(Renderer.ElementRenderer, function ClassNameRenderer(options) {\r\n\t\tthis.className = options.className\r\n\t\tRenderer.apply(this, arguments)\r\n\t}, {\r\n\t\trenderUpdate: function(newValue, element) {\r\n\t\t\tvar currentClassName = element.className\r\n\t\t\tvar changingClassName = this.className\r\n\t\t\t// remove the className (needed for addition or removal)\r\n\t\t\t// see http://jsperf.com/remove-class-name-algorithm/2 for some tests on this\r\n\t\t\tvar removed = currentClassName && (' ' + currentClassName + ' ').replace(' ' + changingClassName + ' ', ' ')\r\n\t\t\tif (newValue) {\r\n\t\t\t\t// addition, add the className\r\n\t\t\t\tchangingClassName = currentClassName ? (removed + changingClassName).slice(1) : changingClassName;\r\n\t\t\t} else {\r\n\t\t\t\t// we already have removed the class, just need to trim\r\n\t\t\t\tchangingClassName = removed.slice(1, removed.length - 1)\r\n\t\t\t}\r\n\t\t\t// only assign if it changed, this can save a lot of time\r\n\t\t\tif (changingClassName != currentClassName) {\r\n\t\t\t\telement.className = changingClassName\r\n\t\t\t}\r\n\t\t}\r\n\t})\r\n\r\n\t// TODO: check for renderContent with text updater\r\n\tvar TextRenderer = Renderer.TextRenderer\r\n\tvar ListRenderer = Renderer.ListRenderer\r\n\t\r\n\tvar toAddToElementPrototypes = []\r\n\tvar createdBaseElements = []\r\n\tvar doc = typeof document !== 'undefined' ? document : {\r\n\t\tcreateElement: function(tag) {\r\n\t\t\treturn {}\r\n\t\t},\r\n\t\taddEventListener: function() {\r\n\t\t}\r\n\t}\r\n\r\n\tvar testStyle = doc.createElement('div').style\r\n\tvar childTagForParent = {\r\n\t\tTABLE: ['tr','td'],\r\n\t\tTBODY: ['tr','td'],\r\n\t\tTR: 'td',\r\n\t\tUL: 'li',\r\n\t\tOL: 'li',\r\n\t\tSELECT: 'option'\r\n\t}\r\n\tvar inputs = {\r\n\t\tINPUT: 1,\r\n\t\tTEXTAREA: 1\r\n\t\t// SELECT: 1, we exclude this, so the default \"content\" of the element can be the options\r\n\t}\r\n\r\n\tfunction booleanStyle(options) {\r\n\t\treturn function(element, value, key) {\r\n\t\t\tif (typeof value === 'boolean') {\r\n\t\t\t\t// has a boolean conversion\r\n\t\t\t\tvalue = options[value ? 0 : 1]\r\n\t\t\t}\r\n\t\t\telement.style[key] = value\r\n\t\t}\r\n\t}\r\n\r\n\tfunction defaultStyle(element, value, key) {\r\n\t\tif (typeof value === 'number') {\r\n\t\t\tvalue = value + 'px'\r\n\t\t}\r\n\t\telement.style[key] = value\r\n\t}\r\n\tfunction directStyle(element, value, key) {\r\n\t\telement.style[key] = value\r\n\t}\r\n\r\n\tvar styleDefinitions = {\r\n\t\tdisplay: booleanStyle(['', 'none']),\r\n\t\tvisibility: booleanStyle(['visible', 'hidden']),\r\n\t\tcolor: directStyle,\r\n\t\topacity: directStyle,\r\n\t\tzoom: directStyle,\r\n\t\tminZoom: directStyle,\r\n\t\tmaxZoom: directStyle,\r\n\t\tfontWeight: directStyle,\r\n\t\tposition: booleanStyle(['absolute', '']),\r\n\t\ttextDecoration: booleanStyle(['underline', '']),\r\n\t\tfontWeight: booleanStyle(['bold', 'normal'])\r\n\t}\r\n\t;[\"alignContent\",\"alignItems\",\"alignSelf\",\"animation\",\"animationDelay\",\"animationDirection\",\"animationDuration\",\"animationFillMode\",\"animationIterationCount\",\"animationName\",\"animationPlayState\",\"animationTimingFunction\",\"backfaceVisibility\",\"background\",\"backgroundAttachment\",\"backgroundBlendMode\",\"backgroundClip\",\"backgroundColor\",\"backgroundImage\",\"backgroundOrigin\",\"backgroundPosition\",\"backgroundPositionX\",\"backgroundPositionY\",\"backgroundRepeat\",\"backgroundRepeatX\",\"backgroundRepeatY\",\"backgroundSize\",\"baselineShift\",\"border\",\"borderBottom\",\"borderBottomColor\",\"borderBottomLeftRadius\",\"borderBottomRightRadius\",\"borderBottomStyle\",\"borderBottomWidth\",\"borderCollapse\",\"borderColor\",\"borderImage\",\"borderImageOutset\",\"borderImageRepeat\",\"borderImageSlice\",\"borderImageSource\",\"borderImageWidth\",\"borderLeft\",\"borderLeftColor\",\"borderLeftStyle\",\"borderLeftWidth\",\"borderRadius\",\"borderRight\",\"borderRightColor\",\"borderRightStyle\",\"borderRightWidth\",\"borderSpacing\",\"borderStyle\",\"borderTop\",\"borderTopColor\",\"borderTopLeftRadius\",\"borderTopRightRadius\",\"borderTopStyle\",\"borderTopWidth\",\"borderWidth\",\"bottom\",\"boxShadow\",\"boxSizing\",\"bufferedRendering\",\"captionSide\",\"clear\",\"clip\",\"clipPath\",\"clipRule\",\"color\",\"colorInterpolation\",\"colorInterpolationFilters\",\"colorRendering\",\"counterIncrement\",\"counterReset\",\"cursor\",\"direction\",\"display\",\"emptyCells\",\"fill\",\"fillOpacity\",\"fillRule\",\"filter\",\"flex\",\"flexBasis\",\"flexDirection\",\"flexFlow\",\"flexGrow\",\"flexShrink\",\"flexWrap\",\"float\",\"floodColor\",\"floodOpacity\",\"font\",\"fontFamily\",\"fontFeatureSettings\",\"fontKerning\",\"fontSize\",\"fontStretch\",\"fontStyle\",\"fontVariant\",\"fontVariantLigatures\",\"fontWeight\",\"height\",\"imageRendering\",\"isolation\",\"justifyContent\",\"left\",\"letterSpacing\",\"lightingColor\",\"lineHeight\",\"listStyle\",\"listStyleImage\",\"listStylePosition\",\"listStyleType\",\"margin\",\"marginBottom\",\"marginLeft\",\"marginRight\",\"marginTop\",\"marker\",\"markerEnd\",\"markerMid\",\"markerStart\",\"mask\",\"maskType\",\"maxHeight\",\"maxWidth\",\"maxZoom\",\"minHeight\",\"minWidth\",\"minZoom\",\"mixBlendMode\",\"motion\",\"motionOffset\",\"motionPath\",\"motionRotation\",\"objectFit\",\"objectPosition\",\"opacity\",\"order\",\"orientation\",\"orphans\",\"outline\",\"outlineColor\",\"outlineOffset\",\"outlineStyle\",\"outlineWidth\",\"overflow\",\"overflowWrap\",\"overflowX\",\"overflowY\",\"padding\",\"paddingBottom\",\"paddingLeft\",\"paddingRight\",\"paddingTop\",\"page\",\"pageBreakAfter\",\"pageBreakBefore\",\"pageBreakInside\",\"paintOrder\",\"perspective\",\"perspectiveOrigin\",\"pointerEvents\",\"position\",\"quotes\",\"resize\",\"right\",\"shapeImageThreshold\",\"shapeMargin\",\"shapeOutside\",\"shapeRendering\",\"size\",\"speak\",\"src\",\"stopColor\",\"stopOpacity\",\"stroke\",\"strokeDasharray\",\"strokeDashoffset\",\"strokeLinecap\",\"strokeLinejoin\",\"strokeMiterlimit\",\"strokeOpacity\",\"strokeWidth\",\"tabSize\",\"tableLayout\",\"textAlign\",\"textAlignLast\",\"textAnchor\",\"textCombineUpright\",\"textDecoration\",\"textIndent\",\"textOrientation\",\"textOverflow\",\"textRendering\",\"textShadow\",\"textTransform\",\"top\",\"touchAction\",\"transform\",\"transformOrigin\",\"transformStyle\",\"transition\",\"transitionDelay\",\"transitionDuration\",\"transitionProperty\",\"transitionTimingFunction\",\"unicodeBidi\",\"unicodeRange\",\"userZoom\",\"vectorEffect\",\"verticalAlign\",\"visibility\",\"whiteSpace\",\"widows\",\"width\",\"willChange\",\"wordBreak\",\"wordSpacing\",\"wordWrap\",\"writingMode\",\"zIndex\",\"zoom\"].forEach(function(property) {\r\n\t\tstyleDefinitions[property] = styleDefinitions[property] || defaultStyle\r\n\t})\r\n\tvar styleSheet\r\n\tvar presumptiveParentMap = new WeakMap()\r\n\r\n\tvar setPrototypeOf = Object.setPrototypeOf || (function(base, proto) { base.__proto__ = proto})\r\n\tvar getPrototypeOf = Object.getPrototypeOf || (function(base) { return base.__proto__ })\r\n\tfunction createCssRule(selector) {\r\n\t\tif (!styleSheet) {\r\n\t\t\tvar styleSheetElement = doc.createElement(\"style\")\r\n\t\t\tstyleSheetElement.setAttribute(\"type\", \"text/css\")\r\n//\t\t\tstyleSheet.appendChild(doc.createTextNode(css))\r\n\t\t\tdoc.head.insertBefore(styleSheetElement, doc.head.firstChild)\r\n\t\t\tstyleSheet = styleSheetElement.sheet\r\n\t\t}\r\n\t\tvar cssRules = styleSheet.cssRules || styleSheet.rules\r\n\t\treturn cssRules[styleSheet.addRule(selector, ' ', cssRules.length)]\r\n\t}\r\n\tvar invalidatedElements = new WeakMap(null, 'invalidated')\r\n\tvar queued\r\n\r\n\tvar toRender = []\r\n\tfunction flatten(target, part) {\r\n\t\tvar base = target.base\r\n\t\tif (base) {\r\n\t\t\tvar basePart = base[part]\r\n\t\t\tif (basePart) {\r\n\t\t\t\ttarget[part] || target[part]\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction layoutChildren(parent, children, container, prepend) {\r\n\t\tvar fragment = (children.length > 3 || prepend) ? doc.createDocumentFragment() : parent\r\n\t\tfor(var i = 0, l = children.length; i < l; i++) {\r\n\t\t\tvar child = children[i]\r\n\t\t\tvar childNode\r\n\t\t\tif (child != null) { // we just skip nulls and undefined, helps make it easier to write conditional element logic\r\n\t\t\t\tif (child.create) {\r\n\t\t\t\t\t// an element constructor\r\n\t\t\t\t\tcurrentParent = parent\r\n\t\t\t\t\tchildNode = child.create()\r\n\t\t\t\t\tfragment.appendChild(childNode)\r\n\t\t\t\t\tif (child.isContentNode) {\r\n\t\t\t\t\t\tcontainer.contentNode = childNode\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (child.notifies) {\r\n\t\t\t\t\t// a variable\r\n\t\t\t\t\tfragment.appendChild(childNode = variableAsContent(parent, child))\r\n\t\t\t\t} else if (typeof child == 'object') {\r\n\t\t\t\t\tif (child instanceof Array) {\r\n\t\t\t\t\t\t// array of sub-children\r\n\t\t\t\t\t\tcontainer = container || parent\r\n\t\t\t\t\t\tchildNode = childNode || parent\r\n\t\t\t\t\t\tlayoutChildren(childNode.contentNode || childNode, child, container)\r\n\t\t\t\t\t} else if (child.nodeType) {\r\n\t\t\t\t\t\t// an element itself\r\n\t\t\t\t\t\tfragment.appendChild(childNode = child)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// TODO: apply properties to last child, but with binding to the parent (for events)\r\n\t\t\t\t\t\tthrow new Error('Unknown child type ' + child)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// a primitive value\r\n\t\t\t\t\tchildNode = doc.createTextNode(child)\r\n\t\t\t\t\tfragment.appendChild(childNode)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (fragment != parent) {\r\n\t\t\tif (prepend) {\r\n\t\t\t\tparent.insertBefore(fragment, parent.firstChild)\r\n\t\t\t} else {\r\n\t\t\t\tparent.appendChild(fragment)\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn childNode\r\n\t}\r\n\tfunction variableAsContent(parent, content) {\r\n\t\tif (content == null) {\r\n\t\t\treturn doc.createTextNode('')\r\n\t\t}\r\n\t\tvar textNode\r\n\t\tif (content.notifies) {\r\n\t\t\ttextNode = doc.createTextNode('')\r\n\t\t\tnew TextRenderer({\r\n\t\t\t\telement: parent,\r\n\t\t\t\ttextNode: textNode,\r\n\t\t\t\tvariable: content\r\n\t\t\t})\r\n\t\t} else {\r\n\t\t\ttextNode = doc.createTextNode(content)\r\n\t\t}\r\n\t\treturn textNode\r\n\t}\r\n\r\n\tfunction bidirectionalHandler(element, value, key) {\r\n\t\tif (value && value.notifies) {\r\n\t\t\tnew InputPropertyRenderer({\r\n\t\t\t\tname: key,\r\n\t\t\t\tvariable: value,\r\n\t\t\t\telement: element\r\n\t\t\t})\r\n\t\t\tif (inputs[element.tagName] || element.tagName === 'SELECT') {\r\n\t\t\t\tbindChanges(element, value, key)\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (element.tagName === 'SELECT' && key === 'value') {\r\n\t\t\t\t// use the deferred <select> value assignment\r\n\t\t\t\tInputPropertyRenderer.prototype.renderSelectValueUpdate(value, element)\r\n\t\t\t} else {\r\n\t\t\t\tif (element.type === 'number') {\r\n\t\t\t\t\tif (isNaN(value)) {\r\n\t\t\t\t\t\tvalue = ''\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telement[key] = value\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction noop() {}\r\n\tvar propertyHandlers = {\r\n\t\tcontent: noop, // content and children have special handling in create\r\n\t\tchildren: noop,\r\n\t\ttagName: noop,\r\n\t\teach: noop, // just used by content, doesn't need to be recorded on the element\r\n\t\tclasses: function(element, classes) {\r\n\t\t\tif (!(classes.length > -1)) {\r\n\t\t\t\t// index the classes, if necessary\r\n\t\t\t\tvar i = 0\r\n\t\t\t\tfor (var key in classes) {\r\n\t\t\t\t\tif (!classes[i]) {\r\n\t\t\t\t\t\tclasses[i] = key\r\n\t\t\t\t\t}\r\n\t\t\t\t\ti++\r\n\t\t\t\t}\r\n\t\t\t\tclasses.length = i\r\n\t\t\t}\r\n\t\t\tfor (var i = 0, l = classes.length; i < l; i++) {\r\n\t\t\t\t// find each class name\r\n\t\t\t\tvar className = classes[i]\r\n\t\t\t\tvar flag = classes[className]\r\n\t\t\t\tif (flag && flag.notifies) {\r\n\t\t\t\t\t// if it is a variable, we react to it\r\n\t\t\t\t\tnew ClassNameRenderer({\r\n\t\t\t\t\t\telement: element,\r\n\t\t\t\t\t\tclassName: className,\r\n\t\t\t\t\t\tvariable: flag\r\n\t\t\t\t\t})\r\n\t\t\t\t} else if (flag || flag === undefined) {\r\n\t\t\t\t\telement.className += ' ' + className\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tclass: applyAttribute,\r\n\t\tfor: applyAttribute,\r\n\t\trole: applyAttribute,\r\n\t\trender: function(element, value, key, properties) {\r\n\t\t\t// TODO: This doesn't need to be a property updater\r\n\t\t\t// we should also verify it is a generator\r\n\t\t\t// and maybe, at some point, find an optimization to eliminate the bind()\r\n\t\t\tnew PropertyRenderer({\r\n\t\t\t\tname: key,\r\n\t\t\t\tvariable: new Variable.GeneratorVariable(value.bind(element, properties)),\r\n\t\t\t\telement: element\r\n\t\t\t})\r\n\t\t},\r\n\t\tvalue: bidirectionalHandler,\r\n\t\tvalueAsNumber: bidirectionalHandler,\r\n\t\tvalueAsDate: bidirectionalHandler,\r\n\t\tchecked: bidirectionalHandler,\r\n\t\tdataset: applySubProperties(function(newValue, element, key) {\r\n\t\t\telement.dataset[key || this.name] = newValue\r\n\t\t}),\r\n\t\tattributes: applySubProperties(function(newValue, element, key) {\r\n\t\t\telement.setAttribute(key || this.name, newValue)\r\n\t\t}),\r\n\t\tstyle: function(element, value, key) {\r\n\t\t\tif (typeof value === 'string') {\r\n\t\t\t\telement.setAttribute('style', value)\r\n\t\t\t} else if (value && value.notifies) {\r\n\t\t\t\tnew AttributeRenderer({\r\n\t\t\t\t\tname: 'style',\r\n\t\t\t\t\tvariable: value,\r\n\t\t\t\t\telment: element\r\n\t\t\t\t})\r\n\t\t\t} else {\r\n\t\t\t\tstyleObjectHandler(element, value, key)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfunction applyAttribute(element, value, key) {\r\n\t\tif (value && value.notifies) {\r\n\t\t\tnew AttributeRenderer({\r\n\t\t\t\tname: key,\r\n\t\t\t\tvariable: value,\r\n\t\t\t\telement: element\r\n\t\t\t})\r\n\t\t} else {\r\n\t\t\telement.setAttribute(key, value)\r\n\t\t}\r\n\t}\r\n\r\n\tvar styleObjectHandler = applySubProperties(function(newValue, element, key) {\r\n\t\telement.style[key || this.name] = newValue\r\n\t})\r\n\r\n\tfunction applySubProperties(renderer) {\r\n\t\tvar SubPropertyRenderer = lang.compose(PropertyRenderer, function SubPropertyRenderer(options) {\r\n\t\t\tPropertyRenderer.apply(this, arguments)\r\n\t\t}, {\r\n\t\t\trenderUpdate: renderer\r\n\t\t})\t\r\n\t\treturn function(element, value, key) {\r\n\t\t\tvar target = element[key]\r\n\t\t\tfor (var subKey in value) {\r\n\t\t\t\tvar subValue = value[subKey]\r\n\t\t\t\tif (subValue && subValue.notifies) {\r\n\t\t\t\t\tnew SubPropertyRenderer({\r\n\t\t\t\t\t\tname: subKey,\r\n\t\t\t\t\t\tvariable: subValue,\r\n\t\t\t\t\t\telement: element\r\n\t\t\t\t\t})\r\n\t\t\t\t} else {\r\n\t\t\t\t\trenderer(subValue, element, subKey)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction assignProperties(element, properties) {\r\n\t\tfor (var key in properties) {\r\n\t\t\tvar value = properties[key]\r\n\t\t\tvar styleDefinition = styleDefinitions[key]\r\n\t\t\tif (propertyHandlers[key]) {\r\n\t\t\t\tpropertyHandlers[key](element, value, key, properties)\r\n\t\t\t} else if ((styleDefinition = styleDefinitions[key]) && element[key] === undefined) {\r\n\t\t\t\tif (value && value.notifies) {\r\n\t\t\t\t\tnew StyleRenderer({\r\n\t\t\t\t\t\tname: key,\r\n\t\t\t\t\t\tvariable: value,\r\n\t\t\t\t\t\telement: element\r\n\t\t\t\t\t})\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstyleDefinition(element, value, key)\r\n\t\t\t\t}\r\n\t\t\t} else if (value && value.notifies) {\r\n\t\t\t\tnew PropertyRenderer({\r\n\t\t\t\t\tname: key,\r\n\t\t\t\t\tvariable: value,\r\n\t\t\t\t\telement: element\r\n\t\t\t\t})\r\n\t\t\t} else if (typeof value === 'function' && key.slice(0, 2) === 'on') {\r\n\t\t\t\telement.addEventListener(key.slice(2), value)\r\n\t\t\t} else {\r\n\t\t\t\telement[key] = value\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction applySelector(element, selector) {\r\n\t\tselector.replace(/(\\.|#)?(\\w+)/g, function(t, operator, name) {\r\n\t\t\tif (operator == '.') {\r\n\t\t\t\telement._class = (element._class ? element._class + ' ' : '') + name\r\n\t\t\t} else if (operator == '#') {\r\n\t\t\t\telement._id = name\r\n\t\t\t} else {\r\n\t\t\t\telement._tag = name\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n\r\n\tfunction buildContent(element, content, key, properties) {\r\n\t\tvar each = element.each || properties.each\r\n\t\tif (each && content) {\r\n\t\t\t// render as list\r\n\t\t\tif (each.create) {\r\n\t\t\t\teach.defineHasOwn = function () {\r\n\t\t\t\t\tvar ItemClass = content.getCollectionOf && content.getCollectionOf() || Item\r\n\t\t\t\t\thasOwn(each, ItemClass, function (element) {\r\n\t\t\t\t\t\tvar itemVariable = ItemClass.from(element._item)\r\n\t\t\t\t\t\treturn itemVariable\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (content.notifies) {\r\n\t\t\t\tnew ListRenderer({\r\n\t\t\t\t\teach: each,\r\n\t\t\t\t\tvariable: content,\r\n\t\t\t\t\telement: element\r\n\t\t\t\t})\r\n\t\t\t} else {\r\n\t\t\t\tvar fragment = doc.createDocumentFragment()\r\n\t\t\t\tif (each.defineHasOwn) {\r\n\t\t\t\t\teach.defineHasOwn()\r\n\t\t\t\t}\r\n\t\t\t\tcontent.forEach(function(item) {\r\n\t\t\t\t\tif (each.create) {\r\n\t\t\t\t\t\tchildElement = each.create({parent: element, _item: item}) // TODO: make a faster object here potentially\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tchildElement = each(item, element)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfragment.appendChild(childElement)\r\n\t\t\t\t})\r\n\t\t\t\telement.appendChild(fragment)\r\n\t\t\t}\r\n\t\t} else if (inputs[element.tagName]) {\r\n\t\t\t// render into input\r\n\t\t\tbuildInputContent(element, content)\r\n\t\t} else if (content instanceof Array) {\r\n\t\t\t// treat array as children (potentially of the content node)\r\n\t\t\telement = element.contentNode || element\r\n\t\t\tlayoutChildren(element, content, element)\r\n\t\t} else {\r\n\t\t\t// render as string\r\n\t\t\telement.appendChild(variableAsContent(element, content))\r\n\t\t}\r\n\t}\r\n\r\n\tfunction bindChanges(element, variable, key, conversion) {\r\n\t\tlang.nextTurn(function() { // wait for next turn in case inputChanges isn't set yet\r\n\t\t\tvar inputEvents = element.inputEvents || ['change', 'alkali-change']\r\n\t\t\tfor (var i = 0, l = inputEvents.length; i < l; i++) {\r\n\t\t\t\telement.addEventListener(inputEvents[i], function (event) {\r\n\t\t\t\t\tvar value = element[key]\r\n\t\t\t\t\tvar result = variable.put(conversion ? conversion(value, element) : value, new Context(element))\r\n\t\t\t\t\tif (result === Variable.deny) {\r\n\t\t\t\t\t\tthrow new Error('Variable change denied')\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n\r\n\tdoc.addEventListener('click', function(event) {\r\n\t\tvar target = event.target\r\n\t\tif (target.type === 'radio') {\r\n\t\t\tvar radios = doc.querySelectorAll('input[type=radio]')\r\n\t\t\tfor (var i = 0, l = radios.length; i < l; i++) {\r\n\t\t\t\tvar radio = radios[i]\r\n\t\t\t\tif (radio.name === target.name && radio !== target) {\r\n\t\t\t\t\tradio.dispatchEvent(new Event('alkali-change', {}))\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t})\r\n\r\n\tfunction conversion(value, element) {\r\n\t\tif (element.type == 'number') {\r\n\t\t\treturn parseFloat(value)\r\n\t\t}\r\n\t\treturn value\r\n\t}\r\n\r\n\tfunction buildInputContent(element, content) {\r\n\t\tvar inputType = element.type\r\n\t\tvar inputProperty = inputType in {date: 1, datetime: 1, time: 1} ?\r\n\t\t\t\t'valueAsDate' : (inputType === 'checkbox' || inputType === 'radio') ?\r\n\t\t\t\t\t'checked' : 'value'\r\n\r\n\t\tif (content && content.notifies) {\r\n\t\t\t// a variable, respond to changes\r\n\t\t\tnew InputPropertyRenderer({\r\n\t\t\t\tvariable: content,\r\n\t\t\t\tname: inputProperty,\r\n\t\t\t\telement: element\r\n\t\t\t})\r\n\t\t\t// and bind the other way as well, updating the variable in response to input changes\r\n\t\t\tbindChanges(element, content, inputProperty, conversion)\r\n\t\t} else {\r\n\t\t\t// primitive\r\n\t\t\telement[inputProperty] = content\r\n\t\t}\r\n\t}\r\n\tvar classHandlers = {\r\n\t\thasOwn: function(Element, value) {\r\n\t\t\thasOwn(Element, value)\r\n\t\t}\r\n\t}\r\n\r\n\tfunction applyToClass(value, Element) {\r\n\t\tvar applyOnCreate = Element._applyOnCreate\r\n\t\tvar prototype = Element.prototype\r\n\t\tif (value && typeof value === 'object') {\r\n\t\t\tif (value instanceof Array || value.notifies) {\r\n\t\t\t\tapplyOnCreate.content = value\r\n\t\t\t} else {\r\n\t\t\t\tfor (var key in value) {\r\n\t\t\t\t// TODO: eventually we want to be able to set these as rules statically per element\r\n\t\t\t\t/*if (styleDefinitions[key]) {\r\n\t\t\t\t\tvar styles = Element.styles || (Element.styles = [])\r\n\t\t\t\t\tstyles.push(key)\r\n\t\t\t\t\tstyles[key] = descriptor.value\r\n\t\t\t\t} else {*/\r\n\t\t\t\t\tif (classHandlers[key]) {\r\n\t\t\t\t\t\thasOwn(Element, value[key])\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// TODO: do deep merging of styles and classes, but not variables\r\n\t\t\t\t\t\tapplyOnCreate[key] = value[key]\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (typeof value === 'function' && !value.for) {\r\n\t\t\tthrow new TypeError('Function as argument not supported')\r\n\t\t} else {\r\n\t\t\tapplyOnCreate.content = value\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getApplySet(Class) {\r\n\t\tif (Class.hasOwnProperty('_applyOnCreate')) {\r\n\t\t\treturn Class._applyOnCreate\r\n\t\t}\r\n\t\t// this means we didn't extend and evaluate the prototype yet\r\n\t\tif (Class.getForClass) {\r\n\t\t\t// we are extending an alkali constructor\r\n\t\t\t// if this class is inheriting from an alkali constructor, work our way up the chain\r\n\t\t\tapplyOnCreate = Class._applyOnCreate = {}\r\n\t\t\tvar parentApplySet = getApplySet(getPrototypeOf(Class))\r\n\t\t\tfor (var key in parentApplySet) {\r\n\t\t\t\tapplyOnCreate[key] = parentApplySet[key]\r\n\t\t\t}\r\n\t\t\t// we need to check the prototype for event handlers\r\n\t\t\tvar prototype = Class.prototype\r\n\t\t\tvar keys = Object.getOwnPropertyNames(prototype)\r\n\t\t\tfor (var i = 0, l = keys.length; i < l; i++) {\r\n\t\t\t\tvar key = keys[i]\r\n\t\t\t\tif (key.slice(0, 2) === 'on' || (key === 'render' && isGenerator(prototype[key]))) {\r\n\t\t\t\t\tapplyOnCreate[key] = prototype[key]\r\n\t\t\t\t} else if (key.slice(0, 6) === 'render') {\r\n\t\t\t\t\tObject.defineProperty(prototype, key[6].toLowerCase() + key.slice(7), renderDescriptor(key))\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn applyOnCreate\r\n\t\t}\r\n\t\treturn null\r\n\t}\r\n\r\n\tfunction renderDescriptor(renderMethod) {\r\n\t\tvar map = new WeakMap()\r\n\t\treturn {\r\n\t\t\tget: function() {\r\n\t\t\t\treturn map.has(this) ? map.get(this) : null\r\n\t\t\t},\r\n\t\t\tset: function(value) {\r\n\t\t\t\tmap.set(this, value)\r\n\t\t\t\tthis[renderMethod](value)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction makeElementConstructor() {\r\n\t\tfunction Element(selector, properties) {\r\n\t\t\tif (this instanceof Element){\r\n\t\t\t\t// create DOM element\r\n\t\t\t\t// Need to detect if we have registered the element and `this` is actually already the correct instance\r\n\t\t\t\treturn create.apply(Element.prototype === getPrototypeOf(this) ? Element :// this means it is from this constructor\r\n\t\t\t\t\tthis.constructor, // this means it was constructed from a subclass\r\n\t\t\t\t\targuments)\r\n\t\t\t} else {\r\n\t\t\t\t// extend to create new class\r\n\t\t\t\treturn withProperties.apply(Element, arguments)\r\n\t\t\t}\r\n\t\t}\r\n\t\tElement.create = create\r\n\t\tElement.with = withProperties\r\n\t\tElement.for = forTarget\r\n\t\tElement.property = propertyForElement\r\n\t\tElement.getForClass = getForClass\r\n\t\treturn Element\r\n\t}\r\n\r\n\tfunction withProperties(selector, properties) {\r\n\t\tvar Element = makeElementConstructor()\r\n\t\tElement.superConstructor = this\r\n\t\tElement.tagName = this.tagName\r\n\t\tif (this.children) {\r\n\t\t\t// just copy this property\r\n\t\t\tElement.children = this.children\r\n\t\t}\r\n\t\tvar prototype = Element.prototype = this.prototype\r\n\r\n\t\tvar hasOwnApplySet\r\n\t\tvar applyOnCreate = Element._applyOnCreate = {}\r\n\t\tvar parentApplySet = getApplySet(this)\r\n\t\t// copy parent properties\r\n\t\tfor (var key in parentApplySet) {\r\n\t\t\tapplyOnCreate[key] = parentApplySet[key]\r\n\t\t}\r\n\r\n\t\tvar i = 0 // for arguments\r\n\t\tif (typeof selector === 'string') {\r\n\t\t\tvar selectorMatch = selector.match(SELECTOR_REGEX)\r\n\t\t\tif (selectorMatch) {\r\n\t\t\t\tdo {\r\n\t\t\t\t\tvar operator = selectorMatch[1]\r\n\t\t\t\t\tvar name = selectorMatch[2]\r\n\t\t\t\t\tif (operator == '.') {\r\n\t\t\t\t\t\tif (applyOnCreate.className) {\r\n\t\t\t\t\t\t\tapplyOnCreate.className += ' ' + name\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tapplyOnCreate.className = name\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tapplyOnCreate.id = name\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar remaining = selectorMatch[3]\r\n\t\t\t\t\tselectorMatch = remaining && remaining.match(SELECTOR_REGEX)\r\n\t\t\t\t} while (selectorMatch)\r\n\t\t\t} else {\r\n\t\t\t\tapplyOnCreate.content = selector\r\n\t\t\t}\r\n\t\t\ti++ // skip the first argument\r\n\t\t}\r\n\r\n\t\tfor (var l = arguments.length; i < l; i++) {\r\n\t\t\tapplyToClass(arguments[i], Element)\r\n\t\t}\r\n\t\treturn Element\r\n\t}\r\n\tvar currentParent\r\n\tfunction create(selector, properties) {\r\n\t\t// TODO: make this a symbol\r\n\t\tvar applyOnCreate = getApplySet(this)\r\n\t\tif (currentParent) {\r\n\t\t\tvar parent = currentParent\r\n\t\t\tcurrentParent = null\r\n\t\t}\r\n/*\t\tif (this._initialized != this) {\r\n\t\t\tthis._initialized = this\r\n\t\t\tthis.initialize && this.initialize()\r\n\t\t\tvar styles = this.styles\r\n\t\t\tif (styles) {\r\n\t\t\t\tvar rule = createCssRule(getUniqueSelector(this))\r\n\t\t\t\tfor (var i = 0, l = styles.length; i < l; i++) {\r\n\t\t\t\t\tvar key = styles[i]\r\n\t\t\t\t\tvar value = styles[key]\r\n\t\t\t\t\t// TODO: if it is a contextualized variable, do this on the element\r\n\t\t\t\t\tvar styleDefinition = styleDefinitions[key]\r\n\t\t\t\t\tif (styleDefinition) {\r\n\t\t\t\t\t\tstyleDefinition(rule, value, key)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!this.hasOwnProperty('_applyOnCreate')) {\r\n\t\t\t\tapplyOnCreate = getApplySet(this)\r\n\t\t\t}\r\n\t\t}*/\r\n\t\tvar element = doc.createElement(this.tagName)\r\n\t\tif (selector && selector.parent) {\r\n\t\t\tparent = selector.parent\r\n\t\t}\r\n\t\tif (parent) {\r\n\t\t\tpresumptiveParentMap.set(element, parent)\r\n\t\t}\r\n\t\tif (!(element instanceof this)) {\r\n\t\t\t// ideally we want to avoid this call, as it is expensive, but for classes that\r\n\t\t\t// don't register a tag name, we have to make sure the prototype chain is correct\r\n\t\t\tsetPrototypeOf(element, this.prototype)\r\n\t\t}\r\n\t\tif (element.constructor != this) {\r\n\t\t\telement.constructor = this // need to do this for hasOwn contextualization to work\r\n\t\t}\r\n\t\tif (arguments.length > 0) {\r\n\t\t\t// copy applyOnCreate when we have arguments\r\n\t\t\tvar ElementApplyOnCreate = applyOnCreate\r\n\t\t\tapplyOnCreate = {}\r\n\t\t\tfor (var key in ElementApplyOnCreate) {\r\n\t\t\t\tapplyOnCreate[key] = ElementApplyOnCreate[key]\r\n\t\t\t}\r\n\t\t\tvar i = 0\r\n\t\t\tif (typeof selector == 'string') {\r\n\t\t\t\ti++\r\n\t\t\t\tvar selectorMatch = selector.match(SELECTOR_REGEX)\r\n\t\t\t\tif (selectorMatch) {\r\n\t\t\t\t\tdo {\r\n\t\t\t\t\t\tvar operator = selectorMatch[1]\r\n\t\t\t\t\t\tvar name = selectorMatch[2]\r\n\t\t\t\t\t\tif (operator == '.') {\r\n\t\t\t\t\t\t\tif (applyOnCreate.className) {\r\n\t\t\t\t\t\t\t\tapplyOnCreate.className += ' ' + name\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tif (element.className) {\r\n\t\t\t\t\t\t\t\t    element.className += ' ' + name\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t    element.className = name\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tif (applyOnCreate.id) {\r\n\t\t\t\t\t\t\t\tapplyOnCreate.id = name\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// just skip right to the element\r\n\t\t\t\t\t\t\t\telement.id = name\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar remaining = selectorMatch[3]\r\n\t\t\t\t\t\tselectorMatch = remaining && remaining.match(SELECTOR_REGEX)\r\n\t\t\t\t\t} while (selectorMatch)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tapplyOnCreate.content = selector\r\n\t\t\t\t}\r\n\t\t\t} else if (selector && selector._item) {\r\n\t\t\t\t// this is kind of hack, to get the Item available before the properties, eventually we may want to\r\n\t\t\t\t// order static properties before variable binding applications, but for now.\r\n\t\t\t\telement._item = selector._item\r\n\t\t\t}\r\n\t\t\tfor (var l = arguments.length; i < l; i++) {\r\n\t\t\t\tvar argument = arguments[i]\r\n\t\t\t\tif (argument && typeof argument === 'object') {\r\n\t\t\t\t\tif (argument instanceof Array || argument.notifies) {\r\n\t\t\t\t\t\tapplyOnCreate.content = argument\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tfor (var key in argument) {\r\n\t\t\t\t\t\t\t// TODO: do deep merging of styles and classes, but not variables\r\n\t\t\t\t\t\t\tapplyOnCreate[key] = argument[key]\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (typeof argument === 'function' && argument.for) {\r\n\t\t\t\t\tapplyOnCreate.content = argument.for(element)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tapplyOnCreate.content = argument\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (element.created) {\r\n\t\t\tapplyOnCreate = element.created(applyOnCreate) || applyOnCreate\r\n\t\t}\r\n\t\t// TODO: inline this for better performance, possibly\r\n\t\tassignProperties(element, applyOnCreate)\r\n\t\tif (this.children) {\r\n\t\t\tlayoutChildren(element, this.children, element)\r\n\t\t}\r\n\t\t// always do this last, so it can be properly inserted inside the children\r\n\t\tif (applyOnCreate.content) {\r\n\t\t\tbuildContent(element, applyOnCreate.content, 'content', applyOnCreate)\r\n\t\t}\r\n\t\telement.ready && element.ready(applyOnCreate)\r\n\t\treturn element\r\n\t}\r\n\r\n\tvar slice = [].slice\r\n\tfunction append(parent){\r\n\t\treturn this.nodeType ?\r\n\t\t\tlayoutChildren(this, arguments, this) : // called as a method\r\n\t\t\tlayoutChildren(parent, slice.call(arguments, 1), parent) // called as a function\r\n\t}\r\n\r\n\tfunction prepend(parent){\r\n\t\treturn this.nodeType ?\r\n\t\t\tlayoutChildren(this, arguments, this, true) : // called as a method\r\n\t\t\tlayoutChildren(parent, slice.call(arguments, 1), parent, true) // called as a function\r\n\t}\r\n\r\n\tfunction registerTag(tagName) {\r\n\t\tthis.tagName = tagName\r\n\t\tif (doc.registerElement && this.prototype.constructor === this) {\r\n\t\t\tdoc.registerElement(tagName, this)\r\n\t\t}\r\n\t}\r\n\r\n\tvar Element = withProperties.call(typeof HTMLElement !== 'undefined' ? HTMLElement : function() {})\r\n\r\n\tElement.registerTag = registerTag\r\n\tElement.assign = assignProperties\r\n\r\n\tElement.within = function(element){\r\n\t\t// find closest child\r\n\t}\r\n\r\n\tgenerate([\r\n\t\t'Video',\r\n\t\t'Source',\r\n\t\t'Media',\r\n\t\t'Audio',\r\n\t\t'UL',\r\n\t\t'Track',\r\n\t\t'Title',\r\n\t\t'TextArea',\r\n\t\t'Template',\r\n\t\t'TBody',\r\n\t\t'THead',\r\n\t\t'TFoot',\r\n\t\t'TR',\r\n\t\t'Table',\r\n\t\t'Col',\r\n\t\t'ColGroup',\r\n\t\t'TH',\r\n\t\t'TD',\r\n\t\t'Caption',\r\n\t\t'Style',\r\n\t\t'Span',\r\n\t\t'Shadow',\r\n\t\t'Select',\r\n\t\t'Script',\r\n\t\t'Quote',\r\n\t\t'Progress',\r\n\t\t'Pre',\r\n\t\t'Picture',\r\n\t\t'Param',\r\n\t\t'P',\r\n\t\t'Output',\r\n\t\t'Option',\r\n\t\t'Optgroup',\r\n\t\t'Object',\r\n\t\t'OL',\r\n\t\t'Ins',\r\n\t\t'Del',\r\n\t\t'Meter',\r\n\t\t'Meta',\r\n\t\t'Menu',\r\n\t\t'Map',\r\n\t\t'Link',\r\n\t\t'Legend',\r\n\t\t'Label',\r\n\t\t'LI',\r\n\t\t'KeyGen',\r\n\t\t'Input',\r\n\t\t'Image',\r\n\t\t'IFrame',\r\n\t\t'H1',\r\n\t\t'H2',\r\n\t\t'H3',\r\n\t\t'H4',\r\n\t\t'H5',\r\n\t\t'H6',\r\n\t\t'Hr',\r\n\t\t'FrameSet',\r\n\t\t'Frame',\r\n\t\t'Form',\r\n\t\t'Font',\r\n\t\t'Embed',\r\n\t\t'Article',\r\n\t\t'Aside',\r\n\t\t'Footer',\r\n\t\t'Figure',\r\n\t\t'FigCaption',\r\n\t\t'Header',\r\n\t\t'Main',\r\n\t\t'Mark',\r\n\t\t'MenuItem',\r\n\t\t'Nav',\r\n\t\t'Section',\r\n\t\t'Summary',\r\n\t\t'WBr',\r\n\t\t'Div',\r\n\t\t'Dialog',\r\n\t\t'Details',\r\n\t\t'DataList',\r\n\t\t'DL',\r\n\t\t'Canvas',\r\n\t\t'Button',\r\n\t\t'Base',\r\n\t\t'Br',\r\n\t\t'Area',\r\n\t\t'A'\r\n\t])\r\n\tgenerateInputs([\r\n\t\t'Checkbox',\r\n\t\t'Password',\r\n\t\t'Submit',\r\n\t\t'Radio',\r\n\t\t'Color',\r\n\t\t'Date',\r\n\t\t'DateTime',\r\n\t\t'Email',\r\n\t\t'Month',\r\n\t\t'Number',\r\n\t\t'Range',\r\n\t\t'Search',\r\n\t\t'Tel',\r\n\t\t'Time',\r\n\t\t'Url',\r\n\t\t'Week'])\r\n\r\n\tvar tags = {}\r\n\tfunction getConstructor(tagName) {\r\n\t\ttagName = tagName.toLowerCase()\r\n\t\treturn tags[tagName] ||\r\n\t\t\t(tags[tagName] =\r\n\t\t\t\tsetTag(withProperties.call(doc.createElement(tagName).constructor), tagName))\r\n\t}\r\n\r\n\tfunction setTag(Element, tagName) {\r\n\t\tElement.tagName = tagName\r\n\t\treturn Element\r\n\t}\r\n\tfunction generate(elements) {\r\n\t\telements.forEach(function(elementName) {\r\n\t\t\tvar ElementClass\r\n\t\t\tObject.defineProperty(Element, elementName, {\r\n\t\t\t\tget: function() {\r\n\t\t\t\t\treturn ElementClass || (ElementClass = getConstructor(elementName))\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t})\r\n\t}\r\n\tfunction generateInputs(elements) {\r\n\t\telements.forEach(function(inputType) {\r\n\t\t\tvar ElementClass\r\n\t\t\tObject.defineProperty(Element, inputType, {\r\n\t\t\t\tget: function() {\r\n\t\t\t\t\t// TODO: make all inputs extend from input generated from generate\r\n\t\t\t\t\treturn ElementClass || (ElementClass = setTag(withProperties.call(HTMLInputElement, {\r\n\t\t\t\t\t\ttype: inputType.toLowerCase()\r\n\t\t\t\t\t}), 'input'))\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\t// alias all the inputs with an Input suffix\r\n\t\t\tObject.defineProperty(Element, inputType + 'Input', {\r\n\t\t\t\tget: function() {\r\n\t\t\t\t\treturn this[inputType]\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t})\r\n\t}\r\n\r\n\tvar aliases = {\r\n\t\tAnchor: 'A',\r\n\t\tParagraph: 'P',\r\n\t\tTextarea: 'TextArea',\r\n\t\tDList: 'DL',\r\n\t\tUList: 'UL',\r\n\t\tOList: 'OL',\r\n\t\tListItem: 'LI',\r\n\t\tText: 'Input',\r\n\t\tTextInput: 'Input',\r\n\t\tTableRow: 'TR',\r\n\t\tTableCell: 'TD',\r\n\t\tTableHeaderCell: 'TH',\r\n\t\tTableHeader: 'THead',\r\n\t\tTableBody: 'TBody'\r\n\t}\r\n\tfor (var alias in aliases) {\r\n\t\t(function(alias, to) {\r\n\t\t\tObject.defineProperty(Element, alias, {\r\n\t\t\t\tget: function() {\r\n\t\t\t\t\treturn this[to]\r\n\t\t\t\t}\r\n\t\t\t})\t\t\t\r\n\t\t})(alias, aliases[alias])\r\n\t}\r\n\r\n\tElement.append = append\r\n\tElement.prepend = prepend\r\n\tElement.refresh = Renderer.refresh\r\n\tvar options = Element.options = {\r\n\t\tmoveLiveElementsEnabled: true,\r\n\t}\r\n\tElement.content = function(element){\r\n\t\t// container marker\r\n\t\treturn {\r\n\t\t\tisContentNode: true,\r\n\t\t\tcreate: element.create.bind(element)\r\n\t\t}\r\n\t}\r\n\t// TODO: unify this in lang\r\n\tElement.extend = function(Class, properties) {\r\n\t\tfunction ExtendedElement() {\r\n\t\t\treturn Class.apply(this, arguments)\r\n\t\t}\r\n\t\tsetPrototypeOf(ExtendedElement, Class)\r\n\t\tvar prototype = ExtendedElement.prototype = Object.create(Class.prototype)\r\n\t\tprototype.constructor = ExtendedElement\r\n\t\tObject.getOwnPropertyNames(properties).forEach(function(key) {\r\n\t\t\tvar descriptor = Object.getOwnPropertyDescriptor(properties, key)\r\n\t\t\tif (classHandlers[key]) {\r\n\t\t\t\tclassHandlers[key](ExtendedElement, descriptor.value)\r\n\t\t\t} else {\r\n\t\t\t\tObject.defineProperty(prototype, key, descriptor)\r\n\t\t\t}\r\n\t\t})\r\n\t\treturn ExtendedElement\r\n\t}\r\n\r\n\tfunction forTarget(target) {\r\n\t\treturn target.constructor.getForClass(target, this)\r\n\t}\r\n\r\n\tfunction hasOwn(From, Target, createInstance) {\r\n\t\tif (typeof Target === 'object' && Target.Class) {\r\n\t\t\treturn hasOwn(From, Target.Class, Target.createInstance)\r\n\t\t}\r\n\t\tif (Target instanceof Array) {\r\n\t\t\treturn Target.forEach(function(Target) {\r\n\t\t\t\thasOwn(From, Target)\r\n\t\t\t})\r\n\t\t}\r\n\t\tvar instanceMap = new WeakMap()\r\n\t\tinstanceMap.createInstance = createInstance\r\n\t\tvar elementMap = From.ownedClasses || (From.ownedClasses = new WeakMap())\r\n\t\telementMap.set(Target, instanceMap)\r\n\t\treturn From\r\n\t}\r\n\r\n\tvar globalInstances = {}\r\n\tfunction getForClass(element, Target) {\r\n\t\tvar createInstance\r\n\t\twhile (element && !(createInstance = element.constructor.ownedClasses && element.constructor.ownedClasses.get(Target))) {\r\n\t\t\telement = element.parentNode || presumptiveParentMap.get(element)\r\n\t\t}\r\n\t\tif (createInstance) {\r\n\t\t\tvar ownedInstances = element.ownedInstances || (element.ownedInstances = new WeakMap())\r\n\t\t\tvar instance = ownedInstances.get(Target)\r\n\t\t\tif (instance === undefined) {\r\n\t\t\t\townedInstances.set(Target, instance = createInstance(element))\r\n\t\t\t\tinstance.subject = element\r\n\t\t\t}\r\n\t\t\treturn instance\r\n\t\t}\r\n\t}\r\n\r\n\tfunction propertyForElement(key) {\r\n\t\t// we just need to establish one Variable class for each element, so we cache it\r\n\t\tThisElementVariable = this._Variable\r\n\t\tif (!ThisElementVariable) {\r\n\t\t\t// need our own branded variable class for this element class\r\n\t\t\tThisElementVariable = this._Variable = Variable()\r\n\r\n\t\t\thasOwn(this, ThisElementVariable, function(element) {\r\n\t\t\t\t// TODO: we might want to do this in init instead\r\n\t\t\t\tvar variableProperties = {}\r\n\t\t\t\tfor (var i = 0; i < element.alkaliRenderers.length; i++){\r\n\t\t\t\t\tvar renderer = element.alkaliRenderers[i]\r\n\t\t\t\t\tif (renderer.name) {\r\n\t\t\t\t\t\tvariableProperties[renderer.name] = {value: renderer.variable}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar elementOverlay = Object.create(element, variableProperties)\r\n\t\t\t\tvar instance = new ThisElementVariable(elementOverlay)\r\n\t\t\t\t// we are not observing, because you can't delegate getters and setters in safari\r\n\t\t\t\t// instance.observeObject()\r\n\t\t\t\treturn instance\r\n\t\t\t})\r\n\t\t}\r\n\t\t// now actually get the property class\r\n\t\treturn ThisElementVariable.property(key)\r\n\t}\r\n\r\n\tvar Item = Element.Item = Variable.Item\r\n\r\n\tfunction enterRenderer(Renderer, options/*, target*/) {\r\n\t\t// this will be used for optimized class-level variables\r\n\t\t/*if (target.started) { // TODO: Might want to pass in started as a parameter\r\n\t\t\t// this means that the renderer has already been created, so we just need to add this instance\r\n\t\t\tRenderer.prototype.renderUpdate.call(options, element)\r\n\t\t} else {*/\r\n\t\tnew Renderer(options)\r\n\t\t//}\r\n\t}\r\n\r\n\tfunction cleanup(target) {\r\n\t\tvar renderers = target.alkaliRenderers\r\n\t\tif (renderers) {\r\n\t\t\tfor (var i = 0, l = renderers.length; i < l; i++) {\r\n\t\t\t\trenderers[i].stop()\r\n\t\t\t}\r\n\t\t\ttarget.needsRestart = true\r\n\t\t}\r\n\t}\r\n\tfunction restart(target) {\r\n\t\tvar renderers = target.alkaliRenderers\r\n\t\tif (renderers) {\r\n\t\t\tfor (var i = 0, l = renderers.length; i < l; i++) {\r\n//\t\t\t\tupdaters[i].start()\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t// setup the mutation observer so we can be notified of attachments and removals\r\n\tfunction elementAttached(element) {\r\n\t\tvar Class = element.constructor\r\n\t\tif (Class.create) {\r\n/*\t\t\tif (Class.attachedInstances) {\r\n\t\t\t\tClass.attachedInstances.push(element)\r\n\t\t\t\tif (Class.attachedInstances.length === 1 && Class.needsRestart) {\r\n\t\t\t\t\trestart(Class)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tClass.attachedInstances = [element]\r\n\t\t\t}*/\r\n\t\t\tif (element.attached) {\r\n\t\t\t\telement.attached()\r\n\t\t\t}\r\n\t\t\tif (element.needsRestart) {\r\n\t\t\t\trestart(element)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfunction elementDetached(element) {\r\n\t\t/*var attachedInstances = element.constructor.attachedInstances\r\n\t\tif (attachedInstances) {\r\n\t\t\tvar index = attachedInstances.indexOf(element)\r\n\t\t\tif (index > -1) {\r\n\t\t\t\tattachedInstances.splice(index, 1)\r\n\t\t\t\tif (attachedInstances.length === 0) {\r\n\t\t\t\t\tcleanup(Class)\r\n\t\t\t\t}\r\n\t\t\t}*/\r\n\t\t\tif (element.detached) {\r\n\t\t\t\telement.detached()\r\n\t\t\t}\r\n\t\t\tcleanup(element)\r\n\t\t//}\r\n\t}\r\n\tif (typeof MutationObserver === 'function') {\r\n\t\tvar docBody = doc.body\r\n\t\tvar lifeStates = [{\r\n\t\t\tname: 'detached',\r\n\t\t\tnodes: 'removedNodes',\r\n\t\t\taction: elementDetached\r\n\t\t}, {\r\n\t\t\tname: 'attached',\r\n\t\t\tnodes: 'addedNodes',\r\n\t\t\taction: elementAttached\r\n\t\t}]\r\n\t\tfunction firstVisit(node, state) {\r\n\t\t\tif (state.name === 'attached') {\r\n\t\t\t\tif (node.__alkaliAttached__) {\r\n\t\t\t\t\treturn false\r\n\t\t\t\t} else {\r\n\t\t\t\t\tnode.__alkaliAttached__ = true\r\n\t\t\t\t\tstate.action(node)\r\n\t\t\t\t\treturn true\r\n\t\t\t\t}\r\n\t\t\t} else if (node.__alkaliAttached__) {\r\n\t\t\t\tif (docBody.contains(node)) {\r\n\t\t\t\t\t// detached event, but it is actually still attached (will get attached in a later mutation record)\r\n\t\t\t\t\t// so don't get through the detached/attached lifecycle\r\n\t\t\t\t\treturn false\r\n\t\t\t\t}\r\n\t\t\t\tnode.__alkaliAttached__ = false\r\n\t\t\t\tstate.action(node)\r\n\t\t\t}\r\n\t\t\treturn true\r\n\t\t}\r\n\t\tvar observer = new MutationObserver(function(mutations) {\r\n\t\t\tfor (var i = 0, il = mutations.length; i < il; i++) {\r\n\t\t\t\tvar mutation = mutations[i]\r\n\t\t\t\t// invoke action on element if we haven't already\r\n\t\t\t\tactionIteration:\r\n\t\t\t\tfor (var j = 0, jl = lifeStates.length; j < jl; j++) { // two steps, removed nodes and added nodes\r\n\t\t\t\t\tvar state = lifeStates[j]\r\n\t\t\t\t\tvar nodes = mutation[state.nodes]\r\n\t\t\t\t\t// iterate over node list\r\n\t\t\t\t\tnodeIteration:\r\n\t\t\t\t\tfor (var k = 0, kl = nodes.length; k < kl; k++) {\r\n\t\t\t\t\t\tvar baseNode = nodes[k]\r\n\t\t\t\t\t\tif (firstVisit(baseNode, state)) {\r\n\t\t\t\t\t\t\t// start traversal with child, if it exists\r\n\t\t\t\t\t\t\tvar currentNode = baseNode.firstChild\r\n\t\t\t\t\t\t\tif (currentNode) {\r\n\t\t\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\t\t\tvar nextNode\r\n\t\t\t\t\t\t\t\t\tif (currentNode.nodeType === 1 && firstVisit(currentNode, state)) {\r\n\t\t\t\t\t\t\t\t\t\t// depth-first search\r\n\t\t\t\t\t\t\t\t\t\tnextNode = currentNode.firstChild\r\n\t\t\t\t\t\t\t\t\t\tif (!nextNode) {\r\n\t\t\t\t\t\t\t\t\t\t\tnextNode = currentNode.nextSibling\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\tnextNode = currentNode.nextSibling\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tif (!nextNode) {\r\n\t\t\t\t\t\t\t\t\t\t// come back out to parents\r\n\t\t\t\t\t\t\t\t\t\t// TODO: try keeping a stack to make this faster\r\n\t\t\t\t\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\t\t\t\t\tcurrentNode = currentNode.parentNode\r\n\t\t\t\t\t\t\t\t\t\t\tif (currentNode === baseNode) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tcontinue nodeIteration\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t} while (!(nextNode = currentNode.nextSibling))\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tcurrentNode = nextNode\r\n\t\t\t\t\t\t\t\t} while (true)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// if (options.moveLiveElementsEnabled) {\r\n\t\t\t\t\t\t// TODO: any options that we can really do here?\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t\tobserver.observe(docBody, {\r\n\t\t\tchildList: true,\r\n\t\t\tsubtree: true\r\n\t\t})\r\n\t}\r\n\t\r\n\tlang.copy(Variable.Context.prototype, {\r\n\t\tspecify: function(Variable) {\r\n\t\t\tvar element = this.subject\r\n\t\t  var distinctive = true\r\n\t\t  ;(this.generics || (this.generics = [])).push(Variable)\r\n\t\t  do {\r\n\t\t    if (this.distinctSubject === element) {\r\n\t\t      distinctive = false\r\n\t\t    }\r\n\t\t    var subjectMap = element.constructor.ownedClasses\r\n\t\t    if (subjectMap) {\r\n\t\t\t\t\tvar instanceMap = subjectMap.get(Variable)\r\n\t\t\t\t\tif (instanceMap) {\r\n\t\t\t      if (distinctive) {\r\n\t\t\t        this.distinctSubject = element\r\n\t\t\t      }\r\n\t\t\t\t\t\tspecifiedInstance = instanceMap.get(element)\r\n\t\t\t\t\t\tif (!specifiedInstance) {\r\n\t\t\t\t\t\t\tinstanceMap.set(element, specifiedInstance = instanceMap.createInstance ?\r\n\t\t\t\t\t\t\t\tinstanceMap.createInstance(element) : new Variable())\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn specifiedInstance\r\n\t\t\t\t\t}\r\n\t\t    }\r\n\t\t  } while ((element = element.parentNode || presumptiveParentMap.get(element)))\r\n\t\t\t// else if no specific context is found, return default instance\r\n\t\t\treturn Variable.defaultInstance\r\n\t\t},\r\n\r\n\t\tgetContextualized: function(variable) {\r\n\t\t\t// returns a variable that has already been contextualized\r\n\t\t\tvar element = this.subject\r\n\t\t\tif (!element) {\r\n\t\t\t\t// no element, just use the default variable\r\n\t\t\t\treturn variable\r\n\t\t\t}\r\n\t\t\tif (variable._contextMap) {\r\n\t\t\t\tdo {\r\n\t\t\t\t\tvar instance = variable._contextMap.get(element)\r\n\t\t\t\t\tif (instance && instance.context.matches(element)) {\r\n\t\t\t\t\t\treturn instance\r\n\t\t\t\t\t}\r\n\t\t\t\t} while ((element = element.parentNode || presumptiveParentMap.get(element)))\r\n\t\t\t}\r\n\t\t\tif (variable.context && variable.context.matches(this.subject)) {\r\n\t\t\t\t// check if the default variable is allowed\r\n\t\t\t\treturn variable\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tmerge: function(childContext) {\r\n\t\t  if (!this.distinctSubject || this.distinctSubject.contains(childContext.distinctSubject)) {\r\n\t\t    this.distinctSubject = childContext.distinctSubject\r\n\t\t  }\r\n\t\t  [].push.apply(this.generics || (this.generics = []), childContext.generics)\r\n\t\t},\r\n\t\tgetDistinctElement: function(Variable, element) {\r\n\t\t  do {\r\n\t\t    var subjectMap = element.constructor.ownedClasses\r\n\t\t    if (subjectMap) {\r\n\t\t\t\t\tvar instanceMap = subjectMap.get(Variable)\r\n\t\t\t\t\tif (instanceMap && instanceMap.has(element)) {\r\n\t\t\t\t\t\treturn element\r\n\t\t\t\t\t}\r\n\t\t    }\r\n\t\t  } while ((element = element.parentNode || presumptiveParentMap.get(element)))\r\n\t\t},\r\n\t\tmatches: function(element) {\r\n\t\t\tvar generics = this.generics\r\n\t\t\tif (generics) {\r\n\t\t\t\tfor (var i = 0, l = generics.length; i < l; i++) {\r\n\t\t\t\t\tif (this.getDistinctElement(generics[i], element) !== this.distinctSubject) {\r\n\t\t\t\t\t\treturn false\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn true\r\n\t\t}\r\n\t})\r\n\t\r\n\r\n\r\n\treturn Element\r\n})\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./Element.js\n ** module id = 1\n ** module chunks = 0\n **/","define(['./util/lang'], function (lang) {\r\n\tvar deny = {}\r\n\tvar noChange = {}\r\n\tvar WeakMap = lang.WeakMap\r\n\tvar setPrototypeOf = Object.setPrototypeOf || (function(base, proto) { base.__proto__ = proto})\r\n\tvar getPrototypeOf = Object.getPrototypeOf || (function(base) { return base.__proto__ })\r\n\t// update types\r\n\tvar ToParent = 2\r\n\tvar RequestChange = 3\r\n\tvar RequestSet = 4\r\n\t\r\n\tvar ToChild = Object.freeze({\r\n\t\ttype: 'refresh'\r\n\t})\r\n\tvar nextId = 1\r\n\tvar propertyListenersMap = new WeakMap(null, 'propertyListenersMap')\r\n\r\n\tvar CacheEntry = lang.compose(WeakMap, function() {\r\n\t},{\r\n\t\t_propertyChange: function(propertyName) {\r\n\t\t\tthis.variable._propertyChange(propertyName, contextFromCache(this))\r\n\t\t}\r\n\t})\r\n\tvar listenerId = 1\r\n\r\n\tfunction when(value, callback) {\r\n\t\tif (value && value.then) {\r\n\t\t\treturn value.then(callback)\r\n\t\t}\r\n\t\treturn callback(value)\r\n\t}\r\n\r\n\tfunction Context(subject){\r\n\t\tthis.subject = subject\r\n\t\tthis.inputs = []\r\n\t}\r\n\tContext.prototype = {\r\n\t\tconstructor: Context,\r\n\t\tnewContext: function(variable) {\r\n\t\t\treturn new Context(this.subject)\r\n\t\t},\r\n\t\tcontextualize: function(variable, parentContext) {\r\n\t\t\t// resolve the contextualization of a variable, and updates this context to be aware of what distinctive aspect of the context has\r\n\t\t\t// been used for resolution\r\n\t\t\tvar contextualized\r\n\t\t\tif (this.distinctSubject) {\r\n\t\t\t\tvar contextMap = variable._contextMap || (variable._contextMap = new WeakMap())\r\n\t\t\t\tcontextualized = contextMap.get(this.distinctSubject)\r\n\t\t\t\tif (!contextualized) {\r\n\t\t\t\t\tcontextMap.set(this.distinctSubject, contextualized = Object.create(variable))\r\n\t\t\t\t\tcontextualized.listeners = false\r\n\t\t\t\t\tcontextualized.context = this\r\n\t\t\t\t\tvar inputs = this.inputs\r\n\t\t\t\t\tfor (var i = 0, l = inputs.length; i < l; i++) {\r\n\t\t\t\t\t\tcontextualized[inputs[i]] = inputs[++i]\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tthis.contextualized = contextualized\r\n\t\t\t\t// do the merge\r\n\t\t\t\tif (parentContext) {\r\n\t\t\t\t\tparentContext.merge(this)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tcontextualized = variable\r\n\t\t\t}\r\n\t\t\t//if (this.contextualized && this.contextualized !== contextualized) {\r\n\t\t\t\t// TOOD: if it has previously been contextualized to a different context (can happen in a promise/async situation), stop previous notifiers and start new ones\r\n\t\t\t//}\r\n\t\t\tparentContext.addInput(contextualized)\r\n\t\t\treturn contextualized\r\n\t\t},\r\n\t\tmerge: function(childContext) {\r\n\t\t\tif (!this.distinctSubject) {\r\n\t\t\t\tthis.distinctSubject = childContext.distinctSubject\r\n\t\t\t}\r\n\t\t},\r\n\t\tspecify: function(Variable) {\r\n\t\t\t// specify a particular instance of a generic variable\r\n\t\t\tvar subject = this.subject\r\n\t\t\tvar subjectMap = subject.constructor.ownedClasses\r\n\t\t\tvar specifiedInstance\r\n\t\t\tif (subjectMap) {\r\n\t\t\t\tif (!this.distinctSubject) {\r\n\t        this.distinctSubject = subject\r\n\t\t\t\t}\r\n\t\t\t\tvar instanceMap = subjectMap.get(Variable)\r\n\t\t\t\tif (instanceMap) {\r\n\t\t\t\t\tspecifiedInstance = instanceMap.get(subject)\r\n\t\t\t\t\tif (!specifiedInstance) {\r\n\t\t\t\t\t\tinstanceMap.set(subject, specifiedInstance = instanceMap.createInstance ? instanceMap.createInstance(subject) : new Variable())\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn specifiedInstance\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// else if no specific context is found, return default instance\r\n\t\t\treturn Variable.defaultInstance\r\n\t\t},\r\n\t\tgetContextualized: function(variable) {\r\n\r\n\t\t\t// returns a variable that has already been contextualized\r\n\t\t\tvar instance = variable._contextMap && this.subject && variable._contextMap.get(this.subject)\r\n\t\t\tif (instance && instance.context && instance.context.matches(this)) {\r\n\t\t\t\treturn instance\r\n\t\t\t}\r\n\t\t},\r\n\t\taddInput: function(inputVariable) {\r\n\t\t\tthis.inputs.push(this.nextProperty, inputVariable)\r\n\t\t},\r\n\t\tmatches: function(context) {\r\n\t\t\t// does another context match the resolution of this one?\r\n\t\t\treturn context.subject === this.subject\r\n\t\t}\r\n\t}\r\n\r\n\tfunction NotifyingContext(listener, subject){\r\n\t\tthis.subject = subject\r\n\t\tthis.listener = listener\r\n\t}\r\n\tNotifyingContext.prototype = Object.create(Context.prototype)\r\n\tNotifyingContext.prototype.constructor = NotifyingContext\r\n\tNotifyingContext.prototype.addInput = function(contextualized) {\r\n\t\tcontextualized.notifies(this.listener)\r\n\t}\r\n\r\n\tfunction whenAll(inputs, callback){\r\n\t\tvar promiseInvolved\r\n\t\tfor (var i = 0, l = inputs.length; i < l; i++) {\r\n\t\t\tif (inputs[i] && inputs[i].then) {\r\n\t\t\t\tpromiseInvolved = true\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (promiseInvolved) {\r\n\t\t\treturn lang.whenAll(inputs, callback)\r\n\t\t}\r\n\t\treturn callback(inputs)\r\n\t}\r\n\r\n\tfunction registerListener(value, listener) {\r\n\t\tvar listeners = propertyListenersMap.get(value)\r\n\t\tvar id = listener.listenerId || (listener.listenerId = ('-' + listenerId++))\r\n\t\tif (listeners) {\r\n\t\t\tif (listeners[id] === undefined) {\r\n\t\t\t\tlisteners[id] = listeners.push(listener) - 1\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\tpropertyListenersMap.set(value, listeners = [listener])\r\n\t\t\tlisteners[id] = 0\r\n\t\t\tif (Variable.autoObserveObjects) {\r\n\t\t\t\tobserve(value)\r\n\t\t\t}\r\n\t\t}\r\n\t\tlistener.listeningToObject = value\r\n\t}\r\n\tfunction deregisterListener(listener) {\r\n\t\tif (listener.listeningToObject) {\r\n\t\t\tvar value = listener.listeningToObject\r\n\t\t\tlistener.listeningToObject = null\r\n\t\t\tvar listeners = propertyListenersMap.get(value)\r\n\t\t\tif (listeners) {\r\n\t\t\t\tvar index = listeners[listener.listenerId]\r\n\t\t\t\tif (index > -1) {\r\n\t\t\t\t\tlisteners.splice(index, 1)\r\n\t\t\t\t\tdelete listeners[listener.listenerId]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction RefreshEvent() {\r\n\t\tthis.visited = new Set()\r\n\t}\r\n\tRefreshEvent.prototype.type = 'refresh'\r\n\r\n\tfunction PropertyChangeEvent(key, childEvent, parent) {\r\n\t\tthis.key = key\r\n\t\tthis.childEvent = childEvent\r\n\t\tthis.parent = parent\r\n\t\tthis.visited = childEvent.visited\r\n\t}\r\n\tPropertyChangeEvent.prototype.type = 'update'\r\n\r\n\tfunction AddEvent(args) {\r\n\t\tthis.visited = new Set()\r\n\t\tfor (var key in args) {\r\n\t\t\tthis[key] = args[key]\r\n\t\t}\r\n\t}\r\n\tAddEvent.prototype.type = 'add'\r\n\tfunction DeleteEvent(args) {\r\n\t\tthis.visited = new Set()\r\n\t\tfor (var key in args) {\r\n\t\t\tthis[key] = args[key]\r\n\t\t}\r\n\t}\r\n\tDeleteEvent.prototype.type = 'delete'\r\n\r\n\tfunction forPropertyNotifyingValues(properties, callback) {\r\n\t\tfor (var key in properties) {\r\n\t\t\tvar property = properties[key]\r\n\t\t\tif (property.returnedVariable) {\r\n\t\t\t\tcallback(property.returnedVariable)\r\n\t\t\t}\r\n\t\t\tif (property.hasChildNotifiers) {\r\n\t\t\t\tvar subProperties = property._properties\r\n\t\t\t\tif (subProperties) {\r\n\t\t\t\t\tforPropertyNotifyingValues(subProperties, callback)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction Variable(value) {\r\n\t\tif (this instanceof Variable) {\r\n\t\t\t// new call, may eventually use new.target\r\n\t\t\tthis.value = typeof value === 'undefined' ? this.default : value\r\n\t\t} else {\r\n\t\t\treturn Variable.extend(value)\r\n\t\t}\r\n\t}\r\n\tvar VariablePrototype = Variable.prototype = {\r\n\t\t// for debugging use\r\n\t\tget _currentValue() {\r\n\t\t\treturn this.valueOf()\r\n\t\t},\r\n\t\tset _currentValue(value) {\r\n\t\t\tthis.put(value)\r\n\t\t},\r\n\t\tconstructor: Variable,\r\n\t\tvalueOf: function(context) {\r\n\t\t\tvar valueContext\r\n\t\t\treturn this.gotValue(this.getValue ?\r\n\t\t\t\tthis.getValue(context && (valueContext = context.newContext())) :\r\n\t\t\t\tthis.value, context, valueContext)\r\n\t\t},\r\n\t\tgotValue: function(value, parentContext, context) {\r\n\t\t\tvar previousNotifyingValue = this.returnedVariable\r\n\t\t\tvar variable = this\r\n\t\t\tif (previousNotifyingValue) {\r\n\t\t\t\tif (value === previousNotifyingValue) {\r\n\t\t\t\t\t// nothing changed, immediately return valueOf (or ownObject if we have it)\r\n\t\t\t\t\tif (variable.ownObject) {\r\n\t\t\t\t\t\treturn variable.ownObject\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (parentContext) {\r\n\t\t\t\t\t\tif (!context) {\r\n\t\t\t\t\t\t\tcontext = parentContext.newContext()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcontext.contextualize(this, parentContext)\r\n\t\t\t\t\t\tcontext.nextProperty = 'returnedVariable'\r\n\t\t\t\t\t\treturn value.valueOf(context)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn value.valueOf()\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// if there was a another value that we were dependent on before, stop listening to it\r\n\t\t\t\t// TODO: we may want to consider doing cleanup after the next rendering turn\r\n\t\t\t\tif (variable.listeners) {\r\n\t\t\t\t\tpreviousNotifyingValue.stopNotifies(variable)\r\n\t\t\t\t}\r\n\t\t\t\tvariable.returnedVariable = null\r\n\t\t\t}\r\n\t\t\tif (value && value.notifies) {\r\n\t\t\t\tvariable.returnedVariable = value\r\n\t\t\t\tif (variable.listeners) {\r\n\t\t\t\t\tvalue.notifies(variable)\r\n\t\t\t\t}\r\n\t\t\t\t/*var parent = variable\r\n\t\t\t\tdo {\r\n\t\t\t\t\tif (parent.listeners) {\r\n\t\t\t\t\t\t// the value is another variable, start receiving notifications, if we, or any parent is live\r\n\t\t\t\t\t\tvariable.returnedVariable.notifies(variable)\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\t}\r\n\t\t\t\t\tparent.hasNotifyingChild = true\r\n\t\t\t\t} while((parent = parent.parent))*/\r\n\t\t\t\tcontext = context || parentContext && (context = parentContext.newContext())\r\n\t\t\t\tif (context) {\r\n\t\t\t\t\tcontext.nextProperty = 'returnedVariable'\r\n\t\t\t\t}\r\n\t\t\t\tvalue = value.valueOf(context)\r\n\t\t\t\tif (variable.ownObject) {\r\n\t\t\t\t\tif (getPrototypeOf(variable.ownObject) !== value) {\r\n\t\t\t\t\t\tsetPrototypeOf(variable.ownObject, value)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvalue = variable.ownObject\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (value === undefined) {\r\n\t\t\t\tvalue = variable.default\r\n\t\t\t}\r\n\t\t\tif (context) {\r\n\t\t\t\tcontext.contextualize(this, parentContext)\r\n\t\t\t}\r\n\t\t\tif (parentContext) {\r\n\r\n\t\t\t\t/*if (!contextualized.listeners) {\r\n\t\t\t\t\t// mark it as initialized, since we have already recursively dependended on inputs\r\n\t\t\t\t\tcontextualized.listeners = []\r\n\t\t\t\t}*/\r\n\r\n\t\t\t\tif (!context) {\r\n\t\t\t\t\tparentContext.addInput(this)\r\n\t\t\t\t}\t\t\t\t\r\n\t\t\t}\r\n\t\t\tif (value && value.then) {\r\n\t\t\t\treturn when(value, function(value) {\r\n\t\t\t\t\treturn Variable.prototype.gotValue.call(variable, value, context)\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\treturn value\r\n\t\t},\r\n\t\tisMap: function() {\r\n\t\t\treturn this.value instanceof Map\r\n\t\t},\r\n\t\tproperty: function(key) {\r\n\t\t\tvar isMap = this.isMap()\r\n\t\t\tvar properties = this._properties || (this._properties = isMap ? new Map() : {})\r\n\t\t\tvar propertyVariable = isMap ? properties.get(key) : properties[key]\r\n\t\t\tif (!propertyVariable) {\r\n\t\t\t\t// create the property variable\r\n\t\t\t\tpropertyVariable = new Property(this, key)\r\n\t\t\t\tif (isMap) {\r\n\t\t\t\t\tproperties.set(key, propertyVariable)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tproperties[key] = propertyVariable\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn propertyVariable\r\n\t\t},\r\n\t\tfor: function(subject) {\r\n\t\t\tif (subject && subject.target && !subject.constructor.getForClass) {\r\n\t\t\t\t// makes HTML events work\r\n\t\t\t\tsubject = subject.target\r\n\t\t\t}\r\n\t\t\treturn new ContextualizedVariable(this, subject || defaultContext)\r\n\t\t},\r\n\t\t_propertyChange: function(propertyName, object, context, type) {\r\n\t\t\tif (this.onPropertyChange) {\r\n\t\t\t\tthis.onPropertyChange(propertyName, object, context)\r\n\t\t\t}\r\n\t\t\tthis.updated(new PropertyChangeEvent(propertyName, new RefreshEvent(), this), null, context)\r\n\t\t},\r\n\t\teachKey: function(callback) {\r\n\t\t\tfor (var i in this._properties) {\r\n\t\t\t\tcallback(i)\r\n\t\t\t}\r\n\t\t},\r\n\t\tapply: function(instance, args) {\r\n\t\t\treturn new Call(this, args)\r\n\t\t},\r\n\t\tcall: function(instance) {\r\n\t\t\treturn this.apply(instance, Array.prototype.slice.call(arguments, 1))\r\n\t\t},\r\n\t\tforDependencies: function(callback) {\r\n\t\t\tif (this.returnedVariable) {\r\n\t\t\t\tcallback(this.returnedVariable)\r\n\t\t\t}\r\n\t\t\tif (this.hasNotifyingChild) {\r\n\t\t\t\tvar properties = this._properties\r\n\t\t\t\tif (properties) {\r\n\t\t\t\t\tforPropertyNotifyingValues(properties, callback)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tinit: function() {\r\n\t\t\tvar variable = this\r\n\t\t\tthis.forDependencies(function(dependency) {\r\n\t\t\t\tdependency.notifies(variable)\r\n\t\t\t})\r\n\r\n\t\t\tif (this.listeningToObject === null) {\r\n\t\t\t\t// we were previously listening to an object, but it needs to be restored\r\n\t\t\t\t// calling valueOf will cause the listening object to be restored\r\n\t\t\t\tthis.valueOf()\r\n\t\t\t}\r\n\t\t},\r\n\t\tcleanup: function() {\r\n\t\t\tthis.listeners = false\r\n\t\t\tvar handles = this.handles\r\n\t\t\tif (handles) {\r\n\t\t\t\tfor (var i = 0; i < handles.length; i++) {\r\n\t\t\t\t\thandles[i].remove()\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.handles = null\r\n\t\t\tvar returnedVariable = this.returnedVariable\r\n\t\t\tif (returnedVariable) {\r\n\t\t\t\t// TODO: move this into the caching class\r\n\t\t\t\tthis.computedVariable = null\r\n\t\t\t}\r\n\t\t\tvar variable = this\r\n\t\t\tthis.forDependencies(function(dependency) {\r\n\t\t\t\tdependency.stopNotifies(variable)\r\n\t\t\t})\r\n\t\t},\r\n\r\n\t\tupdateVersion: function(version) {\r\n\t\t\tthis.version = nextId++\r\n\t\t},\r\n\r\n\t\tgetVersion: function(context) {\r\n\t\t\treturn Math.max(this.version || 0, this.returnedVariable && this.returnedVariable.getVersion ? this.returnedVariable.getVersion(context) : 0)\r\n\t\t},\r\n\r\n\t\tgetSubject: function(selectVariable) {\r\n\t\t\treturn this.subject\r\n\t\t},\r\n\r\n\t\tgetUpdates: function(since) {\r\n\t\t\tvar updates = []\r\n\t\t\tvar nextUpdateMap = this.nextUpdateMap\r\n\t\t\tif (nextUpdateMap && since) {\r\n\t\t\t\twhile ((since = nextUpdateMap.get(since))) {\r\n\t\t\t\t\tif (since.type === 'refresh') {\r\n\t\t\t\t\t\t// if it was refresh, we can clear any prior entries\r\n\t\t\t\t\t\tupdates = []\r\n\t\t\t\t\t}\r\n\t\t\t\t\tupdates.push(since)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn updates\r\n\t\t},\r\n\r\n\t\tupdated: function(updateEvent, by, context) {\r\n\t\t\tif (!updateEvent) {\r\n\t\t\t\tupdateEvent = new RefreshEvent()\r\n\t\t\t}\r\n\t\t\tif (updateEvent.visited.has(this)){\r\n\t\t\t\t// if this event has already visited this variable, skip it\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tupdateEvent.visited.add(this)\r\n\t\t\tvar contextualInstance = context ? context.getContextualized(this) : this\r\n\t\t\tif (contextualInstance) {\r\n\t\t\t\tcontextualInstance.updated(updateEvent, this, context)\r\n\t\t\t}\r\n\t\t\t/*\r\n\t\t\t// at some point we could do an update list so that we could incrementally update\r\n\t\t\t// lists in non-live situations\r\n\t\t\tif (this.lastUpdate) {\r\n\t\t\t\tvar nextUpdateMap = this.nextUpdateMap\r\n\t\t\t\tif (!nextUpdateMap) {\r\n\t\t\t\t\tnextUpdateMap = this.nextUpdateMap = new WeakMap()\r\n\t\t\t\t}\r\n\t\t\t\tnextUpdateMap.set(this.lastUpdate, updateEvent)\r\n\t\t\t}\r\n\r\n\t\t\tthis.lastUpdate = updateEvent */\r\n\t\t\tthis.updateVersion()\r\n\t\t\tvar value = this.value\r\n\r\n\t\t\tvar listeners = this.listeners\r\n\t\t\tif (listeners) {\r\n\t\t\t\tvar variable = this\r\n\t\t\t\t// make a copy, in case they change\r\n\t\t\t\tlisteners.forEach(function(dependent) {\r\n\t\t\t\t\tif ((updateEvent instanceof PropertyChangeEvent) &&\r\n\t\t\t\t\t\t\t(dependent instanceof Property)) {\r\n\t\t\t\t\t\tif (dependent.key === updateEvent.key) {\r\n\t\t\t\t\t\t\tdependent.updated(updateEvent.childEvent, variable, context)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tdependent.updated(updateEvent, variable, context)\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tif (updateEvent instanceof PropertyChangeEvent) {\r\n\t\t\t\tif (this.returnedVariable && this.fixed) {\r\n\t\t\t\t\tthis.returnedVariable.updated(updateEvent, this, context)\r\n\t\t\t\t}\r\n\t\t\t\tif (this.constructor.collection) {\r\n\t\t\t\t\tthis.constructor.collection.updated(updateEvent, this, context)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn updateEvent\r\n\t\t},\r\n\r\n\t\tinvalidate: function() {\r\n\t\t\t// for back-compatibility for now\r\n\t\t\tthis.updated()\r\n\t\t},\r\n\r\n\t\tnotifies: function(target) {\r\n\t\t\tvar listeners = this.listeners\r\n\t\t\tif (!listeners || !this.hasOwnProperty('listeners')) {\r\n\t\t\t\tthis.listeners = listeners = new Set()\r\n\t\t\t\tthis.init()\r\n\t\t\t}\r\n\t\t\tlisteners.add(target)\r\n\t\t},\r\n\t\tsubscribe: function(listener) {\r\n\t\t\t// ES7 Observable (and baconjs) compatible API\r\n\t\t\tvar updated\r\n\t\t\tvar updateQueued\r\n\t\t\tvar variable = this\r\n\t\t\t// it is important to make sure you register for notifications before getting the value\r\n\t\t\tif (typeof listener === 'function') {\r\n\t\t\t\t// BaconJS compatible API\r\n\t\t\t\tvar variable = this\r\n\t\t\t\tvar event = {\r\n\t\t\t\t\tvalue: function() {\r\n\t\t\t\t\t\treturn variable.valueOf()\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tupdated = function() {\r\n\t\t\t\t\tupdateQueued = false\r\n\t\t\t\t\tlistener(event)\r\n\t\t\t\t}\r\n\t\t\t}\telse if (listener.next) {\r\n\t\t\t\t// Assuming ES7 Observable API. It is actually a streaming API, this pretty much violates all principles of reactivity, but we will support it\r\n\t\t\t\tupdated = function() {\r\n\t\t\t\t\tupdateQueued = false\r\n\t\t\t\t\tlistener.next(variable.valueOf())\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tthrow new Error('Subscribing to an invalid listener, the listener must be a function, or have an update or next method')\r\n\t\t\t}\r\n\t\t\tvar updateReceiver = {\r\n\t\t\t\tupdated: function() {\r\n\t\t\t\t\tif (updateQueued) {\r\n\t\t\t\t\t\treturn\r\n\t\t\t\t\t}\r\n\t\t\t\t\tupdateQueued = true\r\n\t\t\t\t\tlang.nextTurn(updated)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tupdated()\r\n\t\t\tthis.notifies(updateReceiver)\r\n\t\t\treturn {\r\n\t\t\t\tunsubscribe: function() {\r\n\t\t\t\t\tvariable.stopNotifies(updateReceiver)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tstopNotifies: function(dependent) {\r\n\t\t\tvar listeners = this.listeners\r\n\t\t\tif (listeners) {\r\n\t\t\t\tlisteners.delete(dependent)\r\n\t\t\t\tif (listeners.size === 0) {\r\n\t\t\t\t\t// clear the listeners so it will be reinitialized if it has\r\n\t\t\t\t\t// listeners again\r\n\t\t\t\t\tthis.cleanup()\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tput: function(value, context) {\r\n\t\t\tvar variable = this\r\n\t\t\tif (this.ownObject) {\r\n\t\t\t\tthis.ownObject = false\r\n\t\t\t}\t\t\r\n\t\t\treturn when(this.getValue ? this.getValue(context) : this.value, function(oldValue) {\r\n\t\t\t\tif (variable.__debug) {\r\n\t\t\t\t\t// _debug _debug is on\r\n\t\t\t\t\tconsole.log('Variable changed from', oldValue, newValue, 'at')\r\n\t\t\t\t\tconsole.log((new Error().stack || '').replace(/Error/, ''))\r\n\t\t\t\t}\r\n\t\t\t\tif (oldValue === value) {\r\n\t\t\t\t\treturn noChange\r\n\t\t\t\t}\r\n\t\t\t\tif (variable.fixed &&\r\n\t\t\t\t\t\t// if it is set to fixed, we see we can put in the current variable\r\n\t\t\t\t\t\toldValue && oldValue.put) {\r\n\t\t\t\t\treturn oldValue.put(value)\r\n\t\t\t\t}\r\n\t\t\t\treturn when(variable.setValue(value, context), function(value) {\r\n\t\t\t\t\tvariable.updated(new RefreshEvent(), variable, context)\r\n\t\t\t\t})\r\n\t\t\t})\r\n\t\t},\r\n\t\tget: function(key) {\r\n\t\t\tif (this._properties && this._properties[key]) {\r\n\t\t\t\treturn this.property(key).valueOf()\r\n\t\t\t}\r\n\t\t\treturn when(this.valueOf(), function(object) {\r\n\t\t\t\tvar value = object && (typeof object.get === 'function' ? object.get(key) : object[key])\r\n\t\t\t\tif (value && value.notifies) {\r\n\t\t\t\t\t// nested variable situation, get underlying value\r\n\t\t\t\t\treturn value.valueOf()\r\n\t\t\t\t}\r\n\t\t\t\treturn value\r\n\t\t\t})\r\n\t\t},\r\n\t\tset: function(key, value) {\r\n\t\t\t// TODO: create an optimized route when the property doesn't exist yet\r\n\t\t\tthis.property(key)._changeValue(null, RequestSet, value)\r\n\t\t},\r\n\t\tundefine: function(key, context) {\r\n\t\t\tthis.set(key, undefined, context)\r\n\t\t},\r\n\t\tproxy: function(proxiedVariable) {\r\n\t\t\tvar thisVariable = this\r\n\t\t\tthis.fixed = true\r\n\t\t\treturn when(this.setValue(proxiedVariable), function(value) {\r\n\t\t\t\tthisVariable.updated(new RefreshEvent(), thisVariable)\r\n\t\t\t})\r\n\t\t},\r\n\t\tnext: function(value) {\r\n\t\t\t// for ES7 observable compatibility\r\n\t\t\tthis.put(value)\r\n\t\t},\r\n\t\terror: function(error) {\r\n\t\t\t// for ES7 observable compatibility\r\n\t\t\tvar listeners = this.listeners\r\n\t\t\tif (listeners) {\r\n\t\t\t\t// make a copy, in case they change\r\n\t\t\t\tlisteners.forEach(function(dependent) {\r\n\t\t\t\t\t// skip notifying property listeners if we are headed up the parent chain\r\n\t\t\t\t\tdependent.error(error)\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t},\r\n\t\tcomplete: function(value) {\r\n\t\t\t// for ES7 observable compatibility\r\n\t\t\tthis.put(value)\r\n\t\t},\r\n\t\tsetValue: function(value) {\r\n\t\t\tthis.value = value\r\n\t\t},\r\n\t\tonValue: function(listener) {\r\n\t\t\treturn this.subscribe(function(event) {\r\n\t\t\t\tlang.when(event.value(), function(value) {\r\n\t\t\t\t\tlistener(value)\r\n\t\t\t\t})\r\n\t\t\t})\r\n\t\t},\r\n\t\ttoJSON: function() {\r\n\t\t\treturn this.valueOf()\r\n\t\t},\r\n\t\ttoString: function() {\r\n\t\t\treturn this.valueOf()\r\n\t\t},\r\n\t\tforEach: function(callbackOrItemClass, callbackOrContext, context) {\r\n\t\t\t// iterate through current value of variable\r\n\t\t\tif (callbackOrItemClass.notifies) {\r\n\t\t\t\tvar collectionVariable = this\r\n\t\t\t\treturn this.forEach(function(item) {\r\n\t\t\t\t\tvar itemVariable = callbackOrItemClass.from(item)\r\n\t\t\t\t\tcallbackOrContext.call(this, itemVariable)\r\n\t\t\t\t}, context)\r\n\t\t\t}\r\n\t\t\treturn when(this.valueOf(callbackOrContext), function(value) {\r\n\t\t\t\tif (value && value.forEach) {\r\n\t\t\t\t\tvalue.forEach(callbackOrItemClass)\r\n\t\t\t\t}else{\r\n\t\t\t\t\tfor (var i in value) {\r\n\t\t\t\t\t\tcallbackOrItemClass.call(value, value[i], i)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t},\r\n\r\n\t\tto: function (transformFunction, reverse) {\r\n\t\t\tif (typeof transformFunction !== 'function') {\r\n\t\t\t\tif (typeof transformFunction === 'object') {\r\n\t\t\t\t\tthis.to(transformFunction.get, transformFunction.set)\r\n\t\t\t\t}\r\n\t\t\t\tthrow new Error('No function provided to transform')\r\n\t\t\t}\r\n\t\t\tif (reverse) {\r\n\t\t\t\ttransformFunction.reverse = function(value, args, context) {\r\n\t\t\t\t\t// for direct to, we can just use the first argument\r\n\t\t\t\t\treverse.call(this, args[0], context)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn new Call(transformFunction, [this])\r\n\t\t},\r\n\t\tget schema() {\r\n\t\t\t// default schema is the constructor\r\n\t\t\treturn this.returnedVariable ? this.returnedVariable.schema : this.constructor\r\n\t\t},\r\n\t\tset schema(schema) {\r\n\t\t\t// but allow it to be overriden\r\n\t\t\tObject.defineProperty(this, 'schema', {\r\n\t\t\t\tvalue: schema\r\n\t\t\t})\r\n\t\t},\r\n\t\tvalidate: function(target, schema) {\r\n\t\t\tif (this.returnedVariable) {\r\n\t\t\t\treturn this.returnedVariable.validate(target, schema)\r\n\t\t\t}\r\n\t\t\tif (schema.type && (schema.type !== typeof target)) {\r\n\t\t\t\treturn ['Target type of ' + typeof target + ' does not match schema type of ' + schema.type]\r\n\t\t\t}\r\n\t\t\tvar valid = []\r\n\t\t\tvalid.isValid = true\r\n\t\t\treturn valid\r\n\t\t},\r\n\r\n\t\tget validation() {\r\n\t\t\tvar validation = new Validating(this)\r\n\t\t\tObject.defineProperty(this, 'validation', {\r\n\t\t\t\tvalue: validation\r\n\t\t\t})\r\n\t\t\treturn validation\r\n\t\t},\r\n\t\tset validation(validation) {\r\n\t\t\t// but allow it to be overriden\r\n\t\t\tObject.defineProperty(this, 'validation', {\r\n\t\t\t\tvalue: validation\r\n\t\t\t})\r\n\t\t},\r\n\t\tgetId: function() {\r\n\t\t\treturn this.id || (this.id = nextId++)\r\n\t\t},\r\n\t\tobserveObject: function() {\r\n\t\t\tvar variable = this\r\n\t\t\treturn when(this.valueOf(), function(object) {\r\n\t\t\t\tvar listeners = propertyListenersMap.get(object)\r\n\t\t\t\tif (!listeners) {\r\n\t\t\t\t\tpropertyListenersMap.set(object, listeners = [])\r\n\t\t\t\t}\r\n\t\t\t\tif (listeners.observerCount) {\r\n\t\t\t\t\tlisteners.observerCount++\r\n\t\t\t\t}else{\r\n\t\t\t\t\tlisteners.observerCount = 1\r\n\t\t\t\t\tvar observer = listeners.observer = lang.observe(object, function(events) {\r\n\t\t\t\t\t\tfor (var i = 0, l = listeners.length; i < l; i++) {\r\n\t\t\t\t\t\t\tvar listener = listeners[i]\r\n\t\t\t\t\t\t\tfor (var j = 0, el = events.length; j < el; j++) {\r\n\t\t\t\t\t\t\t\tvar event = events[j]\r\n\t\t\t\t\t\t\t\tlistener._propertyChange(event.name, object)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t\tif (observer.addKey) {\r\n\t\t\t\t\t\tfor (var i = 0, l = listeners.length; i < l; i++) {\r\n\t\t\t\t\t\t\tvar listener = listeners[i]\r\n\t\t\t\t\t\t\tlistener.eachKey(function(key) {\r\n\t\t\t\t\t\t\t\tobserver.addKey(key)\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tregisterListener(object, variable)\r\n\t\t\t\treturn {\r\n\t\t\t\t\tremove: function() {\r\n\t\t\t\t\t\tderegisterListener(object, variable)\r\n\t\t\t\t\t\tif (!(--listeners.observerCount)) {\r\n\t\t\t\t\t\t\tlisteners.observer.remove()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t},\r\n\t\t\t\t\tdone: function() {\r\n\t\t\t\t\t\t// deliver changes\r\n\t\t\t\t\t\tlang.deliverChanges(observer)\r\n\t\t\t\t\t\tthis.remove()\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t},\r\n\t\tgetCollectionOf: function() {\r\n\t\t\treturn this.constructor.collectionOf\r\n\t\t},\r\n\t\t_willModify: function(context) {\r\n\t\t\t// an intent to modify, so we need to make sure we have our own copy\r\n\t\t\t// of an object when necessary\r\n\t\t\tif (this.fixed) {\r\n\t\t\t\tif (this.value && this.value._willModify) {\r\n\t\t\t\t\treturn this.value._willModify(context)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!this.ownObject && this.value && this.value.notifies) {\r\n\t\t\t\tvar variable = this\r\n\t\t\t\treturn when(this.valueOf(context), function(value) {\r\n\t\t\t\t\tif (value && typeof value === 'object') {\r\n\t\t\t\t\t\tif (value instanceof Array) {\r\n\t\t\t\t\t\t\tvariable.ownObject = value.slice(0)\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tvariable.ownObject = Object.create(value)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t},\r\n\t\t_sN: function(name) {\r\n\t\t\t// for compilers to set a name\r\n\t\t\tthis.name = name\r\n\t\t\treturn this\r\n\t\t},\r\n\t\tget _debug() {\r\n\t\t\tif (this.__debug === undefined) {\r\n\t\t\t\tthis.__debug = true\r\n\t\t\t}\r\n\t\t\treturn this.__debug\r\n\t\t},\r\n\t\tset _debug(_debug) {\r\n\t\t\tthis.__debug = _debug\r\n\t\t},\r\n\t\t// TODO: Move these to VArray\r\n\t\tsplice: function(startingIndex, removalCount) {\r\n\t\t\tvar args = arguments\r\n\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\tvar results = array.splice.apply(array, args)\r\n\t\t\t\tremovedAt(this, results, startingIndex, removalCount, array.length)\r\n\t\t\t\tinsertedAt(this, [].slice.call(args, 2), startingIndex, array.length)\r\n\t\t\t\treturn results\r\n\t\t\t})\r\n\t\t},\r\n\t\tpush: function() {\r\n\t\t\tvar args = arguments\r\n\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\tvar results = array.push.apply(array, args)\r\n\t\t\t\tinsertedAt(this, args, array.length - args.length, array.length)\r\n\t\t\t\treturn results\r\n\t\t\t})\r\n\t\t},\r\n\t\tunshift: function() {\r\n\t\t\tvar args = arguments\r\n\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\tvar results = array.unshift.apply(array, args)\r\n\t\t\t\tinsertedAt(this, args, 0, array.length)\r\n\t\t\t\treturn results\r\n\t\t\t})\r\n\t\t},\r\n\t\tpop: function() {\r\n\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\tvar results = array.pop()\r\n\t\t\t\tremovedAt(this, [results], array.length, 1)\r\n\t\t\t\treturn results\r\n\t\t\t})\r\n\t\t},\r\n\t\tshift: function() {\r\n\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\tvar results = array.shift()\r\n\t\t\t\tremovedAt(this, [results], 0, 1, array.length)\r\n\t\t\t\treturn results\r\n\t\t\t})\r\n\t\t}\r\n\t}\r\n\r\n\tfunction arrayToModify(variable, callback) {\r\n\t\tvariable._willModify()\r\n\t\t// TODO: switch this to allow promises\r\n\t\twhen(variable.cachedValue || variable.valueOf(), function(array) {\r\n\t\t\tif (!array) {\r\n\t\t\t\tvariable.put(array = [])\r\n\t\t\t}\r\n\t\t\tvariable.updateVersion()\r\n\t\t\tvar results = callback.call(variable, array)\r\n\t\t\tvariable.cachedVersion = variable.version // update the cached version so it doesn't need to be recomputed\r\n\t\t\treturn results\r\n\t\t})\r\n\t}\r\n\r\n\tfunction insertedAt(variable, added, startingIndex, arrayLength) {\r\n\t\tvar addedCount = added.length\r\n\t\t// adjust the key positions of any index properties after splice\r\n\t\tif (addedCount > 0) {\r\n\t\t\tif (variable._properties) {\r\n\t\t\t\tvar arrayPosition\r\n\t\t\t\tfor (var i = arrayLength - addedCount; i > startingIndex;) {\r\n\t\t\t\t\tvar arrayPosition = variable._properties[--i]\r\n\t\t\t\t\tif (arrayPosition) {\r\n\t\t\t\t\t\tvariable._properties[i] = undefined\r\n\t\t\t\t\t\tarrayPosition.key += addedCount\r\n\t\t\t\t\t\tvariable._properties[arrayPosition.key] = arrayPosition\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// send out updates\r\n\t\t\tfor (var i = 0, l = added.length; i < l; i++) {\r\n\t\t\t\tvariable.updated(new AddEvent({\r\n\t\t\t\t\tvalue: added[i],\r\n\t\t\t\t\tindex: i + startingIndex,\r\n\t\t\t\t\tmodifier: variable\r\n\t\t\t\t}), variable)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction removedAt(variable, removed, startingIndex, removalCount, arrayLength) {\r\n\t\t// adjust the properties\r\n\t\tvar i = startingIndex + removalCount\r\n\t\tvar arrayPosition\r\n\t\tif (removalCount > 0) {\r\n\t\t\tif (variable._properties) {\r\n\t\t\t\tfor (var i = startingIndex + removalCount; i < arrayLength + removalCount; i++) {\r\n\t\t\t\t\tvar arrayPosition = variable._properties[i]\r\n\t\t\t\t\tif (arrayPosition) {\r\n\t\t\t\t\t\tvariable._properties[i] = undefined\r\n\t\t\t\t\t\tarrayPosition.key -= removalCount\r\n\t\t\t\t\t\tvariable._properties[arrayPosition.key] = arrayPosition\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// send out updates\r\n\t\t\tfor (var i = 0; i < removalCount; i++) {\r\n\t\t\t\tvariable.updated(new DeleteEvent({\r\n\t\t\t\t\tpreviousIndex: startingIndex,\r\n\t\t\t\t\toldValue: removed[i],\r\n\t\t\t\t\tmodifier: variable\r\n\t\t\t\t}), variable)\r\n\t\t\t}\r\n\t\t\tvariable.cachedVersion = variable.version // update the cached version so it doesn't need to be recomputed\r\n\t\t}\r\n\t}\r\n\r\n\tif (typeof Symbol !== 'undefined') {\r\n\t\tVariable.prototype[Symbol.iterator] = function() {\r\n\t\t\treturn this.valueOf()[Symbol.iterator]()\r\n\t\t}\r\n\t}\r\n\r\n\tVariable.VMap = lang.compose(Variable, function(value){\r\n\t\tthis.value = typeof value === 'undefined' ? this.default : value\r\n\t}, {\r\n\t\t// TODO: Move all the get and set functionality for maps out of Variable\r\n\t\tproperty: function(key) {\r\n\t\t\tvar properties = this._properties || (this._properties = new Map())\r\n\t\t\tvar propertyVariable = properties.get(key)\r\n\t\t\tif (!propertyVariable) {\r\n\t\t\t\t// create the property variable\r\n\t\t\t\tpropertyVariable = new Property(this, key)\r\n\t\t\t\tproperties.set(key, propertyVariable)\r\n\t\t\t}\r\n\t\t\treturn propertyVariable\r\n\t\t}\r\n\t})\r\n\r\n\tvar cacheNotFound = {}\r\n\tvar Caching = Variable.Caching = lang.compose(Variable, function(getValue, setValue) {\r\n\t\tif (getValue) {\r\n\t\t\tthis.getValue = getValue\r\n\t\t}\r\n\t\tif (setValue) {\r\n\t\t\tthis.setValue = setValue\r\n\t\t}\r\n\t}, {\r\n\t\tvalueOf: function(context) {\r\n\t\t\t// first check to see if we have the variable already computed\r\n\t\t\tvar contextualizedVariable = this\r\n\t\t\tif (context) {\r\n\t\t\t\tcontextualizedVariable = context.getContextualized(this)\r\n\t\t\t\tif (!contextualizedVariable && this.context && this.context.matches(context)) {\r\n\t\t\t\t\tcontextualizedVariable = this\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (contextualizedVariable && contextualizedVariable.cachedVersion === contextualizedVariable.getVersion()) {\r\n\t\t\t\tif (context) {\r\n\t\t\t\t\tcontext.addInput(contextualizedVariable)\r\n\t\t\t\t}\r\n\t\t\t\treturn contextualizedVariable.cachedValue\r\n\t\t\t}\t\t\t\r\n\r\n\t\t\tvar variable = this\r\n\t\t\tfunction withComputedValue(computedValue) {\r\n\t\t\t\tif (computedValue && computedValue.notifies && variable.listeners) {\r\n\t\t\t\t\tvariable.computedVariable = computedValue\r\n\t\t\t\t}\r\n\t\t\t\tcomputedValue = variable.gotValue(computedValue, context, transformContext)\r\n\t\t\t\tvar contextualizedVariable = transformContext && transformContext.contextualized || variable\r\n\t\t\t\tcontextualizedVariable.cachedVersion = newVersion\r\n\t\t\t\tcontextualizedVariable.cachedValue = computedValue\r\n\t\t\t\tcontextualizedVariable.context = transformContext\r\n\t\t\t\treturn computedValue\r\n\t\t\t}\r\n\r\n\t\t\tvar transformContext\r\n\t\t\tif (context) {\r\n\t\t\t\ttransformContext = context.newContext()\r\n\t\t\t}\r\n\t\t\tvar newVersion = this.getVersion()\r\n\t\t\tvar computedValue = this.getValue(transformContext)\r\n\t\t\tif (computedValue && computedValue.then) {\r\n\t\t\t\t// call it initially so the dependencies can be registered\r\n\t\t\t\tthis.gotValue(null, context, transformContext)\r\n\t\t\t\treturn computedValue.then(withComputedValue)\r\n\t\t\t} else {\r\n\t\t\t\treturn withComputedValue(computedValue)\r\n\t\t\t}\r\n\t\t}\r\n\t})\r\n\r\n\tfunction GetCache() {\r\n\t}\r\n\r\n\tvar Property = lang.compose(Variable, function Property(parent, key) {\r\n\t\tthis.parent = parent\r\n\t\tthis.key = key\r\n\t},\r\n\t{\r\n\t\tforDependencies: function(callback) {\r\n\t\t\tVariable.prototype.forDependencies.call(this, callback)\r\n\t\t\tcallback(this.parent)\r\n\t\t},\r\n\t\tvalueOf: function(context) {\r\n\t\t\tif (context) {\r\n\t\t\t\tvar propertyContext = context.newContext()\r\n\t\t\t\tpropertyContext.nextProperty = 'parent'\r\n\t\t\t}\r\n\t\t\tvar key = this.key\r\n\t\t\tvar property = this\r\n\t\t\tvar object = this.parent.valueOf(propertyContext)\r\n\t\t\tfunction gotValueAndListen(object) {\r\n\t\t\t\tvar value = property.gotValue(object == null ? undefined : typeof object.get === 'function' ? object.get(key) : object[key], context, propertyContext)\r\n\t\t\t\tif (property.listeners) {\r\n\t\t\t\t\tvar listeners = propertyListenersMap.get(object)\r\n\t\t\t\t\tif (listeners && listeners.observer && listeners.observer.addKey) {\r\n\t\t\t\t\t\tlisteners.observer.addKey(key)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn value\r\n\t\t\t}\r\n\t\t\tif (object && object.then) {\r\n\t\t\t\t// call it initially so the dependencies can be registered\r\n\t\t\t\tthis.gotValue(null, context, propertyContext)\r\n\t\t\t\treturn when(object, gotValueAndListen)\r\n\t\t\t}\r\n\t\t\treturn gotValueAndListen(object)\r\n\t\t},\r\n\t\tput: function(value, context) {\r\n\t\t\treturn this._changeValue(context, RequestChange, value)\r\n\t\t},\r\n\t\tparentUpdated: function(updateEvent, context) {\r\n\t\t\treturn Variable.prototype.updated.call(this, updateEvent, this.parent, context)\r\n\t\t},\r\n\t\tupdated: function(updateEvent, by, context) {\r\n\t\t\tif (updateEvent = Variable.prototype.updated.call(this, updateEvent, by, context)) {\r\n\t\t\t\tthis.parent.updated(new PropertyChangeEvent(this.key, updateEvent, this.parent), this, context)\r\n\t\t\t}\r\n\t\t},\r\n\t\tfor: function(subject) {\r\n\t\t\treturn this.parent.for(subject).property(this.key)\r\n\t\t},\r\n\t\t_changeValue: function(context, type, newValue) {\r\n\t\t\tvar key = this.key\r\n\t\t\tvar parent = this.parent\r\n\t\t\tvar variable = this\r\n\t\t\tparent._willModify(context)\r\n\t\t\treturn when(parent.valueOf(context), function(object) {\r\n\t\t\t\tif (object == null) {\r\n\t\t\t\t\t// nothing there yet, create an object to hold the new property\r\n\t\t\t\t\tvar response = parent.put(object = typeof key == 'number' ? [] : {}, context)\r\n\t\t\t\t} else if (typeof object != 'object') {\r\n\t\t\t\t\t// if the parent is not an object, we can't set anything (that will be retained)\r\n\t\t\t\t\treturn deny\r\n\t\t\t\t}\r\n\t\t\t\tvar oldValue = typeof object.get === 'function' ? object.get(key) : object[key]\r\n\t\t\t\tif (oldValue === newValue) {\r\n\t\t\t\t\t// no actual change to make\r\n\t\t\t\t\treturn noChange\r\n\t\t\t\t}\r\n\t\t\t\tif (variable.__debug) {\r\n\t\t\t\t\t// debug is on\r\n\t\t\t\t\tconsole.log('Variable changed from', oldValue, newValue, 'at')\r\n\t\t\t\t\tconsole.log((new Error().stack || '').replace(/Error/, ''))\r\n\t\t\t\t}\r\n\t\t\t\tif (typeof object.set === 'function') {\r\n\t\t\t\t\tobject.set(key, newValue)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (type == RequestChange && oldValue && oldValue.put) {\r\n\t\t\t\t\t\t// if a put and the property value is a variable, assign it to that.\r\n\t\t\t\t\t\toldValue.put(newValue)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tobject[key] = newValue\r\n\t\t\t\t\t\t// or set the setter/getter\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tvariable.updated(null, variable, context)\r\n\r\n\t\t\t\t// now notify any object listeners\r\n\t\t\t\tvar listeners = propertyListenersMap.get(object)\r\n\t\t\t\t// we need to do it before the other listeners, so we can update it before\r\n\t\t\t\t// we trigger a full clobbering of the object\r\n\t\t\t\tif (listeners) {\r\n\t\t\t\t\tlisteners = listeners.slice(0)\r\n\t\t\t\t\tfor (var i = 0, l = listeners.length; i < l; i++) {\r\n\t\t\t\t\t\tvar listener = listeners[i]\r\n\t\t\t\t\t\tif (listener !== parent) {\r\n\t\t\t\t\t\t\t// now go ahead and actually trigger the other listeners (but make sure we don't do the parent again)\r\n\t\t\t\t\t\t\tlistener._propertyChange(key, object, context, type)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t},\r\n\t\t_willModify: function() {\r\n\t\t\tthis.parent._willModify()\r\n\t\t\treturn Variable.prototype._willModify.call(this)\r\n\t\t},\r\n\t\tvalidate: function(target, schema) {\r\n\t\t\treturn this.parent.validate(target.valueOf(), schema)\r\n\t\t}\r\n\t})\r\n\tObject.defineProperty(Property.prototype, 'schema', {\r\n\t\tget: function() {\r\n\t\t\tvar parentSchemaProperties = this.parent.schema.properties\r\n\t\t\treturn parentSchemaProperties && parentSchemaProperties[this.key]\r\n\t\t},\r\n\t\tset: function(schema) {\r\n\t\t\t// have to repeat the override\r\n\t\t\tObject.defineProperty(this, 'schema', {\r\n\t\t\t\tvalue: schema\r\n\t\t\t})\r\n\t\t}\r\n\t})\r\n\tVariable.Property = Property\r\n\r\n\tvar Item = Variable.Item = lang.compose(Variable, function Item(value, content) {\r\n\t\tthis.value = value\r\n\t\tthis.collection = content\r\n\t}, {})\r\n\r\n\tvar Composite = Variable.Composite = lang.compose(Caching, function Composite(args) {\r\n\t\tfor (var i = 0, l = args.length; i < l; i++) {\r\n\t\t\tthis['argument' + i] = args[i]\r\n\t\t}\r\n\t}, {\r\n\t\tforDependencies: function(callback) {\r\n\t\t\t// depend on the args\r\n\t\t\tCaching.prototype.forDependencies.call(this, callback)\r\n\t\t\tvar argument, argumentName\r\n\t\t\tfor (var i = 0; (argument = this[argumentName = 'argument' + i]) || argumentName in this; i++) {\r\n\t\t\t\tif (argument && argument.notifies) {\r\n\t\t\t\t\tcallback(argument)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tupdated: function(updateEvent, by, context) {\r\n\t\t\tif (by !== this.returnedVariable && updateEvent && updateEvent.type !== 'refresh') {\r\n\t\t\t\t// search for the output in the inputs\r\n\t\t\t\tvar argument, argumentName\r\n\t\t\t\tfor (var i = 0; (argument = this[argumentName = 'argument' + i]) || argumentName in this; i++) {\r\n\t\t\t\t\tif (argument === by) {\r\n\t\t\t\t\t\t// if one of the args was updated, we need to do a full refresh (we can't compute differential events without knowledge of how the mapping function works)\r\n\t\t\t\t\t\tupdateEvent = new RefreshEvent()\r\n\t\t\t\t\t\tcontinue\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn Caching.prototype.updated.call(this, updateEvent, by, context)\r\n\t\t},\r\n\r\n\t\tgetUpdates: function(since) {\r\n\t\t\t// this always issues updates, nothing incremental can flow through it\r\n\t\t\tif (!since || since.version < getVersion()) {\r\n\t\t\t\treturn [new RefreshEvent()]\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tgetVersion: function(context) {\r\n\t\t\tvar version = Variable.prototype.getVersion.call(this, context)\r\n\t\t\tvar argument, argumentName\r\n\t\t\tfor (var i = 0; (argument = this[argumentName = 'argument' + i]) || argumentName in this; i++) {\r\n\t\t\t\tif (argument && argument.getVersion) {\r\n\t\t\t\t\tversion = Math.max(version, argument.getVersion(context))\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn version\r\n\t\t},\r\n\r\n\t\tgetValue: function(context) {\r\n\t\t\tvar results = []\r\n\t\t\tvar argument, argumentName\r\n\t\t\tfor (var i = 0; (argument = this[argumentName = 'argument' + i]) || argumentName in this; i++) {\r\n\t\t\t\tif (context) {\r\n\t\t\t\t\tcontext.nextProperty = argumentName\r\n\t\t\t\t}\r\n\t\t\t\tresults[i] = argument && argument.valueOf(context)\r\n\t\t\t}\r\n\t\t\treturn whenAll(results, function(resolved) {\r\n\t\t\t\treturn resolved\r\n\t\t\t})\r\n\t\t},\r\n\t\tgetArguments: function() {\r\n\t\t\tvar args = []\r\n\t\t\tvar argument, argumentName\r\n\t\t\tfor (var i = 0; (argument = this[argumentName = 'argument' + i]) || argumentName in this; i++) {\r\n\t\t\t\targs.push(argument)\r\n\t\t\t}\r\n\t\t\treturn args\r\n\t\t}\r\n\t})\r\n\r\n\t// a call variable is the result of a call\r\n\tvar Call = lang.compose(Composite, function Transform(transform, args) {\r\n\t\tthis.transform = transform\r\n\t\tfor (var i = 0, l = args.length; i < l; i++) {\r\n\t\t\tthis['argument' + i] = args[i]\r\n\t\t}\r\n\t}, {\r\n\t\tfixed: true,\r\n\t\tforDependencies: function(callback) {\r\n\t\t\t// depend on the args\r\n\t\t\tComposite.prototype.forDependencies.call(this, callback)\r\n\t\t\tif (this.transform.notifies) {\r\n\t\t\t\tcallback(this.transform)\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tgetValue: function(context) {\r\n\t\t\tif (context) {\r\n\t\t\t\tcontext.nextProperty = 'transform'\r\n\t\t\t}\r\n\t\t\tvar functionValue = this.transform.valueOf(context)\r\n\t\t\tif (functionValue.then) {\r\n\t\t\t\tvar call = this\r\n\t\t\t\treturn functionValue.then(function(functionValue) {\r\n\t\t\t\t\treturn call.invoke(functionValue, context)\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\treturn this.invoke(functionValue, context)\r\n\t\t},\r\n\r\n\t\tgetVersion: function(context) {\r\n\t\t\t// TODO: shortcut if we are live and since equals this.lastUpdate\r\n\t\t\tvar argsVersion = Composite.prototype.getVersion.call(this, context)\r\n\t\t\tif (this.transform.getVersion) {\r\n\t\t\t\treturn Math.max(argsVersion, this.transform.getVersion(context))\r\n\t\t\t}\r\n\t\t\treturn argsVersion\r\n\t\t},\r\n\r\n\t\texecute: function(context) {\r\n\t\t\tvar call = this\r\n\t\t\treturn when(this.transform.valueOf(context), function(functionValue) {\r\n\t\t\t\treturn call.invoke(functionValue, context, true)\r\n\t\t\t})\r\n\t\t},\r\n\r\n\t\tput: function(value, context) {\r\n\t\t\tvar call = this\r\n\t\t\treturn when(this.valueOf(context), function(originalValue) {\r\n\t\t\t\tif (originalValue === value) {\r\n\t\t\t\t\treturn noChange\r\n\t\t\t\t}\r\n\t\t\t\treturn when(call.transform.valueOf(context), function(functionValue) {\r\n\t\t\t\t\treturn call.invoke(function() {\r\n\t\t\t\t\t\tif (functionValue.reverse) {\r\n\t\t\t\t\t\t\tfunctionValue.reverse.call(call, value, call.getArguments(), context)\r\n\t\t\t\t\t\t\treturn Variable.prototype.put.call(call, value, context)\r\n\t\t\t\t\t\t} else if (originalValue && originalValue.put) {\r\n\t\t\t\t\t\t\treturn originalValue.put(value)\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\treturn deny\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}, context)\r\n\t\t\t\t});\t\t\t\t\r\n\t\t\t})\r\n\t\t},\r\n\t\tinvoke: function(functionValue, context, observeArguments) {\r\n\t\t\tvar instance = this.transform.parent\r\n\t\t\tif (functionValue.handlesVariables || functionValue.property) {\r\n\t\t\t\treturn functionValue.apply(instance, this.getArguments(), context)\r\n\t\t\t}else{\r\n\t\t\t\tvar results = []\r\n\t\t\t\tvar argument, argumentName\r\n\t\t\t\tfor (var i = 0; (argument = this[argumentName = 'argument' + i]) || argumentName in this; i++) {\r\n\t\t\t\t\tif (context) {\r\n\t\t\t\t\t\tcontext.nextProperty = argumentName\r\n\t\t\t\t\t}\r\n\t\t\t\t\tresults[i] = argument && argument.valueOf(context)\r\n\t\t\t\t}\r\n\t\t\t\tinstance = instance && instance.valueOf(context)\r\n\t\t\t\tif (functionValue.handlesPromises) {\r\n\t\t\t\t\treturn functionValue.apply(instance, results, context)\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// include the instance in whenAll\r\n\t\t\t\t\tresults.push(instance)\r\n\t\t\t\t\t// wait for the values to be received\r\n\t\t\t\t\treturn whenAll(results, function(inputs) {\r\n\t\t\t\t\t\tif (observeArguments) {\r\n\t\t\t\t\t\t\tvar handles = []\r\n\t\t\t\t\t\t\tfor (var i = 0, l = inputs.length; i < l; i++) {\r\n\t\t\t\t\t\t\t\tvar input = inputs[i]\r\n\t\t\t\t\t\t\t\tif (input && typeof input === 'object') {\r\n\t\t\t\t\t\t\t\t\thandles.push(observe(input))\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tvar instance = inputs.pop()\r\n\t\t\t\t\t\t\ttry{\r\n\t\t\t\t\t\t\t\tvar result = functionValue.apply(instance, inputs, context)\r\n\t\t\t\t\t\t\t}finally{\r\n\t\t\t\t\t\t\t\twhen(result, function() {\r\n\t\t\t\t\t\t\t\t\tfor (var i = 0; i < l; i++) {\r\n\t\t\t\t\t\t\t\t\t\thandles[i].done()\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn result\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar instance = inputs.pop()\r\n\t\t\t\t\t\treturn functionValue.apply(instance, inputs, context)\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tsetReverse: function(reverse) {\r\n\t\t\tthis.transform.valueOf().reverse = reverse\r\n\t\t\treturn this\r\n\t\t},\r\n\t\tgetCollectionOf: function() {\r\n\t\t\treturn this.returnedVariable && this.returnedVariable.getCollectionOf()\r\n\t\t}\r\n\t})\r\n\tVariable.Call = Call\r\n\r\n\tvar ContextualizedVariable = lang.compose(Variable, function ContextualizedVariable(generic, subject) {\r\n\t\tthis.generic = generic\r\n\t\tthis.subject = subject\r\n\t}, {\r\n\t\tvalueOf: function() {\r\n\t\t\t// TODO: Lookup Context type for all of these using registry or something\r\n\t\t\tvar subject = this.subject\r\n\t\t\treturn this.generic.valueOf(subject.getContextualized ? subject : new Context(subject))\r\n\t\t},\r\n\r\n\t\tforDependencies: function(callback) {\r\n\t\t\tthis.inputs && this.inputs.forEach(callback)\r\n\t\t},\r\n\r\n\t\tgetVersion: function() {\r\n\t\t\tvar version = Variable.prototype.getVersion.call(this)\r\n\t\t\tvar inputs = this.inputs || 0\r\n\t\t\tfor (var i = 0, l = inputs.length; i < l; i++) {\r\n\t\t\t\tvar input = inputs[i]\r\n\t\t\t\tif (input.getVersion) {\r\n\t\t\t\t\tversion = Math.max(version, input.getVersion())\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn version\r\n\t\t},\r\n\r\n\t\tput: function(value) {\r\n\t\t\tvar subject = this.subject\r\n\t\t\treturn this.generic.put(value, subject.getContextualized ? subject : new Context(subject))\r\n\t\t}\r\n\t})\r\n\r\n\r\n\tfunction iterateMethod(method) {\r\n\t\tVariable.prototype[method] = function() {\r\n\t\t\treturn new IterativeMethod(this, method, arguments)\r\n\t\t}\r\n\t}\r\n\r\n\titerateMethod('filter')\r\n\titerateMethod('map')\r\n\titerateMethod('reduce')\r\n\titerateMethod('reduceRight')\r\n\titerateMethod('some')\r\n\titerateMethod('every')\r\n\titerateMethod('slice')\r\n\t\r\n\tvar IterativeMethod = lang.compose(Composite, function(source, method, args) {\r\n\t\tthis.source = source\r\n\t\t// source.interestWithin = true\r\n\t\tthis.method = method\r\n\t\tthis.arguments = args\r\n\t}, {\r\n\t\tgetValue: function(context) {\r\n\t\t\tvar method = this.method\r\n\t\t\tvar args = this.arguments\r\n\t\t\tvar variable = this\r\n\t\t\tif (context) {\r\n\t\t\t\tcontext.nextProperty = 'source'\r\n\t\t\t}\r\n\t\t\treturn when(this.source.valueOf(context), function(array) {\r\n\t\t\t\tif (array && array.forEach) {\r\n\t\t\t\t\tif (context && context.notify) {\r\n\t\t\t\t\t\tvar contextualizedVariable\r\n\t\t\t\t\t\tif (context.distinctSubject) {\r\n\t\t\t\t\t\t\tvar contextMap = variable._contextMap || (variable._contextMap = new WeakMap())\r\n\t\t\t\t\t\t\tif (contextMap.has(context.distinctSubject)) {\r\n\t\t\t\t\t\t\t\tcontextualizedVariable = contextMap.get(context.distinctSubject)\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tcontextMap.set(context.distinctSubject, contextualizedVariable = Object.create(variable))\r\n\t\t\t\t\t\t\t\tcontextualizedVariable.listeners = false\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tcontextualizedVariable = variable\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvariable.notifies(contextualizedVariable)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (method === 'map'){\r\n\t\t\t\t\t\t// fast path, and special behavior for map\r\n\t\t\t\t\t\treturn args[0](array)\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// if not an array convert to an array\r\n\t\t\t\t\tarray = [array]\r\n\t\t\t\t}\r\n\t\t\t\t// apply method\r\n\t\t\t\treturn array[method].apply(array, args)\r\n\t\t\t})\r\n\t\t},\r\n\t\tupdated: function(event, by, context) {\r\n\t\t\tif (!event || event.modifier === this || (event.modifier && event.modifier.constructor === this)) {\r\n\t\t\t\treturn Composite.prototype.updated.call(this, event, by, context)\r\n\t\t\t}\r\n\t\t\tvar propagatedEvent = event.type === 'refresh' ? event : // always propagate refreshes\r\n\t\t\t\tthis[this.method + 'Updated'] ? this[this.method + 'Updated'](event, context) : // if we have an updated handler, use it\r\n\t\t\t\tnew RefreshEvent() // else recompute the array method\r\n\t\t\t// TODO: make sure we normalize the event structure\r\n\t\t\tif (propagatedEvent) {\r\n\t\t\t\tComposite.prototype.updated.call(this, propagatedEvent, by, context)\r\n\t\t\t}\r\n\t\t},\r\n\t\tfilterUpdated: function(event, context) {\r\n\t\t\tvar contextualizedVariable = context ? context.getContextualized(this) : this\r\n\t\t\tif (event.type === 'delete') {\r\n\t\t\t\tvar index = contextualizedVariable.cachedValue.indexOf(event.oldValue)\r\n\t\t\t\tif (index > -1) {\r\n\t\t\t\t\tcontextualizedVariable.splice(index, 1)\r\n\t\t\t\t}\r\n\t\t\t} else if (event.type === 'add') {\r\n\t\t\t\tif ([event.value].filter(this.arguments[0]).length > 0) {\r\n\t\t\t\t\tcontextualizedVariable.push(event.value)\r\n\t\t\t\t}\r\n\t\t\t} else if (event.type === 'update') {\r\n\t\t\t\tvar object = event.parent.valueOf(context)\r\n\t\t\t\tvar index = contextualizedVariable.cachedValue.indexOf(object)\r\n\t\t\t\tvar matches = [object].filter(this.arguments[0]).length > 0\r\n\t\t\t\tif (index > -1) {\r\n\t\t\t\t\tif (matches) {\r\n\t\t\t\t\t\treturn new PropertyChangeEvent(index, event, contextualizedVariable.cachedValue,\r\n\t\t\t\t\t\t\t// might need to do something with this\r\n\t\t\t\t\t\t\tobject)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tcontextualizedVariable.splice(index, 1)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\telse {\r\n\t\t\t\t\tif (matches) {\r\n\t\t\t\t\t\tcontextualizedVariable.push(object)\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// else nothing mactches\r\n\t\t\t\t}\r\n\t\t\t\treturn\r\n\t\t\t} else {\r\n\t\t\t\treturn event\r\n\t\t\t}\r\n\t\t},\r\n\t\tmapUpdated: function(event, context) {\r\n\t\t\tvar contextualizedVariable = context ? context.getContextualized(this) : this\r\n\t\t\tif (event.type === 'delete') {\r\n\t\t\t\tcontextualizedVariable.splice(event.previousIndex, 1)\r\n\t\t\t} else if (event.type === 'add') {\r\n\t\t\t\tcontextualizedVariable.push(this.arguments[0].call(this.arguments[1], event.value))\r\n\t\t\t} else if (event.type === 'update') {\r\n\t\t\t\tvar object = event.parent.valueOf(context)\r\n\t\t\t\tvar array = contextualizedVariable.cachedValue\r\n\t\t\t\tif (array && array.map) {\r\n\t\t\t\t\tvar index = array.indexOf(object)\r\n\t\t\t\t\tvar matches = [object].filter(this.arguments[0]).length > 0\r\n\t\t\t\t\tcontextualizedVariable.splice(index, 1, this.arguments[0].call(this.arguments[1], event.value))\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn event\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\treturn event\r\n\t\t\t}\r\n\t\t},\r\n\t\t// TODO: Create specialized updated handlers for faster recomputation of other array derivatives\r\n\t\tforDependencies: function(callback) {\r\n\t\t\t// depend on the args\r\n\t\t\tComposite.prototype.forDependencies.call(this, callback)\r\n\t\t\tcallback(this.source)\r\n\t\t},\r\n\t\tgetVersion: function(context) {\r\n\t\t\treturn Math.max(Composite.prototype.getVersion.call(this, context), this.source.getVersion(context))\r\n\t\t},\r\n\t\tgetCollectionOf: function(){\r\n\t\t\treturn this.source.getCollectionOf()\r\n\t\t}\r\n\t})\r\n\r\n\r\n\tvar getValue\r\n\tvar GeneratorVariable = Variable.GeneratorVariable = lang.compose(Variable.Composite, function ReactiveGenerator(generator){\r\n\t\tthis.generator = generator\r\n\t}, {\r\n\t\tgetValue: getValue = function(context, resuming) {\r\n\t\t\tvar lastValue\r\n\t\t\tvar i\r\n\t\t\tvar generatorIterator\r\n\t\t\tvar isThrowing\r\n\t\t\tif (resuming) {\r\n\t\t\t\t// resuming from a promise\r\n\t\t\t\tgeneratorIterator = resuming.iterator\r\n\t\t\t\ti = resuming.i\r\n\t\t\t\tlastValue = resuming.value\r\n\t\t\t\tisThrowing = resuming.isThrowing\r\n\t\t\t} else {\r\n\t\t\t\t// a fresh start\r\n\t\t\t\ti = 0\r\n\t\t\t\tgeneratorIterator = this.generator()\t\t\t\t\r\n\t\t\t}\r\n\r\n\t\t\tdo {\r\n\t\t\t\tvar stepReturn = generatorIterator[isThrowing ? 'throw' : 'next'](lastValue)\r\n\t\t\t\tif (stepReturn.done) {\r\n\t\t\t\t\treturn stepReturn.value\r\n\t\t\t\t}\r\n\t\t\t\tvar nextVariable = stepReturn.value\r\n\t\t\t\t// compare with the arguments from the last\r\n\t\t\t\t// execution to see if they are the same\r\n\t\t\t\tvar argumentName = 'argument' + i\r\n\t\t\t\tif (this[argumentName] !== nextVariable) {\r\n\t\t\t\t\tif (this[argumentName]) {\r\n\t\t\t\t\t\tthis[argumentName].stopNotifies(this)\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// subscribe if it is a variable\r\n\t\t\t\t\tif (nextVariable && nextVariable.notifies) {\r\n\t\t\t\t\t\tif (this.listeners) {\r\n\t\t\t\t\t\t\tnextVariable.notifies(this)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tthis[argumentName] = nextVariable\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis[argumentName] = null\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\ti++\r\n\t\t\t\tif (context) {\r\n\t\t\t\t\tcontext.nextProperty = argumentName\r\n\t\t\t\t}\r\n\t\t\t\tlastValue = nextVariable && nextVariable.valueOf(context)\r\n\t\t\t\tif (lastValue && lastValue.then) {\r\n\t\t\t\t\t// if it is a promise, we will wait on it\r\n\t\t\t\t\tvar variable = this\r\n\t\t\t\t\t// and return the promise so that the getValue caller can wait on this\r\n\t\t\t\t\treturn lastValue.then(function(value) {\r\n\t\t\t\t\t\treturn getValue.call(variable, context, {\r\n\t\t\t\t\t\t\ti: i,\r\n\t\t\t\t\t\t\titerator: generatorIterator,\r\n\t\t\t\t\t\t\tvalue: value\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}, function(error) {\r\n\t\t\t\t\t\treturn getValue.call(variable, context, {\r\n\t\t\t\t\t\t\ti: i,\r\n\t\t\t\t\t\t\titerator: generatorIterator,\r\n\t\t\t\t\t\t\tvalue: error,\r\n\t\t\t\t\t\t\tisThrowing: true\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t} while(true)\r\n\t\t}\r\n\t})\r\n\r\n\tvar Validating = lang.compose(Caching, function(target) {\r\n\t\tthis.target = target\r\n\t}, {\r\n\t\tforDependencies: function(callback) {\r\n\t\t\tCaching.prototype.forDependencies.call(this, callback)\r\n\t\t\tcallback(this.target)\r\n\t\t},\r\n\t\tgetVersion: function(context) {\r\n\t\t\treturn Math.max(Variable.prototype.getVersion.call(this, context), this.target.getVersion(context))\r\n\t\t},\r\n\t\tgetValue: function(context) {\r\n\t\t\tvar target = this.target\r\n\t\t\treturn target.validate(target, target.schema)\r\n\t\t}\r\n\t})\r\n\r\n\tfunction validate(target) {\r\n\t\tvar schemaForObject = schema(target)\r\n\t\treturn new Validating(target, schemaForObject)\r\n\t}\r\n\tVariable.VArray = Variable\r\n\tVariable.VPromised = Variable\r\n\tVariable.deny = deny\r\n\tVariable.noChange = noChange\r\n\tfunction addFlag(name) {\r\n\t\tVariable[name] = function(functionValue) {\r\n\t\t\tfunctionValue[name] = true\r\n\t\t}\r\n\t}\r\n\taddFlag(Variable, 'handlesContext')\r\n\taddFlag(Variable, 'handlesPromises')\r\n\r\n\tfunction objectUpdated(object) {\r\n\t\t// simply notifies any subscribers to an object, that it has changed\r\n\t\tvar listeners = propertyListenersMap.get(object)\r\n\t\tif (listeners) {\r\n\t\t\tfor (var i = 0, l = listeners.length; i < l; i++) {\r\n\t\t\t\tlisteners[i]._propertyChange(null, object)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction all(array) {\r\n\t\t// This is intended to mirror Promise.all. It actually takes\r\n\t\t// an iterable, but for now we are just looking for array-like\r\n\t\tif (array.length > -1) {\r\n\t\t\treturn new Composite(array)\r\n\t\t}\r\n\t\tif (arguments.length > 1) {\r\n\t\t\t// support multiple arguments as an array\r\n\t\t\treturn new Composite(arguments)\r\n\t\t}\r\n\t\tif (typeof array === 'object') {\r\n\t\t\t// allow an object as a hash to be mapped\r\n\t\t\tvar keyMapping = []\r\n\t\t\tvar valueArray = []\r\n\t\t\tfor (var key in array) {\r\n\t\t\t\tkeyMapping.push(key)\r\n\t\t\t\tvalueArray.push(array[key])\r\n\t\t\t}\r\n\t\t\treturn new Variable(function(results) {\r\n\t\t\t\tvar resultObject = {}\r\n\t\t\t\tfor (var i = 0; i < results.length; i++) {\r\n\t\t\t\t\tresultObject[keyMapping[i]] = results[i]\r\n\t\t\t\t}\r\n\t\t\t\treturn resultObject\r\n\t\t\t}).apply(null, valueArray)\r\n\t\t}\r\n\t\tthrow new TypeError('Variable.all requires an array')\r\n\t}\r\n\r\n\tfunction hasOwn(Target, createForInstance) {\r\n\r\n\t\tvar ownedClasses = this.ownedClasses || (this.ownedClasses = new WeakMap())\r\n\t\t// TODO: assign to super classes\r\n\t\tvar Class = this\r\n\t\townedClasses.set(Target, createForInstance || function() { return new Target() })\r\n\t\treturn this\r\n\t}\r\n\tfunction getForClass(subject, Target) {\r\n\t\tvar createInstance = subject.constructor.ownedClasses && subject.constructor.ownedClasses.get(Target)\r\n\t\tif (createInstance) {\r\n\t\t\tvar ownedInstances = subject.ownedInstances || (subject.ownedInstances = new WeakMap())\r\n\t\t\tvar instance = ownedInstances.get(Target)\r\n\t\t\tif (!instance) {\r\n\t\t\t\townedInstances.set(Target, instance = createInstance(subject))\r\n\t\t\t\tinstance.subject = subject\r\n\t\t\t}\r\n\t\t\treturn instance\r\n\t\t}\r\n\t}\r\n\tfunction generalizeClass() {\r\n\t\tvar prototype = this.prototype\r\n\t\tvar prototypeNames = Object.getOwnPropertyNames(prototype)\r\n\t\tfor(var i = 0, l = prototypeNames.length; i < l; i++) {\r\n\t\t\tvar name = prototypeNames[i]\r\n\t\t\tObject.defineProperty(this, name, getGeneralizedDescriptor(Object.getOwnPropertyDescriptor(prototype, name), name, this))\r\n\t\t}\r\n\t}\r\n\tfunction getGeneralizedDescriptor(descriptor, name, Class) {\r\n\t\tif (typeof descriptor.value === 'function') {\r\n\t\t\treturn {\r\n\t\t\t\tvalue: generalizeMethod(Class, name)\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\treturn descriptor\r\n\t\t}\r\n\t}\r\n\tfunction generalizeMethod(Class, name) {\r\n\t\t// I think we can just rely on `this`, but we could use the argument:\r\n\t\t// function(possibleEvent) {\r\n\t\t// \tvar target = possibleEvent && possibleEvent.target\r\n\t\tvar method = Class[name] = function() {\r\n\t\t\tvar instance = Class.for(this)\r\n\t\t\treturn instance[name].apply(instance, arguments)\r\n\t\t}\r\n\t\tmethod.for = function(context) {\r\n\t\t\tvar instance = Class.for(context)\r\n\t\t\treturn function() {\r\n\t\t\t\treturn instance[name].apply(instance, arguments)\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn method\r\n\t}\r\n\r\n\tvar defaultContext = {\r\n\t\tname: 'Default context',\r\n\t\tdescription: 'This object is the default context for classes, corresponding to a singleton instance of that class',\r\n\t\tconstructor: {\r\n\t\t\tgetForClass: function(subject, Class) {\r\n\t\t\t\treturn Class.defaultInstance\r\n\t\t\t}\r\n\t\t},\r\n\t\tcontains: function() {\r\n\t\t\treturn true // contains everything\r\n\t\t}\r\n\t}\r\n\tfunction instanceForContext(Class, context) {\r\n\t\tif (!context) {\r\n\t\t\treturn Class.defaultInstance\r\n\t\t}\r\n\t\treturn context.specify(Class)\r\n//\t\tvar instance = context.subject.constructor.getForClass && context.subject.constructor.getForClass(context.subject, Class) || Class.defaultInstance\r\n//\t\tcontext.distinctSubject = mergeSubject(context.distinctSubject, instance.subject)\r\n//\t\treturn instance\r\n\t}\r\n\t// a variable inheritance change goes through its own prototype, so classes/constructor\r\n\t// can be used as variables as well\r\n\tfor (var key in VariablePrototype) {\r\n\t\tObject.defineProperty(Variable, key, Object.getOwnPropertyDescriptor(VariablePrototype, key))\r\n\t}\r\n\tVariable.valueOf = function(context) {\r\n\t\t// contextualized getValue\r\n\t\treturn instanceForContext(this, context).valueOf(context)\r\n\t}\r\n\tVariable.put = function(value, context) {\r\n\t\t// contextualized setValue\r\n\t\treturn instanceForContext(this, context).put(value, context)\r\n\t}\r\n\tVariable.for = function(subject) {\r\n\t\tif (subject != null) {\r\n\t\t\tif (subject.target && !subject.constructor.getForClass) {\r\n\t\t\t\t// makes HTML events work\r\n\t\t\t\tsubject = subject.target\r\n\t\t\t}\r\n\t\t\tvar instance\r\n\t\t\tinstance = new Context(subject).specify(this)\r\n\t\t\tif (instance && !instance.subject) {\r\n\t\t\t\tinstance.subject = subject\r\n\t\t\t}\r\n\t\t\t// TODO: Do we have a global context that we set on defaultInstance?\r\n\t\t\treturn instance || this.defaultInstance\r\n\t\t} else {\r\n\t\t\treturn this.defaultInstance\r\n\t\t}\r\n\t}\r\n\tVariable.from = function(value) {\r\n\t\tif (value && typeof value === 'object') {\r\n\t\t\t// a plain object, we use our own map to retrieve the instance (or create one)\r\n\t\t\tvar instanceMap = this.instanceMap || (this.instanceMap = new WeakMap())\r\n\t\t\tvar instance = instanceMap.get(value)\r\n\t\t\tif (!instance) {\r\n\t\t\t\tinstanceMap.set(value, instance = new this(value))\r\n\t\t\t}\r\n\t\t\treturn instance\r\n\t\t} else {\r\n\t\t\t// a primitive, just unconditionally create a new variable for it\r\n\t\t\treturn new this(value)\r\n\t\t}\r\n\t}\r\n\tVariable.notifies = function(target) {\r\n\t\tthis.defaultInstance.notifies(target)\r\n\t}\r\n\tVariable.stopNotifies = function(target) {\r\n\t\tthis.defaultInstance.stopNotifies(target)\r\n\t}\r\n\tVariable.getCollectionOf = function () {\r\n\t\treturn this.collectionOf\r\n\t}\r\n\tVariable.updated = function(updateEvent, by, context) {\r\n\t\treturn instanceForContext(this, context).updated(updateEvent, by, context)\r\n\t}\r\n\tObject.defineProperty(Variable, 'collectionOf', {\r\n\t\tget: function() {\r\n\t\t\treturn this._collectionOf\r\n\t\t},\r\n\t\tset: function(ItemClass) {\r\n\t\t\tif (this._collectionOf != ItemClass) {\r\n\t\t\t\tthis._collectionOf = ItemClass\r\n\t\t\t\tItemClass.collection = this\r\n\t\t\t}\r\n\t\t}\r\n\t})\r\n\tObject.defineProperty(Variable, 'collection', {\r\n\t\tget: function() {\r\n\t\t\treturn this._collection\r\n\t\t},\r\n\t\tset: function(Collection) {\r\n\t\t\tif (this._collection != Collection) {\r\n\t\t\t\tthis._collection = Collection\r\n\t\t\t\tCollection.collectionOf = this\r\n\t\t\t}\r\n\t\t}\r\n\t})\r\n\tVariable.Context = Context\r\n\tVariable.NotifyingContext = NotifyingContext\r\n\tVariable.generalize = generalizeClass\r\n\tVariable.call = Function.prototype.call // restore these\r\n\tVariable.apply = Function.prototype.apply\r\n\tVariable.extend = function(properties) {\r\n\t\t// TODO: handle arguments\r\n\t\tvar Base = this\r\n\t\tfunction ExtendedVariable() {\r\n\t\t\tif (this instanceof ExtendedVariable) {\r\n\t\t\t\tBase.apply(this, arguments)\r\n\t\t\t} else {\r\n\t\t\t\treturn ExtendedVariable.extend(properties)\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar prototype = ExtendedVariable.prototype = Object.create(this.prototype)\r\n\t\tExtendedVariable.prototype.constructor = ExtendedVariable\r\n\t\tsetPrototypeOf(ExtendedVariable, this)\r\n\t\tfor (var key in properties) {\r\n\t\t\tvar descriptor = Object.getOwnPropertyDescriptor(properties, key)\r\n\t\t\tObject.defineProperty(prototype, key, descriptor)\r\n\t\t\tObject.defineProperty(ExtendedVariable, key, getGeneralizedDescriptor(descriptor, key, ExtendedVariable))\r\n\t\t}\r\n\t\tif (properties && properties.hasOwn) {\r\n\t\t\thasOwn.call(ExtendedVariable, properties.hasOwn)\r\n\t\t}\r\n\t\treturn ExtendedVariable\r\n\t}\r\n\tObject.defineProperty(Variable, 'defaultInstance', {\r\n\t\tget: function() {\r\n\t\t\treturn this.hasOwnProperty('_defaultInstance') ?\r\n\t\t\t\tthis._defaultInstance : (\r\n\t\t\t\t\tthis._defaultInstance = new this(),\r\n\t\t\t\t\tthis._defaultInstance.subject = defaultContext,\r\n\t\t\t\t\tthis._defaultInstance)\r\n\t\t}\r\n\t})\r\n\tVariable.hasOwn = function(Target, createInstance) {\r\n\t\tvar instanceMap = new WeakMap()\r\n\t\tinstanceMap.createInstance = createInstance\r\n\t\tvar subjectMap = this.ownedClasses || (this.ownedClasses = new WeakMap())\r\n\t\tsubjectMap.set(Target, instanceMap)\r\n\t}\r\n\tVariable.all = all\r\n\tVariable.objectUpdated = objectUpdated\r\n\t\r\n\treturn Variable\r\n})\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./Variable.js\n ** module id = 2\n ** module chunks = 0\n **/","define([], function () {\r\n\tvar getPrototypeOf = Object.getPrototypeOf || (function(base) { return base.__proto__ })\r\n\tvar setPrototypeOf = Object.setPrototypeOf || (function(base, proto) { base.__proto__ = proto})\r\n\tvar hasFeatures = {\r\n\t\trequestAnimationFrame: typeof requestAnimationFrame != 'undefined',\r\n\t\tdefineProperty: Object.defineProperty && (function() {\r\n\t\t\ttry{\r\n\t\t\t\tObject.defineProperty({}, 't', {})\r\n\t\t\t\treturn true\r\n\t\t\t}catch(e) {\r\n\t\t\t}\r\n\t\t})(),\r\n\t\tpromise: typeof Promise !== 'undefined',\r\n\t\tMutationObserver: typeof MutationObserver !== 'undefined',\r\n\t\t'WeakMap': typeof WeakMap === 'function'\r\n\t}\r\n\tfunction has(feature) {\r\n\t\treturn hasFeatures[feature]\r\n\t}\r\n\t// This is an polyfill for Object.observe with just enough functionality\r\n\t// for what Variables need\r\n\t// An observe function, with polyfile\r\n\tvar observe =\r\n\t\thas('defineProperty') ? \r\n\t\tfunction observe(target, listener) {\r\n\t\t\t/*for(var i in target) {\r\n\t\t\t\taddKey(i)\r\n\t\t\t}*/\r\n\t\t\tlistener.addKey = addKey\r\n\t\t\tlistener.remove = function() {\r\n\t\t\t\tlistener = null\r\n\t\t\t}\r\n\t\t\treturn listener\r\n\t\t\tfunction addKey(key) {\r\n\t\t\t\tvar keyFlag = 'key' + key\r\n\t\t\t\tif(this[keyFlag]) {\r\n\t\t\t\t\treturn\r\n\t\t\t\t}else{\r\n\t\t\t\t\tthis[keyFlag] = true\r\n\t\t\t\t}\r\n\t\t\t\tvar currentValue = target[key]\r\n\t\t\t\tvar targetAncestor = target\r\n\t\t\t\tvar descriptor\r\n\t\t\t\tdo {\r\n\t\t\t\t\tdescriptor = Object.getOwnPropertyDescriptor(targetAncestor, key)\r\n\t\t\t\t} while(!descriptor && (targetAncestor = getPrototypeOf(targetAncestor)))\r\n\r\n\t\t\t\tif(descriptor && descriptor.set) {\r\n\t\t\t\t\tvar previousSet = descriptor.set\r\n\t\t\t\t\tvar previousGet = descriptor.get\r\n\t\t\t\t\tObject.defineProperty(target, key, {\r\n\t\t\t\t\t\tget: function() {\r\n\t\t\t\t\t\t\treturn (currentValue = previousGet.call(this))\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tset: function(value) {\r\n\t\t\t\t\t\t\tpreviousSet.call(this, value)\r\n\t\t\t\t\t\t\tif(currentValue !== value) {\r\n\t\t\t\t\t\t\t\tcurrentValue = value\r\n\t\t\t\t\t\t\t\tif(listener) {\r\n\t\t\t\t\t\t\t\t\tlistener([{target: this, name: key}])\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tenumerable: descriptor.enumerable\r\n\t\t\t\t\t})\r\n\t\t\t\t}else{\r\n\t\t\t\t\tObject.defineProperty(target, key, {\r\n\t\t\t\t\t\tget: function() {\r\n\t\t\t\t\t\t\treturn currentValue\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tset: function(value) {\r\n\t\t\t\t\t\t\tif(currentValue !== value) {\r\n\t\t\t\t\t\t\t\tcurrentValue = value\r\n\t\t\t\t\t\t\t\tif(listener) {\r\n\t\t\t\t\t\t\t\t\tlistener([{target: this, name: key}])\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tenumerable: !descriptor || descriptor.enumerable\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} :\r\n\t\t// and finally a polling-based solution, for the really old browsers\r\n\t\tfunction(target, listener) {\r\n\t\t\tif(!timerStarted) {\r\n\t\t\t\ttimerStarted = true\r\n\t\t\t\tsetInterval(function() {\r\n\t\t\t\t\tfor(var i = 0, l = watchedObjects.length; i < l; i++) {\r\n\t\t\t\t\t\tdiff(watchedCopies[i], watchedObjects[i], listeners[i])\r\n\t\t\t\t\t}\r\n\t\t\t\t}, 20)\r\n\t\t\t}\r\n\t\t\tvar copy = {}\r\n\t\t\tfor(var i in target) {\r\n\t\t\t\tif(target.hasOwnProperty(i)) {\r\n\t\t\t\t\tcopy[i] = target[i]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\twatchedObjects.push(target)\r\n\t\t\twatchedCopies.push(copy)\r\n\t\t\tlisteners.push(listener)\r\n\t\t}\r\n\tvar queuedListeners\r\n\tfunction queue(listener, object, name) {\r\n\t\tif(queuedListeners) {\r\n\t\t\tif(queuedListeners.indexOf(listener) === -1) {\r\n\t\t\t\tqueuedListeners.push(listener)\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\tqueuedListeners = [listener]\r\n\t\t\tlang.nextTurn(function() {\r\n\t\t\t\tqueuedListeners.forEach(function(listener) {\r\n\t\t\t\t\tvar events = []\r\n\t\t\t\t\tlistener.properties.forEach(function(property) {\r\n\t\t\t\t\t\tevents.push({target: listener.object, name: property})\r\n\t\t\t\t\t})\r\n\t\t\t\t\tlistener(events)\r\n\t\t\t\t\tlistener.object = null\r\n\t\t\t\t\tlistener.properties = null\r\n\t\t\t\t})\r\n\t\t\t\tqueuedListeners = null\r\n\t\t\t}, 0)\r\n\t\t}\r\n\t\tlistener.object = object\r\n\t\tvar properties = listener.properties || (listener.properties = [])\r\n\t\tif(properties.indexOf(name) === -1) {\r\n\t\t\tproperties.push(name)\r\n\t\t}\r\n\t}\r\n\tvar unobserve = has('observe') ? Object.unobserve :\r\n\t\tfunction(target, listener) {\r\n\t\t\tif(listener.remove) {\r\n\t\t\t\tlistener.remove()\r\n\t\t\t}\r\n\t\t\tfor(var i = 0, l = watchedObjects.length; i < l; i++) {\r\n\t\t\t\tif(watchedObjects[i] === target && listeners[i] === listener) {\r\n\t\t\t\t\twatchedObjects.splice(i, 1)\r\n\t\t\t\t\twatchedCopies.splice(i, 1)\r\n\t\t\t\t\tlisteners.splice(i, 1)\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\tvar watchedObjects = []\r\n\tvar watchedCopies = []\r\n\tvar listeners = []\r\n\tvar timerStarted = false\r\n\tfunction diff(previous, current, callback) {\r\n\t\t// TODO: keep an array of properties for each watch for faster iteration\r\n\t\tvar queued\r\n\t\tfor(var i in previous) {\r\n\t\t\tif(previous.hasOwnProperty(i) && previous[i] !== current[i]) {\r\n\t\t\t\t// a property has changed\r\n\t\t\t\tprevious[i] = current[i]\r\n\t\t\t\t(queued || (queued = [])).push({name: i})\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor(var i in current) {\r\n\t\t\tif(current.hasOwnProperty(i) && !previous.hasOwnProperty(i)) {\r\n\t\t\t\t// a property has been added\r\n\t\t\t\tprevious[i] = current[i]\r\n\t\t\t\t(queued || (queued = [])).push({name: i})\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(queued) {\r\n\t\t\tcallback(queued)\r\n\t\t}\r\n\t}\r\n\r\n\tvar id = 1\r\n\t// a function that returns a function, to stop JSON serialization of an\r\n\t// object\r\n\tfunction toJSONHidden() {\r\n\t\treturn toJSONHidden\r\n\t}\r\n\t// An object that will be hidden from JSON serialization\r\n\tvar Hidden = function () {\r\n\t}\r\n\tHidden.prototype.toJSON = toJSONHidden\r\n\r\n\tvar lang = {\r\n\t\trequestAnimationFrame: has('requestAnimationFrame') ? requestAnimationFrame :\r\n\t\t\t(function() {\r\n\t\t\t\tvar toRender = []\r\n\t\t\t\tvar queued = false\r\n\t\t\t\tfunction processAnimationFrame() {\r\n\t\t\t\t\tfor (var i = 0; i < toRender.length; i++) {\r\n\t\t\t\t\t\ttoRender[i]()\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttoRender = []\r\n\t\t\t\t\tqueued = false\r\n\t\t\t\t}\r\n\t\t\t\tfunction requestAnimationFrame(renderer) {\r\n\t\t\t\t \tif (!queued) {\r\n\t\t\t\t\t\tsetTimeout(processAnimationFrame)\r\n\t\t\t\t\t\tqueued = true\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttoRender.push(renderer)\r\n\t\t\t\t}\r\n\t\t\t\treturn requestAnimationFrame\r\n\t\t\t})(),\r\n\t\tPromise: has('promise') ? Promise : (function() {\r\n\t\t\tfunction Promise(execute) {\r\n\t\t\t\tvar isResolved, resolution, errorResolution\r\n\t\t\t\tvar queue = 0\r\n\t\t\t\tfunction resolve(value) {\r\n\t\t\t\t\t// resolve function\r\n\t\t\t\t\tif(value && value.then) {\r\n\t\t\t\t\t\t// received a promise, wait for it\r\n\t\t\t\t\t\tvalue.then(resolve, reject)\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tresolution = value\r\n\t\t\t\t\t\tfinished()\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tfunction reject(error) {\r\n\t\t\t\t\t// reject function\r\n\t\t\t\t\terrorResolution = error\r\n\t\t\t\t\tfinished()\r\n\t\t\t\t}\r\n\t\t\t\texecute(resolve, reject)\r\n\t\t\t\tfunction finished() {\r\n\t\t\t\t\tisResolved = true\r\n\t\t\t\t\tfor(var i = 0, l = queue.length; i < l; i++) {\r\n\t\t\t\t\t\tqueue[i]()\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// clean out the memory\r\n\t\t\t\t\tqueue = 0\r\n\t\t\t\t}\r\n\t\t\t\treturn {\r\n\t\t\t\t\tthen: function(callback, errback) {\r\n\t\t\t\t\t\treturn new Promise(function(resolve, reject) {\r\n\t\t\t\t\t\t\tfunction handle() {\r\n\t\t\t\t\t\t\t\t// promise fulfilled, call the appropriate callback\r\n\t\t\t\t\t\t\t\ttry{\r\n\t\t\t\t\t\t\t\t\tif(errorResolution && !errback) {\r\n\t\t\t\t\t\t\t\t\t\t// errors without a handler flow through\r\n\t\t\t\t\t\t\t\t\t\treject(errorResolution)\r\n\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t// resolve to the callback's result\r\n\t\t\t\t\t\t\t\t\t\tresolve(errorResolution ?\r\n\t\t\t\t\t\t\t\t\t\t\terrback(errorResolution) :\r\n\t\t\t\t\t\t\t\t\t\t\tcallback ?\r\n\t\t\t\t\t\t\t\t\t\t\t\tcallback(resolution) : resolution)\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}catch(newError) {\r\n\t\t\t\t\t\t\t\t\t// caught an error, reject the returned promise\r\n\t\t\t\t\t\t\t\t\treject(newError)\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif(isResolved) {\r\n\t\t\t\t\t\t\t\t// already resolved, immediately handle\r\n\t\t\t\t\t\t\t\thandle()\r\n\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t(queue || (queue = [])).push(handle)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn Promise\r\n\t\t}()),\r\n\r\n\t\tWeakMap: has('WeakMap') ? WeakMap :\r\n\t \tfunction (values, name) {\r\n\t \t\tvar mapProperty = '__' + (name || '') + id++\r\n\t \t\treturn has('defineProperty') ?\r\n\t \t\t{\r\n\t \t\t\tget: function (key) {\r\n\t \t\t\t\treturn key[mapProperty]\r\n\t \t\t\t},\r\n\t \t\t\tset: function (key, value) {\r\n\t \t\t\t\tObject.defineProperty(key, mapProperty, {\r\n\t \t\t\t\t\tvalue: value,\r\n\t \t\t\t\t\tenumerable: false\r\n\t \t\t\t\t})\r\n\t \t\t\t}\r\n\t \t\t} :\r\n\t \t\t{\r\n\t \t\t\tget: function (key) {\r\n\t \t\t\t\tvar intermediary = key[mapProperty]\r\n\t \t\t\t\treturn intermediary && intermediary.value\r\n\t \t\t\t},\r\n\t \t\t\tset: function (key, value) {\r\n\t \t\t\t\t// we use an intermediary that is hidden from JSON serialization, at least\r\n\t \t\t\t\tvar intermediary = key[mapProperty] || (key[mapProperty] = new Hidden())\r\n\t \t\t\t\tintermediary.value = value\r\n\t \t\t\t}\r\n\t \t\t}\r\n\t \t},\r\n\r\n\t\tobserve: observe,\r\n\t\tunobserve: unobserve,\r\n\t\twhen: function(value, callback, errorHandler) {\r\n\t\t\treturn value && value.then ?\r\n\t\t\t\t(value.then(callback, errorHandler) || value) : callback(value)\r\n\t\t},\r\n\t\twhenAll: function(inputs, callback) {\r\n\t\t\tvar promiseInvolved\r\n\t\t\tfor(var i = 0, l = inputs.length; i < l; i++) {\r\n\t\t\t\tif(inputs[i] && inputs[i].then) {\r\n\t\t\t\t\tpromiseInvolved = true\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(promiseInvolved) {\r\n\t\t\t\t// we have asynch inputs, do lazy loading\r\n\t\t\t\treturn {\r\n\t\t\t\t\tthen: function(onResolve, onError) {\r\n\t\t\t\t\t\tvar remaining = 1\r\n\t\t\t\t\t\tvar result\r\n\t\t\t\t\t\tvar readyInputs = []\r\n\t\t\t\t\t\tvar lastPromiseResult\r\n\t\t\t\t\t\tfor(var i = 0; i < inputs.length; i++) {\r\n\t\t\t\t\t\t\tvar input = inputs[i]\r\n\t\t\t\t\t\t\tremaining++\r\n\t\t\t\t\t\t\tif(input && input.then) {\r\n\t\t\t\t\t\t\t\t(function(i, previousPromiseResult) {\r\n\t\t\t\t\t\t\t\t\tlastPromiseResult = input.then(function(value) {\r\n\t\t\t\t\t\t\t\t\t\treadyInputs[i] = value\r\n\t\t\t\t\t\t\t\t\t\tonEach()\r\n\t\t\t\t\t\t\t\t\t\tif(!remaining) {\r\n\t\t\t\t\t\t\t\t\t\t\treturn result\r\n\t\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t\treturn previousPromiseResult\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}, onError)\r\n\t\t\t\t\t\t\t\t})(i, lastPromiseResult)\r\n\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\treadyInputs[i] = input\r\n\t\t\t\t\t\t\t\tonEach()\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tonEach()\r\n\t\t\t\t\t\tfunction onEach() {\r\n\t\t\t\t\t\t\tremaining--\r\n\t\t\t\t\t\t\tif(!remaining) {\r\n\t\t\t\t\t\t\t\tresult = onResolve(callback(readyInputs))\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn lastPromiseResult\r\n\t\t\t\t\t},\r\n\t\t\t\t\tinputs: inputs\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// just sync inputs\r\n\t\t\treturn callback(inputs)\r\n\r\n\t\t},\r\n\t\tcompose: function(Base, constructor, properties) {\r\n\t\t\tvar prototype = constructor.prototype = Object.create(Base.prototype)\r\n\t\t\tsetPrototypeOf(constructor, Base)\r\n\t\t\tfor(var i in properties) {\r\n\t\t\t\tprototype[i] = properties[i]\r\n\t\t\t}\r\n\t\t\tprototype.constructor = constructor\r\n\t\t\treturn constructor\r\n\t\t},\r\n\t\tnextTurn: has('MutationObserver') ?\r\n\t\t\tfunction (callback) {\r\n\t\t\t\t// promises don't resolve consistently on the next micro turn (Edge doesn't do it right),\r\n\t\t\t\t// so use mutation observer\r\n\t\t\t\t// TODO: make a faster mode that doesn't recreate each time\r\n\t\t\t\tvar div = document.createElement('div')\r\n\t\t\t\tvar observer = new MutationObserver(callback)\r\n\t\t\t\tobserver.observe(div, {\r\n\t\t\t\t\tattributes: true\r\n\t\t\t\t})\r\n\t\t\t\tdiv.setAttribute('a', id++)\r\n\t\t\t} :\r\n\t\t\tfunction (callback) {\r\n\t\t\t\t// TODO: we can do better for other, older browsers\r\n\t\t\t\tsetTimeout(callback, 0)\r\n\t\t\t},\r\n\t\tcopy: Object.assign || function(target, source) {\r\n\t\t\tfor(var i in source) {\r\n\t\t\t\ttarget[i] = source[i]\r\n\t\t\t}\r\n\t\t\treturn target\r\n\t\t}\r\n\t}\r\n\tfunction isGenerator(func) {\r\n\t\tif (typeof func === 'function') {\r\n\t\t\tvar constructor = func.constructor\r\n\t\t\treturn (constructor.displayName || constructor.name) === 'GeneratorFunction'\r\n\t\t}\r\n\t}\r\n\tlang.isGenerator = isGenerator\r\n\treturn lang\r\n})\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./util/lang.js\n ** module id = 3\n ** module chunks = 0\n **/","define(['./util/lang', './Variable'], function (lang, Variable) {\r\n\tvar doc = typeof document !== 'undefined' && document\r\n\tvar invalidatedElements\r\n\tvar queued\r\n\tvar toRender = []\r\n\tvar nextId = 1\r\n\tvar requestAnimationFrame = lang.requestAnimationFrame\r\n\tvar Context = Variable.Context\r\n\r\n\tfunction Renderer(options) {\r\n\t\tvar variable = options.variable\r\n\r\n\t\tthis.variable = variable\r\n\t\tif (options.selector) {\r\n\t\t\tthis.selector = options.selector\r\n\t\t}\r\n\t\tif (options.elements) {\r\n\t\t\tthis.elements = options.elements\r\n\t\t\tthis.element = this.elements[0]\r\n\t\t\tfor(var i = 0, l = this.elements.length; i < l; i++) {\r\n\t\t\t\t(this.elements[i].alkaliRenderers || (this.elements[i].alkaliRenderers = [])).push(this)\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (options.element) {\r\n\t\t\tvar element = this.element = options.element;\r\n\t\t\t(element.alkaliRenderers || (element.alkaliRenderers = [])).push(this)\r\n\t\t} else {\r\n\t\t\tthrow new Error('No element provided to Renderer')\r\n\t\t}\r\n\t\tif (options.update) {\r\n\t\t\tthis.updateRendering = options.update\r\n\t\t}\r\n\t\tif (options.shouldRender) {\r\n\t\t\tthis.shouldRender = options.shouldRender\r\n\t\t}\r\n\t\tif (options.renderUpdate) {\r\n\t\t\tthis.renderUpdate = options.renderUpdate\r\n\t\t}\r\n\t\tif (options.alwaysUpdate) {\r\n\t\t\tthis.alwaysUpdate = options.alwaysUpdate\r\n\t\t}\r\n\t\tif (variable.updated) {\r\n\t\t\t// if it has update, we don't need to instantiate a closure\r\n\t\t\tif (options.updateOnStart === false) {\r\n\t\t\t\tvariable.notifies(this)\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// baconjs-esqe API\r\n\t\t\tvar renderer = this\r\n\t\t\tvariable.subscribe(function (event) {\r\n\t\t\t\t// replace the variable with an object\r\n\t\t\t\t// that returns the value from the event\r\n\t\t\t\trenderer.variable = {\r\n\t\t\t\t\tvalueOf: function () {\r\n\t\t\t\t\t\treturn event.value()\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\trenderer.updated()\r\n\t\t\t})\r\n\t\t}\r\n\t\tif (options.updateOnStart !== false){\r\n\t\t\tthis.updateRendering(true)\r\n\t\t}\r\n\t}\r\n\tRenderer.prototype = {\r\n\t\tconstructor: Renderer,\r\n\t\tupdateRendering: function () {\r\n\t\t\tthrow new Error ('updateRendering must be implemented by sub class of Renderer')\r\n\t\t},\r\n\t\tupdated: function (updateEvent, by, context) {\r\n\t\t\tif (!this.invalidated) {\r\n\t\t\t\tif (!context || this.contextMatches(context)) {\r\n\t\t\t\t\t// do this only once, until we render again\r\n\t\t\t\t\tthis.invalidated = true\r\n\t\t\t\t\tvar renderer = this\r\n\t\t\t\t\trequestAnimationFrame(function(){\r\n\t\t\t\t\t\tinvalidatedElements = null\r\n\t\t\t\t\t\trenderer.updateRendering(renderer.alwaysUpdate)\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tnewContext: function() {\r\n\t\t\treturn new Variable.Context(this.element)\r\n\t\t},\r\n\t\taddInput: function(variable) {\r\n\t\t\tthis.contextualized = variable\r\n\t\t},\r\n\t\tgetContextualized: function() {\r\n\t\t\treturn this.contextualized\r\n\t\t},\r\n\t\tspecify: function(Variable) {\r\n\t\t\t// a new context to get thsi\r\n\t\t\treturn this.newContext().specify(Variable)\r\n\t\t},\r\n\t\tmerge: function(){\r\n\t\t\t// noop\r\n\t\t},\r\n\t\tcontextMatches: function(context) {\r\n\t\t\treturn true\r\n\t\t},\r\n\t\tinvalidateElement: function(element) {\r\n\t\t\tif(!invalidatedElements){\r\n\t\t\t\tinvalidatedElements = new WeakMap(null, 'invalidated')\r\n\t\t\t}\r\n\t\t\tvar invalidatedParts = invalidatedElements.get(element)\r\n\t\t\tinvalidatedElements.set(element, invalidatedParts = {})\r\n\t\t\tif (!invalidatedParts[id]) {\r\n\t\t\t\tinvalidatedParts[id] = true\r\n\t\t\t}\r\n\t\t\tif (!queued) {\r\n\t\t\t\tlang.queueTask(processQueue)\r\n\t\t\t\tqueued = true\r\n\t\t\t}\r\n\t\t\tvar renderer = this\r\n\t\t\ttoRender.push(function(){\r\n\t\t\t\trenderer.invalidated = false\r\n\t\t\t\trenderer.updateElement(element)\r\n\t\t\t})\r\n\t\t},\r\n\t\tgetId: function(){\r\n\t\t\treturn this.id || (this.id = nextId++)\r\n\t\t},\r\n\t\tstop: function() {\r\n\t\t\tvar contextualized = this.contextualized || this.variable\r\n\t\t\tcontextualized.stopNotifies(this)\r\n\t\t}\r\n\t}\r\n\r\n\tfunction ElementRenderer(options) {\r\n\t\tRenderer.call(this, options)\r\n\t}\r\n\tElementRenderer.prototype = Object.create(Renderer.prototype)\r\n\tElementRenderer.prototype.shouldRender = function (element) {\r\n\t\treturn document.body.contains(element)\r\n\t}\r\n\tElementRenderer.prototype.getSubject = function () {\r\n\t\treturn this.element\r\n\t}\r\n\tElementRenderer.prototype.updateRendering = function (always, element) {\r\n\t\tif (!element && this.elements) {\r\n\t\t\tvar elements = this.elements\r\n\t\t\tif(!elements.length){\r\n\t\t\t\tif(this.selector){\r\n\t\t\t\t\telements = document.querySelectorAll(this.selector)\r\n\t\t\t\t}else{\r\n\t\t\t\t\tthrow new Error('No element or selector was provided to the Renderer')\r\n\t\t\t\t}\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tfor(var i = 0, l = elements.length; i < l; i++){\r\n\t\t\t\tthis.updateRendering(always, elements[i])\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvar thisElement = element || this.element\r\n\r\n\t\t\tif(always || this.shouldRender(thisElement)){\r\n\t\t\t\t// it is connected\r\n\t\t\t\tthis.updateElement(thisElement)\r\n\t\t\t} else {\r\n\t\t\t\tvar id = this.getId()\r\n\t\t\t\tvar renderers = thisElement.renderersOnShow\r\n\t\t\t\tif(!renderers){\r\n\t\t\t\t\trenderers = thisElement.renderersOnShow = []\r\n\t\t\t\t\tthisElement.className += ' needs-rerendering'\r\n\t\t\t\t}\r\n\t\t\t\tif (!renderers[id]) {\r\n\t\t\t\t\trenderers[id] = this\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tElementRenderer.prototype.addElement = function (element) {\r\n\t\tif (this.selector) {\r\n\t\t\telement.renderersOnShow = [this]\r\n\t\t} else {\r\n\t\t\tthis.elements.push(element)\r\n\t\t}\r\n\t\t// and immediately do an update\r\n\t\tthis.updateElement(element)\r\n\t}\r\n\tElementRenderer.prototype.updateElement = function(element) {\r\n\t\tthis.invalidated = false\r\n\t\ttry {\r\n\t\t\tif (!this.omitValueOf) {\r\n\t\t\t\tvar value = this.variable.valueOf(this)\r\n\t\t\t\tvar contextualized = this.contextualized || this.variable\r\n\t\t\t\t// TODO: we may need to handle recontextualization if it returns a promise\r\n\t\t\t\tcontextualized.notifies(this)\r\n\t\t\t}\r\n\t\t} catch (error) {\r\n\t\t\telement.appendChild(document.createTextNode(error))\r\n\t\t}\r\n\t\tif(value !== undefined || this.started || this.omitValueOf){\r\n\t\t\tthis.started = true\r\n\t\t\tif(value && value.then){\r\n\t\t\t\tif(this.renderLoading){\r\n\t\t\t\t\tthis.renderLoading(value, element)\r\n\t\t\t\t}\r\n\t\t\t\tvar renderer = this\r\n\t\t\t\tvalue.then(function (value) {\r\n\t\t\t\t\trenderer.renderUpdate(value, element)\r\n\t\t\t\t})\r\n\t\t\t}else{\r\n\t\t\t\tthis.renderUpdate(value, element)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tElementRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\tthrow new Error('renderUpdate(newValue) must be implemented')\r\n\t}\r\n\tRenderer.Renderer = Renderer\r\n\tRenderer.ElementRenderer = ElementRenderer\r\n\r\n\tfunction AttributeRenderer(options) {\r\n\t\tif(options.name){\r\n\t\t\tthis.name = options.name\r\n\t\t}\r\n\t\tElementRenderer.apply(this, arguments)\r\n\t}\r\n\tAttributeRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\tAttributeRenderer.prototype.type = 'AttributeRenderer'\r\n\tAttributeRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\telement.setAttribute(this.name, newValue)\r\n\t}\r\n\tRenderer.AttributeRenderer = AttributeRenderer\r\n\r\n\tfunction PropertyRenderer(options) {\r\n\t\tif (options.name) {\r\n\t\t\tthis.name = options.name\r\n\t\t}\r\n\t\tElementRenderer.apply(this, arguments)\r\n\t}\r\n\tPropertyRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\tPropertyRenderer.prototype.type = 'PropertyRenderer'\r\n\tPropertyRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\telement[this.name] = newValue\r\n\t}\r\n\tRenderer.PropertyRenderer = PropertyRenderer\r\n\r\n\tfunction InputPropertyRenderer(options) {\r\n\t\tif (options.element && options.element.tagName === 'SELECT' && options.name === 'value') {\r\n\t\t\t// use the deferred value assignment for <select>\r\n\t\t\tthis.renderUpdate = this.renderSelectValueUpdate\r\n\t\t}\r\n\t\tPropertyRenderer.apply(this, arguments)\r\n\t}\r\n\tInputPropertyRenderer.prototype = Object.create(PropertyRenderer.prototype)\r\n\tInputPropertyRenderer.prototype.type = 'InputPropertyRenderer'\r\n\tInputPropertyRenderer.prototype.renderUpdate = function(newValue, element) {\r\n\t\tif (newValue == null || (element.type === 'number' && isNaN(newValue))) {\r\n\t\t\tnewValue = ''\r\n\t\t}\r\n\t\telement[this.name] = newValue\r\n\t}\r\n\tInputPropertyRenderer.prototype.renderSelectValueUpdate = function (newValue, element) {\r\n\t\telement.value = newValue\r\n\t\tif (element.value != newValue && !element.value) {\r\n\t\t\t// if we didn't successfully set the value of a <select>, we may need to wait until the children are constructed\r\n\t\t\telement.eventualValue = newValue\r\n\t\t\tlang.nextTurn(function() {\r\n\t\t\t\tif (element.eventualValue) {\r\n\t\t\t\t\telement.value = element.eventualValue\r\n\t\t\t\t\telement.eventualValue = undefined\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t} else {\r\n\t\t\telement.eventualValue = undefined\r\n\t\t}\r\n\t}\r\n\tRenderer.InputPropertyRenderer = InputPropertyRenderer\r\n\r\n\tfunction StyleRenderer(options) {\r\n\t\tif(options.name){\r\n\t\t\tthis.name = options.name\r\n\t\t}\r\n\t\tElementRenderer.apply(this, arguments)\r\n\t}\r\n\tStyleRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\tStyleRenderer.prototype.type = 'StyleRenderer'\r\n\tStyleRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\telement.style[this.name] = newValue\r\n\t}\r\n\tRenderer.StyleRenderer = StyleRenderer\r\n\r\n\tfunction ContentRenderer(options) {\r\n\t\tElementRenderer.apply(this, arguments)\r\n\t}\r\n\tContentRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\tContentRenderer.prototype.type = 'ContentRenderer'\r\n\tContentRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\telement.innerHTML = ''\r\n\t\tif (newValue === undefined){\r\n\t\t\tnewValue = ''\r\n\t\t}\r\n\t\telement.appendChild(document.createTextNode(newValue))\r\n\t}\r\n\tRenderer.ContentRenderer = ContentRenderer\r\n\r\n\tfunction TextRenderer(options) {\r\n\t\tthis.position = options.position\r\n\t\tthis.textNode = options.textNode\r\n\t\tElementRenderer.apply(this, arguments)\r\n\t}\r\n\tTextRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\tTextRenderer.prototype.type = 'TextRenderer'\r\n\tTextRenderer.prototype.updated = function (updateEvent, context) {\r\n\t\tif (this.builtList) {\r\n\t\t\tif (updateEvent.type === 'refresh') {\r\n\t\t\t\tthis.builtList = false\r\n\t\t\t\tthis.omitValueOf = false\r\n\t\t\t} else {\r\n\t\t\t\t(this.updates || (this.updates = [])).push(updateEvent)\r\n\t\t\t}\r\n\t\t}\r\n\t\tElementRenderer.prototype.updated.call(this, updateEvent, context)\r\n\t}\r\n\tTextRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\tif (newValue == null){\r\n\t\t\tnewValue = ''\r\n\t\t}\r\n\t\tif (newValue.nodeType) {\r\n\t\t\tif (this.textNode && this.textNode.parentNode == element) {\r\n\t\t\t\t// text node is attached, we can replace it with the node\r\n\t\t\t\telement.replaceChild(newValue, this.textNode)\r\n\t\t\t} else {\r\n\t\t\t\telement.appendChild(newValue)\r\n\t\t\t}\r\n\t\t\tthis.textNode = newValue\r\n\t\t} else if (newValue instanceof Array) {\r\n\t\t\tthis.renderUpdate = ListRenderer.prototype.renderUpdate\r\n\t\t\tthis.omitValueOf = true\r\n\t\t\tthis.renderUpdate(newValue, element)\r\n\t\t} else {\r\n\t\t\t(this.textNode || element.childNodes[this.position]).nodeValue = newValue\r\n\t\t}\r\n\t}\r\n\tRenderer.TextRenderer = TextRenderer\r\n\r\n\tfunction ListRenderer(options) {\r\n\t\tif (options.each) {\r\n\t\t\tthis.each = options.each\r\n\t\t}\r\n\t\tElementRenderer.apply(this, arguments)\r\n\t}\r\n\tListRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\tListRenderer.prototype.updated = function (updateEvent, context) {\r\n\t\tif (this.builtList) {\r\n\t\t\tif (updateEvent.type === 'refresh') {\r\n\t\t\t\tthis.builtList = false\r\n\t\t\t\tthis.omitValueOf = false\r\n\t\t\t} else {\r\n\t\t\t\t(this.updates || (this.updates = [])).push(updateEvent)\r\n\t\t\t}\r\n\t\t}\r\n\t\tElementRenderer.prototype.updated.call(this, updateEvent, context)\r\n\t}\r\n\tListRenderer.prototype.type = 'ListRenderer'\r\n\tListRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\tvar container\r\n\t\tvar each = this.each || function(item) { // TODO: make a single identity function\r\n\t\t\treturn item\r\n\t\t}\r\n\t\tvar thisElement = this.element\r\n\t\tvar renderer = this\r\n\t\tif (!this.builtList) {\r\n\t\t\tthis.builtList = true\r\n\t\t\tthis.omitValueOf = true\r\n\t\t\telement.innerHTML = ''\r\n\t\t\tcontainer = document.createDocumentFragment()\r\n\t\t\tvar childElements = this.childElements = []\r\n\t\t\tif (each.defineHasOwn) {\r\n\t\t\t\teach.defineHasOwn()\r\n\t\t\t}\r\n\t\t\tnewValue.forEach(function(item) {\r\n\t\t\t\teachItem(item)\r\n\t\t\t})\r\n\t\t\tvar contextualized = this.contextualized || this.variable\r\n\t\t\tcontextualized.notifies(this)\r\n\r\n\t\t\tthisElement.appendChild(container)\r\n\t\t} else {\r\n\t\t\tvar childElements = this.childElements\r\n\t\t\tvar updates = this.updates\r\n\t\t\tcontainer = thisElement\r\n\t\t\tupdates.forEach(function(update) {\r\n\t\t\t\tif (update.type === 'refresh') {\r\n\t\t\t\t\trenderer.builtList = false\r\n\t\t\t\t\tfor (var i = 0, l = childElements.length; i < l; i++) {\r\n\t\t\t\t\t\tthisElement.removeChild(childElements[i])\r\n\t\t\t\t\t}\r\n\t\t\t\t\trenderer.renderUpdate()\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (update.previousIndex > -1) {\r\n\t\t\t\t\t\tthisElement.removeChild(childElements[update.previousIndex])\r\n\t\t\t\t\t\tchildElements.splice(update.previousIndex, 1)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (update.index > -1) {\r\n\t\t\t\t\t\tvar nextChild = childElements[update.index] || null\r\n\t\t\t\t\t\teachItem(update.value, update.index, nextChild)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\tthis.updates = [] // clear the updates\r\n\t\t}\r\n\t\tfunction eachItem(item, index, nextChild) {\r\n\t\t\tvar childElement\r\n\t\t\tif (each.create) {\r\n\t\t\t\tchildElement = each.create({parent: thisElement, _item: item}) // TODO: make a faster object here potentially\r\n\t\t\t} else {\r\n\t\t\t\tchildElement = each(item, thisElement)\r\n\t\t\t\tif (childElement.create) {\r\n\t\t\t\t\tchildElement = childElement.create({parent: thisElement, _item: item})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (nextChild) {\r\n\t\t\t\tcontainer.insertBefore(childElement, nextChild)\r\n\t\t\t\tchildElements.splice(index, 0, childElement)\r\n\t\t\t} else {\r\n\t\t\t\tcontainer.appendChild(childElement)\r\n\t\t\t\tchildElements.push(childElement)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tRenderer.ListRenderer = ListRenderer\r\n\r\n\tRenderer.onShowElement = function(shownElement){\r\n\t\trequestAnimationFrame(function(){\r\n\t\t\tinvalidatedElements = null\r\n\t\t\tvar elements = [].slice.call(shownElement.getElementsByClassName('needs-rerendering'))\r\n\t\t\tif (shownElement.className.indexOf('needs-rerendering') > 0){\r\n\t\t\t\tvar includingTop = [shownElement]\r\n\t\t\t\tincludingTop.push.apply(includingTop, elements)\r\n\t\t\t\telements = includingTop\r\n\t\t\t}\r\n\t\t\tfor (var i = 0, l = elements.length; i < l; i++){\r\n\t\t\t\tvar element = elements[i]\r\n\t\t\t\tvar renderers = element.renderersOnShow\r\n\t\t\t\tif(renderers){\r\n\t\t\t\t\telement.renderersOnShow = null\r\n\t\t\t\t\t// remove needs-rerendering class\r\n\t\t\t\t\telement.className = element.className.replace(/\\s?needs\\-rerendering\\s?/g, '')\r\n\t\t\t\t\tfor (var id in renderers) {\r\n\t\t\t\t\t\tvar renderer = renderers[id]\r\n\t\t\t\t\t\trenderer.updateElement(element)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n\r\n\tfunction onElementRemoval(element){\r\n\t\t// cleanup element renderers\r\n\t\tif(element.alkaliRenderers){\r\n\t\t\tvar renderers = element.alkaliRenderers\r\n\t\t\tfor(var i = 0; i < renderers.length; i++){\r\n\t\t\t\tvar renderer = renderers[i]\r\n\t\t\t\trenderer.variable.stopNotifies(renderer)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tRenderer.onElementRemoval = function(element, onlyChildren){\r\n\t\tif(!onlyChildren){\r\n\t\t\tonElementRemoval(element)\r\n\t\t}\r\n\t\tvar children = element.getElementsByTagName('*')\r\n\t\tfor(var i = 0, l = children.length; i < l; i++){\r\n\t\t\tvar child = children[i]\r\n\t\t\tif(child.alkaliRenderers){\r\n\t\t\t\tonElementRemoval(child)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn Renderer\r\n})\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./Renderer.js\n ** module id = 4\n ** module chunks = 0\n **/","define(['./util/lang', './Variable', './operators'], function (lang, Variable, operators) {\r\n\r\n  var isGenerator = lang.isGenerator\r\n  var ObjectTransform = lang.compose(Variable.Call, function ObjectTransform(transform, inputs) {\r\n    this.inputs = inputs\r\n    Variable.Call.apply(this, arguments)\r\n  }, {\r\n    _getAsObject: function() {\r\n      return this.transform.apply(this, preserveObjects(this.inputs))\r\n    }\r\n  })\r\n  function preserveObjects(inputs) {\r\n    for (var i = 0, l = inputs.length; i < l; i++) {\r\n      var input = inputs[i]\r\n      if (input && input._getAsObject) {\r\n        inputs[i] = input._getAsObject()\r\n      }\r\n    }\r\n    return inputs\r\n  }\r\n\tfunction react(generator, options) {\r\n    if (typeof generator !== 'function') {\r\n      throw new Error('react() must be called with a generator. You need to use the babel-plugin-transform-alkali plugin if you want to use reactive expressions')\r\n    }\r\n\t\tif (options && options.reverse) {\r\n\t\t\tgenerator.reverse = options.reverse\r\n\t\t}\r\n\t\treturn new Variable.GeneratorVariable(generator)\r\n\t}\r\n  Object.assign(react, operators)\r\n  react.from = function(value, options) {\r\n    if (value && value.property) {\r\n      return value\r\n    }\r\n    if (typeof value === 'function' && isGenerator(value)) {\r\n      return react(value, options)\r\n    }\r\n    return Variable.from(value)\r\n  }\r\n  react.prop = function(object, property) {\r\n    if (object) {\r\n      // TODO: Use a static set of public methods/properties that can be accessed\r\n      if (object.property) {\r\n        // it is a variable already, but check to see if we are using a method/property directly on the variable\r\n        var directPropertyValue = object[property]\r\n        return directPropertyValue !== undefined ? directPropertyValue : object.property(property)\r\n      }\r\n      return object[property]\r\n    }\r\n    // not even truthy, return undefined\r\n  }\r\n  react.cond = function(test, consequent, alternate) {\r\n    return operators.if(test, operators.choose(consequent, alternate))\r\n  }\r\n  react.fcall = function(target, args) {\r\n    if (target.property && typeof target === 'function') {\r\n      return target.apply(null, preserveObjects(args))\r\n    }\r\n    return new Variable.Call(target, args)\r\n  }\r\n  react.mcall = function(target, key, args) {\r\n    var method = target[key]\r\n    if (typeof method === 'function' && method.property || key === 'bind') {\r\n      // for now we check to see if looks like it could handle a variable, or is a bind call\r\n      return method.apply(target, preserveObjects(args))\r\n    }\r\n    return new Variable.Call(target[key].bind(target), args)\r\n  }\r\n  react.ncall = function(target, args) {\r\n    if (target.property && typeof target === 'function') {\r\n      return new (target.bind.apply(target, [null].concat(preserveObjects(args))))()\r\n    }\r\n    return new Variable.Call(function() {\r\n      return new (target.bind.apply(target, [null].concat(arguments)))()\r\n    }, args)\r\n  }\r\n\r\n  react.obj = function(transform, inputs) {\r\n    return new ObjectTransform(transform, inputs)\r\n  }\r\n\r\n\treturn react\r\n})\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./react.js\n ** module id = 5\n ** module chunks = 0\n **/","define(['./Variable'], function (Variable) {\r\n\tvar deny = Variable.deny;\r\n\tvar operatingFunctions = {};\r\n\tvar operators = {};\r\n\tfunction getOperatingFunction(expression){\r\n\t\t// jshint evil: true\r\n\t\treturn operatingFunctions[expression] ||\r\n\t\t\t(operatingFunctions[expression] =\r\n\t\t\t\tnew Function('a', 'b', 'deny', 'return ' + expression));\r\n\t}\r\n\tfunction operator(operator, name, precedence, forward, reverseA, reverseB){\r\n\t\t// defines the standard operators\r\n\t\tvar reverse = function(output, inputs){\r\n\t\t\tvar a = inputs[0],\r\n\t\t\t\tb = inputs[1];\r\n\t\t\tif(a && a.put){\r\n\t\t\t\tvar result = reverseA(output, b && b.valueOf());\r\n\t\t\t\tif(result !== deny){\r\n\t\t\t\t\ta.put(result);\r\n\t\t\t\t}\r\n\t\t\t}else if(b && b.put){\r\n\t\t\t\tb.put(reverseB(output, a && a.valueOf()));\r\n\t\t\t}else{\r\n\t\t\t\treturn deny;\r\n\t\t\t}\r\n\t\t};\r\n\t\t// define a function that can lazily ensure the operating function\r\n\t\t// is available\r\n\t\tvar operatorHandler = {\r\n\t\t\tapply: function(instance, args){\r\n\t\t\t\tforward = getOperatingFunction(forward);\r\n\t\t\t\treverseA = reverseA && getOperatingFunction(reverseA);\r\n\t\t\t\treverseB = reverseB && getOperatingFunction(reverseB);\r\n\t\t\t\tforward.reverse = reverse;\r\n\t\t\t\toperators[operator] = operatorHandler = new Variable(forward);\r\n\r\n\t\t\t\taddFlags(operatorHandler);\r\n\t\t\t\targs = Array.prototype.slice.call(args);\r\n\t\t\t\targs.push(deny)\r\n\t\t\t\treturn operatorHandler.apply(instance, args);\r\n\t\t\t}\r\n\t\t};\r\n\t\tfunction addFlags(operatorHandler){\r\n\t\t\toperatorHandler.precedence = precedence;\r\n\t\t\toperatorHandler.infix = reverseB !== false;\r\n\t\t}\r\n\t\taddFlags(operatorHandler);\r\n\t\toperators[operator] = operatorHandler;\r\n\t\toperators[name] = function() {\r\n\t\t\treturn operatorHandler.apply(null, arguments)\r\n\t\t}\r\n\t}\r\n\t// using order precedence from:\r\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence\r\n\toperator('+', 'add', 6, 'a+b', 'a-b', 'a-b');\r\n\toperator('-', 'subtract', 6, 'a-b', 'a+b', 'b-a');\r\n\toperator('*', 'multiply', 5, 'a*b', 'a/b', 'a/b');\r\n\toperator('/', 'divide', 5, 'a/b', 'a*b', 'b/a');\r\n//\toperator('^', 7, 'a^b', 'a^(-b)', 'Math.log(a)/Math.log(b)');\r\n\toperator('?', 'if', 16, 'b[a?0:1]', 'a===b[0]||(a===b[1]?false:deny)', '[a,b]');\r\n\toperator(':', 'choose', 15, '[a,b]', 'a[0]?a[1]:deny', 'a[1]');\r\n\toperator('!', 'not', 4, '!a', '!a', false);\r\n\toperator('%', 'remainder', 5, 'a%b');\r\n\toperator('>', 'greater', 8, 'a>b');\r\n\toperator('>=', 'greaterOrEqual', 8, 'a>=b');\r\n\toperator('<', 'less', 8, 'a<b');\r\n\toperator('<=', 'lessOrEqual', 8, 'a<=b');\r\n\toperator('===', 'looseEqual', 9, 'a===b');\r\n\toperator('==', 'equal', 9, 'a==b');\r\n\toperator('&', 'and', 8, 'a&&b');\r\n\toperator('|', 'or', 8, 'a||b');\r\n\toperator('round', 'round', 8, 'Math.round(a*Math.pow(10,b||1))/Math.pow(10,b||1)', 'a', 'a');\r\n\treturn operators;\r\n})\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./operators.js\n ** module id = 6\n ** module chunks = 0\n **/","define(['./util/lang', './Variable'], function (lang, Variable) {\r\n\r\n\tfunction deepCopy(source, target, derivativeMap) {\r\n\t\tif (source && typeof source == 'object') {\r\n\t\t\tif (source instanceof Array) {\r\n\t\t\t\ttarget = [] // always create a new array for array targets\r\n\t\t\t\tfor(var i = 0, l = source.length; i < l; i++) {\r\n\t\t\t\t\ttarget[i] = deepCopy(source[i], null, derivativeMap)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (!target || typeof target !== 'object') {\r\n\t\t\t\t\ttarget = derivativeMap && derivativeMap.get(source)\r\n\t\t\t\t\tif (!target) {\r\n\t\t\t\t\t\ttarget = {}\r\n\t\t\t\t\t\tderivativeMap && derivativeMap.set(source, target)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tfor (var i in source) {\r\n\t\t\t\t\ttarget[i] = deepCopy(source[i], target[i], derivativeMap)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn target\r\n\t\t}\r\n\t\treturn source\r\n\t}\r\n\r\n\tvar Copy = lang.compose(Variable, function(copiedFrom) {\r\n\t\t// this is the variable that we derive from\r\n\t\tthis.copiedFrom = copiedFrom\r\n\t\tthis.derivativeMap = new lang.WeakMap(null, 'derivative')\r\n\t\tthis.isDirty = new Variable(false)\r\n\t}, {\r\n\t\tvalueOf: function(context) {\r\n\t\t\tif(this.state) {\r\n\t\t\t\tthis.state = null\r\n\t\t\t}\r\n\t\t\tvar value = this.copiedFrom.valueOf(context)\r\n\t\t\tif(value && typeof value == 'object') {\r\n\t\t\t\tvar derivative = this.derivativeMap.get(value)\r\n\t\t\t\tif (derivative == null) {\r\n\t\t\t\t\tthis.derivativeMap.set(value, derivative = deepCopy(value, undefined, this.derivativeMap))\r\n\t\t\t\t\tthis.setValue(derivative, context)\r\n\t\t\t\t}\r\n\t\t\t\treturn derivative\r\n\t\t\t}\r\n\t\t\tvar thisValue = this.getValue ? this.getValue(context) : this.value\r\n\t\t\tif(thisValue === undefined) {\r\n\t\t\t\treturn value\r\n\t\t\t}\r\n\t\t\treturn thisValue\r\n\t\t},\r\n\t\tgetCopyOf: function(value) {\r\n\t\t\tvar derivative = this.derivativeMap.get(value)\r\n\t\t\tif (derivative == null) {\r\n\t\t\t\tthis.derivativeMap.set(value, derivative = deepCopy(value, undefined, this.derivativeMap))\r\n\t\t\t}\r\n\t\t\treturn derivative\r\n\t\t},\r\n\t\tsave: function() {\r\n\t\t\t// copy back to the original object\r\n\t\t\tvar original = this.copiedFrom.valueOf()\r\n\t\t\tvar newCopiedFrom = deepCopy(this.valueOf(), original)\r\n\t\t\tif (original !== newCopiedFrom) {\r\n\t\t\t\t// if we have replaced it with a new object/value, put it\r\n\t\t\t\tthis.copiedFrom.put && this.copiedFrom.put(newCopiedFrom)\r\n\t\t\t} else {\r\n\t\t\t\t// else we have modified an existing object, but we still need to notify\r\n\t\t\t\tif (this.copiedFrom.notifies && this.copiedFrom.updated) { // copiedFrom doesn't have to be a variable, it can be a plain object\r\n\t\t\t\t\tthis.copiedFrom.updated()\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.isDirty.put(false)\r\n\t\t\tthis.onSave && this.onSave()\r\n\t\t},\r\n\t\trevert: function() {\r\n\t\t\tvar original = this.copiedFrom.valueOf()\r\n\t\t\tthis.put(deepCopy(original, this.derivativeMap.get(original), this.derivativeMap))\r\n\t\t\tthis.isDirty.put(false)\r\n\t\t},\r\n\t\tupdated: function() {\r\n\t\t\tthis.isDirty.put(true)\r\n\t\t\treturn Variable.prototype.updated.apply(this, arguments)\r\n\t\t}\r\n\t})\r\n\treturn Copy\r\n})\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./Copy.js\n ** module id = 7\n ** module chunks = 0\n **/"],"sourceRoot":""}