{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///index.js","webpack:///webpack/bootstrap bb068071d0ad95897dbb","webpack:///./index.js","webpack:///./Element.js","webpack:///./util/lang.js","webpack:///./Renderer.js","webpack:///./Variable.js","webpack:///./reactive.js","webpack:///./operators.js","webpack:///./Copy.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","apply","undefined","Element","Renderer","reactive","Copy","operators","VariableExports","lang","main","Object","create","copy","defineProperty","getOwnPropertyDescriptor","react","spawn","ElementRenderer","booleanStyle","options","element","value","key","style","defaultStyle","directStyle","layoutChildren","parent","children","container","prepend","fragment","length","doc","createDocumentFragment","i","l","childNode","child","currentParent","appendChild","isContentNode","contentNode","notifies","ref","isIterable","variableAsContent","Array","nodeType","Error","createTextNode","insertBefore","firstChild","content","textNode","renderer","TextRenderer","variable","bidirectionalHandler","InputPropertyRenderer","name","inputs","tagName","bindChanges","prototype","renderSelectValueUpdate","type","isNaN","noop","applyAttribute","AttributeRenderer","setAttribute","applySubProperties","SubPropertyRenderer","compose","PropertyRenderer","arguments","renderUpdate","put","PropertiesRenderer","subKey","subValue","assignProperties","properties","propertyHandlers","_propertyHandlers","constructor","VariableClass","hasOwn","styleDefinition","propertyHandler","styleDefinitions","StyleRenderer","slice","addEventListener","enumerable","configurable","writable","assignGenerators","customGenerators","styleGenerators","nativeGenerators","generators","_generators","GeneratorVariable","bind","buildContent","each","defineHasOwn","ItemClass","getCollectionOf","Item","itemVariable","from","_item","ListRenderer","forEach","item","childElement","buildInputContent","conversion","nextTurn","inputEvents","event","Context","executeWithin","result","deny","parseFloat","inputType","inputProperty","date","datetime","time","mergeObject","existing","applyToConstructor","argument","applyOnCreate","_applyOnCreate","Variable","isGenerator","classHandlers","TypeError","getApplySet","Class","hasOwnProperty","getForClass","parentApplySet","getPrototypeOf","keys","getOwnPropertyNames","propertyName","toLowerCase","renderDescriptor","renderMethod","map","WeakMap","get","has","set","makeElementConstructor","BaseClass","isNativeElement","setPrototypeOf","isNativeClass","constructOrCall","withProperties","selector","ownedClasses","forTarget","property","propertyForElement","selectorMatch","match","SELECTOR_REGEX","operator","className","remaining","_ElementClass","construct","HTMLElement","createElement","presumptiveParentMap","buggyConstructorSetter","ElementApplyOnCreate","created","shadow","attachShadow","mode","ready","append","defineElement","tagSelector","extendElement","customElements","console","warn","extends","error","getConstructor","tags","setupElement","HTMLConstructor","props","elementPropertyHandlers","assigned","handlers","generate","elements","elementName","ElementClass","generateInputs","HTMLInputElement","target","From","Target","createInstance","elementMap","instanceMap","parentNode","ownedInstances","instance","subject","ThisElementVariable","_Variable","elementOverlay","alkaliRenderers","variableProperties","cleanup","renderers","stop","needsRestart","restart","elementAttached","attached","elementDetached","detached","firstVisit","node","state","__alkaliAttached__","action","body","contains","knownElementProperties","newValue","definition","Reflect","Constructor","args","ClassNameRenderer","currentClassName","changingClassName","removed","replace","newProperties","push","lastProperties","document","tag","INPUT","TEXTAREA","testElement","originalConstructor","__proto__","display","visibility","color","opacity","zoom","minZoom","maxZoom","fontWeight","position","textDecoration","base","classes","flag","class","for","role","render","dataset","attributes","styleObjectHandler","input","valueAsNumber","valueAsDate","checked","e","select","textarea","a","area","button","dialog","embed","form","frame","frameset","iframe","img","option","optgroup","output","label","td","th","script","track","link","meta","meter","progress","del","ins","source","video","keygen","object","param","radios","querySelectorAll","radio","dispatchEvent","Event","assign","within","aliases","Anchor","Image","Paragraph","Textarea","DList","UList","OList","ListItem","Text","TextInput","TableRow","TableCell","TableHeaderCell","TableHeader","TableBody","alias","to","refresh","moveLiveElementsEnabled","Content","Symbol","hasInstance","extend","ExtendedElement","descriptor","MutationObserver","lifeStates","nodes","observer","mutations","il","mutation","j","jl","nodeIteration","k","kl","baseNode","currentNode","nextNode","nextSibling","observe","childList","subtree","specify","distinctive","generics","distinctSubject","subjectMap","specifiedInstance","defaultInstance","getContextualized","_contextMap","context","matches","merge","childContext","getDistinctElement","feature","hasFeatures","SyncPromise","SyncErrorPromise","unhandledTimeout","setTimeout","queue","listener","queuedListeners","indexOf","events","diff","previous","current","callback","queued","toJSONHidden","func","displayName","isGeneratorIterator","iterator","next","generator","stepReturn","generatorIterator","isThrowing","nextValue","done","then","isSync","proto","requestAnimationFrame","promise","Promise","onFulfilled","onRejected","catch","handler","clearTimeout","addKey","keyFlag","currentValue","targetAncestor","previousSet","previousGet","remove","timerStarted","setInterval","watchedObjects","watchedCopies","listeners","unobserve","splice","Hidden","toJSON","extendClass","eval","possibleConstructOrCall","processAnimationFrame","toRender","execute","resolve","reject","resolution","finished","errorResolution","isResolved","errback","handle","newError","Set","add","values","mapProperty","intermediary","when","errorHandler","Base","div","deepCopy","constructHandler","callHandler","functionConstruct","SubClass","update","updateRendering","shouldRender","alwaysUpdate","updated","subscribe","valueOf","updateOnStart","contextualized","ContentRenderer","onElementRemoval","stopNotifies","invalidatedElements","nextId","version","updateEvent","by","invalidated","contextMatches","deferredRender","isCanceled","setVersion","newContext","integrate","addInput","invalidateElement","invalidatedParts","queueTask","processQueue","updateElement","getId","getSubject","always","thisElement","renderersOnShow","addElement","omitValueOf","started","resolved","renderLoading","removeAttribute","oldValue","String","eventualValue","innerHTML","builtList","updates","replaceChild","childNodes","nodeValue","eachItem","childElements","removeChild","actions","previousIndex","index","nextChild","newElement","onShowElement","shownElement","getElementsByClassName","includingTop","onlyChildren","getElementsByTagName","NotifyingContext","registerListener","propertyListenersMap","listenerId","autoObserveObjects","listeningToObject","deregisterListener","RefreshEvent","visited","PropertyChangeEvent","childEvent","ArrayEvent","DeleteEvent","forPropertyNotifyingValues","_properties","returnedVariable","hasChildNotifiers","subProperties","assignPromise","arrayToModify","cachedValue","array","newArray","isWritable","results","cachedVersion","insertedAt","added","startingIndex","arrayLength","addedCount","modifier","arrayPosition","removedAt","removalCount","toArray","makeSubVar","Type","objectUpdated","_propertyChange","all","transform","Transform","argsToArray","VArray","as","keyMapping","valueArray","resultObject","createForInstance","generalizeClass","prototypeNames","getGeneralizedDescriptor","generalizeMethod","method","instanceForContext","Map","VFunction","VMethod","VString","VNumber","Number","VBoolean","Boolean","VSet","VDate","Date","defineArrayMethod","returns","IterativeResults","IterativeMethod","reverse","noChange","RequestChange","RequestSet","NOT_MODIFIED","toString","nextVersion","now","contextFromCache","executor","previousContext","contextualize","parentContext","contextMap","sources","Math","max","_logStackTrace","v","stack","split","test","shift","coalesce","_debugOpts","shortStackTrace","line","some","re","log","__debug","s","stackObject","join","VariablePrototype","_currentValue","allowPromise","gotValue","getValue","forChild","versionWithChildren","ifModifiedSince","previousNotifyingValue","deferredContext","__variable","PropertyClass","propertyVariable","isPropertyClass","ContextualizedVariable","defaultContext","fixed","_isWritable","_changeValue","deniedPut","newObject","parentEvent","onPropertyChange","eachKey","forDependencies","hasNotifyingChild","init","contextualizes","dependency","handles","updateVersion","getVersion","getFullVersion","selectVariable","getUpdates","since","nextUpdateMap","isDownstream","dependent","collection","invalidate","updateQueued","updateReceiver","unsubscribe","undefine","is","proxy","proxiedVariable","complete","setValue","onValue","callbackOrItemClass","collectionOf","transformFunction","_Transform","whileResolving","valueUntilResolved","useLastValue","WhileResolving","schema","parentSchemaProperties","validate","required","valid","isValid","validation","Validating","structured","structure","observeObject","observerCount","el","deliverChanges","_sN","_debug","random","_lastUpdated","NewType","names","ExtendedVariable","getGeneratorDescriptor","defineAs","_defaultInstance","VMap","whenAllResolved","promiseSafeResult","isAsyncInputs","onResolve","readyState","staysUpdated","transformContext","isPromise","lastError","isFinite","argumentName","lastPromiseResult","whenArgumentResolved","__index","__previousPromiseResult","getArguments","originalValue","setReverse","defaultValue","ContextualTransform","contextualizedVariable","_needsContextualization","generic","_isStrictArray","unshift","pop","of","ArrayClass","resuming","generatorContext","oldSources","newLength","newSources","description","proxyHandler","deleteProperty","ownKeys","Proxy","_collectionOf","_collection","Collection","generalize","Function","returnValue","charAt","codeCharAt","lastIndexOf","substr","toUpperCase","toFixed","toExponential","toPrecision","toLocaleString","clear","delete","_array","toDateString","toTimeString","toGMTString","toUTCString","getTime","setTime","VPromise","__esModule","default","isStrictArray","_mappedItems","wrapped","filter","mapFunction","emit","keyGenerator","valueGenerator","hasKeyFunction","hasValueFunction","hasKey","group","variables","preserveObjects","_getAsObject","getType","typeMappings","typedObject","getp","directPropertyValue","prop","cond","consequent","alternate","choose","fcall","mcall","ncall","concat","obj","val","cls","definitions","getOperatingFunction","expression","operatingFunctions","precedence","forward","reverseA","reverseB","addFlags","operatorHandler","infix","firstError","b","message","derivativeMap","copiedFrom","isDirty","sync","forModification","derivative","getCopyOf","save","original","newCopiedFrom","onSave","revert"],"mappings":"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5C,GAAAiS,GAAAF,EAAA/R,EACAiS,GAAAxQ,OAAA0J,EAAA1J,MAAAwQ,IAAA9G,GACA8G,EAAAC,cAAA,GAAAC,OAAA,uBA6CA,IAkLA/R,IAlLAuG,IACAuI,QAAA/I,EACA/B,YAAA+B,EACAqJ,QAAArJ,EACAsJ,WAAAtJ,EACA/G,MAAA+G,EACA9C,OAAA,SAAAtF,EAAAmB,GACAmE,EAAAtF,EAAAmB,IAEAO,SAAA,SAAA1B,EAAAmB,GACAnB,EAAA0B,SAAAP,GAEAsK,OAAA,SAAAzL,EAAAmB,GACAnB,EAAAyL,OAAAtK,IAkTAwE,YA0CA3F,GAAAwM,EAAA,mBAAArB,yBAAA,aAEAnL,IAAA8L,gBACA9L,GAAAqU,OAAA,SAAAjH,EAAAnI,GACA,wBAAAmI,GAOApI,EAAAoI,EAAAnI,IALA6D,EAAAsE,OACA9E,GAAArD,EAAAmI,KAQApN,GAAAsU,OAAA,SAAApT,KAIA4L,GACA,QACA,SACA,QACA,QACA,KACA,IACA,QACA,QACA,WACA,WACA,QACA,QACA,QACA,KACA,QACA,MACA,WACA,KACA,KACA,UACA,MACA,MACA,QACA,SACA,OACA,QACA,SACA,SACA,SACA,IACA,QACA,WACA,MACA,UACA,QACA,IACA,SACA,SACA,WACA,SACA,KACA,MACA,IACA,MACA,QACA,OACA,OACA,MACA,OACA,SACA,QACA,KACA,SACA,QACA,MACA,SACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,WACA,QACA,OACA,OACA,QACA,KACA,OACA,OACA,MACA,IACA,UACA,QACA,OACA,SACA,SACA,aACA,SACA,OACA,OACA,WACA,MACA,UACA,OACA,UACA,MACA,MACA,SACA,UACA,WACA,KACA,SACA,SACA,OACA,KACA,OACA,MAEAI,GACA,WACA,WACA,SACA,QACA,QACA,OACA,WACA,QACA,QACA,SACA,QACA,SACA,MACA,OACA,MACA,QAEA,IAAAX,OA4DAgI,IACAC,OAAA,IACAC,MAAA,MACAC,UAAA,IACAC,SAAA,WACAC,MAAA,KACAC,MAAA,KACAC,MAAA,KACAC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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"alkali\"] = factory();\n\telse\n\t\troot[\"alkali\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"alkali\"] = factory();\n\telse\n\t\troot[\"alkali\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/// <reference path=\"./typings.d.ts\" />\r\n\t(function (root, factory) { if (true) {\r\n\t  !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1), __webpack_require__(3), __webpack_require__(5), __webpack_require__(7), __webpack_require__(6), __webpack_require__(4), __webpack_require__(2)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) } else if (typeof module === 'object' && module.exports) {        \r\n\t  module.exports = factory(require('./Element'), require('./Renderer'), require('./reactive'), require('./Copy'), require('./operators'), require('./Variable'), require('./util/lang')) // Node\r\n\t}}(this, function (Element, Renderer, reactive, Copy, operators, VariableExports, lang) {\r\n\t\r\n\t\tvar main = Object.create(Element)\r\n\t\tmain.Copy = Copy\r\n\t\tmain.Element = Element\r\n\t\tlang.copy(main, VariableExports)\r\n\t\tObject.defineProperty(main, 'currentContext', Object.getOwnPropertyDescriptor(VariableExports, 'currentContext'))\r\n\t\tmain.reactive = reactive\r\n\t\tlang.copy(main.react, reactive) // For backwards compatibility with babel transform\r\n\t\tmain.spawn = lang.spawn\r\n\t\tmain.Renderer = Renderer.ElementRenderer\r\n\t\tlang.copy(main, Renderer)\r\n\t\tlang.copy(main, operators)\r\n\t\tmain.default = undefined // no default export\r\n\t\treturn main\r\n\t}))\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) { if (true) {\r\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(3), __webpack_require__(4)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) } else if (typeof module === 'object' && module.exports) {\t\t\t\t\r\n\t\tmodule.exports = factory(require('./util/lang'), require('./Renderer'), require('./Variable')) // Node\r\n\t}}(this, function (lang, Renderer, VariableExports) {\r\n\t\tvar Variable = VariableExports.Variable\r\n\t\tvar knownElementProperties = [\r\n\t\t\t'textContent', // Node\r\n\t\t\t'id', 'className', 'innerHTML', // Element\r\n\t\t\t'title', 'lang', 'translate', 'dir', 'tabIndex', 'accessKey', 'draggable', 'spellcheck', 'contentEditable', 'innerText', 'webkitdropzone'] // HTMLElement\r\n\t\r\n\t\tvar SELECTOR_REGEX = /^(\\.|#)([-\\w]+)(.+)?/\r\n\t\tvar isGenerator = lang.isGenerator\r\n\t\tvar Context = VariableExports.Context\r\n\t\tvar PropertyRenderer = Renderer.PropertyRenderer\r\n\t\tvar InputPropertyRenderer = Renderer.InputPropertyRenderer\r\n\t\tvar AttributeRenderer = Renderer.AttributeRenderer\r\n\t\tvar StyleRenderer = lang.compose(Renderer.StyleRenderer, function StyleRenderer() {\r\n\t\t\tRenderer.StyleRenderer.apply(this, arguments)\r\n\t\t}, {\r\n\t\t\trenderUpdate: function(newValue, element) {\r\n\t\t\t\tvar definition = styleDefinitions[this.name]\r\n\t\t\t\tif (definition) {\r\n\t\t\t\t\tdefinition(element, newValue, this.name)\r\n\t\t\t\t} else {\r\n\t\t\t\t\telement.style[this.name] = newValue\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\tvar construct = typeof Reflect !== 'undefined' ? Reflect.construct :\r\n\t\t\tfunction(Constructor, args, Class) {\r\n\t\t\t\treturn Constructor.apply(Object.create(Class.prototype), args)\r\n\t\t\t}\r\n\t\r\n\t\tvar constructOrCall = lang.constructOrCall\r\n\t\tvar ClassNameRenderer = lang.compose(Renderer.ElementRenderer, function ClassNameRenderer(options) {\r\n\t\t\tthis.name = options.name\r\n\t\t\tRenderer.apply(this, arguments)\r\n\t\t}, {\r\n\t\t\trenderUpdate: function(newValue, element) {\r\n\t\t\t\tvar currentClassName = element.className\r\n\t\t\t\tvar changingClassName = this.name\r\n\t\t\t\t// remove the className (needed for addition or removal)\r\n\t\t\t\t// see http://jsperf.com/remove-class-name-algorithm/2 for some tests on this\r\n\t\t\t\tvar removed = currentClassName && (' ' + currentClassName + ' ').replace(' ' + changingClassName + ' ', ' ')\r\n\t\t\t\tif (newValue) {\r\n\t\t\t\t\t// addition, add the className\r\n\t\t\t\t\tchangingClassName = currentClassName ? (removed + changingClassName).slice(1) : changingClassName;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// we already have removed the class, just need to trim\r\n\t\t\t\t\tchangingClassName = removed.slice(1, removed.length - 1)\r\n\t\t\t\t}\r\n\t\t\t\t// only assign if it changed, this can save a lot of time\r\n\t\t\t\tif (changingClassName != currentClassName) {\r\n\t\t\t\t\telement.className = changingClassName\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t\tvar PropertiesRenderer = lang.compose(Renderer.ElementRenderer, function PropertiesRenderer(options) {\r\n\t\t\tthis.PropertyRenderer = options.PropertyRenderer\r\n\t\t\tRenderer.apply(this, arguments)\r\n\t\t}, {\r\n\t\t\trenderUpdate: function(newValue, element) {\r\n\t\t\t\tvar newProperties = []\r\n\t\t\t\t// assign properties based on object properties\r\n\t\t\t\tfor (var name in newValue) {\r\n\t\t\t\t\tthis.PropertyRenderer.prototype.renderUpdate.call({\r\n\t\t\t\t\t\tname: name\r\n\t\t\t\t\t}, newValue[name], element)\r\n\t\t\t\t\tnewProperties.push(name)\r\n\t\t\t\t}\r\n\t\t\t\tvar lastProperties = this.lastProperties\r\n\t\t\t\tif (lastProperties) {\r\n\t\t\t\t\t// if previous state existed, remove old names of any properties that don't exist anymore\r\n\t\t\t\t\tfor (var i = 0, l = lastProperties.length; i < l; i++) {\r\n\t\t\t\t\t\tvar name = lastProperties[i]\r\n\t\t\t\t\t\tif (!(name in newValue)) {\r\n\t\t\t\t\t\t\tthis.PropertyRenderer.prototype.renderUpdate.call({\r\n\t\t\t\t\t\t\t\tname: name\r\n\t\t\t\t\t\t\t}, undefined, element)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tthis.lastProperties = newProperties // store the class names if we need to remove any on next state change\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\t// TODO: check for renderContent with text updater\r\n\t\tvar TextRenderer = Renderer.TextRenderer\r\n\t\tvar ListRenderer = Renderer.ListRenderer\r\n\t\r\n\t\tvar doc = typeof document !== 'undefined' ? document : {\r\n\t\t\tcreateElement: function(tag) {\r\n\t\t\t\treturn {}\r\n\t\t\t},\r\n\t\t\taddEventListener: function() {\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tvar inputs = {\r\n\t\t\tINPUT: 1,\r\n\t\t\tTEXTAREA: 1\r\n\t\t\t// SELECT: 1, we exclude this, so the default \"content\" of the element can be the options\r\n\t\t}\r\n\t\r\n\t\tvar buggyConstructorSetter = false\r\n\t\tvar testElement = doc.createElement('font')\r\n\t\tvar originalConstructor = testElement.constructor\r\n\t\ttestElement.constructor = function(){}\r\n\t\tif (doc.createElement('font').constructor == testElement.constructor) {\r\n\t\t\t// In safari, setting the constructor can actually assign it at the prototype level, instead of at the instance\r\n\t\t\ttestElement.__proto__.constructor = originalConstructor // restore the original constructor\r\n\t\t\tbuggyConstructorSetter = true\r\n\t\t\tlang.buggyConstructorSetter = buggyConstructorSetter\r\n\t\t}\r\n\t\r\n\t\r\n\t\tfunction booleanStyle(options) {\r\n\t\t\treturn function(element, value, key) {\r\n\t\t\t\tif (typeof value !== 'string') {\r\n\t\t\t\t\t// use the boolean conversion\r\n\t\t\t\t\tvalue = options[value ? 0 : 1]\r\n\t\t\t\t}\r\n\t\t\t\telement.style[key] = value\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction defaultStyle(element, value, key) {\r\n\t\t\tif (typeof value === 'number') {\r\n\t\t\t\tvalue = value + 'px'\r\n\t\t\t}\r\n\t\t\telement.style[key] = value\r\n\t\t}\r\n\t\tfunction directStyle(element, value, key) {\r\n\t\t\telement.style[key] = value\r\n\t\t}\r\n\t\r\n\t\tvar styleDefinitions = {\r\n\t\t\tdisplay: booleanStyle(['', 'none']),\r\n\t\t\tvisibility: booleanStyle(['visible', 'hidden']),\r\n\t\t\tcolor: directStyle,\r\n\t\t\topacity: directStyle,\r\n\t\t\tzoom: directStyle,\r\n\t\t\tminZoom: directStyle,\r\n\t\t\tmaxZoom: directStyle,\r\n\t\t\tfontWeight: directStyle,\r\n\t\t\tposition: booleanStyle(['absolute', '']),\r\n\t\t\ttextDecoration: booleanStyle(['underline', '']),\r\n\t\t\tfontWeight: directStyle // numbers are allowed here (TODO: eventually allow booleans too)\r\n\t\t}\r\n\t\t;[\"alignContent\",\"alignItems\",\"alignSelf\",\"animation\",\"animationDelay\",\"animationDirection\",\"animationDuration\",\"animationFillMode\",\"animationIterationCount\",\"animationName\",\"animationPlayState\",\"animationTimingFunction\",\"backfaceVisibility\",\"background\",\"backgroundAttachment\",\"backgroundBlendMode\",\"backgroundClip\",\"backgroundColor\",\"backgroundImage\",\"backgroundOrigin\",\"backgroundPosition\",\"backgroundPositionX\",\"backgroundPositionY\",\"backgroundRepeat\",\"backgroundRepeatX\",\"backgroundRepeatY\",\"backgroundSize\",\"baselineShift\",\"border\",\"borderBottom\",\"borderBottomColor\",\"borderBottomLeftRadius\",\"borderBottomRightRadius\",\"borderBottomStyle\",\"borderBottomWidth\",\"borderCollapse\",\"borderColor\",\"borderImage\",\"borderImageOutset\",\"borderImageRepeat\",\"borderImageSlice\",\"borderImageSource\",\"borderImageWidth\",\"borderLeft\",\"borderLeftColor\",\"borderLeftStyle\",\"borderLeftWidth\",\"borderRadius\",\"borderRight\",\"borderRightColor\",\"borderRightStyle\",\"borderRightWidth\",\"borderSpacing\",\"borderStyle\",\"borderTop\",\"borderTopColor\",\"borderTopLeftRadius\",\"borderTopRightRadius\",\"borderTopStyle\",\"borderTopWidth\",\"borderWidth\",\"bottom\",\"boxShadow\",\"boxSizing\",\"bufferedRendering\",\"captionSide\",\"clear\",\"clip\",\"clipPath\",\"clipRule\",\"color\",\"colorInterpolation\",\"colorInterpolationFilters\",\"colorRendering\",\"counterIncrement\",\"counterReset\",\"cursor\",\"direction\",\"display\",\"emptyCells\",\"fill\",\"fillOpacity\",\"fillRule\",\"filter\",\"flex\",\"flexBasis\",\"flexDirection\",\"flexFlow\",\"flexGrow\",\"flexShrink\",\"flexWrap\",\"float\",\"floodColor\",\"floodOpacity\",\"font\",\"fontFamily\",\"fontFeatureSettings\",\"fontKerning\",\"fontSize\",\"fontStretch\",\"fontStyle\",\"fontVariant\",\"fontVariantLigatures\",\"fontWeight\",\"height\",\"imageRendering\",\"isolation\",\"justifyContent\",\"left\",\"letterSpacing\",\"lightingColor\",\"lineHeight\",\"listStyle\",\"listStyleImage\",\"listStylePosition\",\"listStyleType\",\"margin\",\"marginBottom\",\"marginLeft\",\"marginRight\",\"marginTop\",\"marker\",\"markerEnd\",\"markerMid\",\"markerStart\",\"mask\",\"maskType\",\"maxHeight\",\"maxWidth\",\"maxZoom\",\"minHeight\",\"minWidth\",\"minZoom\",\"mixBlendMode\",\"motion\",\"motionOffset\",\"motionPath\",\"motionRotation\",\"objectFit\",\"objectPosition\",\"opacity\",\"order\",\"orientation\",\"orphans\",\"outline\",\"outlineColor\",\"outlineOffset\",\"outlineStyle\",\"outlineWidth\",\"overflow\",\"overflowWrap\",\"overflowX\",\"overflowY\",\"padding\",\"paddingBottom\",\"paddingLeft\",\"paddingRight\",\"paddingTop\",\"page\",\"pageBreakAfter\",\"pageBreakBefore\",\"pageBreakInside\",\"paintOrder\",\"perspective\",\"perspectiveOrigin\",\"pointerEvents\",\"position\",\"quotes\",\"resize\",\"right\",\"shapeImageThreshold\",\"shapeMargin\",\"shapeOutside\",\"shapeRendering\",\"size\",\"speak\",\"src\",\"stopColor\",\"stopOpacity\",\"stroke\",\"strokeDasharray\",\"strokeDashoffset\",\"strokeLinecap\",\"strokeLinejoin\",\"strokeMiterlimit\",\"strokeOpacity\",\"strokeWidth\",\"tabSize\",\"tableLayout\",\"textAlign\",\"textAlignLast\",\"textAnchor\",\"textCombineUpright\",\"textDecoration\",\"textIndent\",\"textOrientation\",\"textOverflow\",\"textRendering\",\"textShadow\",\"textTransform\",\"top\",\"touchAction\",\"transform\",\"transformOrigin\",\"transformStyle\",\"transition\",\"transitionDelay\",\"transitionDuration\",\"transitionProperty\",\"transitionTimingFunction\",\"unicodeBidi\",\"unicodeRange\",\"userZoom\",\"vectorEffect\",\"verticalAlign\",\"visibility\",\"whiteSpace\",\"widows\",\"width\",\"willChange\",\"wordBreak\",\"wordSpacing\",\"wordWrap\",\"writingMode\",\"zIndex\",\"zoom\"].forEach(function(property) {\r\n\t\t\tstyleDefinitions[property] = styleDefinitions[property] || defaultStyle\r\n\t\t})\r\n\t\tvar styleSheet\r\n\t\tvar presumptiveParentMap = new lang.WeakMap()\r\n\t\r\n\t\tvar setPrototypeOf = lang.setPrototypeOf\r\n\t\tvar getPrototypeOf = Object.getPrototypeOf || (function(base) { return base.__proto__ })\r\n\t\tfunction createCssRule(selector) {\r\n\t\t\tif (!styleSheet) {\r\n\t\t\t\tvar styleSheetElement = doc.createElement(\"style\")\r\n\t\t\t\tstyleSheetElement.setAttribute(\"type\", \"text/css\")\r\n\t//\t\t\tstyleSheet.appendChild(doc.createTextNode(css))\r\n\t\t\t\tdoc.head.insertBefore(styleSheetElement, doc.head.firstChild)\r\n\t\t\t\tstyleSheet = styleSheetElement.sheet\r\n\t\t\t}\r\n\t\t\tvar cssRules = styleSheet.cssRules || styleSheet.rules\r\n\t\t\treturn cssRules[styleSheet.addRule(selector, ' ', cssRules.length)]\r\n\t\t}\r\n\t\r\n\t\t// TODO: Need to do some more testing to see if that would improve performance:\r\n\t\t// var fragmentThresholdHeuristic = (typeof navigator !== 'undefined' && navigator.userAgent.indexOf('Chrome') > 0) ? 1 : 3\r\n\t\r\n\t\tfunction layoutChildren(parent, children, container, prepend) {\r\n\t\t\tvar fragment = (children.length > 1 || prepend) ? doc.createDocumentFragment() : parent\r\n\t\t\tfor(var i = 0, l = children.length; i < l; i++) {\r\n\t\t\t\tvar child = children[i]\r\n\t\t\t\tvar childNode\r\n\t\t\t\tif (child != null) { // we just skip nulls and undefined, helps make it easier to write conditional element logic\r\n\t\t\t\t\tif (typeof child === 'function') {\r\n\t\t\t\t\t\t// an element constructor\r\n\t\t\t\t\t\tcurrentParent = parent\r\n\t\t\t\t\t\tchildNode = new child()\r\n\t\t\t\t\t\tfragment.appendChild(childNode)\r\n\t\t\t\t\t\tif (child.isContentNode) {\r\n\t\t\t\t\t\t\tcontainer.contentNode = childNode\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (child.notifies) {\r\n\t\t\t\t\t\t// a variable\r\n\t\t\t\t\t\tvar ref = child.isIterable ? fragment : parent\r\n\t\t\t\t\t\tfragment.appendChild(childNode = variableAsContent(ref, child))\r\n\t\t\t\t\t} else if (typeof child == 'object') {\r\n\t\t\t\t\t\tif (child instanceof Array) {\r\n\t\t\t\t\t\t\t// array of sub-children\r\n\t\t\t\t\t\t\tcontainer = container || parent\r\n\t\t\t\t\t\t\tchildNode = childNode || parent\r\n\t\t\t\t\t\t\tlayoutChildren(childNode.contentNode || childNode, child, container)\r\n\t\t\t\t\t\t} else if (child.nodeType) {\r\n\t\t\t\t\t\t\t// an element itself\r\n\t\t\t\t\t\t\tfragment.appendChild(childNode = child)\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// TODO: apply properties to last child, but with binding to the parent (for events)\r\n\t\t\t\t\t\t\tthrow new Error('Unknown child type ' + child)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// a primitive value\r\n\t\t\t\t\t\tchildNode = doc.createTextNode(child)\r\n\t\t\t\t\t\tfragment.appendChild(childNode)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (fragment != parent) {\r\n\t\t\t\tif (prepend) {\r\n\t\t\t\t\tparent.insertBefore(fragment, parent.firstChild)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tparent.appendChild(fragment)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn childNode\r\n\t\t}\r\n\t\tfunction variableAsContent(parent, content) {\r\n\t\t\tif (content == null) {\r\n\t\t\t\treturn doc.createTextNode('')\r\n\t\t\t}\r\n\t\t\tvar textNode\r\n\t\t\tif (content.notifies) {\r\n\t\t\t\ttextNode = doc.createTextNode('')\r\n\t\t\t\tvar renderer = new TextRenderer({\r\n\t\t\t\t\telement: parent,\r\n\t\t\t\t\ttextNode: textNode,\r\n\t\t\t\t\tvariable: content\r\n\t\t\t\t})\r\n\t\t\t\ttextNode = renderer.textNode // it can be swapped for another node\r\n\t\t\t} else {\r\n\t\t\t\ttextNode = doc.createTextNode(content)\r\n\t\t\t}\r\n\t\t\treturn textNode\r\n\t\t}\r\n\t\r\n\t\tfunction bidirectionalHandler(element, value, key) {\r\n\t\t\tif (value && value.notifies) {\r\n\t\t\t\tnew InputPropertyRenderer({\r\n\t\t\t\t\tname: key,\r\n\t\t\t\t\tvariable: value,\r\n\t\t\t\t\telement: element\r\n\t\t\t\t})\r\n\t\t\t\tif (inputs[element.tagName] || element.tagName === 'SELECT') {\r\n\t\t\t\t\tbindChanges(element, value, key)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (element.tagName === 'SELECT' && key === 'value') {\r\n\t\t\t\t\t// use the deferred <select> value assignment\r\n\t\t\t\t\tInputPropertyRenderer.prototype.renderSelectValueUpdate(value, element)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (element.type === 'number') {\r\n\t\t\t\t\t\tif (isNaN(value)) {\r\n\t\t\t\t\t\t\tvalue = ''\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telement[key] = value\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction noop() {}\r\n\t\tvar propertyHandlers = {\r\n\t\t\tchildren: noop,\r\n\t\t\ttagName: noop,\r\n\t\t\t_generators: noop,\r\n\t\t\tclasses: function(element, classes) {\r\n\t\t\t\tif (classes.notifies && classes.put) {\r\n\t\t\t\t\t// it is a variable\r\n\t\t\t\t\tnew PropertiesRenderer({\r\n\t\t\t\t\t\tPropertyRenderer: ClassNameRenderer,\r\n\t\t\t\t\t\telement: element,\r\n\t\t\t\t\t\tvariable: classes\r\n\t\t\t\t\t})\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t\tif (!(classes.length > -1)) {\r\n\t\t\t\t\t// index the classes, if necessary\r\n\t\t\t\t\tvar i = 0\r\n\t\t\t\t\tfor (var key in classes) {\r\n\t\t\t\t\t\tif (!classes[i]) {\r\n\t\t\t\t\t\t\tclasses[i] = key\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ti++\r\n\t\t\t\t\t}\r\n\t\t\t\t\tclasses.length = i\r\n\t\t\t\t}\r\n\t\t\t\tfor (var i = 0, l = classes.length; i < l; i++) {\r\n\t\t\t\t\t// find each class name\r\n\t\t\t\t\tvar className = classes[i]\r\n\t\t\t\t\tvar flag = classes[className]\r\n\t\t\t\t\tif (flag && flag.notifies) {\r\n\t\t\t\t\t\t// if it is a variable, we react to it\r\n\t\t\t\t\t\tnew ClassNameRenderer({\r\n\t\t\t\t\t\t\telement: element,\r\n\t\t\t\t\t\t\tname: className,\r\n\t\t\t\t\t\t\tvariable: flag\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t} else if (flag || flag === undefined) {\r\n\t\t\t\t\t\telement.className += ' ' + className\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tclass: applyAttribute,\r\n\t\t\tfor: applyAttribute, // TODO: move to label?\r\n\t\t\trole: applyAttribute,\r\n\t\t\trender: function(element, value, key, properties) {\r\n\t\t\t\t// TODO: This doesn't need to be a property updater (is in place for *render())\r\n\t\t\t\t// we should also verify it is a generator\r\n\t\t\t\t// and maybe, at some point, find an optimization to eliminate the bind()\r\n\t\t\t\tnew PropertyRenderer({\r\n\t\t\t\t\tname: key,\r\n\t\t\t\t\tvariable: typeof value === 'function' ? new VariableExports.GeneratorVariable(value.bind(element, properties)) : value, // if it was defined on the constructor, it should already be bound\r\n\t\t\t\t\telement: element\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tdataset: applySubProperties(function(newValue, element, key) {\r\n\t\t\t\tkey = key || this.name\r\n\t\t\t\tif (newValue == null) {\r\n\t\t\t\t\tdelete element.dataset[key]\t\r\n\t\t\t\t} else {\r\n\t\t\t\t\telement.dataset[key] = newValue\r\n\t\t\t\t}\r\n\t\t\t}),\r\n\t\t\tattributes: applySubProperties(function(newValue, element, key) {\r\n\t\t\t\tAttributeRenderer.prototype.renderUpdate.call({\r\n\t\t\t\t\tname: key || this.name\r\n\t\t\t\t}, newValue, element)\r\n\t\t\t}),\r\n\t\t\tstyle: function(element, value, key) {\r\n\t\t\t\tif (typeof value === 'string') {\r\n\t\t\t\t\telement.setAttribute('style', value)\r\n\t\t\t\t} else if (value && value.notifies) {\r\n\t\t\t\t\tnew AttributeRenderer({\r\n\t\t\t\t\t\tname: 'style',\r\n\t\t\t\t\t\tvariable: value,\r\n\t\t\t\t\t\telement: element\r\n\t\t\t\t\t})\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstyleObjectHandler(element, value, key)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tknownElementProperties.forEach(function(property) {\r\n\t\t\tpropertyHandlers[property] = true\r\n\t\t})\r\n\t\tif (typeof HTMLElement !== 'undefined') {\r\n\t\t\tHTMLElement.prototype._propertyHandlers = propertyHandlers // inherit this, at least for now\r\n\t\t}\r\n\t\tvar elementPropertyHandlers = {\r\n\t\t\tinput: lang.copy(['accept', 'alt', 'autocomplete', 'autofocus', 'capture', 'defaultChecked', 'dirName', 'disabled', 'form', 'files', 'formAction', 'formEnctype', 'formMethod', 'formNoValidate', 'formTarget', 'indeterminate', 'inputMode', 'list', 'max', 'maxLength', 'min', 'minLength', 'multiple', 'name', 'pattern', 'placeholder', 'readOnly', 'required', 'size', 'src', 'step', 'type', 'defaultValue', 'willValidate', 'validity', 'validationMessage', 'useMap', 'autocapitalize', 'webkitdirectory', 'incremental', 'stepUp', 'stepDown'], {\r\n\t\t\t\tvalue: bidirectionalHandler,\r\n\t\t\t\tvalueAsNumber: bidirectionalHandler,\r\n\t\t\t\tvalueAsDate: bidirectionalHandler,\r\n\t\t\t\tchecked: bidirectionalHandler,\r\n\t\t\t\ttype: function(element, value) {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\telement.type = value\r\n\t\t\t\t\t} catch(e) {\r\n\t\t\t\t\t\t// IE 11 will throw an error here\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}),\r\n\t\t\tselect: lang.copy(['name', 'size', 'type', 'selectedIndex', 'validationMessage'], {\r\n\t\t\t\tvalue: bidirectionalHandler\r\n\t\t\t}),\r\n\t\t\ttextarea: lang.copy(['cols', 'dirName', 'maxLength', 'minLength', 'name', 'placeholder', 'rows', 'wrap', 'type', 'defaultValue', 'textLength', 'validationMessage', 'autocapitalize'], {\r\n\t\t\t\tvalue: bidirectionalHandler\r\n\t\t\t}),\r\n\t\t\ta: ['target', 'download', 'ping', 'rel', 'hreflang', 'type', 'referrerPolicy', 'href', 'media'],\r\n\t\t\tarea: ['target', 'download', 'coords', 'rel', 'hreflang', 'type', 'referrerPolicy', 'href', 'media', 'alt', 'shape'],\r\n\t\t\tbutton: ['disabled', 'formAction', 'formEnctype', 'formMethod', 'formTarget', 'name', 'type', 'value', 'validationMessage'],\r\n\t\t\tdialog: ['open'],\r\n\t\t\tembed: ['src', 'type', 'name'],\r\n\t\t\tform: ['acceptCharset', 'action', 'autocomplete', 'enctype', 'encoding', 'method', 'name', 'target', 'novalidate'],\r\n\t\t\tframe: ['name', 'scrolling', 'src', 'frameBorder'],\r\n\t\t\tframeset: ['cols', 'rows'],\r\n\t\t\tiframe: ['src', 'srcdoc', 'name', 'referrerPolicy', 'align', 'scrolling', 'frameBorder', 'longDesc'],\r\n\t\t\timg: ['src', 'alt', 'crossorigin', 'ismap', 'longdesc', 'sizes', 'srcset', 'usemap', 'referrerpolicy'],\r\n\t\t\toption: ['label', 'value', 'text', 'index'],\r\n\t\t\toptgroup: ['label'],\r\n\t\t\toutput: ['name', 'type', 'defaultValue', 'value', 'validationMessage'],\r\n\t\t\tlabel: ['htmlFor'],\r\n\t\t\ttd: ['colSpan', 'rowSpan'],\r\n\t\t\tth: ['colSpan', 'rowSpan'],\r\n\t\t\tscript: ['src', 'type', 'charset', 'text', 'event', 'htmlFor', 'integrity'],\r\n\t\t\tstyle: ['media', 'type'],\r\n\t\t\ttrack: ['kind', 'src', 'srclang', 'label'],\r\n\t\t\tlink: ['href', 'rel', 'media', 'hreflang', 'type', 'charset', 'rev', 'target', 'integrity', 'as'],\r\n\t\t\tmeta: ['name', 'httpEquiv', 'content', 'scheme'],\r\n\t\t\tmeter: ['value', 'min', 'max', 'low', 'high', 'optimum'],\r\n\t\t\tprogress: ['value', 'max', 'position'],\r\n\t\t\tdel: ['cite', 'dateTime'],\r\n\t\t\tins: ['cite', 'dateTime'],\r\n\t\t\tsource: ['src', 'type', 'srcset', 'sizes', 'media'],\r\n\t\t\tvideo: ['videoWidth', 'videoHeight', 'poster', 'webkitDecodedFrameCount', 'webkitDroppedFrameCount'],\r\n\t\t\tkeygen: ['challenge', 'keytype', 'name', 'type', 'validationMessage'],\r\n\t\t\tobject: ['data', 'type', 'name', 'useMap', 'validationMessage', 'archive', 'code', 'hspace', 'standby', 'vspace', 'codeBase', 'codeType'],\r\n\t\t\tparam: ['name', 'value', 'type', 'valueType']\r\n\t\t}\r\n\t\r\n\t\tfunction applyAttribute(element, value, key) {\r\n\t\t\tif (value && value.notifies) {\r\n\t\t\t\tnew AttributeRenderer({\r\n\t\t\t\t\tname: key,\r\n\t\t\t\t\tvariable: value,\r\n\t\t\t\t\telement: element\r\n\t\t\t\t})\r\n\t\t\t} else {\r\n\t\t\t\telement.setAttribute(key, value)\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tvar styleObjectHandler = applySubProperties(function(newValue, element, key) {\r\n\t\t\telement.style[key || this.name] = newValue\r\n\t\t})\r\n\t\r\n\t\tfunction applySubProperties(renderer) {\r\n\t\t\tvar SubPropertyRenderer = lang.compose(PropertyRenderer, function SubPropertyRenderer(options) {\r\n\t\t\t\tPropertyRenderer.apply(this, arguments)\r\n\t\t\t}, {\r\n\t\t\t\trenderUpdate: renderer\r\n\t\t\t})\r\n\t\t\treturn function(element, value, key) {\r\n\t\t\t\tif (value.notifies && value.put) {\r\n\t\t\t\t\tnew PropertiesRenderer({\r\n\t\t\t\t\t\tPropertyRenderer: SubPropertyRenderer,\r\n\t\t\t\t\t\tvariable: value,\r\n\t\t\t\t\t\telement: element\r\n\t\t\t\t\t})\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t\tfor (var subKey in value) {\r\n\t\t\t\t\tvar subValue = value[subKey]\r\n\t\t\t\t\tif (subValue && subValue.notifies) {\r\n\t\t\t\t\t\tnew SubPropertyRenderer({\r\n\t\t\t\t\t\t\tname: subKey,\r\n\t\t\t\t\t\t\tvariable: subValue,\r\n\t\t\t\t\t\t\telement: element\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\trenderer(subValue, element, subKey)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction assignProperties(element, properties) {\r\n\t\t\tvar propertyHandlers = element._propertyHandlers\r\n\t\t\tvar Element = element.constructor\r\n\t\t\tfor (var key in properties) {\r\n\t\t\t\tvar value = properties[key]\r\n\t\t\t\tvar VariableClass = Element[key]\r\n\t\t\t\tif (typeof VariableClass === 'function' && VariableClass.notifies && VariableClass !== value) {\r\n\t\t\t\t\thasOwn(Element, VariableClass)\r\n\t\t\t\t\t// if (value instanceof VariableClass) { TODO: assign the value as the owned instance\r\n\t\t\t\t\tVariableClass.for(element).put(value)\r\n\t\t\t\t}\r\n\t\t\t\tvar styleDefinition\r\n\t\t\t\tvar propertyHandler = propertyHandlers[key]\r\n\t\t\t\tif (propertyHandler) {\r\n\t\t\t\t\tif (propertyHandler === true) {\r\n\t\t\t\t\t\tif (value && value.notifies) {\r\n\t\t\t\t\t\t// a standard, known element property\r\n\t\t\t\t\t\t\tnew PropertyRenderer({\r\n\t\t\t\t\t\t\t\tname: key,\r\n\t\t\t\t\t\t\t\tvariable: value,\r\n\t\t\t\t\t\t\t\telement: element\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\telement[key] = value\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tpropertyHandler(element, value, key, properties)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if ((styleDefinition = styleDefinitions[key])) {\r\n\t\t\t\t\tif (value && value.notifies) {\r\n\t\t\t\t\t\tnew StyleRenderer({\r\n\t\t\t\t\t\t\tname: key,\r\n\t\t\t\t\t\t\tvariable: value,\r\n\t\t\t\t\t\t\telement: element\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tstyleDefinition(element, value, key)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (element[key] == null) {\r\n\t\t\t\t\t// we are working an unknown/unstandard property (or an event listener)\r\n\t\t\t\t\t// undefined or null means we can safely set\r\n\t\t\t\t\t// TODO: we may want to do the event listener check first so we can handle oncustomevent (that needs an addEventListener call to work)\r\n\t\t\t\t\telement[key] = value\r\n\t\t\t\t} else if (typeof value === 'function' && key.slice(0, 2) === 'on') {\r\n\t\t\t\t\t// event listener with one already defined on the prototype\r\n\t\t\t\t\telement.addEventListener(key.slice(2), value)\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// otherwise bypass/override the native getter/setter\r\n\t\t\t\t\tObject.defineProperty(element, key, {\r\n\t\t\t\t\t\tvalue: value,\r\n\t\t\t\t\t\tenumerable: true,\r\n\t\t\t\t\t\tconfigurable: true,\r\n\t\t\t\t\t\twritable: true\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction assignGenerators(element, properties) {\r\n\t\t\tvar generators = properties._generators\r\n\t\t\tvar customGenerators\r\n\t\t\tvar styleGenerators\r\n\t\t\tvar nativeGenerators\r\n\t\t\tvar propertyHandlers = element._propertyHandlers\r\n\t\t\tfor (var key in generators) {\r\n\t\t\t\tvar variable = new VariableExports.GeneratorVariable(generators[key].bind(element, properties))\r\n\t\t\t\tif (propertyHandlers[key]) {\r\n\t\t\t\t\t(nativeGenerators || (nativeGenerators = {}))[key] = variable\r\n\t\t\t\t} else if (styleDefinitions[key]) {\r\n\t\t\t\t\t(styleGenerators || (styleGenerators = {}))[key] = variable\r\n\t\t\t\t} else {\r\n\t\t\t\t\t(customGenerators || (customGenerators = {}))[key] = variable\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (customGenerators) {\r\n\t\t\t\t// custom ones must go first\r\n\t\t\t\tassignProperties(element, customGenerators)\r\n\t\t\t}\r\n\t\t\tif (styleGenerators) {\r\n\t\t\t\tassignProperties(element, styleGenerators)\r\n\t\t\t}\r\n\t\t\tif (nativeGenerators) {\r\n\t\t\t\t// native ones must come last so they can access custom ones\r\n\t\t\t\tassignProperties(element, nativeGenerators)\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction buildContent(element, content, key, properties) {\r\n\t\t\tvar each = element.each || properties.each\r\n\t\t\tif (each && content) {\r\n\t\t\t\t// render as list\r\n\t\t\t\tif (each.create) {\r\n\t\t\t\t\teach.defineHasOwn = function () {\r\n\t\t\t\t\t\tvar ItemClass = content.getCollectionOf && content.getCollectionOf() || Item\r\n\t\t\t\t\t\thasOwn(each, ItemClass, function (element) {\r\n\t\t\t\t\t\t\tvar itemVariable = ItemClass.from(element._item)\r\n\t\t\t\t\t\t\treturn itemVariable\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (content.notifies) {\r\n\t\t\t\t\tnew ListRenderer({\r\n\t\t\t\t\t\teach: each,\r\n\t\t\t\t\t\tvariable: content,\r\n\t\t\t\t\t\telement: element\r\n\t\t\t\t\t})\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar fragment = doc.createDocumentFragment()\r\n\t\t\t\t\tif (each.defineHasOwn) {\r\n\t\t\t\t\t\teach.defineHasOwn()\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcontent.forEach(function(item) {\r\n\t\t\t\t\t\tif (each.create) {\r\n\t\t\t\t\t\t\tchildElement = each.create({parent: element, _item: item}) // TODO: make a faster object here potentially\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tchildElement = each(item, element)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfragment.appendChild(childElement)\r\n\t\t\t\t\t})\r\n\t\t\t\t\telement.appendChild(fragment)\r\n\t\t\t\t}\r\n\t\t\t} else if (inputs[element.tagName]) {\r\n\t\t\t\t// render into input\r\n\t\t\t\tbuildInputContent(element, content)\r\n\t\t\t} else if (content instanceof Array) {\r\n\t\t\t\t// treat array as children (potentially of the content node)\r\n\t\t\t\telement = element.contentNode || element\r\n\t\t\t\tlayoutChildren(element, content, element)\r\n\t\t\t} else {\r\n\t\t\t\t// render as string\r\n\t\t\t\telement.appendChild(variableAsContent(element, content))\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction bindChanges(element, variable, key, conversion) {\r\n\t\t\tlang.nextTurn(function() { // wait for next turn in case inputChanges isn't set yet\r\n\t\t\t\tvar inputEvents = element.inputEvents || ['change', 'alkali-change']\r\n\t\t\t\tfor (var i = 0, l = inputEvents.length; i < l; i++) {\r\n\t\t\t\t\telement.addEventListener(inputEvents[i], function (event) {\r\n\t\t\t\t\t\tvar value = element[key]\r\n\t\t\t\t\t\tnew Context(element).executeWithin(function() {\r\n\t\t\t\t\t\t\tvar result = variable.put(conversion ? conversion(value, element) : value)\r\n\t\t\t\t\t\t\tif (result === VariableExports.deny) {\r\n\t\t\t\t\t\t\t\tthrow new Error('Variable change denied')\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t}\r\n\t\r\n\t\tdoc.addEventListener('click', function(event) {\r\n\t\t\tvar target = event.target\r\n\t\t\tif (target.type === 'radio') {\r\n\t\t\t\tvar radios = doc.querySelectorAll('input[type=radio]')\r\n\t\t\t\tfor (var i = 0, l = radios.length; i < l; i++) {\r\n\t\t\t\t\tvar radio = radios[i]\r\n\t\t\t\t\tif (radio.name === target.name && radio !== target) {\r\n\t\t\t\t\t\tradio.dispatchEvent(new Event('alkali-change', {}))\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\tfunction conversion(value, element) {\r\n\t\t\tif (element.type == 'number') {\r\n\t\t\t\treturn parseFloat(value)\r\n\t\t\t}\r\n\t\t\treturn value\r\n\t\t}\r\n\t\r\n\t\tfunction buildInputContent(element, content) {\r\n\t\t\tvar inputType = element.type\r\n\t\t\tvar inputProperty = inputType in {date: 1, datetime: 1, time: 1} ?\r\n\t\t\t\t\t'valueAsDate' : (inputType === 'checkbox' || inputType === 'radio') ?\r\n\t\t\t\t\t\t'checked' : 'value'\r\n\t\r\n\t\t\tif (content && content.notifies) {\r\n\t\t\t\t// a variable, respond to changes\r\n\t\t\t\tnew InputPropertyRenderer({\r\n\t\t\t\t\tvariable: content,\r\n\t\t\t\t\tname: inputProperty,\r\n\t\t\t\t\telement: element\r\n\t\t\t\t})\r\n\t\t\t\t// and bind the other way as well, updating the variable in response to input changes\r\n\t\t\t\tbindChanges(element, content, inputProperty, conversion)\r\n\t\t\t} else {\r\n\t\t\t\t// primitive\r\n\t\t\t\telement[inputProperty] = content\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction mergeObject(Element, value, key, properties) {\r\n\t\t\tvar existing = properties[key]\r\n\t\t\tif (existing) {\r\n\t\t\t\tfor (var subKey in value) {\r\n\t\t\t\t\texisting[subKey] = value[subKey]\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tproperties[key] = value\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tvar classHandlers = {\r\n\t\t\tclasses: mergeObject,\r\n\t\t\t_generators: mergeObject,\r\n\t\t\tdataset: mergeObject,\r\n\t\t\tattributes: mergeObject,\r\n\t\t\tstyle: mergeObject,\r\n\t\t\thasOwn: function(Element, value) {\r\n\t\t\t\thasOwn(Element, value)\r\n\t\t\t},\r\n\t\t\tchildren: function(Element, value) {\r\n\t\t\t\tElement.children = value\r\n\t\t\t},\r\n\t\t\tshadow: function(Element, value) {\r\n\t\t\t\tElement.shadow = value\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction applyToConstructor(argument, Element) {\r\n\t\t\tvar applyOnCreate = Element._applyOnCreate\r\n\t\t\tif (argument && typeof argument === 'object') {\r\n\t\t\t\tif (argument instanceof Array || argument.notifies) {\r\n\t\t\t\t\tapplyOnCreate.content = argument\r\n\t\t\t\t} else {\r\n\t\t\t\t\tfor (var key in argument) {\r\n\t\t\t\t\t// TODO: eventually we want to be able to set these as rules statically per element\r\n\t\t\t\t\t/*if (styleDefinitions[key]) {\r\n\t\t\t\t\t\tvar styles = Element.styles || (Element.styles = [])\r\n\t\t\t\t\t\tstyles.push(key)\r\n\t\t\t\t\t\tstyles[key] = descriptor.value\r\n\t\t\t\t\t} else {*/\r\n\t\t\t\t\t\tvar value = argument[key]\r\n\t\t\t\t\t\tvar VariableClass = Element[key]\r\n\t\t\t\t\t\tif (typeof value === 'function') {\r\n\t\t\t\t\t\t\tif (value.notifies) {\r\n\t\t\t\t\t\t\t\tif (value === Variable) {\r\n\t\t\t\t\t\t\t\t\tvalue = Variable() // create a branded variable if we are using a generic one\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t// for Variable classes we make them statically available on the element\r\n\t\t\t\t\t\t\t\tElement[key] = value\r\n\t\t\t\t\t\t\t} else if (isGenerator(value)) {\r\n\t\t\t\t\t\t\t\tif (key.slice(0, 4) === 'get_') {\r\n\t\t\t\t\t\t\t\t\tkey = key.slice(4)\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t(applyOnCreate._generators || (applyOnCreate._generators = {}))[key] = value\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else if (value && value.notifies) {\r\n\t\t\t\t\t\t\t// also store any variables as statically available properties\r\n\t\t\t\t\t\t\tElement[key] = value\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (classHandlers[key]) { // Could eliminate this if we got rid of hasOwn\r\n\t\t\t\t\t\t\tclassHandlers[key](Element, value, key, applyOnCreate)\r\n\t\t\t\t\t\t} else if (typeof VariableClass === 'function' && VariableClass.notifies) {\r\n\t\t\t\t\t\t\tapplyOnCreate[key] = new VariableClass(value)\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tapplyOnCreate[key] = value\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else if (typeof argument === 'function' && !argument.for) {\r\n\t\t\t\tthrow new TypeError('Function as argument not supported')\r\n\t\t\t} else {\r\n\t\t\t\tapplyOnCreate.content = argument\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction getApplySet(Class) {\r\n\t\t\tif (Class.hasOwnProperty('_applyOnCreate')) {\r\n\t\t\t\treturn Class._applyOnCreate\r\n\t\t\t}\r\n\t\t\t// this means we didn't extend and evaluate the prototype yet\r\n\t\t\tif (Class.getForClass) {\r\n\t\t\t\t// we are extending an alkali constructor\r\n\t\t\t\t// if this class is inheriting from an alkali constructor, work our way up the chain\r\n\t\t\t\tvar applyOnCreate = Class._applyOnCreate = {}\r\n\t\t\t\tvar parentApplySet = getApplySet(getPrototypeOf(Class))\r\n\t\t\t\tfor (var key in parentApplySet) {\r\n\t\t\t\t\tapplyOnCreate[key] = classHandlers[key] ? Object.create(parentApplySet[key]) : parentApplySet[key]\r\n\t\t\t\t}\r\n\t\t\t\t// we need to check the prototype for event handlers\r\n\t\t\t\tvar prototype = Class.prototype\r\n\t\t\t\tvar propertyHandlers\r\n\t\t\t\tvar keys = Object.getOwnPropertyNames(prototype)\r\n\t\t\t\tfor (var i = 0, l = keys.length; i < l; i++) {\r\n\t\t\t\t\tvar key = keys[i]\r\n\t\t\t\t\tif (key.slice(0, 2) === 'on' || (key === 'render' && isGenerator(prototype[key]))) {\r\n\t\t\t\t\t\tapplyOnCreate[key] = prototype[key]\r\n\t\t\t\t\t} else if (key.slice(0, 6) === 'render') {\r\n\t\t\t\t\t\tvar propertyName = key[6].toLowerCase() + key.slice(7)\r\n\t\t\t\t\t\tif (!propertyHandlers) {\r\n\t\t\t\t\t\t\tpropertyHandlers = prototype._propertyHandlers = Object.create(prototype._propertyHandlers)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tpropertyHandlers[propertyName] = true // TODO: is it better to implement this with property handlers?\r\n\t\t\t\t\t\tObject.defineProperty(prototype, propertyName, renderDescriptor(key))\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn applyOnCreate\r\n\t\t\t}\r\n\t\t\treturn null\r\n\t\t}\r\n\t\r\n\t\tfunction renderDescriptor(renderMethod) {\r\n\t\t\tvar map = new lang.WeakMap()\r\n\t\t\treturn {\r\n\t\t\t\tget: function() {\r\n\t\t\t\t\treturn map.has(this) ? map.get(this) : null\r\n\t\t\t\t},\r\n\t\t\t\tset: function(value) {\r\n\t\t\t\t\tmap.set(this, value)\r\n\t\t\t\t\tthis[renderMethod](value)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction makeElementConstructor(BaseClass) {\r\n\t\t\tvar isNativeElement = !BaseClass.with // TODO: Create a separate constructor for this\r\n\t\t\t// this is an optimization to allow consecutive alkali constructors to bypass each other\r\n\t\t\tif (Object.setPrototypeOf) {\r\n\t\t\t\twhile (BaseClass.prototype.constructor !== BaseClass && !BaseClass.hasOwnProperty('with')) {\r\n\t\t\t\t\tBaseClass = getPrototypeOf(BaseClass)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tvar isNativeClass = Object.getOwnPropertyDescriptor(BaseClass, 'prototype').writable === false\r\n\t\t\treturn constructOrCall(BaseClass, isNativeElement && create, withProperties, isNativeClass)\r\n\t\t}\r\n\t\r\n\t\tfunction withProperties(selector, properties) {\r\n\t\t\tvar Element = makeElementConstructor(this)\r\n\t\t\tif (this.with) {\r\n\t\t\t\t// TODO: Might consider only doing this for derivatives of derivatives, since we don't need to inherit from base constructors\r\n\t\t\t\t// or only doing this in the case of element having custom properties (could mark it with a flag)\r\n\t\t\t\tsetPrototypeOf(Element, this)\r\n\t\t\t\tElement.ownedClasses = null\r\n\t\t\t} else {\r\n\t\t\t\tElement.create = create\r\n\t\t\t\tElement.with = withProperties\r\n\t\t\t\tElement.for = forTarget\r\n\t\t\t\tElement.property = propertyForElement\r\n\t\t\t\tElement.getForClass = getForClass\r\n\t\t\t}\r\n\t\t\tElement.prototype = this.prototype\r\n\t\r\n\t\t\tvar applyOnCreate = Element._applyOnCreate = {}\r\n\t\t\tvar parentApplySet = getApplySet(this)\r\n\t\t\t// copy parent properties\r\n\t\t\tfor (var key in parentApplySet) {\r\n\t\t\t\tapplyOnCreate[key] = classHandlers[key] ? Object.create(parentApplySet[key]) : parentApplySet[key]\r\n\t\t\t}\r\n\t\r\n\t\t\tvar i = 0 // for arguments\r\n\t\t\tif (typeof selector === 'string') {\r\n\t\t\t\tvar selectorMatch = selector.match(SELECTOR_REGEX)\r\n\t\t\t\tif (selectorMatch) {\r\n\t\t\t\t\tdo {\r\n\t\t\t\t\t\tvar operator = selectorMatch[1]\r\n\t\t\t\t\t\tvar name = selectorMatch[2]\r\n\t\t\t\t\t\tif (operator == '.') {\r\n\t\t\t\t\t\t\tif (applyOnCreate.className) {\r\n\t\t\t\t\t\t\t\tapplyOnCreate.className += ' ' + name\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tapplyOnCreate.className = name\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tapplyOnCreate.id = name\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar remaining = selectorMatch[3]\r\n\t\t\t\t\t\tselectorMatch = remaining && remaining.match(SELECTOR_REGEX)\r\n\t\t\t\t\t} while (selectorMatch)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tapplyOnCreate.content = selector\r\n\t\t\t\t}\r\n\t\t\t\ti++ // skip the first argument\r\n\t\t\t}\r\n\t\r\n\t\t\tfor (var l = arguments.length; i < l; i++) {\r\n\t\t\t\tapplyToConstructor(arguments[i], Element)\r\n\t\t\t}\r\n\t\t\treturn Element\r\n\t\t}\r\n\t\tvar currentParent\r\n\t\tfunction create(selector, properties) {\r\n\t\t\t// TODO: make this a symbol\r\n\t\t\tvar applyOnCreate = getApplySet(this)\r\n\t\t\tif (currentParent) {\r\n\t\t\t\tvar parent = currentParent\r\n\t\t\t\tcurrentParent = null\r\n\t\t\t}\r\n\t/*\t\tif (this._initialized != this) {\r\n\t\t\t\tthis._initialized = this\r\n\t\t\t\tthis.initialize && this.initialize()\r\n\t\t\t\tvar styles = this.styles\r\n\t\t\t\tif (styles) {\r\n\t\t\t\t\tvar rule = createCssRule(getUniqueSelector(this))\r\n\t\t\t\t\tfor (var i = 0, l = styles.length; i < l; i++) {\r\n\t\t\t\t\t\tvar key = styles[i]\r\n\t\t\t\t\t\tvar value = styles[key]\r\n\t\t\t\t\t\t// TODO: if it is a contextualized variable, do this on the element\r\n\t\t\t\t\t\tvar styleDefinition = styleDefinitions[key]\r\n\t\t\t\t\t\tif (styleDefinition) {\r\n\t\t\t\t\t\t\tstyleDefinition(rule, value, key)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (!this.hasOwnProperty('_applyOnCreate')) {\r\n\t\t\t\t\tapplyOnCreate = getApplySet(this)\r\n\t\t\t\t}\r\n\t\t\t}*/\r\n\t\t\tvar element = this._ElementClass ?\r\n\t\t\t\tconstruct(HTMLElement, arguments, this._ElementClass) : // does HTMLElement differ from any other constructors?\r\n\t\t\t\tdoc.createElement(this.tagName)\r\n\t\t\tif (selector && selector.parent) {\r\n\t\t\t\tparent = selector.parent\r\n\t\t\t}\r\n\t\t\tif (parent) {\r\n\t\t\t\tpresumptiveParentMap.set(element, parent)\r\n\t\t\t}\r\n\t\t\tif (!(element instanceof this)) {\r\n\t\t\t\t// ideally we want to avoid this call, as it is expensive, but for classes that\r\n\t\t\t\t// don't register a tag name, we have to make sure the prototype chain is correct\r\n\t\t\t\tsetPrototypeOf(element, this.prototype)\r\n\t\t\t}\r\n\t\t\tif (element.constructor != this) {\r\n\t\t\t\tif (buggyConstructorSetter) {\r\n\t\t\t\t\t// in safari, directly setting the constructor messes up the native prototype\r\n\t\t\t\t\tObject.defineProperty(element, 'constructor', { value: this })\r\n\t\t\t\t} else {\r\n\t\t\t\t\telement.constructor = this // need to do this for hasOwn contextualization to work\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (arguments.length > 0) {\r\n\t\t\t\t// copy applyOnCreate when we have arguments\r\n\t\t\t\tvar ElementApplyOnCreate = applyOnCreate\r\n\t\t\t\tapplyOnCreate = {}\r\n\t\t\t\tfor (var key in ElementApplyOnCreate) {\r\n\t\t\t\t\tapplyOnCreate[key] = classHandlers[key] ? Object.create(ElementApplyOnCreate[key]) : ElementApplyOnCreate[key]\r\n\t\t\t\t}\r\n\t\t\t\tvar i = 0\r\n\t\t\t\tif (typeof selector == 'string') {\r\n\t\t\t\t\ti++\r\n\t\t\t\t\tvar selectorMatch = selector.match(SELECTOR_REGEX)\r\n\t\t\t\t\tif (selectorMatch) {\r\n\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\tvar operator = selectorMatch[1]\r\n\t\t\t\t\t\t\tvar name = selectorMatch[2]\r\n\t\t\t\t\t\t\tif (operator == '.') {\r\n\t\t\t\t\t\t\t\tif (applyOnCreate.className) {\r\n\t\t\t\t\t\t\t\t\tapplyOnCreate.className += ' ' + name\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tif (element.className) {\r\n\t\t\t\t\t\t\t\t\t\t\telement.className += ' ' + name\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\telement.className = name\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tif (applyOnCreate.id) {\r\n\t\t\t\t\t\t\t\t\tapplyOnCreate.id = name\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t// just skip right to the element\r\n\t\t\t\t\t\t\t\t\telement.id = name\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tvar remaining = selectorMatch[3]\r\n\t\t\t\t\t\t\tselectorMatch = remaining && remaining.match(SELECTOR_REGEX)\r\n\t\t\t\t\t\t} while (selectorMatch)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tapplyOnCreate.content = selector\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (selector && selector._item) {\r\n\t\t\t\t\t// this is kind of hack, to get the Item available before the properties, eventually we may want to\r\n\t\t\t\t\t// order static properties before variable binding applications, but for now.\r\n\t\t\t\t\telement._item = selector._item\r\n\t\t\t\t}\r\n\t\t\t\tfor (var l = arguments.length; i < l; i++) {\r\n\t\t\t\t\tvar argument = arguments[i]\r\n\t\t\t\t\tif (argument && typeof argument === 'object') {\r\n\t\t\t\t\t\tif (argument instanceof Array || argument.notifies) {\r\n\t\t\t\t\t\t\tapplyOnCreate.content = argument\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tfor (var key in argument) {\r\n\t\t\t\t\t\t\t\tif (classHandlers[key]) {\r\n\t\t\t\t\t\t\t\t\tclassHandlers[key](this, argument[key], key, applyOnCreate)\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tapplyOnCreate[key] = argument[key]\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (typeof argument === 'function' && argument.for) {\r\n\t\t\t\t\t\tapplyOnCreate.content = argument.for(element)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tapplyOnCreate.content = argument\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (element.created) {\r\n\t\t\t\tapplyOnCreate = element.created(applyOnCreate) || applyOnCreate\r\n\t\t\t} else if (applyOnCreate.created) {\r\n\t\t\t\tapplyOnCreate = applyOnCreate.created.call(element, applyOnCreate) || applyOnCreate\r\n\t\t\t}\r\n\t\t\t// TODO: inline this for better performance, possibly\r\n\t\t\tassignProperties(element, applyOnCreate)\r\n\t\r\n\t\t\tif (applyOnCreate._generators) {\r\n\t\t\t\tassignGenerators(element, applyOnCreate)\r\n\t\t\t}\r\n\t\r\n\t\t\tif (this.children) {\r\n\t\t\t\tlayoutChildren(element, this.children, element)\r\n\t\t\t}\r\n\t\t\tif (this.shadow) {\r\n\t\t\t\tlayoutChildren(element.attachShadow({mode: 'open'}), this.shadow, element)\r\n\t\t\t}\r\n\t\t\t// always do this last, so it can be properly inserted inside the children\r\n\t\t\tif (element.content != null) {\r\n\t\t\t\tbuildContent(element, element.content, 'content', applyOnCreate)\r\n\t\t\t}\r\n\t\t\telement.ready && element.ready(applyOnCreate)\r\n\t\t\treturn element\r\n\t\t}\r\n\t\r\n\t\tvar slice = [].slice\r\n\t\tfunction append(parent){\r\n\t\t\treturn this.nodeType ?\r\n\t\t\t\tlayoutChildren(this, arguments, this) : // called as a method\r\n\t\t\t\tlayoutChildren(parent, slice.call(arguments, 1), parent) // called as a function\r\n\t\t}\r\n\t\r\n\t\tfunction prepend(parent){\r\n\t\t\treturn this.nodeType ?\r\n\t\t\t\tlayoutChildren(this, arguments, this, true) : // called as a method\r\n\t\t\t\tlayoutChildren(parent, slice.call(arguments, 1), parent, true) // called as a function\r\n\t\t}\r\n\t\r\n\t\tfunction defineElement(tagSelector, Element) {\r\n\t\t\tif (!Element) {\r\n\t\t\t\t// allow optional first param\r\n\t\t\t\treturn tagSelector.with()\r\n\t\t\t}\r\n\t\t\tvar extendElement = Element.tagName\r\n\t\t\tvar selector = tagSelector.match(/[\\.\\#].+/)\r\n\t\t\tvar tagName = selector ? tagSelector.slice(0, tagSelector.length - (selector = selector[0]).length) : tagSelector\r\n\t\t\tElement.tagName = tagName\r\n\t\t\tif (typeof customElements === 'object') {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tif (Element._ElementClass = customElements.get(tagName)) {\r\n\t\t\t\t\t\tconsole.warn('Element', tagName, 'already registered')\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tcustomElements.define(tagName, Element, { extends: extendElement })\r\n\t\t\t\t\t\tElement._ElementClass = Element\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch(error) {\r\n\t\t\t\t\tconsole.warn(error)\r\n\t\t\t\t}\r\n\t\t\t} else if (extendElement && extendElement != 'div' && extendElement != 'span') {\r\n\t\t\t\tconsole.warn('This browser does not support customized built-in elements, make sure to only extend Element, Div, or Span')\r\n\t\t\t}\r\n\t\t\tif (!Element.with) {\r\n\t\t\t\tElement.with = withProperties\r\n\t\t\t}\r\n\t\t\treturn selector ? Element.with(selector) : Element.with()\r\n\t\t}\r\n\t\r\n\t\tvar Element = setupElement(typeof HTMLElement !== 'undefined' ? HTMLElement : function() {})\r\n\t\r\n\t\tElement.defineElement = defineElement\r\n\t\tElement.assign = function(target, properties) {\r\n\t\t\tif (typeof target === 'function') {\r\n\t\t\t\t// assign properties to an existing constructor/class\r\n\t\t\t\tgetApplySet(target) // make sure we have our own applyOnCreate first\r\n\t\t\t\tapplyToConstructor(properties, target)\r\n\t\t\t} else {\r\n\t\t\t\t// assign to an element\r\n\t\t\t\t// TODO: Handle content property separately\r\n\t\t\t\treturn assignProperties(target, properties)\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tElement.within = function(element){\r\n\t\t\t// find closest child\r\n\t\t}\r\n\t\r\n\t\tgenerate([\r\n\t\t\t'Video',\r\n\t\t\t'Source',\r\n\t\t\t'Media',\r\n\t\t\t'Audio',\r\n\t\t\t'UL',\r\n\t\t\t'U',\r\n\t\t\t'Track',\r\n\t\t\t'Title',\r\n\t\t\t'TextArea',\r\n\t\t\t'Template',\r\n\t\t\t'TBody',\r\n\t\t\t'THead',\r\n\t\t\t'TFoot',\r\n\t\t\t'TR',\r\n\t\t\t'Table',\r\n\t\t\t'Col',\r\n\t\t\t'ColGroup',\r\n\t\t\t'TH',\r\n\t\t\t'TD',\r\n\t\t\t'Caption',\r\n\t\t\t'Sup',\r\n\t\t\t'Sub',\r\n\t\t\t'Style',\r\n\t\t\t'Strong',\r\n\t\t\t'Span',\r\n\t\t\t'Small',\r\n\t\t\t'Shadow',\r\n\t\t\t'Select',\r\n\t\t\t'Script',\r\n\t\t\t'S',\r\n\t\t\t'Quote',\r\n\t\t\t'Progress',\r\n\t\t\t'Pre',\r\n\t\t\t'Picture',\r\n\t\t\t'Param',\r\n\t\t\t'P',\r\n\t\t\t'Output',\r\n\t\t\t'Option',\r\n\t\t\t'Optgroup',\r\n\t\t\t'Object',\r\n\t\t\t'OL',\r\n\t\t\t'Ins',\r\n\t\t\t'I',\r\n\t\t\t'Del',\r\n\t\t\t'Meter',\r\n\t\t\t'Meta',\r\n\t\t\t'Menu',\r\n\t\t\t'Map',\r\n\t\t\t'Link',\r\n\t\t\t'Legend',\r\n\t\t\t'Label',\r\n\t\t\t'LI',\r\n\t\t\t'KeyGen',\r\n\t\t\t'Input',\r\n\t\t\t'Img',\r\n\t\t\t'IFrame',\r\n\t\t\t'H1',\r\n\t\t\t'H2',\r\n\t\t\t'H3',\r\n\t\t\t'H4',\r\n\t\t\t'H5',\r\n\t\t\t'H6',\r\n\t\t\t'Hr',\r\n\t\t\t'FrameSet',\r\n\t\t\t'Frame',\r\n\t\t\t'Form',\r\n\t\t\t'Font',\r\n\t\t\t'Embed',\r\n\t\t\t'Em',\r\n\t\t\t'Code',\r\n\t\t\t'Cite',\r\n\t\t\t'Dfn',\r\n\t\t\t'B',\r\n\t\t\t'Article',\r\n\t\t\t'Aside',\r\n\t\t\t'Abbr',\r\n\t\t\t'Footer',\r\n\t\t\t'Figure',\r\n\t\t\t'FigCaption',\r\n\t\t\t'Header',\r\n\t\t\t'Main',\r\n\t\t\t'Mark',\r\n\t\t\t'MenuItem',\r\n\t\t\t'Nav',\r\n\t\t\t'Section',\r\n\t\t\t'Slot',\r\n\t\t\t'Summary',\r\n\t\t\t'WBr',\r\n\t\t\t'Div',\r\n\t\t\t'Dialog',\r\n\t\t\t'Details',\r\n\t\t\t'DataList',\r\n\t\t\t'DL',\r\n\t\t\t'Canvas',\r\n\t\t\t'Button',\r\n\t\t\t'Base',\r\n\t\t\t'Br',\r\n\t\t\t'Area',\r\n\t\t\t'A'\r\n\t\t])\r\n\t\tgenerateInputs([\r\n\t\t\t'Checkbox',\r\n\t\t\t'Password',\r\n\t\t\t'Submit',\r\n\t\t\t'Radio',\r\n\t\t\t'Color',\r\n\t\t\t'Date',\r\n\t\t\t'DateTime',\r\n\t\t\t'Email',\r\n\t\t\t'Month',\r\n\t\t\t'Number',\r\n\t\t\t'Range',\r\n\t\t\t'Search',\r\n\t\t\t'Tel',\r\n\t\t\t'Time',\r\n\t\t\t'Url',\r\n\t\t\t'Week'])\r\n\t\r\n\t\tvar tags = {}\r\n\t\tfunction getConstructor(tagName) {\r\n\t\t\ttagName = tagName.toLowerCase()\r\n\t\t\treturn tags[tagName] ||\r\n\t\t\t\t(tags[tagName] =\r\n\t\t\t\t\tsetupElement(doc.createElement(tagName).constructor, tagName))\r\n\t\t}\r\n\t\r\n\t\tfunction setupElement(HTMLConstructor, tagName, type) {\r\n\t\t\tvar Element = type ?\r\n\t\t\t\twithProperties.call(HTMLConstructor, { type: type }) :\r\n\t\t\t\twithProperties.call(HTMLConstructor)\r\n\t\t\tvar props = elementPropertyHandlers[tagName]\r\n\t\t\tif (props && !props.assigned) {\r\n\t\t\t\tvar handlers = Element.prototype._propertyHandlers = Object.create(propertyHandlers)\r\n\t\t\t\tfor (var i = 0, l = props.length; i < l; i++) {\r\n\t\t\t\t\thandlers[props[i]] = true\r\n\t\t\t\t}\r\n\t\t\t\tif (props.value) {\r\n\t\t\t\t\tfor (var i in props) {\r\n\t\t\t\t\t\tif (!(i > -1)) { // assign any string properties if necessary\r\n\t\t\t\t\t\t\thandlers[i] = props[i]\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tprops.assigned = true\r\n\t\t\t}\r\n\t\t\tElement.tagName = tagName\r\n\t\t\t// once https://bugs.chromium.org/p/chromium/issues/detail?id=648828&desc=4 is implemented we can do:\r\n\t\t\t// Element._HTMLConstructor = HTMLConstructor\r\n\t\t\treturn Element\r\n\t\t}\r\n\t\tfunction generate(elements) {\r\n\t\t\telements.forEach(function(elementName) {\r\n\t\t\t\tvar ElementClass\r\n\t\t\t\tObject.defineProperty(Element, elementName, {\r\n\t\t\t\t\tget: function() {\r\n\t\t\t\t\t\treturn ElementClass || (ElementClass = getConstructor(elementName))\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t})\r\n\t\t}\r\n\t\tfunction generateInputs(elements) {\r\n\t\t\telements.forEach(function(inputType) {\r\n\t\t\t\tvar ElementClass\r\n\t\t\t\tObject.defineProperty(Element, inputType, {\r\n\t\t\t\t\tget: function() {\r\n\t\t\t\t\t\t// TODO: make all inputs extend from input generated from generate\r\n\t\t\t\t\t\treturn ElementClass || (ElementClass = setupElement(HTMLInputElement, 'input', inputType.toLowerCase()))\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t\t// alias all the inputs with an Input suffix\r\n\t\t\t\tObject.defineProperty(Element, inputType + 'Input', {\r\n\t\t\t\t\tget: function() {\r\n\t\t\t\t\t\treturn this[inputType]\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t})\r\n\t\t}\r\n\t\r\n\t\tvar aliases = {\r\n\t\t\tAnchor: 'A',\r\n\t\t\tImage: 'Img',\r\n\t\t\tParagraph: 'P',\r\n\t\t\tTextarea: 'TextArea',\r\n\t\t\tDList: 'DL',\r\n\t\t\tUList: 'UL',\r\n\t\t\tOList: 'OL',\r\n\t\t\tListItem: 'LI',\r\n\t\t\tText: 'Input',\r\n\t\t\tTextInput: 'Input',\r\n\t\t\tTableRow: 'TR',\r\n\t\t\tTableCell: 'TD',\r\n\t\t\tTableHeaderCell: 'TH',\r\n\t\t\tTableHeader: 'THead',\r\n\t\t\tTableBody: 'TBody'\r\n\t\t}\r\n\t\tfor (var alias in aliases) {\r\n\t\t\t(function(alias, to) {\r\n\t\t\t\tObject.defineProperty(Element, alias, {\r\n\t\t\t\t\tget: function() {\r\n\t\t\t\t\t\treturn this[to]\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t})(alias, aliases[alias])\r\n\t\t}\r\n\t\r\n\t\tElement.append = append\r\n\t\tRenderer.append = append // make it available to the renderer\r\n\t\tElement.prepend = prepend\r\n\t\tElement.refresh = Renderer.refresh\r\n\t\tElement.options = {\r\n\t\t\tmoveLiveElementsEnabled: true,\r\n\t\t}\r\n\t\tElement.content = function(Element){\r\n\t\t\t// container marker\r\n\t\t\tfunction Content() {\r\n\t\t\t\treturn new Element()\r\n\t\t\t}\r\n\t\t\tContent.isContentNode = true\r\n\t\t\treturn Content\r\n\t\t}\r\n\t\r\n\t\tElement.ElementClass = function() {}\r\n\t\tif (typeof Symbol !== 'undefined') {\r\n\t\t\t// make instanceof work for Element\r\n\t\t\tObject.defineProperty(Element.ElementClass, Symbol.hasInstance, { value: function(target) {\r\n\t\t\t\treturn target && (target.create && target.with)\r\n\t\t\t}})\r\n\t\t}\r\n\t\r\n\t\t// TODO: unify this in lang\r\n\t\tElement.extend = function(Class, properties) {\r\n\t\t\tfunction ExtendedElement() {\r\n\t\t\t\treturn Class.apply(this, arguments)\r\n\t\t\t}\r\n\t\t\tsetPrototypeOf(ExtendedElement, Class)\r\n\t\t\tvar prototype = ExtendedElement.prototype = Object.create(Class.prototype, {\r\n\t\t\t\tconstructor: { value: ExtendedElement }\r\n\t\t\t})\r\n\t\t\tObject.getOwnPropertyNames(properties).forEach(function(key) {\r\n\t\t\t\tvar descriptor = Object.getOwnPropertyDescriptor(properties, key)\r\n\t\t\t\tif (classHandlers[key]) {\r\n\t\t\t\t\tclassHandlers[key](ExtendedElement, descriptor.value, key, properties)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tObject.defineProperty(prototype, key, descriptor)\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\treturn ExtendedElement\r\n\t\t}\r\n\t\r\n\t\tfunction forTarget(target) {\r\n\t\t\treturn target.constructor.getForClass(target, this)\r\n\t\t}\r\n\t\r\n\t\tfunction hasOwn(From, Target, createInstance) {\r\n\t\t\tif (typeof Target === 'object') {\r\n\t\t\t\t// we were given an actual instance, use that\r\n\t\t\t\tvar elementMap = From.ownedClasses || (From.ownedClasses = new lang.WeakMap())\r\n\t\t\t\tvar instanceMap = {get: function () {\r\n\t\t\t\t\treturn Target\r\n\t\t\t\t}}\r\n\t\t\t\telementMap.set(Target.constructor, instanceMap)\r\n\t\t\t\treturn hasOwn(From, Target.Class, Target.createInstance)\r\n\t\t\t}\r\n\t\t\tif (Target instanceof Array) {\r\n\t\t\t\treturn Target.forEach(function(Target) {\r\n\t\t\t\t\thasOwn(From, Target)\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tvar elementMap = From.ownedClasses || (From.ownedClasses = new lang.WeakMap())\r\n\t\t\t// TODO: Go up through prototype chain of Target and set each one\r\n\t\t\tif (!elementMap.has(Target)) {\r\n\t\t\t\tvar instanceMap = new lang.WeakMap()\r\n\t\t\t\tinstanceMap.createInstance = createInstance\r\n\t\t\t\telementMap.set(Target, instanceMap)\r\n\t\t\t}\r\n\t\t\treturn From\r\n\t\t}\r\n\t\r\n\t\tfunction getForClass(element, Target) {\r\n\t\t\tvar createInstance\r\n\t\t\twhile (element && !(createInstance = element.constructor.ownedClasses && element.constructor.ownedClasses.get(Target))) {\r\n\t\t\t\telement = element.parentNode || presumptiveParentMap.get(element)\r\n\t\t\t}\r\n\t\t\tif (createInstance) {\r\n\t\t\t\tvar ownedInstances = element.ownedInstances || (element.ownedInstances = new lang.WeakMap())\r\n\t\t\t\tvar instance = ownedInstances.get(Target)\r\n\t\t\t\tif (instance === undefined) {\r\n\t\t\t\t\townedInstances.set(Target, instance = createInstance(element))\r\n\t\t\t\t\tinstance.subject = element\r\n\t\t\t\t}\r\n\t\t\t\treturn instance\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction propertyForElement(key) {\r\n\t\t\t// we just need to establish one Variable class for each element, so we cache it\r\n\t\t\tThisElementVariable = this._Variable\r\n\t\t\tif (!ThisElementVariable) {\r\n\t\t\t\t// need our own branded variable class for this element class\r\n\t\t\t\tThisElementVariable = this._Variable = Variable()\r\n\t\r\n\t\t\t\thasOwn(this, ThisElementVariable, function(element) {\r\n\t\t\t\t\t// TODO: we might want to do this in init instead\r\n\t\t\t\t\tvar elementOverlay\r\n\t\t\t\t\tif (element.alkaliRenderers) {\r\n\t\t\t\t\t\tvar variableProperties = {}\r\n\t\t\t\t\t\tfor (var i = 0; i < element.alkaliRenderers.length; i++){\r\n\t\t\t\t\t\t\tvar renderer = element.alkaliRenderers[i]\r\n\t\t\t\t\t\t\tif (renderer.name) {\r\n\t\t\t\t\t\t\t\tvariableProperties[renderer.name] = {value: renderer.variable}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telementOverlay = Object.create(element, variableProperties)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\telementOverlay = element\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar instance = new ThisElementVariable(elementOverlay)\r\n\t\t\t\t\t// we are not observing, because you can't delegate getters and setters in safari\r\n\t\t\t\t\t// instance.observeObject()\r\n\t\t\t\t\treturn instance\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\t// now actually get the property class\r\n\t\t\treturn ThisElementVariable.property(key)\r\n\t\t}\r\n\t\r\n\t\tvar Item = Element.Item = VariableExports.Item\r\n\t\r\n\t\tfunction enterRenderer(Renderer, options/*, target*/) {\r\n\t\t\t// this will be used for optimized class-level variables\r\n\t\t\t/*if (target.started) { // TODO: Might want to pass in started as a parameter\r\n\t\t\t\t// this means that the renderer has already been created, so we just need to add this instance\r\n\t\t\t\tRenderer.prototype.renderUpdate.call(options, element)\r\n\t\t\t} else {*/\r\n\t\t\tnew Renderer(options)\r\n\t\t\t//}\r\n\t\t}\r\n\t\r\n\t\tfunction cleanup(target) {\r\n\t\t\tvar renderers = target.alkaliRenderers\r\n\t\t\tif (renderers) {\r\n\t\t\t\tfor (var i = 0, l = renderers.length; i < l; i++) {\r\n\t\t\t\t\trenderers[i].stop()\r\n\t\t\t\t}\r\n\t\t\t\ttarget.needsRestart = true\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction restart(target) {\r\n\t\t\tvar renderers = target.alkaliRenderers\r\n\t\t\tif (renderers) {\r\n\t\t\t\tfor (var i = 0, l = renderers.length; i < l; i++) {\r\n\t//\t\t\t\tupdaters[i].start()\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t// setup the mutation observer so we can be notified of attachments and removals\r\n\t\tfunction elementAttached(element) {\r\n\t\t\tvar Class = element.constructor\r\n\t\t\tif (Class.create) {\r\n\t/*\t\t\tif (Class.attachedInstances) {\r\n\t\t\t\t\tClass.attachedInstances.push(element)\r\n\t\t\t\t\tif (Class.attachedInstances.length === 1 && Class.needsRestart) {\r\n\t\t\t\t\t\trestart(Class)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tClass.attachedInstances = [element]\r\n\t\t\t\t}*/\r\n\t\t\t\tif (element.attached) {\r\n\t\t\t\t\telement.attached()\r\n\t\t\t\t}\r\n\t\t\t\tif (element.needsRestart) {\r\n\t\t\t\t\trestart(element)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction elementDetached(element) {\r\n\t\t\t/*var attachedInstances = element.constructor.attachedInstances\r\n\t\t\tif (attachedInstances) {\r\n\t\t\t\tvar index = attachedInstances.indexOf(element)\r\n\t\t\t\tif (index > -1) {\r\n\t\t\t\t\tattachedInstances.splice(index, 1)\r\n\t\t\t\t\tif (attachedInstances.length === 0) {\r\n\t\t\t\t\t\tcleanup(Class)\r\n\t\t\t\t\t}\r\n\t\t\t\t}*/\r\n\t\t\t\tif (element.detached) {\r\n\t\t\t\t\telement.detached()\r\n\t\t\t\t}\r\n\t\t\t\tcleanup(element)\r\n\t\t\t//}\r\n\t\t}\r\n\t\tif (typeof MutationObserver === 'function') {\r\n\t\t\tvar lifeStates = [{\r\n\t\t\t\tname: 'detached',\r\n\t\t\t\tnodes: 'removedNodes',\r\n\t\t\t\taction: elementDetached\r\n\t\t\t}, {\r\n\t\t\t\tname: 'attached',\r\n\t\t\t\tnodes: 'addedNodes',\r\n\t\t\t\taction: elementAttached\r\n\t\t\t}]\r\n\t\t\tfunction firstVisit(node, state) {\r\n\t\t\t\tif (state.name === 'attached') {\r\n\t\t\t\t\tif (node.__alkaliAttached__) {\r\n\t\t\t\t\t\treturn false\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tnode.__alkaliAttached__ = true\r\n\t\t\t\t\t\tstate.action(node)\r\n\t\t\t\t\t\treturn true\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (node.__alkaliAttached__) {\r\n\t\t\t\t\tif (doc.body.contains(node)) {\r\n\t\t\t\t\t\t// detached event, but it is actually still attached (will get attached in a later mutation record)\r\n\t\t\t\t\t\t// so don't get through the detached/attached lifecycle\r\n\t\t\t\t\t\treturn false\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnode.__alkaliAttached__ = false\r\n\t\t\t\t\tstate.action(node)\r\n\t\t\t\t}\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\t\t\tvar observer = new MutationObserver(function(mutations) {\r\n\t\t\t\tfor (var i = 0, il = mutations.length; i < il; i++) {\r\n\t\t\t\t\tvar mutation = mutations[i]\r\n\t\t\t\t\t// invoke action on element if we haven't already\r\n\t\t\t\t\tactionIteration:\r\n\t\t\t\t\tfor (var j = 0, jl = lifeStates.length; j < jl; j++) { // two steps, removed nodes and added nodes\r\n\t\t\t\t\t\tvar state = lifeStates[j]\r\n\t\t\t\t\t\tvar nodes = mutation[state.nodes]\r\n\t\t\t\t\t\t// iterate over node list\r\n\t\t\t\t\t\tnodeIteration:\r\n\t\t\t\t\t\tfor (var k = 0, kl = nodes.length; k < kl; k++) {\r\n\t\t\t\t\t\t\tvar baseNode = nodes[k]\r\n\t\t\t\t\t\t\tif (firstVisit(baseNode, state)) {\r\n\t\t\t\t\t\t\t\t// start traversal with child, if it exists\r\n\t\t\t\t\t\t\t\tvar currentNode = baseNode.firstChild\r\n\t\t\t\t\t\t\t\tif (currentNode) {\r\n\t\t\t\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\t\t\t\tvar nextNode\r\n\t\t\t\t\t\t\t\t\t\tif (currentNode.nodeType === 1 && firstVisit(currentNode, state)) {\r\n\t\t\t\t\t\t\t\t\t\t\t// depth-first search\r\n\t\t\t\t\t\t\t\t\t\t\tnextNode = currentNode.firstChild\r\n\t\t\t\t\t\t\t\t\t\t\tif (!nextNode) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tnextNode = currentNode.nextSibling\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\tnextNode = currentNode.nextSibling\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tif (!nextNode) {\r\n\t\t\t\t\t\t\t\t\t\t\t// come back out to parents\r\n\t\t\t\t\t\t\t\t\t\t\t// TODO: try keeping a stack to make this faster\r\n\t\t\t\t\t\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentNode = currentNode.parentNode\r\n\t\t\t\t\t\t\t\t\t\t\t\tif (currentNode === baseNode) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tcontinue nodeIteration\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t} while (!(nextNode = currentNode.nextSibling))\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tcurrentNode = nextNode\r\n\t\t\t\t\t\t\t\t\t} while (true)\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// if (options.moveLiveElementsEnabled) {\r\n\t\t\t\t\t\t\t// TODO: any options that we can really do here?\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\tobserver.observe(doc.body || doc, {\r\n\t\t\t\tchildList: true,\r\n\t\t\t\tsubtree: true\r\n\t\t\t})\r\n\t\t}\r\n\t\r\n\t\tlang.copy(VariableExports.Context.prototype, {\r\n\t\t\tspecify: function(Variable) {\r\n\t\t\t\tvar element = this.subject\r\n\t\t\t\tvar distinctive = true\r\n\t\t\t\t;(this.generics || (this.generics = [])).push(Variable)\r\n\t\t\t\tdo {\r\n\t\t\t\t\tif (this.distinctSubject === element) {\r\n\t\t\t\t\t\tdistinctive = false\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar subjectMap = element.constructor.ownedClasses\r\n\t\t\t\t\tif (subjectMap) {\r\n\t\t\t\t\t\tvar instanceMap = subjectMap.get(Variable)\r\n\t\t\t\t\t\tif (instanceMap) {\r\n\t\t\t\t\t\t\tif (distinctive) {\r\n\t\t\t\t\t\t\t\tthis.distinctSubject = element\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tspecifiedInstance = instanceMap.get(element)\r\n\t\t\t\t\t\t\tif (!specifiedInstance) {\r\n\t\t\t\t\t\t\t\tinstanceMap.set(element, specifiedInstance = instanceMap.createInstance ?\r\n\t\t\t\t\t\t\t\t\tinstanceMap.createInstance(element) : new Variable())\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn specifiedInstance\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} while ((element = element.parentNode || presumptiveParentMap.get(element)))\r\n\t\t\t\t// else if no specific context is found, return default instance\r\n\t\t\t\treturn Variable.defaultInstance\r\n\t\t\t},\r\n\t\r\n\t\t\tgetContextualized: function(variable) {\r\n\t\t\t\t// returns a variable that has already been contextualized\r\n\t\t\t\tvar element = this.subject\r\n\t\t\t\tif (!element) {\r\n\t\t\t\t\t// no element, just use the default variable\r\n\t\t\t\t\treturn variable\r\n\t\t\t\t}\r\n\t\t\t\tif (variable._contextMap) {\r\n\t\t\t\t\tdo {\r\n\t\t\t\t\t\tvar instance = variable._contextMap.get(element)\r\n\t\t\t\t\t\tif (instance && instance.context.matches(element)) {\r\n\t\t\t\t\t\t\treturn instance\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} while ((element = element.parentNode || presumptiveParentMap.get(element)))\r\n\t\t\t\t}\r\n\t\t\t\tif (variable.context && variable.context.matches(this.subject)) {\r\n\t\t\t\t\t// check if the default variable is allowed\r\n\t\t\t\t\treturn variable\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\r\n\t\t\tmerge: function(childContext) {\r\n\t\t\t\tif (!this.distinctSubject ||\r\n\t\t\t\t\t\t(this.distinctSubject !== childContext.distinctSubject && this.distinctSubject.contains(childContext.distinctSubject))) {\r\n\t\t\t\t\tthis.distinctSubject = childContext.distinctSubject\r\n\t\t\t\t}\r\n\t\t\t\t[].push.apply(this.generics || (this.generics = []), childContext.generics)\r\n\t\t\t},\r\n\t\t\tgetDistinctElement: function(Variable, element) {\r\n\t\t\t\tdo {\r\n\t\t\t\t\tvar subjectMap = element.constructor.ownedClasses\r\n\t\t\t\t\tif (subjectMap) {\r\n\t\t\t\t\t\tvar instanceMap = subjectMap.get(Variable)\r\n\t\t\t\t\t\tif (instanceMap && instanceMap.has(element)) {\r\n\t\t\t\t\t\t\treturn element\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} while ((element = element.parentNode || presumptiveParentMap.get(element)))\r\n\t\t\t},\r\n\t\t\tmatches: function(element) {\r\n\t\t\t\tvar generics = this.generics\r\n\t\t\t\tif (generics) {\r\n\t\t\t\t\tfor (var i = 0, l = generics.length; i < l; i++) {\r\n\t\t\t\t\t\tif (this.getDistinctElement(generics[i], element) !== this.distinctSubject) {\r\n\t\t\t\t\t\t\treturn false\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\treturn Element\r\n\t}))\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) { if (true) {\r\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) } else if (typeof module === 'object' && module.exports) {\t\t\t\t\r\n\t\tmodule.exports = factory() // Node\r\n\t}}(this, function () {\r\n\t\tvar getPrototypeOf = Object.getPrototypeOf || (function(base) { return base.__proto__ })\r\n\t\tvar setPrototypeOf = Object.setPrototypeOf || (function(base, proto) {\r\n\t\t\tfor (var key in proto) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tif (!base.hasOwnProperty(key)) {\r\n\t\t\t\t\t\tif (proto.hasOwnProperty(key)) {\r\n\t\t\t\t\t\t\tObject.defineProperty(base, key, \r\n\t\t\t\t\t\t\t\tObject.getOwnPropertyDescriptor(proto, key))\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tbase[key] = proto[key]\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch(error) {}\r\n\t\t\t}\r\n\t\t})\r\n\t\tvar hasFeatures = {\r\n\t\t\trequestAnimationFrame: typeof requestAnimationFrame != 'undefined',\r\n\t\t\tdefineProperty: Object.defineProperty && (function() {\r\n\t\t\t\ttry{\r\n\t\t\t\t\tObject.defineProperty({}, 't', {})\r\n\t\t\t\t\treturn true\r\n\t\t\t\t}catch(e) {\r\n\t\t\t\t}\r\n\t\t\t})(),\r\n\t\t\tpromise: typeof Promise !== 'undefined',\r\n\t\t\tMutationObserver: typeof MutationObserver !== 'undefined',\r\n\t\t\t'WeakMap': typeof WeakMap === 'function'\r\n\t\t}\r\n\t\tfunction has(feature) {\r\n\t\t\treturn hasFeatures[feature]\r\n\t\t}\r\n\t\r\n\t\tfunction SyncPromise(value) {\r\n\t\t\tthis.value = value\r\n\t\t}\r\n\t\tSyncPromise.prototype = {\r\n\t\t\tthen: function(onFulfilled, onRejected) {\r\n\t\t\t\tif (!onFulfilled) {\r\n\t\t\t\t\treturn new SyncPromise(this.value)\r\n\t\t\t\t}\r\n\t\t\t\ttry {\r\n\t\t\t\t\tvar result = onFulfilled(this.value)\r\n\t\t\t\t\treturn (result && result.then) ? result : new SyncPromise(result)\r\n\t\t\t\t} catch(error) {\r\n\t\t\t\t\treturn new SyncErrorPromise(error)\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tcatch: function(handler) {\r\n\t\t\t\treturn this.then(null, handler)\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction SyncErrorPromise(error) {\r\n\t\t\tthis.value = error\r\n\t\t\tthis.unhandledTimeout = setTimeout(function() {\r\n\t\t\t\tconsole.error('Uncaught (in promise)', error)\r\n\t\t\t})\r\n\t\t}\r\n\t\tSyncErrorPromise.prototype = new SyncPromise()\r\n\t\tSyncErrorPromise.prototype.then = function(onFulfilled, onRejected) {\r\n\t\t\tclearTimeout(this.unhandledTimeout)\r\n\t\t\tif (!onRejected) {\r\n\t\t\t\treturn new SyncErrorPromise(this.value)\r\n\t\t\t}\r\n\t\t\treturn SyncPromise.prototype.then.call(this, onRejected)\r\n\t\t}\r\n\t\t// This is an polyfill for Object.observe with just enough functionality\r\n\t\t// for what Variables need\r\n\t\t// An observe function, with polyfile\r\n\t\tvar observe =\r\n\t\t\thas('defineProperty') ? \r\n\t\t\tfunction observe(target, listener) {\r\n\t\t\t\t/*for(var i in target) {\r\n\t\t\t\t\taddKey(i)\r\n\t\t\t\t}*/\r\n\t\t\t\tlistener.addKey = addKey\r\n\t\t\t\tlistener.remove = function() {\r\n\t\t\t\t\tlistener = null\r\n\t\t\t\t}\r\n\t\t\t\treturn listener\r\n\t\t\t\tfunction addKey(key) {\r\n\t\t\t\t\tvar keyFlag = 'key' + key\r\n\t\t\t\t\tif(this[keyFlag]) {\r\n\t\t\t\t\t\treturn\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tthis[keyFlag] = true\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar currentValue = target[key]\r\n\t\t\t\t\tvar targetAncestor = target\r\n\t\t\t\t\tvar descriptor\r\n\t\t\t\t\tdo {\r\n\t\t\t\t\t\tdescriptor = Object.getOwnPropertyDescriptor(targetAncestor, key)\r\n\t\t\t\t\t} while(!descriptor && (targetAncestor = getPrototypeOf(targetAncestor)))\r\n\t\r\n\t\t\t\t\tif(descriptor && descriptor.set) {\r\n\t\t\t\t\t\tvar previousSet = descriptor.set\r\n\t\t\t\t\t\tvar previousGet = descriptor.get\r\n\t\t\t\t\t\tObject.defineProperty(target, key, {\r\n\t\t\t\t\t\t\tget: function() {\r\n\t\t\t\t\t\t\t\treturn (currentValue = previousGet.call(this))\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\tset: function(value) {\r\n\t\t\t\t\t\t\t\tpreviousSet.call(this, value)\r\n\t\t\t\t\t\t\t\tif(currentValue !== value) {\r\n\t\t\t\t\t\t\t\t\tcurrentValue = value\r\n\t\t\t\t\t\t\t\t\tif(listener) {\r\n\t\t\t\t\t\t\t\t\t\tlistener([{target: this, name: key}])\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\tenumerable: descriptor.enumerable\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tObject.defineProperty(target, key, {\r\n\t\t\t\t\t\t\tget: function() {\r\n\t\t\t\t\t\t\t\treturn currentValue\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\tset: function(value) {\r\n\t\t\t\t\t\t\t\tif(currentValue !== value) {\r\n\t\t\t\t\t\t\t\t\tcurrentValue = value\r\n\t\t\t\t\t\t\t\t\tif(listener) {\r\n\t\t\t\t\t\t\t\t\t\tlistener([{target: this, name: key}])\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\tenumerable: !descriptor || descriptor.enumerable\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} :\r\n\t\t\t// and finally a polling-based solution, for the really old browsers\r\n\t\t\tfunction(target, listener) {\r\n\t\t\t\tif(!timerStarted) {\r\n\t\t\t\t\ttimerStarted = true\r\n\t\t\t\t\tsetInterval(function() {\r\n\t\t\t\t\t\tfor(var i = 0, l = watchedObjects.length; i < l; i++) {\r\n\t\t\t\t\t\t\tdiff(watchedCopies[i], watchedObjects[i], listeners[i])\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}, 20)\r\n\t\t\t\t}\r\n\t\t\t\tvar copy = {}\r\n\t\t\t\tfor(var i in target) {\r\n\t\t\t\t\tif(target.hasOwnProperty(i)) {\r\n\t\t\t\t\t\tcopy[i] = target[i]\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\twatchedObjects.push(target)\r\n\t\t\t\twatchedCopies.push(copy)\r\n\t\t\t\tlisteners.push(listener)\r\n\t\t\t}\r\n\t\tvar queuedListeners\r\n\t\tfunction queue(listener, object, name) {\r\n\t\t\tif(queuedListeners) {\r\n\t\t\t\tif(queuedListeners.indexOf(listener) === -1) {\r\n\t\t\t\t\tqueuedListeners.push(listener)\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\tqueuedListeners = [listener]\r\n\t\t\t\tlang.nextTurn(function() {\r\n\t\t\t\t\tqueuedListeners.forEach(function(listener) {\r\n\t\t\t\t\t\tvar events = []\r\n\t\t\t\t\t\tlistener.properties.forEach(function(property) {\r\n\t\t\t\t\t\t\tevents.push({target: listener.object, name: property})\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t\tlistener(events)\r\n\t\t\t\t\t\tlistener.object = null\r\n\t\t\t\t\t\tlistener.properties = null\r\n\t\t\t\t\t})\r\n\t\t\t\t\tqueuedListeners = null\r\n\t\t\t\t}, 0)\r\n\t\t\t}\r\n\t\t\tlistener.object = object\r\n\t\t\tvar properties = listener.properties || (listener.properties = [])\r\n\t\t\tif(properties.indexOf(name) === -1) {\r\n\t\t\t\tproperties.push(name)\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar unobserve = has('observe') ? Object.unobserve :\r\n\t\t\tfunction(target, listener) {\r\n\t\t\t\tif(listener.remove) {\r\n\t\t\t\t\tlistener.remove()\r\n\t\t\t\t}\r\n\t\t\t\tfor(var i = 0, l = watchedObjects.length; i < l; i++) {\r\n\t\t\t\t\tif(watchedObjects[i] === target && listeners[i] === listener) {\r\n\t\t\t\t\t\twatchedObjects.splice(i, 1)\r\n\t\t\t\t\t\twatchedCopies.splice(i, 1)\r\n\t\t\t\t\t\tlisteners.splice(i, 1)\r\n\t\t\t\t\t\treturn\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\tvar watchedObjects = []\r\n\t\tvar watchedCopies = []\r\n\t\tvar listeners = []\r\n\t\tvar timerStarted = false\r\n\t\tfunction diff(previous, current, callback) {\r\n\t\t\t// TODO: keep an array of properties for each watch for faster iteration\r\n\t\t\tvar queued\r\n\t\t\tfor(var i in previous) {\r\n\t\t\t\tif(previous.hasOwnProperty(i) && previous[i] !== current[i]) {\r\n\t\t\t\t\t// a property has changed\r\n\t\t\t\t\tprevious[i] = current[i]\r\n\t\t\t\t\t(queued || (queued = [])).push({name: i})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor(var i in current) {\r\n\t\t\t\tif(current.hasOwnProperty(i) && !previous.hasOwnProperty(i)) {\r\n\t\t\t\t\t// a property has been added\r\n\t\t\t\t\tprevious[i] = current[i]\r\n\t\t\t\t\t(queued || (queued = [])).push({name: i})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(queued) {\r\n\t\t\t\tcallback(queued)\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tvar id = 1\r\n\t\t// a function that returns a function, to stop JSON serialization of an\r\n\t\t// object\r\n\t\tfunction toJSONHidden() {\r\n\t\t\treturn toJSONHidden\r\n\t\t}\r\n\t\t// An object that will be hidden from JSON serialization\r\n\t\tvar Hidden = function () {\r\n\t\t}\r\n\t\tHidden.prototype.toJSON = toJSONHidden\r\n\t\r\n\t\tvar extendClass, constructOrCall\r\n\t\ttry {\r\n\t\t\t// do this with an eval to avoid syntax errors in browsers that do not support class and new.target\r\n\t\t\textendClass = eval('(function(Base){ return class extends Base {}})')\r\n\t\t\tvar possibleConstructOrCall = eval('\"use strict\";(function(BaseClass, constructHandler, callHandler, constructClass){ return function Element() { return this instanceof Element ? constructHandler ? constructHandler.apply(new.target || this.constructor, arguments) : constructClass ? Reflect.construct(BaseClass, arguments, new.target || this.constructor) : lang.functionConstruct(BaseClass, arguments, new.target || this.constructor, this) : callHandler.apply(Element, arguments) } })')\r\n\t\t\t// actually using new.target bombs in Edge, so it is basically unusable\r\n\t\t\tnew (possibleConstructOrCall(function() {}, function() {}))()\r\n\t\t\tconstructOrCall = possibleConstructOrCall\r\n\t\t} catch(e) {\r\n\t\t}\r\n\t\r\n\t\tvar lang = {\r\n\t\t\trequestAnimationFrame: has('requestAnimationFrame') ? requestAnimationFrame :\r\n\t\t\t\t(function() {\r\n\t\t\t\t\tvar toRender = []\r\n\t\t\t\t\tvar queued = false\r\n\t\t\t\t\tfunction processAnimationFrame() {\r\n\t\t\t\t\t\tfor (var i = 0; i < toRender.length; i++) {\r\n\t\t\t\t\t\t\ttoRender[i]()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttoRender = []\r\n\t\t\t\t\t\tqueued = false\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfunction requestAnimationFrame(renderer) {\r\n\t\t\t\t\t \tif (!queued) {\r\n\t\t\t\t\t\t\tsetTimeout(processAnimationFrame)\r\n\t\t\t\t\t\t\tqueued = true\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttoRender.push(renderer)\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn requestAnimationFrame\r\n\t\t\t\t})(),\r\n\t\t\tSyncPromise: SyncPromise,\r\n\t\t\tPromise: has('promise') ? Promise : (function() {\r\n\t\t\t\tfunction Promise(execute) {\r\n\t\t\t\t\tvar isResolved, resolution, errorResolution\r\n\t\t\t\t\tvar queue = 0\r\n\t\t\t\t\tfunction resolve(value) {\r\n\t\t\t\t\t\t// resolve function\r\n\t\t\t\t\t\tif(value && value.then) {\r\n\t\t\t\t\t\t\t// received a promise, wait for it\r\n\t\t\t\t\t\t\tvalue.then(resolve, reject)\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\tresolution = value\r\n\t\t\t\t\t\t\tfinished()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfunction reject(error) {\r\n\t\t\t\t\t\t// reject function\r\n\t\t\t\t\t\terrorResolution = error\r\n\t\t\t\t\t\tfinished()\r\n\t\t\t\t\t}\r\n\t\t\t\t\texecute(resolve, reject)\r\n\t\t\t\t\tfunction finished() {\r\n\t\t\t\t\t\tisResolved = true\r\n\t\t\t\t\t\tfor(var i = 0, l = queue.length; i < l; i++) {\r\n\t\t\t\t\t\t\tqueue[i]()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// clean out the memory\r\n\t\t\t\t\t\tqueue = 0\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tthen: function(callback, errback) {\r\n\t\t\t\t\t\t\treturn new Promise(function(resolve, reject) {\r\n\t\t\t\t\t\t\t\tfunction handle() {\r\n\t\t\t\t\t\t\t\t\t// promise fulfilled, call the appropriate callback\r\n\t\t\t\t\t\t\t\t\ttry{\r\n\t\t\t\t\t\t\t\t\t\tif(errorResolution && !errback) {\r\n\t\t\t\t\t\t\t\t\t\t\t// errors without a handler flow through\r\n\t\t\t\t\t\t\t\t\t\t\treject(errorResolution)\r\n\t\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t\t// resolve to the callback's result\r\n\t\t\t\t\t\t\t\t\t\t\tresolve(errorResolution ?\r\n\t\t\t\t\t\t\t\t\t\t\t\terrback(errorResolution) :\r\n\t\t\t\t\t\t\t\t\t\t\t\tcallback ?\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tcallback(resolution) : resolution)\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}catch(newError) {\r\n\t\t\t\t\t\t\t\t\t\t// caught an error, reject the returned promise\r\n\t\t\t\t\t\t\t\t\t\treject(newError)\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif(isResolved) {\r\n\t\t\t\t\t\t\t\t\t// already resolved, immediately handle\r\n\t\t\t\t\t\t\t\t\thandle()\r\n\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t(queue || (queue = [])).push(handle)\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn Promise\r\n\t\t\t}()),\r\n\t\t\tSet: typeof Set !== 'undefined' ? Set : function () {\r\n\t\t\t\tvar elements = []\r\n\t\t\t\treturn {\r\n\t\t\t\t\tadd: function(element) {\r\n\t\t\t\t\t\tif (!this.has(element)) {\r\n\t\t\t\t\t\t\telements.push(element)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t},\r\n\t\t\t\t\thas: function(element) {\r\n\t\t\t\t\t\treturn elements.indexOf(element) > -1\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tWeakMap: has('WeakMap') ? WeakMap :\r\n\t\t \tfunction (values, name) {\r\n\t\t \t\tvar mapProperty = '__' + (name || '') + id++\r\n\t\t \t\treturn has('defineProperty') ?\r\n\t\t \t\t{\r\n\t\t \t\t\tget: function (key) {\r\n\t\t \t\t\t\treturn key[mapProperty]\r\n\t\t \t\t\t},\r\n\t\t \t\t\tset: function (key, value) {\r\n\t\t \t\t\t\tObject.defineProperty(key, mapProperty, {\r\n\t\t \t\t\t\t\tvalue: value,\r\n\t\t \t\t\t\t\tenumerable: false\r\n\t\t \t\t\t\t})\r\n\t\t \t\t\t}\r\n\t\t \t\t} :\r\n\t\t \t\t{\r\n\t\t \t\t\tget: function (key) {\r\n\t\t \t\t\t\tvar intermediary = key[mapProperty]\r\n\t\t \t\t\t\treturn intermediary && intermediary.value\r\n\t\t \t\t\t},\r\n\t\t \t\t\tset: function (key, value) {\r\n\t\t \t\t\t\t// we use an intermediary that is hidden from JSON serialization, at least\r\n\t\t \t\t\t\tvar intermediary = key[mapProperty] || (key[mapProperty] = new Hidden())\r\n\t\t \t\t\t\tintermediary.value = value\r\n\t\t \t\t\t}\r\n\t\t \t\t}\r\n\t\t \t},\r\n\t\r\n\t\t\tobserve: observe,\r\n\t\t\tunobserve: unobserve,\r\n\t\t\textendClass: extendClass,\r\n\t\t\twhen: function(value, callback, errorHandler) {\r\n\t\t\t\treturn value && value.then ?\r\n\t\t\t\t\t(value.then(callback, errorHandler) || value) : callback(value)\r\n\t\t\t},\r\n\t\t\tcompose: function(Base, constructor, properties) {\r\n\t\t\t\tvar prototype = constructor.prototype = Object.create(Base.prototype)\r\n\t\t\t\tsetPrototypeOf(constructor, Base)\r\n\t\t\t\tfor(var i in properties) {\r\n\t\t\t\t\tprototype[i] = properties[i]\r\n\t\t\t\t}\r\n\t\t\t\tprototype.constructor = constructor\r\n\t\t\t\treturn constructor\r\n\t\t\t},\r\n\t\t\tsetPrototypeOf: setPrototypeOf,\r\n\t\t\tnextTurn: has('MutationObserver') ?\r\n\t\t\t\tfunction (callback) {\r\n\t\t\t\t\t// promises don't resolve consistently on the next micro turn (Edge doesn't do it right),\r\n\t\t\t\t\t// so use mutation observer\r\n\t\t\t\t\t// TODO: make a faster mode that doesn't recreate each time\r\n\t\t\t\t\tvar div = document.createElement('div')\r\n\t\t\t\t\tvar observer = new MutationObserver(callback)\r\n\t\t\t\t\tobserver.observe(div, {\r\n\t\t\t\t\t\tattributes: true\r\n\t\t\t\t\t})\r\n\t\t\t\t\tdiv.setAttribute('a', id++)\r\n\t\t\t\t} :\r\n\t\t\t\tfunction (callback) {\r\n\t\t\t\t\t// TODO: we can do better for other, older browsers\r\n\t\t\t\t\tsetTimeout(callback, 0)\r\n\t\t\t\t},\r\n\t\t\tcopy: Object.assign || function(target, source) {\r\n\t\t\t\tfor(var i in source) {\r\n\t\t\t\t\ttarget[i] = source[i]\r\n\t\t\t\t}\r\n\t\t\t\treturn target\r\n\t\t\t},\r\n\t\t\tdeepCopy: function(source) {\r\n\t\t\t\tif (source && typeof source == 'object') {\r\n\t\t\t\t\tif (source instanceof Array) {\r\n\t\t\t\t\t\tvar target = [] // always create a new array for array targets\r\n\t\t\t\t\t\tfor(var i = 0, l = source.length; i < l; i++) {\r\n\t\t\t\t\t\t\ttarget[i] = lang.deepCopy(source[i])\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tvar target = {}\r\n\t\t\t\t\t\tfor (var i in source) {\r\n\t\t\t\t\t\t\ttarget[i] = lang.deepCopy(source[i])\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn target\r\n\t\t\t\t}\r\n\t\t\t\treturn source\r\n\t\t\t},\r\n\t\t\tconstructOrCall: constructOrCall || function(BaseClass, constructHandler, callHandler) {\r\n\t\t\t\treturn function Element() {\r\n\t\t\t\t\tif (this instanceof Element) {\r\n\t\t\t\t\t\tif (!this.hasOwnProperty('constructor') && Element.prototype === getPrototypeOf(this)) {\r\n\t\t\t\t\t\t\tif (constructHandler) {\r\n\t\t\t\t\t\t\t\treturn constructHandler.apply(Element, arguments)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (lang.buggyConstructorSetter) {\r\n\t\t\t\t\t\t\t\t// in safari, directly setting the constructor messes up the native prototype\r\n\t\t\t\t\t\t\t\tObject.defineProperty(this, 'constructor', { value: Element })\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tthis.constructor = Element\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else if (constructHandler) {\r\n\t\t\t\t\t\t\treturn constructHandler.apply(this.constructor, arguments)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn BaseClass.apply(this, arguments)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn callHandler.apply(Element, arguments)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tfunctionConstruct: function(BaseClass, args, SubClass, instance) {\r\n\t\t\t\tif (!instance.hasOwnProperty('constructor') && SubClass.prototype === Object.getPrototypeOf(instance)) {\r\n\t\t\t\t\tinstance = Object.create(SubClass.prototype)\r\n\t\t\t\t\tif (lang.buggyConstructorSetter) {\r\n\t\t\t\t\t\t// in safari, directly setting the constructor messes up the native prototype\r\n\t\t\t\t\t\tObject.defineProperty(instance, 'constructor', { value: SubClass })\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tinstance.constructor = SubClass\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn BaseClass.apply(instance, args)\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction isGenerator(func) {\r\n\t\t\tif (typeof func === 'function') {\r\n\t\t\t\tvar constructor = func.constructor\r\n\t\t\t\t// this is used to handle both native generators and transpiled generators\r\n\t\t\t\treturn (constructor.displayName || constructor.name) === 'GeneratorFunction'\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction isGeneratorIterator(iterator) {\r\n\t\t\tif (iterator && iterator.next) {\r\n\t\t\t\tvar constructor = iterator.constructor.constructor\r\n\t\t\t\treturn (constructor.displayName || constructor.name) === 'GeneratorFunction'\r\n\t\t\t}\r\n\t\t}\r\n\t\tlang.isGenerator = isGenerator\r\n\t\r\n\t\tfunction spawn(generator) {\r\n\t\t\tvar generatorIterator = typeof generator === 'function' ? generator() : generator\r\n\t\t\tvar resuming\r\n\t\t\tvar nextValue\r\n\t\t\tvar isThrowing\r\n\t\t\treturn next()\r\n\t\t\tfunction next() {\r\n\t\t\t\tdo {\r\n\t\t\t\t\tvar stepReturn = generatorIterator[isThrowing ? 'throw' : 'next'](nextValue)\r\n\t\t\t\t\tif (stepReturn.done) {\r\n\t\t\t\t\t\treturn stepReturn.value\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnextValue = stepReturn.value\r\n\t\t\t\t\t// if the return value is a (generator) iterator, execute it\r\n\t\t\t\t\tif (nextValue && nextValue.next && isGeneratorIterator(nextValue)) {\r\n\t\t\t\t\t\tnextValue = spawn(nextValue)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (nextValue && nextValue.then) {\r\n\t\t\t\t\t\t// if it is a promise, we will wait on it\r\n\t\t\t\t\t\t// and return the promise so that the next caller can wait on this\r\n\t\t\t\t\t\tvar resolved\r\n\t\t\t\t\t\tvar isSync = null\r\n\t\t\t\t\t\tvar result = nextValue.then(function(value) {\r\n\t\t\t\t\t\t\tnextValue = value\r\n\t\t\t\t\t\t\tif (isSync === false) {\r\n\t\t\t\t\t\t\t\treturn next()\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tisSync = true\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}, function(error) {\r\n\t\t\t\t\t\t\tnextValue = error\r\n\t\t\t\t\t\t\tisThrowing = true\r\n\t\t\t\t\t\t\treturn next()\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t\tif (!isSync) {\r\n\t\t\t\t\t\t\tisSync = false\r\n\t\t\t\t\t\t\treturn result\r\n\t\t\t\t\t\t} // else keeping looping to avoid recursion\r\n\t\t\t\t\t}\r\n\t\t\t\t\tisThrowing = false\r\n\t\t\t\t} while(true)\r\n\t\t\t}\r\n\t\t}\r\n\t\tlang.spawn = spawn\r\n\t\treturn lang\r\n\t}))\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) { if (true) {\r\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(4)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) } else if (typeof module === 'object' && module.exports) {        \r\n\t  module.exports = factory(require('./util/lang'), require('./Variable')) // Node\r\n\t}}(this, function (lang, VariableExports) {\r\n\t\tvar doc = typeof document !== 'undefined' && document\r\n\t\tvar invalidatedElements\r\n\t\tvar queued\r\n\t\tvar toRender = []\r\n\t\tvar nextId = 1\r\n\t\tvar requestAnimationFrame = lang.requestAnimationFrame\r\n\t\tvar Context = VariableExports.Context\r\n\t\r\n\t\tfunction Renderer(options) {\r\n\t\t\tvar variable = options.variable\r\n\t\r\n\t\t\tthis.variable = variable\r\n\t\t\tif (options.selector) {\r\n\t\t\t\tthis.selector = options.selector\r\n\t\t\t}\r\n\t\t\tif (options.elements) {\r\n\t\t\t\tthis.elements = options.elements\r\n\t\t\t\tthis.element = this.elements[0]\r\n\t\t\t\tfor(var i = 0, l = this.elements.length; i < l; i++) {\r\n\t\t\t\t\t(this.elements[i].alkaliRenderers || (this.elements[i].alkaliRenderers = [])).push(this)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (options.element) {\r\n\t\t\t\tvar element = this.element = options.element;\r\n\t\t\t\t(element.alkaliRenderers || (element.alkaliRenderers = [])).push(this)\r\n\t\t\t} else {\r\n\t\t\t\tthrow new Error('No element provided to Renderer')\r\n\t\t\t}\r\n\t\t\tif (options.update) {\r\n\t\t\t\tthis.updateRendering = options.update\r\n\t\t\t}\r\n\t\t\tif (options.shouldRender) {\r\n\t\t\t\tthis.shouldRender = options.shouldRender\r\n\t\t\t}\r\n\t\t\tif (options.renderUpdate) {\r\n\t\t\t\tthis.renderUpdate = options.renderUpdate\r\n\t\t\t}\r\n\t\t\tif (options.alwaysUpdate) {\r\n\t\t\t\tthis.alwaysUpdate = options.alwaysUpdate\r\n\t\t\t}\r\n\t\t\tif (!variable.updated) {\r\n\t\t\t\t// baconjs-esqe API\r\n\t\t\t\tvar renderer = this\r\n\t\t\t\tvariable.subscribe(function (event) {\r\n\t\t\t\t\t// replace the variable with an object\r\n\t\t\t\t\t// that returns the value from the event\r\n\t\t\t\t\trenderer.variable = {\r\n\t\t\t\t\t\tvalueOf: function () {\r\n\t\t\t\t\t\t\treturn event.value()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\trenderer.updated()\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tif (options.updateOnStart === false){\r\n\t\t\t\tvar contextualized = this.contextualized || this.variable\r\n\t\t\t\tthis.variable.valueOf(this)\r\n\t\t\t\t// even if we don't render on start, we still need to compute the value so we can depend on the computed \r\n\t\t\t\t// TODO: we may need to handle recontextualization if it returns a promise\r\n\t\t\t\tcontextualized.notifies(this)\r\n\t\t\t} else {\r\n\t\t\t\tthis.updateRendering(true)\r\n\t\t\t}\r\n\t\t}\r\n\t\tRenderer.prototype = {\r\n\t\t\tconstructor: Renderer,\r\n\t\t\tversion: 0,\r\n\t\t\tnotifies: true,\r\n\t\t\tupdateRendering: function () {\r\n\t\t\t\tthrow new Error ('updateRendering must be implemented by sub class of Renderer')\r\n\t\t\t},\r\n\t\t\tupdated: function (updateEvent, by, context) {\r\n\t\t\t\tif (!this.invalidated) {\r\n\t\t\t\t\tif (!context || this.contextMatches(context)) {\r\n\t\t\t\t\t\t// do this only once, until we render again\r\n\t\t\t\t\t\tthis.invalidated = true\r\n\t\t\t\t\t\tif (this.deferredRender) {\r\n\t\t\t\t\t\t\tthis.deferredRender.isCanceled = true\r\n\t\t\t\t\t\t\tthis.deferredRender = null\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar renderer = this\r\n\t\t\t\t\t\trequestAnimationFrame(function(){\r\n\t\t\t\t\t\t\tinvalidatedElements = null\r\n\t\t\t\t\t\t\trenderer.updateRendering(renderer.alwaysUpdate)\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\texecuteWithin: Context.prototype.executeWithin,\r\n\t\t\tsetVersion: function(){\r\n\t\t\t\t// this doesn't need its own version/hash\r\n\t\t\t},\r\n\t\t\tnewContext: function() {\r\n\t\t\t\treturn new Context(this.element, true)\r\n\t\t\t},\r\n\t\t\tintegrate: function(context, contextualized) {\r\n\t\t\t\tthis.addInput(contextualized)\r\n\t\t\t},\r\n\t\t\taddInput: function(contextualized) {\r\n\t\t\t\tif (this.variable !== contextualized) {\r\n\t\t\t\t\tthis.contextualized = contextualized\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tgetContextualized: function(Variable) {\r\n\t\t\t\treturn Context.prototype.getContextualized.call(this, Variable)\r\n\t\t\t\t//return this.contextualized || this.variable\r\n\t\t\t},\r\n\t\t\tspecify: function(Variable) {\r\n\t\t\t\treturn this.contextualized = Context.prototype.specify.call(this, Variable)\r\n\t\t\t\t// a new context to get this\r\n\t\t\t\tthis.contextualized = this.newContext(null, true).specify(Variable)\r\n\t\r\n\t\t\t},\r\n\t\t\tmerge: function(){\r\n\t\t\t\t// noop\r\n\t\t\t},\r\n\t\t\tcontextMatches: function(context) {\r\n\t\t\t\treturn true\r\n\t\t\t},\r\n\t\t\tinvalidateElement: function(element) {\r\n\t\t\t\tif(!invalidatedElements){\r\n\t\t\t\t\tinvalidatedElements = new WeakMap(null, 'invalidated')\r\n\t\t\t\t}\r\n\t\t\t\tvar invalidatedParts = invalidatedElements.get(element)\r\n\t\t\t\tinvalidatedElements.set(element, invalidatedParts = {})\r\n\t\t\t\tif (!invalidatedParts[id]) {\r\n\t\t\t\t\tinvalidatedParts[id] = true\r\n\t\t\t\t}\r\n\t\t\t\tif (!queued) {\r\n\t\t\t\t\tlang.queueTask(processQueue)\r\n\t\t\t\t\tqueued = true\r\n\t\t\t\t}\r\n\t\t\t\tvar renderer = this\r\n\t\t\t\ttoRender.push(function(){\r\n\t\t\t\t\trenderer.invalidated = false\r\n\t\t\t\t\trenderer.updateElement(element)\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tgetId: function(){\r\n\t\t\t\treturn this.id || (this.id = nextId++)\r\n\t\t\t},\r\n\t\t\tstop: function() {\r\n\t\t\t\tvar contextualized = this.contextualized || this.variable\r\n\t\t\t\tcontextualized.stopNotifies(this)\r\n\t\t\t}\r\n\t\t}\r\n\t\tObject.defineProperty(Renderer.prototype, 'subject', {\r\n\t\t\tget: function() {\r\n\t\t\t\treturn this.element\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\tfunction ElementRenderer(options) {\r\n\t\t\tRenderer.call(this, options)\r\n\t\t}\r\n\t\tElementRenderer.prototype = Object.create(Renderer.prototype)\r\n\t\tElementRenderer.prototype.shouldRender = function (element) {\r\n\t\t\treturn document.body.contains(element)\r\n\t\t}\r\n\t\tElementRenderer.prototype.getSubject = function () {\r\n\t\t\treturn this.element\r\n\t\t}\r\n\t\tElementRenderer.prototype.updateRendering = function (always, element) {\r\n\t\t\tif (!element && this.elements) {\r\n\t\t\t\tvar elements = this.elements\r\n\t\t\t\tif(!elements.length){\r\n\t\t\t\t\tif(this.selector){\r\n\t\t\t\t\t\telements = document.querySelectorAll(this.selector)\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tthrow new Error('No element or selector was provided to the Renderer')\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t\tfor(var i = 0, l = elements.length; i < l; i++){\r\n\t\t\t\t\tthis.updateRendering(always, elements[i])\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tvar thisElement = element || this.element\r\n\t\r\n\t\t\t\tif(always || this.shouldRender(thisElement)){\r\n\t\t\t\t\t// it is connected\r\n\t\t\t\t\tthis.updateElement(thisElement)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar id = this.getId()\r\n\t\t\t\t\tvar renderers = thisElement.renderersOnShow\r\n\t\t\t\t\tif(!renderers){\r\n\t\t\t\t\t\trenderers = thisElement.renderersOnShow = []\r\n\t\t\t\t\t\tthisElement.className += ' needs-rerendering'\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!renderers[id]) {\r\n\t\t\t\t\t\trenderers[id] = this\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tElementRenderer.prototype.addElement = function (element) {\r\n\t\t\tif (this.selector) {\r\n\t\t\t\telement.renderersOnShow = [this]\r\n\t\t\t} else {\r\n\t\t\t\tthis.elements.push(element)\r\n\t\t\t}\r\n\t\t\t// and immediately do an update\r\n\t\t\tthis.updateElement(element)\r\n\t\t}\r\n\t\tElementRenderer.prototype.updateElement = function(element) {\r\n\t\t\tthis.invalidated = false\r\n\t\t\tif (this.omitValueOf) {\r\n\t\t\t\tthis.started = true\r\n\t\t\t\tthis.renderUpdate(undefined, element)\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tvar resolved\r\n\t\t\tvar renderer = this\r\n\t\t\tvar deferredRender\r\n\t\t\tthis.executeWithin(function() {\r\n\t\t\t\tdeferredRender = renderer.variable.then(function(value) {\r\n\t\t\t\t\tresolved = true\r\n\t\t\t\t\tif (deferredRender) {\r\n\t\t\t\t\t\tif (deferredRender === renderer.deferredRender) {\r\n\t\t\t\t\t\t\trenderer.deferredRender = null\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (deferredRender.isCanceled) {\r\n\t\t\t\t\t\t\treturn\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!renderer.invalidated) {\r\n\t\t\t\t\t\tif (renderer.contextualized && renderer.contextualized !== renderer.variable) {\r\n\t\t\t\t\t\t\trenderer.contextualized.stopNotifies(renderer)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\trenderer.executeWithin(function() {\r\n\t\t\t\t\t\t\trenderer.contextualized = renderer.variable.notifies(renderer)\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t\tif(value !== undefined || renderer.started){\r\n\t\t\t\t\t\t\trenderer.started = true\r\n\t\t\t\t\t\t\trenderer.renderUpdate(value, element)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}, function(error) {\r\n\t\t\t\t\tconsole.error('Error rendering', renderer, error)\r\n\t\t\t\t})\r\n\t\t\t})\r\n\t\t\tif(!resolved){\r\n\t\t\t\t// start listening for changes immediately\r\n\t\t\t\tthis.executeWithin(function() {\r\n\t\t\t\t\trenderer.contextualized = renderer.variable.notifies(renderer)\r\n\t\t\t\t})\r\n\t\t\t\tthis.deferredRender = deferredRender\r\n\t\t\t\tif (this.renderLoading) {\r\n\t\t\t\t\t// if we have loading renderer call it\r\n\t\t\t\t\tthis.renderLoading(deferredRender, element)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tElementRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\t\tthrow new Error('renderUpdate(newValue) must be implemented')\r\n\t\t}\r\n\t\tRenderer.Renderer = Renderer\r\n\t\tRenderer.ElementRenderer = ElementRenderer\r\n\t\r\n\t\tfunction AttributeRenderer(options) {\r\n\t\t\tif(options.name){\r\n\t\t\t\tthis.name = options.name\r\n\t\t\t}\r\n\t\t\tElementRenderer.apply(this, arguments)\r\n\t\t}\r\n\t\tAttributeRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\t\tAttributeRenderer.prototype.type = 'AttributeRenderer'\r\n\t\tAttributeRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\t\tif (typeof newValue == 'boolean' || newValue == null) {\r\n\t\t\t\t// for booleans or null/undefined, treat the attribute boolean-like, setting and removing\r\n\t\t\t\tif (newValue) {\r\n\t\t\t\t\telement.setAttribute(this.name, '') // \"set\" the attribute to enabled\r\n\t\t\t\t} else {\r\n\t\t\t\t\telement.removeAttribute(this.name) // disable the attribute, removing it\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t// otherwise, assign value as string\r\n\t\t\t\telement.setAttribute(this.name, newValue)\r\n\t\t\t}\r\n\t\t}\r\n\t\tRenderer.AttributeRenderer = AttributeRenderer\r\n\t\r\n\t\tfunction PropertyRenderer(options) {\r\n\t\t\tif (options.name) {\r\n\t\t\t\tthis.name = options.name\r\n\t\t\t}\r\n\t\t\tElementRenderer.apply(this, arguments)\r\n\t\t}\r\n\t\tPropertyRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\t\tPropertyRenderer.prototype.type = 'PropertyRenderer'\r\n\t\tPropertyRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\t\telement[this.name] = newValue\r\n\t\t}\r\n\t\tRenderer.PropertyRenderer = PropertyRenderer\r\n\t\r\n\t\tfunction InputPropertyRenderer(options) {\r\n\t\t\tif (options.element && options.element.tagName === 'SELECT' && options.name === 'value') {\r\n\t\t\t\t// use the deferred value assignment for <select>\r\n\t\t\t\tthis.renderUpdate = this.renderSelectValueUpdate\r\n\t\t\t}\r\n\t\t\tPropertyRenderer.apply(this, arguments)\r\n\t\t}\r\n\t\tInputPropertyRenderer.prototype = Object.create(PropertyRenderer.prototype)\r\n\t\tInputPropertyRenderer.prototype.type = 'InputPropertyRenderer'\r\n\t\tInputPropertyRenderer.prototype.renderUpdate = function(newValue, element) {\r\n\t\t\tif (newValue == null || (element.type === 'number' && isNaN(newValue))) {\r\n\t\t\t\tnewValue = ''\r\n\t\t\t}\r\n\t\t\tvar oldValue = element[this.name]\r\n\t\t\tif (typeof oldValue === 'string' && typeof newValue !== 'string') {\r\n\t\t\t\tnewValue = newValue == null ? '' : String(newValue)\r\n\t\t\t}\r\n\t\t\tif (oldValue != newValue) {\r\n\t\t\t\telement[this.name] = newValue\r\n\t\t\t}\r\n\t\t}\r\n\t\tInputPropertyRenderer.prototype.renderSelectValueUpdate = function (newValue, element) {\r\n\t\t\telement.value = newValue\r\n\t\t\tif (element.value != newValue && !element.value) {\r\n\t\t\t\t// if we didn't successfully set the value of a <select>, we may need to wait until the children are constructed\r\n\t\t\t\telement.eventualValue = newValue\r\n\t\t\t\tlang.nextTurn(function() {\r\n\t\t\t\t\tif (element.eventualValue) {\r\n\t\t\t\t\t\telement.value = element.eventualValue\r\n\t\t\t\t\t\telement.eventualValue = undefined\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t} else {\r\n\t\t\t\telement.eventualValue = undefined\r\n\t\t\t}\r\n\t\t}\r\n\t\tRenderer.InputPropertyRenderer = InputPropertyRenderer\r\n\t\r\n\t\tfunction StyleRenderer(options) {\r\n\t\t\tif(options.name){\r\n\t\t\t\tthis.name = options.name\r\n\t\t\t}\r\n\t\t\tElementRenderer.apply(this, arguments)\r\n\t\t}\r\n\t\tStyleRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\t\tStyleRenderer.prototype.type = 'StyleRenderer'\r\n\t\tStyleRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\t\telement.style[this.name] = newValue\r\n\t\t}\r\n\t\tRenderer.StyleRenderer = StyleRenderer\r\n\t\r\n\t\tfunction ContentRenderer(options) {\r\n\t\t\tElementRenderer.apply(this, arguments)\r\n\t\t}\r\n\t\tContentRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\t\tContentRenderer.prototype.type = 'ContentRenderer'\r\n\t\tContentRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\t\telement.innerHTML = ''\r\n\t\t\tif (newValue === undefined){\r\n\t\t\t\tnewValue = ''\r\n\t\t\t}\r\n\t\t\telement.appendChild(document.createTextNode(newValue))\r\n\t\t}\r\n\t\tRenderer.ContentRenderer = ContentRenderer\r\n\t\r\n\t\tfunction TextRenderer(options) {\r\n\t\t\tthis.position = options.position\r\n\t\t\tthis.textNode = options.textNode\r\n\t\t\tElementRenderer.apply(this, arguments)\r\n\t\t}\r\n\t\tTextRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\t\tTextRenderer.prototype.type = 'TextRenderer'\r\n\t\tTextRenderer.prototype.updated = function (updateEvent, context) {\r\n\t\t\tif (this.builtList) {\r\n\t\t\t\tif (updateEvent.type === 'refresh') {\r\n\t\t\t\t\tthis.builtList = false\r\n\t\t\t\t\tthis.omitValueOf = false\r\n\t\t\t\t} else {\r\n\t\t\t\t\t(this.updates || (this.updates = [])).push(updateEvent)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tElementRenderer.prototype.updated.call(this, updateEvent, context)\r\n\t\t}\r\n\t\tTextRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\t\tif (newValue == null){\r\n\t\t\t\tnewValue = ''\r\n\t\t\t}\r\n\t\t\tif (newValue.create) {\r\n\t\t\t\tnewValue = newValue.create({parent: element})\r\n\t\t\t}\r\n\t\t\tif (newValue.nodeType) {\r\n\t\t\t\tif (this.textNode && this.textNode.parentNode == element) {\r\n\t\t\t\t\t// text node is attached, we can replace it with the node\r\n\t\t\t\t\telement.replaceChild(newValue, this.textNode)\r\n\t\t\t\t} else {\r\n\t\t\t\t\telement.appendChild(newValue)\r\n\t\t\t\t}\r\n\t\t\t\tthis.textNode = newValue\r\n\t\t\t} else if (newValue instanceof Array) {\r\n\t\t\t\tthis.renderUpdate = ListRenderer.prototype.renderUpdate\r\n\t\t\t\tthis.omitValueOf = true\r\n\t\t\t\tthis.renderUpdate(newValue, element)\r\n\t\t\t} else {\r\n\t\t\t\t(this.textNode || element.childNodes[this.position]).nodeValue = newValue\r\n\t\t\t}\r\n\t\t}\r\n\t\tRenderer.TextRenderer = TextRenderer\r\n\t\r\n\t\tfunction ListRenderer(options) {\r\n\t\t\tif (options.each) {\r\n\t\t\t\tthis.each = options.each\r\n\t\t\t}\r\n\t\t\tElementRenderer.apply(this, arguments)\r\n\t\t}\r\n\t\tListRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\t\tListRenderer.prototype.updated = function (updateEvent, context) {\r\n\t\t\tif (this.builtList) {\r\n\t\t\t\tif (updateEvent.type === 'refresh') {\r\n\t\t\t\t\tthis.builtList = false\r\n\t\t\t\t\tthis.omitValueOf = false\r\n\t\t\t\t} else {\r\n\t\t\t\t\t(this.updates || (this.updates = [])).push(updateEvent)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tElementRenderer.prototype.updated.call(this, updateEvent, context)\r\n\t\t}\r\n\t\tListRenderer.prototype.type = 'ListRenderer'\r\n\t\tListRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\t\tvar container\r\n\t\t\tvar each = this.each || function(item) { // TODO: make a single identity function\r\n\t\t\t\treturn item\r\n\t\t\t}\r\n\t\t\tvar thisElement = this.element\r\n\t\t\tvar renderer = this\r\n\t\t\tif (!this.builtList) {\r\n\t\t\t\tthis.builtList = true\r\n\t\t\t\tthis.omitValueOf = true\r\n\t\t\t\telement.innerHTML = ''\r\n\t\t\t\tvar childElements = this.childElements = []\r\n\t\t\t\tif (each.defineHasOwn) {\r\n\t\t\t\t\teach.defineHasOwn()\r\n\t\t\t\t}\r\n\t\t\t\tif (newValue) {\r\n\t\t\t\t\tnewValue.forEach(function(item) {\r\n\t\t\t\t\t\tchildElements.push(Renderer.append(thisElement, eachItem(item)))\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t\tvar contextualized = this.contextualized || this.variable\r\n\t\t\t\tcontextualized.notifies(this)\r\n\t\r\n\t\t\t\t// TODO: restore using a doc fragment to add these items:\r\n\t\t\t\t// thisElement.appendChild(container)\r\n\t\t\t} else {\r\n\t\t\t\tvar childElements = this.childElements\r\n\t\t\t\tvar updates = this.updates\r\n\t\t\t\tcontainer = thisElement\r\n\t\t\t\tupdates.forEach(function(update) {\r\n\t\t\t\t\tif (update.type === 'refresh') {\r\n\t\t\t\t\t\trenderer.builtList = false\r\n\t\t\t\t\t\tfor (var i = 0, l = childElements.length; i < l; i++) {\r\n\t\t\t\t\t\t\tthisElement.removeChild(childElements[i])\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\trenderer.renderUpdate()\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tfor (var i = 0, l = update.actions.length; i < l; i++) {\r\n\t\t\t\t\t\t\tvar action = update.actions[i]\r\n\t\t\t\t\t\t\tif (action.previousIndex > -1) {\r\n\t\t\t\t\t\t\t\tthisElement.removeChild(childElements[action.previousIndex])\r\n\t\t\t\t\t\t\t\tchildElements.splice(action.previousIndex, 1)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (action.index > -1) {\r\n\t\t\t\t\t\t\t\tvar nextChild = childElements[action.index]\r\n\t\t\t\t\t\t\t\tvar newElement = Renderer.append(thisElement, eachItem(action.value))\r\n\t\t\t\t\t\t\t\tif (nextChild) {\r\n\t\t\t\t\t\t\t\t\tthisElement.insertBefore(newElement, nextChild)\r\n\t\t\t\t\t\t\t\t\tchildElements.splice(action.index, 0, newElement)\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tchildElements.push(newElement)\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t\tthis.updates = [] // clear the updates\r\n\t\t\t}\r\n\t\t\tfunction eachItem(item) {\r\n\t\t\t\tvar childElement\r\n\t\t\t\tif (each.create) {\r\n\t\t\t\t\tchildElement = each.create({parent: thisElement, _item: item}) // TODO: make a faster object here potentially\r\n\t\t\t\t} else {\r\n\t\t\t\t\tchildElement = each(item, thisElement)\r\n\t\t\t\t\tif (childElement.create) {\r\n\t\t\t\t\t\tchildElement = childElement.create({parent: thisElement, _item: item})\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn childElement\r\n\t\t\t}\r\n\t\t}\r\n\t\tRenderer.ListRenderer = ListRenderer\r\n\t\r\n\t\tRenderer.onShowElement = function(shownElement){\r\n\t\t\trequestAnimationFrame(function(){\r\n\t\t\t\tinvalidatedElements = null\r\n\t\t\t\tvar elements = [].slice.call(shownElement.getElementsByClassName('needs-rerendering'))\r\n\t\t\t\tif (shownElement.className.indexOf('needs-rerendering') > 0){\r\n\t\t\t\t\tvar includingTop = [shownElement]\r\n\t\t\t\t\tincludingTop.push.apply(includingTop, elements)\r\n\t\t\t\t\telements = includingTop\r\n\t\t\t\t}\r\n\t\t\t\tfor (var i = 0, l = elements.length; i < l; i++){\r\n\t\t\t\t\tvar element = elements[i]\r\n\t\t\t\t\tvar renderers = element.renderersOnShow\r\n\t\t\t\t\tif(renderers){\r\n\t\t\t\t\t\telement.renderersOnShow = null\r\n\t\t\t\t\t\t// remove needs-rerendering class\r\n\t\t\t\t\t\telement.className = element.className.replace(/\\s?needs\\-rerendering\\s?/g, '')\r\n\t\t\t\t\t\tfor (var id in renderers) {\r\n\t\t\t\t\t\t\tvar renderer = renderers[id]\r\n\t\t\t\t\t\t\trenderer.updateElement(element)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t}\r\n\t\r\n\t\tfunction onElementRemoval(element){\r\n\t\t\t// cleanup element renderers\r\n\t\t\tif(element.alkaliRenderers){\r\n\t\t\t\tvar renderers = element.alkaliRenderers\r\n\t\t\t\tfor(var i = 0; i < renderers.length; i++){\r\n\t\t\t\t\tvar renderer = renderers[i]\r\n\t\t\t\t\trenderer.variable.stopNotifies(renderer)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tRenderer.onElementRemoval = function(element, onlyChildren){\r\n\t\t\tif(!onlyChildren){\r\n\t\t\t\tonElementRemoval(element)\r\n\t\t\t}\r\n\t\t\tvar children = element.getElementsByTagName('*')\r\n\t\t\tfor(var i = 0, l = children.length; i < l; i++){\r\n\t\t\t\tvar child = children[i]\r\n\t\t\t\tif(child.alkaliRenderers){\r\n\t\t\t\t\tonElementRemoval(child)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn Renderer\r\n\t}))\r\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) { if (true) {\r\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) } else if (typeof module === 'object' && module.exports) {\t\t\t\t\r\n\t\tmodule.exports = factory(require('./util/lang')) // Node\r\n\t}}(this, function (lang) {\r\n\t\tvar deny = {}\r\n\t\tvar noChange = {}\r\n\t\tvar context\r\n\t\tvar WeakMap = lang.WeakMap\r\n\t\tvar setPrototypeOf = lang.setPrototypeOf\r\n\t\tvar getPrototypeOf = Object.getPrototypeOf || (function(base) { return base.__proto__ })\r\n\t\tvar isGenerator = lang.isGenerator\r\n\t\tvar undefined // makes it faster to be locally scoped\r\n\t\t// update types\r\n\t\tvar RequestChange = 3\r\n\t\tvar RequestSet = 4\r\n\t\tvar NOT_MODIFIED = {\r\n\t\t\tname: 'Not modified',\r\n\t\t\ttoString: function () {\r\n\t\t\t\treturn 'Marker for not-modified response'\r\n\t\t\t},\r\n\t\t}\r\n\t\r\n\t\tvar propertyListenersMap = new lang.WeakMap(null, 'propertyListenersMap')\r\n\t\tvar isStructureChecked = new lang.WeakMap()\r\n\t\tvar nextVersion = Date.now()\r\n\t\r\n\t\tvar CacheEntry = lang.compose(WeakMap, function() {\r\n\t\t},{\r\n\t\t\t_propertyChange: function(propertyName) {\r\n\t\t\t\tthis.variable._propertyChange(propertyName, contextFromCache(this))\r\n\t\t\t}\r\n\t\t})\r\n\t\tvar listenerId = 1\r\n\t\r\n\t\tfunction when(value, callback, errback) {\r\n\t\t\tif (value && value.then) {\r\n\t\t\t\treturn value.then(callback, errback)\r\n\t\t\t}\r\n\t\t\treturn callback(value)\r\n\t\t}\r\n\t\tfunction whenStrict(value, callback) {\r\n\t\t\tif (value && value.then && !value.notifies) {\r\n\t\t\t\treturn value.then(callback)\r\n\t\t\t}\r\n\t\t\treturn callback(value)\r\n\t\t}\r\n\t\r\n\t\tfunction Context(subject, notifies){\r\n\t\t\tthis.subject = subject\r\n\t\t\tif (notifies) {\r\n\t\t\t\tthis.notifies = notifies\r\n\t\t\t}\r\n\t\t}\r\n\t\tContext.prototype = {\r\n\t\t\tconstructor: Context,\r\n\t\t\tnewContext: function(variable) {\r\n\t\t\t\treturn new Context(this.subject, this.notifies)\r\n\t\t\t},\r\n\t\t\texecuteWithin: function(executor) {\r\n\t\t\t\tvar previousContext = context\r\n\t\t\t\ttry {\r\n\t\t\t\t\tcontext = this\r\n\t\t\t\t\treturn executor()\r\n\t\t\t\t} finally {\r\n\t\t\t\t\tcontext = previousContext\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\t//version: 2166136261, // FNV-1a prime seed\r\n\t\t\tversion: 0,\r\n\t\t\trestart: function() {\r\n\t\t\t\t//this.version = 2166136261\r\n\t\t\t},\r\n\t\t\tcontextualize: function(variable, parentContext) {\r\n\t\t\t\t// resolve the contextualization of a variable, and updates this context to be aware of what distinctive aspect of the context has\r\n\t\t\t\t// been used for resolution\r\n\t\t\t\tvar contextualized\r\n\t\t\t\tif (this.distinctSubject) {\r\n\t\t\t\t\tvar contextMap = variable._contextMap || (variable._contextMap = new lang.WeakMap())\r\n\t\t\t\t\tcontextualized = contextMap.get(this.distinctSubject)\r\n\t\t\t\t\tif (!contextualized) {\r\n\t\t\t\t\t\tcontextMap.set(this.distinctSubject, contextualized = Object.create(variable))\r\n\t\t\t\t\t\tcontextualized.listeners = false\r\n\t\t\t\t\t\tcontextualized.context = this\r\n\t\t\t\t\t\tvar sources = this.sources\r\n\t\t\t\t\t\tfor (var i = 0, l = sources.length; i < l; i++) {\r\n\t\t\t\t\t\t\tcontextualized[sources[i]] = sources[++i]\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.contextualized = contextualized\r\n\t\t\t\t\t// do the merge\r\n\t\t\t\t\tif (parentContext) {\r\n\t\t\t\t\t\tparentContext.merge(this)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcontextualized = variable\r\n\t\t\t\t}\r\n\t\t\t\t//if (this.contextualized && this.contextualized !== contextualized) {\r\n\t\t\t\t\t// TOOD: if it has previously been contextualized to a different context (can happen in a promise/async situation), stop previous notifiers and start new ones\r\n\t\t\t\t//}\r\n\t\t\t\treturn contextualized\r\n\t\t\t},\r\n\t\t\tsetVersion: function(version) {\r\n\t/*\t\t\t// FNV1a hash algorithm 32-bit\r\n\t\t\t\treturn this.version = (this.version ^ (version || 0)) * 16777619 >>> 0*/\r\n\t\r\n\t/*\t\t\t// 54 bit FNV1a hash algorithm\r\n\t\t\t\tvar xored = this.version ^ (version || 0)\r\n\t\t\t\t// 435 + 1099511627776 = 1099511628211 is 64 bit FNV prime\r\n\t\t\t\treturn this.version =\r\n\t\t\t\t\txored * 435 + // compute hash on lower 32 bits\r\n\t\t\t\t\t(xor & 16777215) * 1099511627776 + // compute hash on lower 24 bits that overflow into upper 32 bits\r\n\t\t\t\t\t((this.version / 4294967296 >>> 0) * 435 & 2097151) * 4294967296 // hash on upper 32 bits*/\r\n\t\t\t\t// 54 bit derivative of FNV1a that better uses JS numbers/operators\r\n\t\t\t\t\r\n\t\t\t\t// a fast, efficient hash\r\n\t\t\t\t//return this.version = (this.version ^ (version || 0)) * 1049011 + (this.version / 5555555 >>> 0)\r\n\t\t\t\t// if we are using globally monotonically increasing version, we can just use max\r\n\t\t\t\tif (isNaN(version)) {\r\n\t\t\t\t\tthrow new Error('Bad version')\r\n\t\t\t\t}\r\n\t\t\t\treturn this.version = Math.max(this.version, version)\r\n\t\t\t},\r\n\t\t\tmerge: function(childContext) {\r\n\t\t\t\tif (!this.distinctSubject) {\r\n\t\t\t\t\tthis.distinctSubject = childContext.distinctSubject\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tspecify: function(Variable) {\r\n\t\t\t\t// specify a particular instance of a generic variable\r\n\t\t\t\tvar subject = this.subject\r\n\t\t\t\tvar subjectMap = subject.constructor.ownedClasses\r\n\t\t\t\tvar specifiedInstance\r\n\t\t\t\tif (subjectMap) {\r\n\t\t\t\t\tif (!this.distinctSubject) {\r\n\t\t\t\t\t\tthis.distinctSubject = subject\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar instanceMap = subjectMap.get(Variable)\r\n\t\t\t\t\tif (instanceMap) {\r\n\t\t\t\t\t\tspecifiedInstance = instanceMap.get(subject)\r\n\t\t\t\t\t\tif (!specifiedInstance) {\r\n\t\t\t\t\t\t\tinstanceMap.set(subject, specifiedInstance = instanceMap.createInstance ? instanceMap.createInstance(subject) : new Variable())\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn specifiedInstance\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// else if no specific context is found, return default instance\r\n\t\t\t\treturn Variable.defaultInstance\r\n\t\t\t},\r\n\t\t\tgetContextualized: function(variable) {\r\n\t\t\t\tif (!this.subject) {\r\n\t\t\t\t\t// no subject, just use the default variable\r\n\t\t\t\t\treturn variable\r\n\t\t\t\t}\r\n\t\t\t\t// returns a variable that has already been contextualized\r\n\t\t\t\tvar instance = variable._contextMap && this.subject && variable._contextMap.get(this.subject)\r\n\t\t\t\tif (instance && instance.context && instance.context.matches(this)) {\r\n\t\t\t\t\treturn instance\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tmatches: function(context) {\r\n\t\t\t\t// does another context match the resolution of this one?\r\n\t\t\t\treturn context.subject === this.subject\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction NotifyingContext(listener, subject){\r\n\t\t\tthis.subject = subject\r\n\t\t\tthis.listener = listener\r\n\t\t}\r\n\t\tNotifyingContext.prototype = Object.create(Context.prototype)\r\n\t\tNotifyingContext.prototype.constructor = NotifyingContext\r\n\t\tNotifyingContext.prototype.addInput = function(contextualized) {\r\n\t\t\tcontextualized.notifies(this.listener)\r\n\t\t}\r\n\t\r\n\t\tfunction registerListener(value, listener) {\r\n\t\t\tvar listeners = propertyListenersMap.get(value)\r\n\t\t\tvar id = listener.listenerId || (listener.listenerId = ('-' + listenerId++))\r\n\t\t\tif (listeners) {\r\n\t\t\t\tif (listeners[id] === undefined) {\r\n\t\t\t\t\tlisteners[id] = listeners.push(listener) - 1\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\tpropertyListenersMap.set(value, listeners = [listener])\r\n\t\t\t\tlisteners[id] = 0\r\n\t\t\t\tif (Variable.autoObserveObjects) {\r\n\t\t\t\t\tobserve(value)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tlistener.listeningToObject = value\r\n\t\t}\r\n\t\tfunction deregisterListener(listener) {\r\n\t\t\tif (listener.listeningToObject) {\r\n\t\t\t\tvar value = listener.listeningToObject\r\n\t\t\t\tlistener.listeningToObject = null\r\n\t\t\t\tvar listeners = propertyListenersMap.get(value)\r\n\t\t\t\tif (listeners) {\r\n\t\t\t\t\tvar index = listeners[listener.listenerId]\r\n\t\t\t\t\tif (index > -1) {\r\n\t\t\t\t\t\tlisteners.splice(index, 1)\r\n\t\t\t\t\t\tdelete listeners[listener.listenerId]\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction RefreshEvent() {\r\n\t\t\tthis.visited = new lang.Set()\r\n\t\t}\r\n\t\tRefreshEvent.prototype.type = 'refresh'\r\n\t\r\n\t\tfunction PropertyChangeEvent(key, childEvent, parent) {\r\n\t\t\tthis.key = key\r\n\t\t\tthis.childEvent = childEvent\r\n\t\t\tthis.parent = parent\r\n\t\t\tthis.visited = childEvent.visited\r\n\t\t}\r\n\t\tPropertyChangeEvent.prototype.type = 'update'\r\n\t\r\n\t\tfunction ArrayEvent(args) {\r\n\t\t\tthis.visited = new lang.Set()\r\n\t\t\tfor (var key in args) {\r\n\t\t\t\tthis[key] = args[key]\r\n\t\t\t}\r\n\t\t}\r\n\t\tArrayEvent.prototype.type = 'array-update'\r\n\t\tfunction DeleteEvent(args) {\r\n\t\t\tthis.visited = new lang.Set()\r\n\t\t\tfor (var key in args) {\r\n\t\t\t\tthis[key] = args[key]\r\n\t\t\t}\r\n\t\t}\r\n\t\tDeleteEvent.prototype.type = 'delete'\r\n\t\r\n\t\tfunction forPropertyNotifyingValues(variable, properties, callback) {\r\n\t\t\tif (variable === properties) {\r\n\t\t\t\tforPropertyNotifyingValues(variable, variable._properties, callback)\r\n\t\t\t}\r\n\t\t\tfor (var key in properties) {\r\n\t\t\t\tvar property = properties[key]\r\n\t\t\t\tif (property && property.parent == variable) {\r\n\t\t\t\t\tif (property.returnedVariable) {\r\n\t\t\t\t\t\tcallback(property.returnedVariable)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (property.hasChildNotifiers) {\r\n\t\t\t\t\t\tvar subProperties = property._properties\r\n\t\t\t\t\t\tif (subProperties) {\r\n\t\t\t\t\t\t\tforPropertyNotifyingValues(property, property, callback)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction assignPromise(variable, promise, callback) {\r\n\t\t\tvar isSync\r\n\t\t\tpromise.then(function(value) {\r\n\t\t\t\tif (isSync !== false) {\r\n\t\t\t\t\t// synchronous resolution\r\n\t\t\t\t\tisSync = true\r\n\t\t\t\t} else if (variable.promise === promise) {\r\n\t\t\t\t\t// async resolution make sure we are the still the most recent promise\r\n\t\t\t\t\tvariable.promise = null\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// if async and we are not the most recent, just return\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t\tif (callback) { // custom handler\r\n\t\t\t\t\tcallback(value) \r\n\t\t\t\t} else {\r\n\t\t\t\t\tvariable.value = value\r\n\t\t\t\t}\r\n\t\t\t}, function(error) {\r\n\t\t\t\tif (isSync !== false) {\r\n\t\t\t\t\t// synchronous resolution\r\n\t\t\t\t\tisSync = true\r\n\t\t\t\t} else if (variable.promise === promise) {\r\n\t\t\t\t\t// async resolution make sure we are the still the most recent promise\r\n\t\t\t\t\tvariable.promise = null\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// if async and we are not the most recent, just return\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t\tvariable.error = error\r\n\t\t\t})\r\n\t\t\tif (!isSync) {\r\n\t\t\t\tisSync = false\r\n\t\t\t\tvariable.promise = promise\r\n\t\t\t}\r\n\t\t\treturn promise\r\n\t\t}\r\n\t\r\n\t\tfunction Variable(value) {\r\n\t\t\tif (this instanceof Variable) {\r\n\t\t\t\t// new call, may eventually use new.target\r\n\t\t\t\tif (value !== undefined) {\r\n\t\t\t\t\tif (value && value.then && !value.notifies) {\r\n\t\t\t\t\t\tassignPromise(this, value)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.value = value\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\treturn Variable.with(value)\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tVariable._logStackTrace = function(v) {\r\n\t\t\tvar stack = (new Error().stack || '').split(/[\\r\\n]+/)\r\n\t\t\tif (stack[0] && /^Error\\s*/.test(stack[0])) stack.shift()\r\n\t\t\tif (stack[0] && /_logStackTrace/.test(stack[0])) stack.shift()\r\n\t\t\tvar coalesce = (this._debugOpts && this._debugOpts.coalesce) || []\r\n\t\t\tif (this._debugOpts && this._debugOpts.shortStackTrace) {\r\n\t\t\t\t// find the first non-coalesced line\r\n\t\t\t\tvar line\r\n\t\t\t\tstack.some(function(line) {\r\n\t\t\t\t\tif (!coalesce.some(function(re) {\r\n\t\t\t\t\t\treturn re.re.test(line)\r\n\t\t\t\t\t})) {\r\n\t\t\t\t\t\tline = stack[0]\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t\tconsole.log('Variable ' + v.__debug + ' changed', line && line.replace(/^\\s+/, ''))\r\n\t\t\t} else {\r\n\t\t\t\tif (coalesce.length) {\r\n\t\t\t\t\tvar s = []\r\n\t\t\t\t\tvar re\r\n\t\t\t\t\tfor (var i = 0; i < stack.length; i++) {\r\n\t\t\t\t\t\tvar line = stack[i]\r\n\t\t\t\t\t\tif (re) {\r\n\t\t\t\t\t\t\tif (re.test(line)) continue\r\n\t\t\t\t\t\t\tre = null\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tre\r\n\t\t\t\t\t\tcoalesce.some(function(re) {\r\n\t\t\t\t\t\t\treturn re = re.re.test(line)\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t\tline = line.replace(/^\\s+/,'')\r\n\t\t\t\t\t\tif (re) {\r\n\t\t\t\t\t\t\ts.push('(' + re.name + ') ' + line)\r\n\t\t\t\t\t\t\tre = re.re\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\ts.push(line)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tstack = s\r\n\t\t\t\t}\r\n\t\t\t\tvar stackObject = this._debugOpts && this._debugOpts.stackObject\r\n\t\t\t\tif (stackObject) {\r\n\t\t\t\t\tconsole.log('Variable ' + v.__debug + ' changed', stack)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tconsole.log('Variable ' + v.__debug + ' changed\\r\\n' + stack.join('\\r\\n'))\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tVariable._debugOpts = {\r\n\t\t\tcoalesce: [{ name: 'alkali', re: /\\/alkali\\// }, { name: 'Promise', re: /(Promise\\.)|(PromiseArray\\.)|(\\/bluebird\\/)/ }],\r\n\t\t\tstackObject: false\r\n\t\t}\r\n\t\r\n\t\tvar VariablePrototype = Variable.prototype = {\r\n\t\t\t// for debugging use\r\n\t\t\tget _currentValue() {\r\n\t\t\t\treturn this.valueOf(true)\r\n\t\t\t},\r\n\t\t\tset _currentValue(value) {\r\n\t\t\t\tthis.put(value)\r\n\t\t\t},\r\n\t\t\tconstructor: Variable,\r\n\t\t\tvalueOf: function(allowPromise) {\r\n\t\t\t\tvar result = this.gotValue(this.getValue())\r\n\t\t\t\treturn (allowPromise || !(result && result.then)) ? result : undefined\r\n\t\t\t},\r\n\t\t\tthen: function(onFulfilled, onRejected) {\r\n\t\t\t\tvar result = this.valueOf(true)\r\n\t\t\t\tif (!result || !result.then) {\r\n\t\t\t\t\tresult = new lang.SyncPromise(result) // ensure it is promise-like\r\n\t\t\t\t}\r\n\t\t\t\tif (onFulfilled || onRejected) { // call then if we have any callbacks\r\n\t\t\t\t\treturn result.then(onFulfilled, onRejected)\r\n\t\t\t\t}\r\n\t\t\t\treturn result\r\n\t\t\t},\r\n\t\t\tgetValue: function(forChild) {\r\n\t\t\t\tif (context) {\r\n\t\t\t\t\tcontext.setVersion(forChild ? this.version : Math.max(this.version || 0, this.versionWithChildren || 0))\r\n\t\t\t\t}\r\n\t\t\t\tvar key = this.key\r\n\t\t\t\tvar parent\r\n\t\t\t\tif (key != null && (parent = this.parent) != null) {\r\n\t\t\t\t\tif (context) {\r\n\t\t\t\t\t\tif (context.ifModifiedSince != null) {\r\n\t\t\t\t\t\t\t// just too complicated to handle NOT_MODIFED objects for now\r\n\t\t\t\t\t\t\t// TODO: Maybe handle this and delegate NOT_MODIFIED through this\r\n\t\t\t\t\t\t\t// chain and through gotValue\r\n\t\t\t\t\t\t\tcontext.ifModifiedSince = undefined \r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar property = this\r\n\t\t\t\t\tvar object\r\n\t\t\t\t\tif (parent.getValue) {\r\n\t\t\t\t\t\t// parent needs value context, might want to do separate context,\r\n\t\t\t\t\t\t// but would need to treat special so it retrieves the version\r\n\t\t\t\t\t\t// only and not the versionWithChildren\r\n\t\t\t\t\t\tobject = parent.getValue(true)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tobject = parent.value\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (object && object.then && !object.notifies) {\r\n\t\t\t\t\t\treturn when(object, function(object) {\r\n\t\t\t\t\t\t\tvar value = object == null ? undefined :\r\n\t\t\t\t\t\t\t\ttypeof object.property === 'function' ? object.property(key) :\r\n\t\t\t\t\t\t\t\ttypeof object.get === 'function' ? object.get(key) : object[key]\r\n\t\t\t\t\t\t\t//if (property.listeners) {\r\n\t\t\t\t\t\t\t\tvar listeners = propertyListenersMap.get(object)\r\n\t\t\t\t\t\t\t\tif (listeners && listeners.observer && listeners.observer.addKey) {\r\n\t\t\t\t\t\t\t\t\tlisteners.observer.addKey(key)\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t//}\r\n\t\t\t\t\t\t\treturn value\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar value = object == null ? undefined :\r\n\t\t\t\t\t\ttypeof object.property === 'function' ? object.property(key) :\r\n\t\t\t\t\t\ttypeof object.get === 'function' ? object.get(key) : object[key]\r\n\t\t\t\t\t//if (property.listeners) {\r\n\t\t\t\t\t\tvar listeners = propertyListenersMap.get(object)\r\n\t\t\t\t\t\tif (listeners && listeners.observer && listeners.observer.addKey) {\r\n\t\t\t\t\t\t\tlisteners.observer.addKey(key)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t//}\r\n\t\t\t\t\treturn value\r\n\t\t\t\t}\r\n\t\t\t\tif (this.promise) {\r\n\t\t\t\t\treturn this.promise\r\n\t\t\t\t}\r\n\t\t\t\tvar value = this.value\r\n\t\t\t\treturn value !== undefined ?\r\n\t\t\t\t\tthis.value : this.default\r\n\t\t\t},\r\n\t\t\tgotValue: function(value) {\r\n\t\t\t\tvar previousNotifyingValue = this.returnedVariable\r\n\t\t\t\tvar variable = this\r\n\t\t\t\tif (previousNotifyingValue) {\r\n\t\t\t\t\tif (value === previousNotifyingValue) {\r\n\t\t\t\t\t\t// nothing changed, immediately return valueOf\r\n\t\t\t\t\t\treturn value.valueOf(true)\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// if there was a another value that we were dependent on before, stop listening to it\r\n\t\t\t\t\t// TODO: we may want to consider doing cleanup after the next rendering turn\r\n\t\t\t\t\tif (variable.listeners) {\r\n\t\t\t\t\t\tpreviousNotifyingValue.stopNotifies(variable)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvariable.returnedVariable = null\r\n\t\t\t\t}\r\n\t\t\t\tif (value && value.notifies) {\r\n\t\t\t\t\tvariable.returnedVariable = value\r\n\t\t\t\t\tif (variable.listeners) {\r\n\t\t\t\t\t\tvalue.notifies(variable)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvalue = value.valueOf(true)\r\n\t\t\t\t}\r\n\t\t\t\tif (value && value.then) {\r\n\t\t\t\t\tvar deferredContext = context\r\n\t\t\t\t\treturn value.then(function(value) {\r\n\t\t\t\t\t\tif (value) {\r\n\t\t\t\t\t\t\tif (value.__variable) {\r\n\t\t\t\t\t\t\t\tvalue = value.__variable\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (value.subscribe) {\r\n\t\t\t\t\t\t\t\tif (deferredContext) {\r\n\t\t\t\t\t\t\t\t\treturn deferredContext.executeWithin(function() {\r\n\t\t\t\t\t\t\t\t\t\treturn Variable.prototype.gotValue.call(variable, value)\r\n\t\t\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\treturn Variable.prototype.gotValue.call(variable, value)\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn value\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t\treturn value\r\n\t\t\t},\r\n\t\t\tPropertyClass: Variable,\r\n\t\t\tproperty: function(key, PropertyClass) {\r\n\t\t\t\tvar propertyVariable = this[key]\r\n\t\t\t\tif (!propertyVariable || !propertyVariable.notifies) {\r\n\t\t\t\t\tpropertyVariable = this._properties && this._properties[key]\r\n\t\t\t\t}\r\n\t\t\t\tif (!propertyVariable) {\r\n\t\t\t\t\t// create the property variable\r\n\t\t\t\t\tvar Class = PropertyClass\r\n\t\t\t\t\tif (!Class) {\r\n\t\t\t\t\t\tClass = this.constructor[key]\r\n\t\t\t\t\t\tif (typeof Class !== 'function' || !Class.isPropertyClass) {\r\n\t\t\t\t\t\t\tClass = this.PropertyClass\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tpropertyVariable = new Class()\r\n\t\t\t\t\tpropertyVariable.key = key\r\n\t\t\t\t\tpropertyVariable.parent = this\r\n\t\t\t\t\tif (this[key] === undefined) {\r\n\t\t\t\t\t\tthis[key] = propertyVariable\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t(this._properties || (this._properties = {}))[key] = propertyVariable\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (PropertyClass) {\r\n\t\t\t\t\tif (!(propertyVariable instanceof PropertyClass)) {\r\n\t\t\t\t\t\tthrow new TypeError('Existing property variable does not match requested variable type')\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn propertyVariable\r\n\t\t\t},\r\n\t\t\tfor: function(subject) {\r\n\t\t\t\tif (subject && subject.target && !subject.constructor.getForClass) {\r\n\t\t\t\t\t// makes HTML events work\r\n\t\t\t\t\tsubject = subject.target\r\n\t\t\t\t}\r\n\t\t\t\tif (this.parent) {\r\n\t\t\t\t\treturn this.parent.for(subject).property(this.key)\r\n\t\t\t\t}\r\n\t\t\t\treturn new ContextualizedVariable(this, subject || defaultContext)\r\n\t\t\t},\r\n\t\t\tget isWritable() {\r\n\t\t\t\treturn this.fixed ? !this.value || this.value.isWritable : this._isWritable\r\n\t\t\t},\r\n\t\t\tset isWritable(isWritable) {\r\n\t\t\t\tthis._isWritable = isWritable\r\n\t\t\t},\r\n\t\t\t_isWritable: true,\r\n\t\t\t_changeValue: function(type, newValue, event) {\r\n\t\t\t\tvar key = this.key\r\n\t\t\t\tvar parent = this.parent\r\n\t\t\t\tif (!parent) {\r\n\t\t\t\t\treturn this.put(newValue, event)\r\n\t\t\t\t}\r\n\t\t\t\tvar variable = this\r\n\t\t\t\tvar object = parent.getValue ? parent.getValue(true) : parent.value\r\n\t\t\t\tif (object != null) {\r\n\t\t\t\t\tif (typeof object != 'object') {\r\n\t\t\t\t\t\t// if the parent is not an object, we can't set anything (that will be retained)\r\n\t\t\t\t\t\tvar error = new Error('Can not set property on non-object')\r\n\t\t\t\t\t\terror.deniedPut = true\r\n\t\t\t\t\t\tthrow error\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar oldValue = typeof object.get === 'function' ? object.get(key) : object[key]\r\n\t\t\t\t\tif (oldValue === newValue && typeof newValue != 'object') {\r\n\t\t\t\t\t\t// no actual change to make\r\n\t\t\t\t\t\treturn noChange\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (object && typeof object.set === 'function') {\r\n\t\t\t\t\tobject.set(key, newValue, event)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (type == RequestChange && oldValue && oldValue.put && (!newValue && newValue.put)) {\r\n\t\t\t\t\t\t// if a put and the property value is a variable, assign it to that.\r\n\t\t\t\t\t\treturn oldValue.put(newValue, event)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (newValue && newValue.then && !newValue.notifies) {\r\n\t\t\t\t\t\t\t// wait for it to resolve and then assign\r\n\t\t\t\t\t\t\treturn newValue.then(function(newValue) {\r\n\t\t\t\t\t\t\t\treturn variable._changeValue(type, newValue, event)\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// copy, if this is a copy-on-write variable\r\n\t\t\t\t\t\t\t// nothing there yet, create an object to hold the new property\r\n\t\t\t\t\t\t\tvar newObject = object == null\r\n\t\t\t\t\t\t\t\t? typeof key == 'number' ? [] : {}\r\n\t\t\t\t\t\t\t\t: parent.isWritable\r\n\t\t\t\t\t\t\t\t\t? lang.copy(\r\n\t\t\t\t\t\t\t\t\t\tobject.constructor === Object\r\n\t\t\t\t\t\t\t\t\t\t?\t{}\r\n\t\t\t\t\t\t\t\t\t\t:\tobject.constructor === Array\r\n\t\t\t\t\t\t\t\t\t\t\t?\t[]\r\n\t\t\t\t\t\t\t\t\t\t\t: Object.create(Object.getPrototypeOf(object)), object)\r\n\t\t\t\t\t\t\t\t\t: object\r\n\t\t\t\t\t\t\tnewObject[key] = newValue\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// or set the setter/getter\r\n\t\t\t\t\t}\r\n\t\t\t\t\tevent = event || new RefreshEvent()\r\n\t\t\t\t\tvar parentEvent = new PropertyChangeEvent(key, event, this)\r\n\t\t\t\t\tparentEvent.oldValue = oldValue\r\n\t\t\t\t\tparentEvent.target = variable\r\n\t\t\t\t\treturn when(newObject === object ?\r\n\t\t\t\t\t\t\tparent.updated(parentEvent, this) :\r\n\t\t\t\t\t\t\tparent.put(newObject, parentEvent), function() {\r\n\t\t\t\t\t\tvariable.updated(event, variable)\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t\tvariable.updated(event, variable)\r\n\t\r\n\t\t\t\t// now notify any object listeners\r\n\t\t\t\tvar listeners = propertyListenersMap.get(object)\r\n\t\t\t\t// we need to do it before the other listeners, so we can update it before\r\n\t\t\t\t// we trigger a full clobbering of the object\r\n\t\t\t\tif (listeners) {\r\n\t\t\t\t\tlisteners = listeners.slice(0)\r\n\t\t\t\t\tfor (var i = 0, l = listeners.length; i < l; i++) {\r\n\t\t\t\t\t\tvar listener = listeners[i]\r\n\t\t\t\t\t\tif (listener !== parent) {\r\n\t\t\t\t\t\t\t// now go ahead and actually trigger the other listeners (but make sure we don't do the parent again)\r\n\t\t\t\t\t\t\tlistener.updated(event)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn newValue\r\n\t\t\t},\r\n\t\r\n\t\t\t_propertyChange: function(propertyName, object, type) {\r\n\t\t\t\tif (this.onPropertyChange) {\r\n\t\t\t\t\tthis.onPropertyChange(propertyName, object)\r\n\t\t\t\t}\r\n\t\t\t\tthis.updated(new PropertyChangeEvent(propertyName, new RefreshEvent(), this))\r\n\t\t\t},\r\n\t\t\teachKey: function(callback) {\r\n\t\t\t\tfor (var i in this._properties) {\r\n\t\t\t\t\tcallback(i)\r\n\t\t\t\t}\r\n\t\t\t\tfor (var i in this) {\r\n\t\t\t\t\tif (this.hasOwnProperty[i]) {\r\n\t\t\t\t\t\tvar value = this[i]\r\n\t\t\t\t\t\tif (value && value.parent == this && value.listeners) {\r\n\t\t\t\t\t\t\tcallback(i)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tapply: function(instance, args) {\r\n\t\t\t\treturn new Transform(args[0], this, args)\r\n\t\t\t},\r\n\t\t\tcall: function(instance) {\r\n\t\t\t\treturn this.apply(instance, Array.prototype.slice.call(arguments, 1))\r\n\t\t\t},\r\n\t\t\tforDependencies: function(callback) {\r\n\t\t\t\tif (this.returnedVariable) {\r\n\t\t\t\t\tcallback(this.returnedVariable)\r\n\t\t\t\t}\r\n\t\t\t\tif (this.hasNotifyingChild) {\r\n\t\t\t\t\tforPropertyNotifyingValues(this, this, callback)\r\n\t\t\t\t}\r\n\t\t\t\tif (this.parent) {\r\n\t\t\t\t\tcallback(this.parent)\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tinit: function() {\r\n\t\t\t\tvar variable = this\r\n\t\t\t\tvar contextualizes, sources = [] // TODO: optimize this\r\n\t\t\t\tthis.forDependencies(function(dependency) {\r\n\t\t\t\t\tvar contextualized = dependency.notifies(variable)\r\n\t\t\t\t\tif (contextualized !== dependency) {\r\n\t\t\t\t\t\tcontextualizes = true\r\n\t\t\t\t\t}\r\n\t\t\t\t\tsources.push(contextualized)\r\n\t\t\t\t})\r\n\t\t\t\tif (contextualizes) {\r\n\t\t\t\t\tvar contextualized = new ContextualizedVariable()\r\n\t\t\t\t\t//context.instanceMap.set(this, contextualized)\r\n\t\t\t\t\tcontextualized.sources = sources\r\n\t\t\t\t\tcontextualized.init()\r\n\t\t\t\t\treturn contextualized\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif (this.listeningToObject === null) {\r\n\t\t\t\t\t// we were previously listening to an object, but it needs to be restored\r\n\t\t\t\t\t// calling valueOf will cause the listening object to be restored\r\n\t\t\t\t\tthis.valueOf()\r\n\t\t\t\t}\r\n\t\t\t\treturn this\r\n\t\t\t},\r\n\t\t\tcleanup: function() {\r\n\t\t\t\tthis.listeners = false\r\n\t\t\t\tvar handles = this.handles\r\n\t\t\t\tif (handles) {\r\n\t\t\t\t\tfor (var i = 0; i < handles.length; i++) {\r\n\t\t\t\t\t\thandles[i].remove()\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tthis.handles = null\r\n\t\t\t\tvar returnedVariable = this.returnedVariable\r\n\t\t\t\tvar variable = this\r\n\t\t\t\tthis.forDependencies(function(dependency) {\r\n\t\t\t\t\tdependency.stopNotifies(variable)\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\r\n\t\t\tversion: 0,\r\n\t\t\tversionWithChildren: 0,\r\n\t\r\n\t\t\tupdateVersion: function(version) {\r\n\t\t\t\tthis.version = nextVersion = Math.max(Date.now(), nextVersion + 1)\r\n\t\t\t},\r\n\t\r\n\t\t\tgetVersion: function() {\r\n\t\t\t\treturn Math.max(this.version,\r\n\t\t\t\t\tthis.returnedVariable && this.returnedVariable.getVersion ? this.returnedVariable.getFullVersion(context) : 0,\r\n\t\t\t\t\tthis.parent ? this.parent.getVersion(context) : 0)\r\n\t\t\t},\r\n\t\t\tgetFullVersion: function() {\r\n\t\t\t\treturn Math.max(this.versionWithChildren, this.getVersion())\r\n\t\t\t},\r\n\t\r\n\t\t\tgetSubject: function(selectVariable) {\r\n\t\t\t\treturn this.subject\r\n\t\t\t},\r\n\t\r\n\t\t\tgetUpdates: function(since) {\r\n\t\t\t\tvar updates = []\r\n\t\t\t\tvar nextUpdateMap = this.nextUpdateMap\r\n\t\t\t\tif (nextUpdateMap && since) {\r\n\t\t\t\t\twhile ((since = nextUpdateMap.get(since))) {\r\n\t\t\t\t\t\tif (since.type === 'refresh') {\r\n\t\t\t\t\t\t\t// if it was refresh, we can clear any prior entries\r\n\t\t\t\t\t\t\tupdates = []\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tupdates.push(since)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn updates\r\n\t\t\t},\r\n\t\r\n\t\t\tupdated: function(updateEvent, by, isDownstream) {\r\n\t\t\t\tif (!updateEvent) {\r\n\t\t\t\t\tupdateEvent = new RefreshEvent()\r\n\t\t\t\t\tupdateEvent.source = this\r\n\t\t\t\t}\r\n\t\t\t\tif (updateEvent.visited.has(this)){\r\n\t\t\t\t\t// if this event has already visited this variable, skip it\r\n\t\t\t\t\treturn updateEvent\r\n\t\t\t\t}\r\n\t\t\t\tupdateEvent.visited.add(this)\r\n\t\t\t\tif (this.__debug) {\r\n\t\t\t\t\t// debug is on\r\n\t\t\t\t\tVariable._logStackTrace(this)\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t/*var contextualInstance = context && context.getContextualized(this)\r\n\t\t\t\tif (contextualInstance) {\r\n\t\t\t\t\tcontextualInstance.updated(updateEvent, this)\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// at some point we could do an update list so that we could incrementally update\r\n\t\t\t\t// lists in non-live situations\r\n\t\t\t\tif (this.lastUpdate) {\r\n\t\t\t\t\tvar nextUpdateMap = this.nextUpdateMap\r\n\t\t\t\t\tif (!nextUpdateMap) {\r\n\t\t\t\t\t\tnextUpdateMap = this.nextUpdateMap = new lang.WeakMap()\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnextUpdateMap.set(this.lastUpdate, updateEvent)\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.lastUpdate = updateEvent */\r\n\t\t\t\tif (updateEvent instanceof PropertyChangeEvent) {\r\n\t\t\t\t\tthis.versionWithChildren = Math.max(Date.now(), nextVersion + 1)\r\n\t\t\t\t} else if (!isDownstream) {\r\n\t\t\t\t\tthis.updateVersion()\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar listeners = this.listeners\r\n\t\t\t\tif (listeners) {\r\n\t\t\t\t\tvar variable = this\r\n\t\t\t\t\t// make a copy, in case they change\r\n\t\t\t\t\tlisteners = listeners.slice()\r\n\t\t\t\t\tfor (var i = 0, l = listeners.length; i < l; i++) {\r\n\t\t\t\t\t\tvar dependent = listeners[i]\r\n\t\t\t\t\t\tif ((updateEvent instanceof PropertyChangeEvent) &&\r\n\t\t\t\t\t\t\t\tdependent.parent) {\r\n\t\t\t\t\t\t\tif (dependent.key === updateEvent.key) {\r\n\t\t\t\t\t\t\t\tdependent.updated(updateEvent.childEvent, variable)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tdependent.updated(updateEvent, variable, true)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (updateEvent instanceof PropertyChangeEvent) {\r\n\t\t\t\t\tif (this.returnedVariable && this.fixed) {\r\n\t\t\t\t\t\tthis.returnedVariable.updated(updateEvent, this)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (this.constructor.collection) {\r\n\t\t\t\t\t\tthis.constructor.collection.updated(updateEvent, this)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (this.parent) {\r\n\t\t\t\t\tthis.parent.updated(new PropertyChangeEvent(this.key, updateEvent, this.parent), this)\r\n\t\t\t\t}\r\n\t\t\t\tif (this.collection) {\r\n\t\t\t\t\tthis.collection.updated(updateEvent, this)\r\n\t\t\t\t}\r\n\t\t\t\treturn updateEvent\r\n\t\t\t},\r\n\t\r\n\t\t\tinvalidate: function() {\r\n\t\t\t\t// for back-compatibility for now\r\n\t\t\t\tthis.updated()\r\n\t\t\t},\r\n\t\r\n\t\t\tnotifies: function(target) {\r\n\t\t\t\t// TODO: Eventually we want this to be trigerred from context, but context gets shared with returned variables, so will need to handle that\r\n\t\t\t\tif (!target) {\r\n\t\t\t\t\tthrow new Error('No listener provided for notification')\r\n\t\t\t\t}\r\n\t\t\t\tvar listeners = this.listeners\r\n\t\t\t\tif (!listeners || !this.hasOwnProperty('listeners')) {\r\n\t\t\t\t\tvar variable = this.init()\r\n\t\t\t\t\tvariable.listeners = listeners = [target]\r\n\t\t\t\t\treturn variable\r\n\t\t\t\t} else if (listeners.indexOf(target) === -1) {\r\n\t\t\t\t\tlisteners.push(target)\r\n\t\t\t\t}\r\n\t\t\t\treturn this\r\n\t\t\t},\r\n\t\t\tsubscribe: function(listener) {\r\n\t\t\t\t// ES7 Observable (and baconjs) compatible API\r\n\t\t\t\tvar updated\r\n\t\t\t\tvar updateQueued\r\n\t\t\t\tvar variable = this\r\n\t\t\t\t// it is important to make sure you register for notifications before getting the value\r\n\t\t\t\tif (typeof listener === 'function') {\r\n\t\t\t\t\t// BaconJS compatible API\r\n\t\t\t\t\tvar variable = this\r\n\t\t\t\t\tvar event = {\r\n\t\t\t\t\t\tvalue: function() {\r\n\t\t\t\t\t\t\treturn new Context(null, true).executeWithin(function() {\r\n\t\t\t\t\t\t\t\treturn variable.valueOf(true)\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tupdated = function() {\r\n\t\t\t\t\t\tupdateQueued = false\r\n\t\t\t\t\t\tlistener(event)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\telse if (listener.next) {\r\n\t\t\t\t\t// Assuming ES7 Observable API. It is actually a streaming API, this pretty much violates all principles of reactivity, but we will support it\r\n\t\t\t\t\tupdated = function() {\r\n\t\t\t\t\t\tupdateQueued = false\r\n\t\t\t\t\t\tvariable.then(function(value) {\r\n\t\t\t\t\t\t\tlistener.next(value)\r\n\t\t\t\t\t\t}, function(error) {\r\n\t\t\t\t\t\t\tlistener.error(value)\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow new Error('Subscribing to an invalid listener, the listener must be a function, or have an update or next method')\r\n\t\t\t\t}\r\n\t\t\t\tvar updateReceiver = {\r\n\t\t\t\t\tupdated: function() {\r\n\t\t\t\t\t\tif (updateQueued) {\r\n\t\t\t\t\t\t\treturn\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tupdateQueued = true\r\n\t\t\t\t\t\tlang.nextTurn(updated)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tupdated()\r\n\t\t\t\tthis.notifies(updateReceiver)\r\n\t\t\t\treturn {\r\n\t\t\t\t\tunsubscribe: function() {\r\n\t\t\t\t\t\tvariable.stopNotifies(updateReceiver)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tstopNotifies: function(dependent) {\r\n\t\t\t\tvar listeners = this.listeners\r\n\t\t\t\tif (listeners) {\r\n\t\t\t\t\tvar index = listeners.indexOf(dependent)\r\n\t\t\t\t\tif (index > -1) {\r\n\t\t\t\t\t\tlisteners.splice(index, 1)\r\n\t\t\t\t\t\tif (listeners.length === 0) {\r\n\t\t\t\t\t\t\t// clear the listeners so it will be reinitialized if it has\r\n\t\t\t\t\t\t\t// listeners again\r\n\t\t\t\t\t\t\tthis.cleanup()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tput: function(value, event) {\r\n\t\t\t\tvar variable = this\r\n\t\t\t\tif (this.parent) {\r\n\t\t\t\t\treturn this._changeValue(RequestChange, value, event)\r\n\t\t\t\t}\r\n\t\t\t\tvar oldValue = this.getValue ? this.getValue() : this.value\r\n\t\t\t\tif (oldValue === value && typeof value != 'object') {\r\n\t\t\t\t\treturn noChange\r\n\t\t\t\t}\r\n\t\t\t\tif (oldValue && oldValue.put &&\r\n\t\t\t\t\t\t// if it is set to fixed, we see we can put in the current variable\r\n\t\t\t\t\t\t(variable.fixed || !(value && value.put))) {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\treturn oldValue.put(value)\r\n\t\t\t\t\t} catch (error) {\r\n\t\t\t\t\t\tif (!error.deniedPut) {\r\n\t\t\t\t\t\t\tthrow error\r\n\t\t\t\t\t\t}// else if the put was denied, continue on and set the value on this variable\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (value && value.then && !value.notifies) {\r\n\t\t\t\t\tvalue = assignPromise(this, value)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvariable.value = value\r\n\t\t\t\t}\r\n\t\t\t\tevent = event || new RefreshEvent()\r\n\t\t\t\tevent.oldValue = oldValue\r\n\t\t\t\tevent.target = variable\r\n\t\t\t\tvariable.updated(event, variable)\r\n\t\t\t\treturn value\r\n\t\t\t},\r\n\t\t\tget: function(key) {\r\n\t\t\t\tif (this[key] || (this._properties && this._properties[key])) {\r\n\t\t\t\t\treturn this.property(key).valueOf(true)\r\n\t\t\t\t}\r\n\t\t\t\tvar object = this.getValue()\r\n\t\t\t\tif (!object) {\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t\tif (typeof object.get === 'function') {\r\n\t\t\t\t\treturn object.get(key)\r\n\t\t\t\t}\r\n\t\t\t\tvar value = object[key]\r\n\t\t\t\tif (value && value.notifies) {\r\n\t\t\t\t\t// nested variable situation, get underlying value\r\n\t\t\t\t\treturn value.valueOf(true)\r\n\t\t\t\t}\r\n\t\t\t\treturn value\r\n\t\t\t},\r\n\t\t\tset: function(key, value, event) {\r\n\t\t\t\t// TODO: create an optimized route when the property doesn't exist yet\r\n\t\t\t\tthis.property(key)._changeValue(RequestSet, value, event)\r\n\t\t\t},\r\n\t\t\tundefine: function(key) {\r\n\t\t\t\tthis.set(key, undefined)\r\n\t\t\t},\r\n\t\t\tis: function(newValue, event) {\r\n\t\t\t\tif (this.parent) {\r\n\t\t\t\t\tvar parent = this.parent\r\n\t\t\t\t\tvar key = this.key\r\n\t\t\t\t\tvar object = (parent.getValue ? parent.getValue(true) : parent.value)\r\n\t\t\t\t\tvar parentEvent = new PropertyChangeEvent(key, event || new RefreshEvent(), parent)\r\n\t\t\t\t\tif (object) {\r\n\t\t\t\t\t\tobject[key] = newValue\r\n\t\t\t\t\t\tthis.updated(parentEvent, this)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tobject = (typeof key === 'number' ? [] : {})\r\n\t\t\t\t\t\tobject[key] = newValue\r\n\t\t\t\t\t\tparent.is(object, parentEvent)\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn this\r\n\t\t\t\t}\r\n\t\t\t\tthis.fixed = true\r\n\t\r\n\t\t\t\tthis.value = newValue\r\n\t\t\t\tthis.updated(new RefreshEvent(), this)\r\n\t\t\t\treturn this\r\n\t\t\t},\r\n\t\t\tproxy: function(proxiedVariable) {\r\n\t\t\t\treturn this.is(proxiedVariable)\r\n\t\t\t},\r\n\t\t\tnext: function(value) {\r\n\t\t\t\t// for ES7 observable compatibility\r\n\t\t\t\tthis.put(value)\r\n\t\t\t},\r\n\t\t\terror: function(error) {\r\n\t\t\t\t// for ES7 observable compatibility\r\n\t\t\t\tvar listeners = this.listeners\r\n\t\t\t\tif (listeners) {\r\n\t\t\t\t\t// make a copy, in case they change\r\n\t\t\t\t\tlisteners.forEach(function(dependent) {\r\n\t\t\t\t\t\t// skip notifying property listeners if we are headed up the parent chain\r\n\t\t\t\t\t\tdependent.error(error)\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tcomplete: function(value) {\r\n\t\t\t\t// for ES7 observable compatibility\r\n\t\t\t\tthis.put(value)\r\n\t\t\t},\r\n\t\t\tsetValue: function(value) {\r\n\t\t\t\treturn this.value = value\r\n\t\t\t},\r\n\t\t\tonValue: function(listener) {\r\n\t\t\t\treturn this.subscribe(function(event) {\r\n\t\t\t\t\twhen(event.value(), function(value) {\r\n\t\t\t\t\t\tlistener(value)\r\n\t\t\t\t\t})\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\ttoJSON: function() {\r\n\t\t\t\treturn this.valueOf()\r\n\t\t\t},\r\n\t\t\ttoString: function() {\r\n\t\t\t\treturn String(this.valueOf())\r\n\t\t\t},\r\n\t\t\tforEach: function(callbackOrItemClass, callback) {\r\n\t\t\t\t// iterate through current value of variable\r\n\t\t\t\tif (callbackOrItemClass.notifies) {\r\n\t\t\t\t\treturn this.forEach(function(item) {\r\n\t\t\t\t\t\tvar itemVariable = callbackOrItemClass.from(item)\r\n\t\t\t\t\t\tcallback.call(this, itemVariable)\r\n\t\t\t\t\t}, context)\r\n\t\t\t\t}\r\n\t\t\t\tvar collectionOf = this.collectionOf\r\n\t\t\t\tif (collectionOf) {\r\n\t\t\t\t\tvar variable = this\r\n\t\t\t\t\treturn when(this.valueOf(true), function(value) {\r\n\t\t\t\t\t\tif (value && value.forEach) {\r\n\t\t\t\t\t\t\tvalue.forEach(function(item, index) {\r\n\t\t\t\t\t\t\t\tcallbackOrItemClass.call(variable, variable.property(index, collectionOf))\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t\treturn when(this.valueOf(true), function(value) {\r\n\t\t\t\t\tif (value && value.forEach) {\r\n\t\t\t\t\t\tvalue.forEach(callbackOrItemClass)\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tfor (var i in value) {\r\n\t\t\t\t\t\t\tcallbackOrItemClass.call(value, value[i], i)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\r\n\t\t\tto: function (transformFunction, reverse) {\r\n\t\t\t\tif (typeof transformFunction !== 'function') {\r\n\t\t\t\t\tif (typeof transformFunction === 'object') {\r\n\t\t\t\t\t\tthis.to(transformFunction.get, transformFunction.set)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthrow new Error('No function provided to transform')\r\n\t\t\t\t}\r\n\t\t\t\tif (reverse) {\r\n\t\t\t\t\ttransformFunction.reverse = function(value, args) {\r\n\t\t\t\t\t\t// for direct to, we can just use the first argument\r\n\t\t\t\t\t\treverse.call(this, value, args[0])\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (transformFunction.prototype instanceof Variable) {\r\n\t\t\t\t\treturn new transformFunction(this)\r\n\t\t\t\t}\r\n\t\t\t\treturn new (this._Transform || Transform)(this, transformFunction)\r\n\t\t\t},\r\n\t\t\tmap: function (transformFunction) {\r\n\t\t\t\treturn this.to(function(value) {\r\n\t\t\t\t\tif (value instanceof Array) {\r\n\t\t\t\t\t\tthrow new Error('map without VArray')\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn transformFunction(value)\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tas: function(Class) {\r\n\t\t\t\t// easiest way to cast to a variable class\r\n\t\t\t\tvar instance = new Class(this)\r\n\t\t\t\tinstance.fixed = true\r\n\t\t\t\treturn instance\r\n\t\t\t},\r\n\t\t\twhileResolving: function(valueUntilResolved, useLastValue) {\r\n\t\t\t\treturn valueUntilResolved || arguments.length > 0 ? new WhileResolving(this, valueUntilResolved, useLastValue) :\r\n\t\t\t\t\tnew WhileResolving(this, undefined, true) // for zero arguments we default to the last value\r\n\t\t\t},\r\n\t\t\tget schema() {\r\n\t\t\t\t// default schema is the constructor\r\n\t\t\t\tif (this.returnedVariable) {\r\n\t\t\t\t\treturn this.returnedVariable.schema\r\n\t\t\t\t}\r\n\t\t\t\tif (this.parent) {\r\n\t\t\t\t\tvar parentSchemaProperties = this.parent.schema.properties || this.parent.schema\r\n\t\t\t\t\treturn parentSchemaProperties && parentSchemaProperties[this.key]\r\n\t\t\t\t}\r\n\t\t\t\treturn this.constructor\r\n\t\t\t},\r\n\t\t\tset schema(schema) {\r\n\t\t\t\t// but allow it to be overriden\r\n\t\t\t\tObject.defineProperty(this, 'schema', {\r\n\t\t\t\t\tvalue: schema\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tvalidate: function(target, schema) {\r\n\t\t\t\tif (this.returnedVariable) {\r\n\t\t\t\t\treturn this.returnedVariable.validate(target, schema)\r\n\t\t\t\t}\r\n\t\t\t\tif (this.parent) {\r\n\t\t\t\t\treturn this.parent.validate(target.valueOf(), schema)\r\n\t\t\t\t}\r\n\t\t\t\tif (schema) {\r\n\t\t\t\t\tif (schema.type && (schema.type !== typeof target)) {\r\n\t\t\t\t\t\treturn ['Target type of ' + typeof target + ' does not match schema type of ' + schema.type]\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (schema.required && (target == null || target == '' || (typeof target === 'number' && isNaN(target)))) {\r\n\t\t\t\t\t\treturn ['Value is required']\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tvar valid = []\r\n\t\t\t\tvalid.isValid = true\r\n\t\t\t\treturn valid\r\n\t\t\t},\r\n\t\r\n\t\t\tget validation() {\r\n\t\t\t\tvar validation = new Validating(this)\r\n\t\t\t\tObject.defineProperty(this, 'validation', {\r\n\t\t\t\t\tvalue: validation\r\n\t\t\t\t})\r\n\t\t\t\treturn validation\r\n\t\t\t},\r\n\t\t\tset validation(validation) {\r\n\t\t\t\t// but allow it to be overriden\r\n\t\t\t\tObject.defineProperty(this, 'validation', {\r\n\t\t\t\t\tvalue: validation\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tset structured(structure) {\r\n\t\t\t\t// find any variable properties and attaches them as a property\r\n\t\t\t\tvar keys = Object.keys(this)\r\n\t\t\t\tvar properties = keys.length > 1 && this._properties || (this._properties = {})\r\n\t\t\t\tfor(var i = 0, l = keys.length; i < l; i++) {\r\n\t\t\t\t\tvar key = keys[i]\r\n\t\t\t\t\tvar value = this[key]\r\n\t\t\t\t\tif (value instanceof Variable) {\r\n\t\t\t\t\t\tvar existing = properties[key]\r\n\t\t\t\t\t\tif (existing) {\r\n\t\t\t\t\t\t\tif (existing !== value) {\r\n\t\t\t\t\t\t\t\t// an existing property exists, put in it\r\n\t\t\t\t\t\t\t\texisting.put(value)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tif (value.parent) {\r\n\t\t\t\t\t\t\t\tif (value.parent === this) {\r\n\t\t\t\t\t\t\t\t\tcontinue // just being assigned to another property\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t// property already exists with different parent, make a proxy\r\n\t\t\t\t\t\t\t\t\tvar newValue = new Variable()\r\n\t\t\t\t\t\t\t\t\tnewValue.proxy(value)\r\n\t\t\t\t\t\t\t\t\tvalue = newValue\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tvalue.key = key\r\n\t\t\t\t\t\t\tvalue.parent = this\r\n\t\t\t\t\t\t\tproperties[key] = value\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tgetId: function() {\r\n\t\t\t\treturn this.id || (this.id = Variable.nextId++)\r\n\t\t\t},\r\n\t\t\tobserveObject: function() {\r\n\t\t\t\tvar variable = this\r\n\t\t\t\treturn when(this.valueOf(), function(object) {\r\n\t\t\t\t\tvar listeners = propertyListenersMap.get(object)\r\n\t\t\t\t\tif (!listeners) {\r\n\t\t\t\t\t\tpropertyListenersMap.set(object, listeners = [])\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (listeners.observerCount) {\r\n\t\t\t\t\t\tlisteners.observerCount++\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tlisteners.observerCount = 1\r\n\t\t\t\t\t\tvar observer = listeners.observer = lang.observe(object, function(events) {\r\n\t\t\t\t\t\t\tfor (var i = 0, l = listeners.length; i < l; i++) {\r\n\t\t\t\t\t\t\t\tvar listener = listeners[i]\r\n\t\t\t\t\t\t\t\tfor (var j = 0, el = events.length; j < el; j++) {\r\n\t\t\t\t\t\t\t\t\tvar event = events[j]\r\n\t\t\t\t\t\t\t\t\tlistener._propertyChange(event.name, object)\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t\tif (observer.addKey) {\r\n\t\t\t\t\t\t\tfor (var i = 0, l = listeners.length; i < l; i++) {\r\n\t\t\t\t\t\t\t\tvar listener = listeners[i]\r\n\t\t\t\t\t\t\t\tlistener.eachKey(function(key) {\r\n\t\t\t\t\t\t\t\t\tobserver.addKey(key)\r\n\t\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tregisterListener(object, variable)\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tremove: function() {\r\n\t\t\t\t\t\t\tderegisterListener(object, variable)\r\n\t\t\t\t\t\t\tif (!(--listeners.observerCount)) {\r\n\t\t\t\t\t\t\t\tlisteners.observer.remove()\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tdone: function() {\r\n\t\t\t\t\t\t\t// deliver changes\r\n\t\t\t\t\t\t\tlang.deliverChanges(observer)\r\n\t\t\t\t\t\t\tthis.remove()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tgetCollectionOf: function() {\r\n\t\t\t\treturn this.returnedVariable && this.returnedVariable.collectionOf || this.constructor.collectionOf\r\n\t\t\t},\r\n\t\t\t_sN: function(name) {\r\n\t\t\t\t// for compilers to set a name\r\n\t\t\t\tthis.name = name\r\n\t\t\t\treturn this\r\n\t\t\t},\r\n\t\t\tget _debug() {\r\n\t\t\t\tif (this.__debug === undefined) {\r\n\t\t\t\t\tthis.__debug = this.name || (Math.random() + '').slice(2)\r\n\t\t\t\t}\r\n\t\t\t\treturn this.__debug\r\n\t\t\t},\r\n\t\t\tset _debug(_debug) {\r\n\t\t\t\tthis.__debug = _debug\r\n\t\t\t},\r\n\t\t\tget _lastUpdated() {\r\n\t\t\t\treturn new Date(this.getVersion())\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\t// a variable inheritance change goes through its own prototype, so classes/constructor\r\n\t\t// can be used as variables as well\r\n\t\tfor (var key in VariablePrototype) {\r\n\t\t\tObject.defineProperty(Variable, key, Object.getOwnPropertyDescriptor(VariablePrototype, key))\r\n\t\t}\r\n\t\r\n\t\tVariable.as = function(Type) {\r\n\t\t\tvar NewType = this.with({})\r\n\t\t\tvar target = NewType.prototype\r\n\t\t\tvar prototype = Type.prototype\r\n\t\t\tdo {\r\n\t\t\t\tvar names = Object.getOwnPropertyNames(prototype)\r\n\t\t\t\tfor (var i = 0; i < names.length; i++) {\r\n\t\t\t\t\tvar name = names[i]\r\n\t\t\t\t\tif (!Object.getOwnPropertyDescriptor(target, name)) {\r\n\t\t\t\t\t\tObject.defineProperty(target, name, Object.getOwnPropertyDescriptor(prototype, name))\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tprototype = getPrototypeOf(prototype)\r\n\t\t\t} while (prototype && prototype !== Variable.prototype)\r\n\t\t\treturn NewType\r\n\t\t}\r\n\t\r\n\t\tVariable.with = function(properties, ExtendedVariable) {\r\n\t\t\t// TODO: handle arguments\r\n\t\t\tvar Base = this\r\n\t\t\tvar prototype\r\n\t\t\tif (Object.getOwnPropertyDescriptor(this, 'prototype').writable === false) {\r\n\t\t\t\t// extending native class\r\n\t\t\t\tExtendedVariable = lang.extendClass(this)\r\n\t\t\t\tprototype = ExtendedVariable.prototype\r\n\t\t\t} else {\r\n\t\t\t\t// extending function/constructor\r\n\t\t\t\tExtendedVariable = ExtendedVariable || function() {\r\n\t\t\t\t\tif (this instanceof ExtendedVariable) {\r\n\t\t\t\t\t\tBase.apply(this, arguments)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn ExtendedVariable.with(properties)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tprototype = ExtendedVariable.prototype = Object.create(this.prototype)\r\n\t\t\t\tprototype.constructor = ExtendedVariable\r\n\t\t\t\tsetPrototypeOf(ExtendedVariable, this)\r\n\t\t\t}\r\n\t\t\treturn ExtendedVariable.assign(properties)\r\n\t\t}\r\n\t\tVariable.assign = function(properties) {\r\n\t\t\tvar prototype = this.prototype\r\n\t\t\tfor (var key in properties) {\r\n\t\t\t\tvar descriptor = Object.getOwnPropertyDescriptor(properties, key)\r\n\t\t\t\tvar value = descriptor.value\r\n\t\t\t\tif (typeof value === 'function' && key !== 'collectionOf') {\r\n\t\t\t\t\tif (value.notifies) {\r\n\t\t\t\t\t\t// variable class\r\n\t\t\t\t\t\tdescriptor = (function(key, Class) {\r\n\t\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\t\tget: function() {\r\n\t\t\t\t\t\t\t\t\tvar property = (this._properties || (this._properties = {}))[key]\r\n\t\t\t\t\t\t\t\t\tif (!property) {\r\n\t\t\t\t\t\t\t\t\t\tthis._properties[key] = property = new Class()\r\n\t\t\t\t\t\t\t\t\t\tproperty.key = key\r\n\t\t\t\t\t\t\t\t\t\tproperty.parent = this\r\n\t\t\t\t\t\t\t\t\t\tif (property.listeners) {\r\n\t\t\t\t\t\t\t\t\t\t\t// if it already has listeners, need to reinit it with the parent\r\n\t\t\t\t\t\t\t\t\t\t\tproperty.init()\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\treturn property\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t\tset: function(value) {\r\n\t\t\t\t\t\t\t\t\tthis[key]._changeValue(RequestSet, value)\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t\tenumerable: true\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t})(key, value)\r\n\t\t\t\t\t\tif (value === Variable) {\r\n\t\t\t\t\t\t\tvalue = Variable() // create own instance\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvalue.isPropertyClass = true\r\n\t\t\t\t\t} else if (isGenerator(value)) {\r\n\t\t\t\t\t\tdescriptor = getGeneratorDescriptor(value)\r\n\t\t\t\t\t} else if (value.defineAs) {\r\n\t\t\t\t\t\tdescriptor = value.defineAs(key)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tvalue = generalizeMethod(value, key)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tObject.defineProperty(prototype, key, descriptor)\r\n\t\t\t\tif (value !== undefined) {\r\n\t\t\t\t\t// TODO: If there is a getter/setter here, use defineProperty\r\n\t\t\t\t\tthis[key] = value\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// getter/setter\r\n\t\t\t\t\tObject.defineProperty(this, key, descriptor)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (properties && properties.hasOwn) {\r\n\t\t\t\thasOwn.call(this, properties.hasOwn)\r\n\t\t\t}\r\n\t\t\treturn this\r\n\t\t}\r\n\t\r\n\t\tObject.defineProperty(Variable, 'defaultInstance', {\r\n\t\t\tget: function() {\r\n\t\t\t\treturn this.hasOwnProperty('_defaultInstance') ?\r\n\t\t\t\t\tthis._defaultInstance : (\r\n\t\t\t\t\t\tthis._defaultInstance = new this(),\r\n\t\t\t\t\t\tthis._defaultInstance.subject = defaultContext,\r\n\t\t\t\t\t\tthis._defaultInstance)\r\n\t\t\t}\r\n\t\t})\r\n\t\tVariable.hasOwn = function(Target, createInstance) {\r\n\t\t\tvar instanceMap = new lang.WeakMap()\r\n\t\t\tinstanceMap.createInstance = createInstance\r\n\t\t\tvar subjectMap = this.ownedClasses || (this.ownedClasses = new lang.WeakMap())\r\n\t\t\tsubjectMap.set(Target, instanceMap)\r\n\t\t}\r\n\t\r\n\t\r\n\t\tfunction arrayToModify(variable, callback) {\r\n\t\t\t// TODO: switch this to allow promises\r\n\t\t\treturn when(variable.cachedValue || variable.valueOf(true), function(array) {\r\n\t\t\t\tvar newArray = array ?\r\n\t\t\t\t\tvariable.isWritable ? array.slice(0) : array\r\n\t\t\t\t\t: []\r\n\t\t\t\tvar results = callback.call(variable, newArray)\r\n\t\t\t\treturn when(newArray === array ? // if we are just modifying the original array\r\n\t\t\t\t\t\tvariable.updated(results[1], variable) : // then just send out an updated event\r\n\t\t\t\t\t\tvariable.put(newArray, results[1]), function() { // otherwise put in the new array\r\n\t\t\t\t\tvariable.cachedVersion++ // update the cached version, so any version checking will know it has changed\r\n\t\t\t\t\treturn results[0]\r\n\t\t\t\t})\r\n\t\t\t})\r\n\t\t}\r\n\t\r\n\t\tfunction insertedAt(variable, added, startingIndex, arrayLength, event) {\r\n\t\t\tvar addedCount = added.length\r\n\t\t\t// adjust the key positions of any index properties after splice\r\n\t\t\tif (addedCount > 0) {\r\n\t\t\t\tevent = event || new ArrayEvent({\r\n\t\t\t\t\tmodifier: variable,\r\n\t\t\t\t\tactions: []\r\n\t\t\t\t})\r\n\t\t\t\tvar arrayPosition\r\n\t\t\t\tfor (var i = arrayLength - addedCount; i > startingIndex;) {\r\n\t\t\t\t\tvar arrayPosition = variable[--i]\r\n\t\t\t\t\tif (arrayPosition) {\r\n\t\t\t\t\t\tvariable[i] = undefined\r\n\t\t\t\t\t\tarrayPosition.key += addedCount\r\n\t\t\t\t\t\tvariable[arrayPosition.key] = arrayPosition\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// send out updates\r\n\t\t\t\tfor (var i = 0, l = added.length; i < l; i++) {\r\n\t\t\t\t\tevent.actions.push({\r\n\t\t\t\t\t\tvalue: added[i],\r\n\t\t\t\t\t\tindex: i + startingIndex,\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn event\r\n\t\t}\r\n\t\r\n\t\tfunction removedAt(variable, removed, startingIndex, removalCount, arrayLength) {\r\n\t\t\t// adjust the properties\r\n\t\t\tvar i = startingIndex + removalCount\r\n\t\t\tvar arrayPosition\r\n\t\t\tif (removalCount > 0) {\r\n\t\t\t\tvar event = new ArrayEvent({\r\n\t\t\t\t\tmodifier: variable,\r\n\t\t\t\t\tactions: []\r\n\t\t\t\t})\r\n\t\t\t\tfor (var i = startingIndex + removalCount; i < arrayLength + removalCount; i++) {\r\n\t\t\t\t\tvar arrayPosition = variable[i]\r\n\t\t\t\t\tif (arrayPosition) {\r\n\t\t\t\t\t\tvariable[i] = undefined\r\n\t\t\t\t\t\tarrayPosition.key -= removalCount\r\n\t\t\t\t\t\tvariable[arrayPosition.key] = arrayPosition\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// send out updates\r\n\t\t\t\tfor (var i = 0; i < removalCount; i++) {\r\n\t\t\t\t\tevent.actions.push({\r\n\t\t\t\t\t\tpreviousIndex: startingIndex,\r\n\t\t\t\t\t\toldValue: removed[i]\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t\tvariable.cachedVersion = variable.version // update the cached version so it doesn't need to be recomputed\r\n\t\t\t}\r\n\t\t\treturn event\r\n\t\t}\r\n\t\r\n\t\tif (typeof Symbol !== 'undefined') {\r\n\t\t\tVariable.prototype[Symbol.iterator] = function() {\r\n\t\t\t\tvar iterator = this.valueOf()[Symbol.iterator]()\r\n\t\t\t\tvar variable = this\r\n\t\t\t\tvar collectionOf = this.collectionOf\r\n\t\t\t\tif (collectionOf) {\r\n\t\t\t\t\tvar parent = this\r\n\t\t\t\t\tvar i = 0\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tnext: function() {\r\n\t\t\t\t\t\t\tvar result = iterator.next()\r\n\t\t\t\t\t\t\tif (!result.done) {\r\n\t\t\t\t\t\t\t\tresult.value = variable.property(i++, collectionOf)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn result\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn iterator\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tvar VMap = Variable.VMap = lang.compose(Variable, function(value){\r\n\t\t\tif (typeof value !== 'undefined') {\r\n\t\t\t\tthis.value = value\r\n\t\t\t}\r\n\t\t}, {\r\n\t\t\tfixed: true,\r\n\t\t\tisWritable: false,\r\n\t\t\t// TODO: Move all the get and set functionality for maps out of Variable\r\n\t\t\tproperty: function(key, PropertyClass) {\r\n\t\t\t\tvar properties = this._properties || (this._properties = new Map())\r\n\t\t\t\tvar propertyVariable = properties.get(key)\r\n\t\t\t\tif (!propertyVariable) {\r\n\t\t\t\t\t// create the property variable\r\n\t\t\t\t\tpropertyVariable = new (PropertyClass || this.PropertyClass)()\r\n\t\t\t\t\tpropertyVariable.key = key\r\n\t\t\t\t\tpropertyVariable.parent = this\r\n\t\t\t\t\tif (propertyVariable.listeners) {\r\n\t\t\t\t\t\t// if it already has listeners, need to reinit it with the parent\r\n\t\t\t\t\t\tpropertyVariable.init()\r\n\t\t\t\t\t}\r\n\t\t\t\t\tproperties.set(key, propertyVariable)\r\n\t\t\t\t}\r\n\t\t\t\treturn propertyVariable\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\tvar Transform = Variable.Transform = lang.compose(Variable, function Transform(source, transform, sources) {\r\n\t\t\tif (source !== undefined || sources) {\r\n\t\t\t\tthis.source = source\r\n\t\t\t}\r\n\t\t\tif (transform) {\r\n\t\t\t\tthis.transform = transform\r\n\t\t\t\tif (sources) {\r\n\t\t\t\t\tfor (var i = 1, l = sources.length; i < l; i++) {\r\n\t\t\t\t\t\tthis['source' + i] = sources[i]\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}, {\r\n\t\t\tgetValue: function() {\r\n\t\t\t\t// first check to see if we have the variable already computed\r\n\t\t\t\tif (this.readyState == 'invalidated') {\r\n\t\t\t\t\tthis.readyState = nextVersion.toString()\r\n\t\t\t\t} else if (isFinite(this.readyState)) {\r\n\t\t\t\t\t// will un-invalidate this later (contextualizedVariable.readyState = 'up-to-date')\r\n\t\t\t\t} else if ((this.listeners && this.readyState === 'up-to-date' || this.staysUpdated) && this.cachedVersion > -1) {\r\n\t\t\t\t\t// it is live, so we can shortcut and just return the cached value\r\n\t\t\t\t\tif (context) {\r\n\t\t\t\t\t\tcontext.setVersion(this.cachedVersion)\r\n\t\t\t\t\t\tif (context.ifModifiedSince >= this.cachedVersion && !this.returnedVariable) {\r\n\t\t\t\t\t\t\treturn NOT_MODIFIED\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn this.promise || this.cachedValue\r\n\t\t\t\t}\r\n\t\t\t\t/*if (!this.hasOwnProperty('source1') && context) {\r\n\t\t\t\t\t// TODO: Not sure if this is a helpful optimization or not\r\n\t\t\t\t\t// if we have a single source, we can use ifModifiedSince\r\n\t\t\t\t\tif (!contextualizedVariable && this.context && this.context.matches(context)) {\r\n\t\t\t\t\t\t\tcontextualizedVariable = this\r\n\t\t\t\t\t\t}\r\n\t\t\t\t}*/\r\n\t\t\t\tvar readyState = this.readyState\r\n\t\t\t\tvar parentContext = context\r\n\t\t\t\tvar transformContext = context = context ? context.newContext() : new Context()\r\n\t\t\t\tvar args = []\r\n\t\t\t\tvar isAsyncInputs\r\n\t\t\t\ttry {\r\n\t\t\t\t\tif (this.version) {\r\n\t\t\t\t\t\t// get the version in there\r\n\t\t\t\t\t\ttransformContext.setVersion(this.version)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (this && this.cachedVersion >= this.version && this.cachedVersion > -1 && !this.hasOwnProperty('source1')) {\r\n\t\t\t\t\t\ttransformContext.ifModifiedSince = this.cachedVersion\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// TODO: var hasCustomTransformFunction = this.transform && this.transform.value === ObjectValueOf\r\n\t\t\t \t\tvar transform = this.transform && this.transform.valueOf()\r\n\t\r\n\t\t\t\t\tvar argument, argumentName, lastPromiseResult, resolved = []\r\n\t\t\t\t\tvar afterPromiseResolved\r\n\t\t\t\t\tvar remaining = 1\r\n\t\t\t\t\tvar variable = this\r\n\t\t\t\t\tvar whenArgumentResolved = function(result) {\r\n\t\t\t\t\t\tresolved[this.__index || 0] = result\r\n\t\t\t\t\t\tremaining--\r\n\t\t\t\t\t\tif(remaining === 0) {\r\n\t\t\t\t\t\t\treturn whenAllResolved()\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\treturn this.__previousPromiseResult\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfor (var i = 0; (argument = this[argumentName = i > 0 ? 'source' + i : 'source']) || argumentName in this; i++) {\r\n\t\t\t\t\t\tif (argument) {\r\n\t\t\t\t\t\t\tvar result = argument.valueOf(true)\r\n\t\t\t\t\t\t\tif (result && result.then) {\r\n\t\t\t\t\t\t\t\tremaining++\r\n\t\t\t\t\t\t\t\tif (i === 0) {\r\n\t\t\t\t\t\t\t\t\tlastPromiseResult = result.then(whenArgumentResolved)\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tlastPromiseResult = result.then(whenArgumentResolved.bind({\r\n\t\t\t\t\t\t\t\t\t\t__index: i,\r\n\t\t\t\t\t\t\t\t\t\t__previousPromiseResult: lastPromiseResult\r\n\t\t\t\t\t\t\t\t\t}))\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tresolved[i] = result\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tresolved[i] = argument\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (--remaining === 0) {\r\n\t\t\t\t\t\treturn whenAllResolved()\r\n\t\t\t\t\t\t// everything resolved, fast path\r\n\t\t\t\t\t}\r\n\t\t\t\t\tisAsyncInputs = true\r\n\t\t\t\t\tfunction whenAllResolved() {\r\n\t\t \t\t\t\tif (transformContext.ifModifiedSince !== undefined) {\r\n\t\t \t\t\t\t\ttransformContext.ifModifiedSince = undefined\r\n\t\t \t\t\t\t}\r\n\t\t\t\t\t\tvar version = transformContext.version\r\n\t\t\t\t\t\tif (variable.cachedVersion >= version || resolved[0] == NOT_MODIFIED) { // note that cached version can get \"ahead\" of `version` of all dependencies, in cases where the transform ends up executing an valueOf() that advances the resolution context version number. \r\n\t\t\t\t\t\t\t// get it out of the cache\r\n\t\t\t\t\t\t\tif (parentContext) {\r\n\t\t\t\t\t\t\t\tparentContext.setVersion(version)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (parentContext && parentContext.ifModifiedSince >= version &&\r\n\t\t\t\t\t\t\t\t\tparentContext.ifModifiedSince >= variable.cachedVersion &&\r\n\t\t\t\t\t\t\t\t\t!variable.returnedVariable) {\r\n\t\t\t\t\t\t\t\treturn NOT_MODIFIED\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn variable.promise || promiseSafeResult(variable.cachedValue)\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tvar result = transform ? transform.apply(variable, resolved) : resolved[0]\r\n\t\t\t\t\t\tvar isPromise = result && result.then && !result.notifies\r\n\t\t\t\t\t\tversion = transformContext.version\r\n\t\r\n\t\t\t\t\t\tif (isPromise) {\r\n\t\t\t\t\t\t\tvar promise = variable.promise = result\r\n\t\t\t\t\t\t\tvariable.cachedVersion = version\r\n\t\t\t\t\t\t\tresult = result.then(function(resolved) {\r\n\t\t\t\t\t\t\t\tif (promise === variable.promise) { // make sure we are still the latest promise\r\n\t\t\t\t\t\t\t\t\tvariable.promise = null\r\n\t\t\t\t\t\t\t\t\tonResolve(resolved, transformContext.version)\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\treturn resolved\r\n\t\t\t\t\t\t\t}, function(error) {\r\n\t\t\t\t\t\t\t\tif (promise === variable.promise) { // make sure we are still the latest promise\r\n\t\t\t\t\t\t\t\t\t// clear out the cache on an error\r\n\t\t\t\t\t\t\t\t\tvariable.promise = null\r\n\t\t\t\t\t\t\t\t\tvariable.lastError = error\r\n\t\t\t\t\t\t\t\t\tonResolve(null, -1)\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tthrow error // rethrow so it isn't silenced\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tonResolve(result, version)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn promiseSafeResult(result)\r\n\t\r\n\t\t\t\t\t\tfunction promiseSafeResult(result) {\r\n\t\t\t\t\t\t\tif (isAsyncInputs && result && result.notifies) {\r\n\t\t\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\t\t\t__variable: result\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn result\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfunction onResolve(result, version) {\r\n\t\t\t\t\t\t\tif (variable.readyState === readyState) {\r\n\t\t\t\t\t\t\t\tif (parentContext) {\r\n\t\t\t\t\t\t\t\t\tparentContext.setVersion(version)\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tvariable.readyState = (variable.listeners || variable.staysUpdated || parentContext && parentContext.notifies) ? 'up-to-date' : '' // mark it as up-to-date now\r\n\t\t\t\t\t\t\t\tvariable.cachedVersion = version\r\n\t\t\t\t\t\t\t\tvariable.cachedValue = result\r\n\t\t\t\t\t\t\t}/* else {\r\n\t\t\t\t\t\t\t\tconsole.log('ready state different than when the variable trasnform started ', variable, variable.readyState, readyState)\r\n\t\t\t\t\t\t\t}*/\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn lastPromiseResult\r\n\t\t\t\t} finally {\r\n\t\t\t\t\tif (parentContext) {\r\n\t\t\t\t\t\tparentContext.setVersion(transformContext.version)\r\n\t\t\t\t\t}\r\n\t\t \t\t\tcontext = parentContext\r\n\t\t \t\t}\r\n\t\t \t},\r\n\t\r\n\t\t\tforDependencies: function(callback) {\r\n\t\t\t\t// depend on the args\r\n\t\t\t\tVariable.prototype.forDependencies.call(this, callback)\r\n\t\t\t\tvar argument, argumentName\r\n\t\t\t\tfor (var i = 0; (argument = this[argumentName = i > 0 ? 'source' + i : 'source']) || argumentName in this; i++) {\r\n\t\t\t\t\tif (argument && argument.notifies) {\r\n\t\t\t\t\t\tcallback(argument)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\r\n\t\t\tupdated: function(updateEvent, by, isDownstream) {\r\n\t\t\t\tthis.readyState = 'invalidated'\r\n\t\t\t\tif (this.promise) {\r\n\t\t\t\t\tthis.promise = null\r\n\t\t\t\t}\r\n\t\t\t\tif (by !== this.returnedVariable && updateEvent && updateEvent.type !== 'refresh') {\r\n\t\t\t\t\t// search for the output in the sources\r\n\t\t\t\t\tvar argument, argumentName\r\n\t\t\t\t\tfor (var i = 0; (argument = this[argumentName = i > 0 ? 'source' + i : 'source']) || argumentName in this; i++) {\r\n\t\t\t\t\t\tif (argument === by) {\r\n\t\t\t\t\t\t\t// if one of the args was updated, we need to do a full refresh (we can't compute differential events without knowledge of how the mapping function works)\r\n\t\t\t\t\t\t\tupdateEvent = new RefreshEvent()\r\n\t\t\t\t\t\t\tcontinue\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn Variable.prototype.updated.call(this, updateEvent, by, isDownstream)\r\n\t\t\t},\r\n\t\r\n\t\t\tcleanup: function() {\r\n\t\t\t\tif (this.readyState === 'up-to-date' && !this.staysUpdated) {\r\n\t\t\t\t\tthis.readyState = '' // once there are no listeners, we can't guarantee we are up-to-date\r\n\t\t\t\t}\r\n\t\t\t\tVariable.prototype.cleanup.call(this)\r\n\t\t\t},\r\n\t\r\n\t\t\tgetUpdates: function(since) {\r\n\t\t\t\t// this always issues updates, nothing incremental can flow through it\r\n\t\t\t\tif (!since || since.version < getVersion()) {\r\n\t\t\t\t\treturn [new RefreshEvent()]\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\r\n\t\t\tgetArguments: function() {\r\n\t\t\t\tvar args = []\r\n\t\t\t\tvar argument, argumentName\r\n\t\t\t\tfor (var i = 0; (argument = this[argumentName = i > 0 ? 'source' + i : 'source']) || argumentName in this; i++) {\r\n\t\t\t\t\targs.push(argument)\r\n\t\t\t\t}\r\n\t\t\t\treturn args\r\n\t\t\t},\r\n\t\t\tput: function(value, event) {\r\n\t\t\t\tvar call = this\r\n\t\t\t\treturn when(this.valueOf(true), function(originalValue) {\r\n\t\t\t\t\tif (originalValue === value && typeof value != 'object') {\r\n\t\t\t\t\t\treturn noChange\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar transform = call.transform.valueOf()\r\n\t\t\t\t\tif (transform.reverse) {\r\n\t\t\t\t\t\t(transform.reverse).call(call, value, call.getArguments())\r\n\t\t\t\t\t\tcall.updated(event)\r\n\t\t\t\t\t} else if (originalValue && originalValue.put) {\r\n\t\t\t\t\t\treturn originalValue.put(value, event)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tvar error = new Error('Can not put value into a one-way transform, that lacks a reversal')\r\n\t\t\t\t\t\terror.deniedPut = true\r\n\t\t\t\t\t\tthrow error\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tsetReverse: function(reverse) {\r\n\t\t\t\tthis.transform.valueOf().reverse = reverse\r\n\t\t\t\treturn this\r\n\t\t\t}\r\n\t\t})\r\n\t\tObject.defineProperty(Transform.prototype, 'isWritable', {\r\n\t\t\tget: function() {\r\n\t\t\t\treturn this.transform && !!this.transform.reverse\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\tvar RESOLUTION_UPDATE = {}\r\n\t\t\tWhileResolving = lang.compose(Transform, function WhileResolving(variable, defaultValue, useLastValue) {\r\n\t\t\tthis.source = variable\r\n\t\t\tif (defaultValue !== undefined) {\r\n\t\t\t\tthis.default = defaultValue\r\n\t\t\t}\r\n\t\t\tif (useLastValue) {\r\n\t\t\t\tthis.useLastValue = true\r\n\t\t\t}\r\n\t\t}, {\r\n\t\t\tfixed: true,\r\n\t\t\tgetValue: function() {\r\n\t\t\t\tvar result = Transform.prototype.getValue.call(this)\r\n\t\t\t\tif (result && result.then) {\r\n\t\t\t\t\tvar version = this.version\r\n\t\t\t\t\tvar variable = this\r\n\t\t\t\t\tresult.then(function(value) {\r\n\t\t\t\t\t\tif (version === variable.version) {\r\n\t\t\t\t\t\t\tVariable.prototype.updated.call(variable)\r\n\t\t\t\t\t\t\tvariable.cachedVersion = variable.version\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}, function (error) {\r\n\t\t\t\t\t\tconsole.error('Variable resolution failed', error)\r\n\t\t\t\t\t})\r\n\t\t\t\t\treturn this.useLastValue && 'cachedValue' in this ? this.cachedValue : this.default\r\n\t\t\t\t}\r\n\t\t\t\treturn result\r\n\t\t\t},\r\n\t\t\tput: function(value, event) {\r\n\t\t\t\treturn this.source.put(value, event)\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\tvar ContextualTransform = lang.compose(Transform, function ContextualTransform() {\r\n\t\t\tTransform.apply(this, arguments)\r\n\t\t}, {\r\n\t\t\tgetValue: function() {\r\n\t\t\t\t// first check to see if we have the variable already computed\r\n\t\t\t\tvar contextualizedVariable = context ? context.getContextualized(this) : this\r\n\t\t\t\tif (contextualizedVariable && contextualizedVariable !== this) {\r\n\t\t\t\t\treturn contextualizedVariable.getValue()\r\n\t\t\t\t}\r\n\t\t\t\treturn Transform.prototype.getValue.call(this)\r\n\t\t\t},\r\n\t\t\t_needsContextualization: true\r\n\t\t})\r\n\t\r\n\t\tvar Item = lang.compose(Variable, function Item(value, content) {\r\n\t\t\tthis.value = value\r\n\t\t\tthis.collection = content\r\n\t\t}, {})\r\n\t\r\n\t\tvar ContextualizedVariable = lang.compose(Variable, function ContextualizedVariable(generic, subject) {\r\n\t\t\tthis.generic = generic\r\n\t\t\tthis.subject = subject\r\n\t\t}, {\r\n\t\t\tvalueOf: function() {\r\n\t\t\t\t// TODO: Lookup Context type for all of these using registry or something\r\n\t\t\t\tvar subject = this.subject\r\n\t\t\t\tvar context = subject.getContextualized ? subject : new Context(subject)\r\n\t\t\t\tvar generic = this.generic\r\n\t\t\t\treturn context.executeWithin(function() {\r\n\t\t\t\t\treturn generic.valueOf()\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\r\n\t\t\tforDependencies: function(callback) {\r\n\t\t\t\tthis.sources && this.sources.forEach(callback)\r\n\t\t\t},\r\n\t\r\n\t\t\tgetVersion: function() {\r\n\t\t\t\tvar version = Variable.prototype.getVersion.call(this)\r\n\t\t\t\tvar sources = this.sources || 0\r\n\t\t\t\tfor (var i = 0, l = sources.length; i < l; i++) {\r\n\t\t\t\t\tvar source = sources[i]\r\n\t\t\t\t\tif (source.getFullVersion) {\r\n\t\t\t\t\t\tversion = Math.max(version, source.getFullVersion())\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn version\r\n\t\t\t},\r\n\t\r\n\t\t\tput: function(value, event) {\r\n\t\t\t\tvar subject = this.subject\r\n\t\t\t\treturn this.generic.put(value, event)\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\tvar VArray = Variable.VArray = lang.compose(Variable, function VArray(value) {\r\n\t\t\treturn makeSubVar(this, value, VArray)\r\n\t\t}, {\r\n\t\t\t_isStrictArray: true,\r\n\t\t\t/* TODO: at some point, we might add support for length, but need to make it be dependent/notified by array changes\r\n\t\t\tget length() {\r\n\t\t\t\tif (typeof this !== 'function') {\r\n\t\t\t\t\tObject.defineProperty(this, 'length', {\r\n\t\t\t\t\t\tconfigurable: true\r\n\t\t\t\t\t})\r\n\t\t\t\t\treturn this.property('length')\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tset length(length) {\r\n\t\t\t\t// allow overriding\r\n\t\t\t\tObject.defineProperty(this, 'length', {\r\n\t\t\t\t\tvalue: length\r\n\t\t\t\t})\r\n\t\t\t},*/\r\n\t\t\tproperty: function(key, PropertyClass) {\r\n\t\t\t\treturn Variable.prototype.property.call(this, key, PropertyClass || typeof key === 'number' && this.collectionOf)\r\n\t\t\t},\r\n\t\t\tsplice: function(startingIndex, removalCount) {\r\n\t\t\t\tvar args = arguments\r\n\t\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\t\tif (startingIndex < 0) {\r\n\t\t\t\t\t\tstartingIndex = array.length + startingIndex\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar results = array.splice.apply(array, args)\r\n\t\t\t\t\tvar event = removedAt(this, results, startingIndex, removalCount, array.length)\r\n\t\t\t\t\tevent = insertedAt(this, [].slice.call(args, 2), startingIndex, array.length, event)\r\n\t\t\t\t\treturn [results, event]\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tpush: function() {\r\n\t\t\t\tvar args = arguments\r\n\t\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\t\tvar results = array.push.apply(array, args)\r\n\t\t\t\t\tvar event = insertedAt(this, args, array.length - args.length, array.length)\r\n\t\t\t\t\treturn [results, event]\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tunshift: function() {\r\n\t\t\t\tvar args = arguments\r\n\t\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\t\tvar results = array.unshift.apply(array, args)\r\n\t\t\t\t\tvar event = insertedAt(this, args, 0, array.length)\r\n\t\t\t\t\treturn [results, event]\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tpop: function() {\r\n\t\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\t\tvar results = array.pop()\r\n\t\t\t\t\tvar event = removedAt(this, [results], array.length, 1)\r\n\t\t\t\t\treturn [results, event]\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tshift: function() {\r\n\t\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\t\tvar results = array.shift()\r\n\t\t\t\t\tvar event = removedAt(this, [results], 0, 1, array.length)\r\n\t\t\t\t\treturn [results, event]\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t})\r\n\t\tVArray.of = function(collectionOf) {\r\n\t\t\tvar ArrayClass = VArray({collectionOf: collectionOf})\r\n\t\t\tif (this !== VArray) {\r\n\t\t\t\t// new operator\r\n\t\t\t\treturn new ArrayClass()\r\n\t\t\t}\r\n\t\t\treturn ArrayClass\r\n\t\t}\r\n\t\r\n\t\tfunction toArray(array) {\r\n\t\t\tif (!array) {\r\n\t\t\t\treturn []\r\n\t\t\t}\r\n\t\t\tif (array.length > -1) {\r\n\t\t\t\treturn array\r\n\t\t\t}\r\n\t\t\tvar newArray = []\r\n\t\t\tif (array.forEach) {\r\n\t\t\t\tarray.forEach(function(item) {\r\n\t\t\t\t\tnewArray.push(item)\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\treturn newArray\r\n\t\t}\r\n\t\r\n\t\tvar getValue\r\n\t\tvar GeneratorVariable = lang.compose(Transform, function ReactiveGenerator(generator){\r\n\t\t\tthis.generator = generator\r\n\t\t}, {\r\n\t\t\ttransform: {\r\n\t\t\t\tvalueOf: function() {\r\n\t\t\t\t\tvar generatorContext = context\r\n\t\t\t\t\tvar resuming\r\n\t\t\t\t\treturn next\r\n\t\t\t\t\tfunction next() {\r\n\t\t\t\t\t\tvar nextValue\r\n\t\t\t\t\t\tvar i\r\n\t\t\t\t\t\tvar generatorIterator\r\n\t\t\t\t\t\tvar isThrowing\r\n\t\t\t\t\t\tif (resuming) {\r\n\t\t\t\t\t\t\t// resuming from a promise\r\n\t\t\t\t\t\t\tgeneratorIterator = resuming.iterator\r\n\t\t\t\t\t\t\ti = resuming.i\r\n\t\t\t\t\t\t\tnextValue = resuming.value\r\n\t\t\t\t\t\t\tif (nextValue && nextValue.then) {\r\n\t\t\t\t\t\t\t\tthrow new Error('Generator resumed with promise or variable', nextValue)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tisThrowing = resuming.isThrowing\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tif (generatorContext) {\r\n\t\t\t\t\t\t\t\t// must restart the context, if the input values had previously been checked and hashed against this context, must restart them.\r\n\t\t\t\t\t\t\t\tgeneratorContext.restart()\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\ti = 0\r\n\t\t\t\t\t\t\tgeneratorIterator = this.generator()\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\tvar stepReturn = generatorIterator[isThrowing ? 'throw' : 'next'](nextValue)\r\n\t\t\t\t\t\t\tif (stepReturn.done) {\r\n\t\t\t\t\t\t\t\tvar oldSources = this.sources || []\r\n\t\t\t\t\t\t\t\tvar newLength = i\r\n\t\t\t\t\t\t\t\tvar newSources = []\r\n\t\t\t\t\t\t\t\twhile(this[argumentName = i > 0 ? 'source' + i : 'source']) {\r\n\t\t\t\t\t\t\t\t\t// clear out old properties\r\n\t\t\t\t\t\t\t\t\tthis[argumentName] = undefined\r\n\t\t\t\t\t\t\t\t\ti++\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tfor (i = 0; i < newLength; i++) {\r\n\t\t\t\t\t\t\t\t\t// create new array\r\n\t\t\t\t\t\t\t\t\tvar argumentName = i > 0 ? 'source' + i : 'source'\r\n\t\t\t\t\t\t\t\t\tif (this[argumentName] && this[argumentName].notifies) {\r\n\t\t\t\t\t\t\t\t\t\tnewSources.push(this[argumentName])\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tfor (i = 0; i < oldSources.length; i++) {\r\n\t\t\t\t\t\t\t\t\tif (newSources.indexOf(oldSources[i]) == -1) {\r\n\t\t\t\t\t\t\t\t\t\toldSources[i].stopNotifies(this)\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tthis.sources = newSources\r\n\t\t\t\t\t\t\t\treturn stepReturn.value\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tnextValue = stepReturn.value\r\n\t\t\t\t\t\t\t// compare with the arguments from the last\r\n\t\t\t\t\t\t\t// execution to see if they are the same\r\n\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\tvar argumentName = i > 0 ? 'source' + i : 'source'\r\n\t\t\t\t\t\t\t\tif (this[argumentName] !== nextValue || this[argumentName] === undefined) {\r\n\t\t\t\t\t\t\t\t\t// subscribe if it is a variable\r\n\t\t\t\t\t\t\t\t\tif (nextValue && nextValue.notifies) {\r\n\t\t\t\t\t\t\t\t\t\tif (this.listeners) {\r\n\t\t\t\t\t\t\t\t\t\t\tnextValue.notifies(this)\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tthis[argumentName] = nextValue\r\n\t\t\t\t\t\t\t\t\t} else if (typeof nextValue === 'function' && isGenerator(nextValue)) {\r\n\t\t\t\t\t\t\t\t\t\tresuming = {\r\n\t\t\t\t\t\t\t\t\t\t\ti: i,\r\n\t\t\t\t\t\t\t\t\t\t\titerator: nextValue()\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tnext.call(this)\r\n\t\t\t\t\t\t\t\t\t\ti = resuming.i\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\tthis[argumentName] = null\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\ti++\r\n\t\t\t\t\t\t\t\tif (nextValue && nextValue.then) {\r\n\t\t\t\t\t\t\t\t\t// if it is a promise or variable, we will wait on it\r\n\t\t\t\t\t\t\t\t\tvar variable = this\r\n\t\t\t\t\t\t\t\t\tresuming = {\r\n\t\t\t\t\t\t\t\t\t\ti: i,\r\n\t\t\t\t\t\t\t\t\t\titerator: generatorIterator\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tvar isSync = null\r\n\t\t\t\t\t\t\t\t\t// and return the promise so that the next caller can wait on this\r\n\t\t\t\t\t\t\t\t\tvar promise = nextValue.then(function(value) {\r\n\t\t\t\t\t\t\t\t\t\tif (isSync !== false) {\r\n\t\t\t\t\t\t\t\t\t\t\tisSync = true\r\n\t\t\t\t\t\t\t\t\t\t\tnextValue = value\r\n\t\t\t\t\t\t\t\t\t\t\treturn\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tresuming.value = value\r\n\t\t\t\t\t\t\t\t\t\tif (generatorContext) {\r\n\t\t\t\t\t\t\t\t\t\t\treturn generatorContext.executeWithin(next.bind(variable))\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\treturn next.call(variable)\r\n\t\t\t\t\t\t\t\t\t}, function(error) {\r\n\t\t\t\t\t\t\t\t\t\tresuming.value = error\r\n\t\t\t\t\t\t\t\t\t\tresuming.isThrowing = true\r\n\t\t\t\t\t\t\t\t\t\tif (generatorContext) {\r\n\t\t\t\t\t\t\t\t\t\t\treturn generatorContext.executeWithin(next.bind(variable))\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\treturn next.call(variable)\r\n\t\t\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\t\t\tif (!isSync) {\r\n\t\t\t\t\t\t\t\t\t\tisSync = false\r\n\t\t\t\t\t\t\t\t\t\treturn promise\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tisThrowing = false\r\n\t\t\t\t\t\t\t} catch (error) {\r\n\t\t\t\t\t\t\t\tisThrowing = true\r\n\t\t\t\t\t\t\t\tnextValue = error\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} while(true)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\tvar Validating = lang.compose(Transform, function(source) {\r\n\t\t\tthis.source = source\r\n\t\t}, {\r\n\t\t\ttransform: function(target) {\r\n\t\t\t\tvar target = this.source\r\n\t\t\t\treturn target && target.validate(target, target.schema)\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\tfunction makeSubVar(instance, value, Type) {\r\n\t\t\tif (instance instanceof Variable) {\r\n\t\t\t\tVariable.call(instance, value)\r\n\t\t\t} else {\r\n\t\t\t\treturn Type.with(value)\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction objectUpdated(object) {\r\n\t\t\t// simply notifies any subscribers to an object, that it has changed\r\n\t\t\tvar listeners = propertyListenersMap.get(object)\r\n\t\t\tif (listeners) {\r\n\t\t\t\tfor (var i = 0, l = listeners.length; i < l; i++) {\r\n\t\t\t\t\tlisteners[i]._propertyChange(null, object)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tvar argsToArray = {\r\n\t\t\tapply: function(instance, args) {\r\n\t\t\t\treturn args\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction all(array, transform) {\r\n\t\t\t// This is intended to mirror Promise.all. It actually takes\r\n\t\t\t// an iterable, but for now we are just looking for array-like\r\n\t\t\tif (array instanceof Array) {\r\n\t\t\t\tif (array.length > 1000) {\r\n\t\t\t\t\t //throw new Error('too big')\r\n\t\t\t\t}\r\n\t\t\t\tif (array.length > 0 || typeof transform === 'function') {\r\n\t\t\t\t\t// TODO: Return VArray Transform\r\n\t\t\t\t\treturn new Transform(array[0], typeof transform === 'function' ? transform : argsToArray, array)\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn new VArray([])\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (arguments.length > 1) {\r\n\t\t\t\t// support multiple arguments as an array\r\n\t\t\t\treturn new Transform(arguments[0], argsToArray, arguments).as(VArray)\r\n\t\t\t}\r\n\t\t\tif (typeof array === 'object') {\r\n\t\t\t\t// allow an object as a hash to be mapped\r\n\t\t\t\tvar keyMapping = []\r\n\t\t\t\tvar valueArray = []\r\n\t\t\t\tfor (var key in array) {\r\n\t\t\t\t\tkeyMapping.push(key)\r\n\t\t\t\t\tvalueArray.push(array[key])\r\n\t\t\t\t}\r\n\t\t\t\treturn new Variable(function(results) {\r\n\t\t\t\t\tvar resultObject = {}\r\n\t\t\t\t\tfor (var i = 0; i < results.length; i++) {\r\n\t\t\t\t\t\tresultObject[keyMapping[i]] = results[i]\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn resultObject\r\n\t\t\t\t}).apply(null, valueArray)\r\n\t\t\t}\r\n\t\t\tthrow new TypeError('Variable.all requires an array')\r\n\t\t}\r\n\t\r\n\t\tfunction hasOwn(Target, createForInstance) {\r\n\t\r\n\t\t\tvar ownedClasses = this.ownedClasses || (this.ownedClasses = new lang.WeakMap())\r\n\t\t\t// TODO: assign to super classes\r\n\t\t\tvar Class = this\r\n\t\t\townedClasses.set(Target, createForInstance || function() { return new Target() })\r\n\t\t\treturn this\r\n\t\t}\r\n\t\tfunction generalizeClass() {\r\n\t\t\tvar prototype = this.prototype\r\n\t\t\tvar prototypeNames = Object.getOwnPropertyNames(prototype)\r\n\t\t\tfor(var i = 0, l = prototypeNames.length; i < l; i++) {\r\n\t\t\t\tvar name = prototypeNames[i]\r\n\t\t\t\tObject.defineProperty(this, name, getGeneralizedDescriptor(Object.getOwnPropertyDescriptor(prototype, name), name, this))\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction getGeneralizedDescriptor(descriptor, name, Class) {\r\n\t\t\tif (typeof descriptor.value === 'function') {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tvalue: generalizeMethod(Class, name)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\treturn descriptor\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction generalizeMethod(Class, name) {\r\n\t\t\t// I think we can just rely on `this`, but we could use the argument:\r\n\t\t\t// function(possibleEvent) {\r\n\t\t\t// \tvar target = possibleEvent && possibleEvent.target\r\n\t\t\tvar method = Class[name] = function() {\r\n\t\t\t\tvar instance = Class.for(this)\r\n\t\t\t\treturn instance[name].apply(instance, arguments)\r\n\t\t\t}\r\n\t\t\tmethod.for = function(context) {\r\n\t\t\t\tvar instance = Class.for(context)\r\n\t\t\t\treturn function() {\r\n\t\t\t\t\treturn instance[name].apply(instance, arguments)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn method\r\n\t\t}\r\n\t\r\n\t\tvar defaultContext = {\r\n\t\t\tname: 'Default context',\r\n\t\t\tdescription: 'This object is the default context for classes, corresponding to a singleton instance of that class',\r\n\t\t\tconstructor: {\r\n\t\t\t\tgetForClass: function(subject, Class) {\r\n\t\t\t\t\treturn Class.defaultInstance\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tcontains: function() {\r\n\t\t\t\treturn true // contains everything\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction instanceForContext(Class, context) {\r\n\t\t\tif (!context) {\r\n\t\t\t\treturn Class.defaultInstance\r\n\t\t\t}\r\n\t\t\tvar instance = context.specify(Class)\r\n\t\t\tif (!context.instanceMap) {\r\n\t\t\t\tcontext.instanceMap = new Map()\r\n\t\t\t}\r\n\t\t\tcontext.instanceMap.set(Class, instance)\r\n\t\t\treturn instance\r\n\t//\t\tvar instance = context.subject.constructor.getForClass && context.subject.constructor.getForClass(context.subject, Class) || Class.defaultInstance\r\n\t//\t\tcontext.distinctSubject = mergeSubject(context.distinctSubject, instance.subject)\r\n\t//\t\treturn instance\r\n\t\t}\r\n\t\tVariable.valueOf = function(allowPromise) {\r\n\t\t\t// contextualized valueOf\r\n\t\t\treturn instanceForContext(this, context).valueOf(allowPromise)\r\n\t\t}\r\n\t\tVariable.then = function(callback, errback) {\r\n\t\t\t// contextualized valueOf\r\n\t\t\treturn instanceForContext(this, context).then(callback, errback)\r\n\t\t}\r\n\t\tVariable.getValue = function() {\r\n\t\t\t// contextualized getValue\r\n\t\t\treturn instanceForContext(this, context)\r\n\t\t}\r\n\t\tVariable.put = function(value) {\r\n\t\t\t// contextualized setValue\r\n\t\t\treturn instanceForContext(this, context).put(value)\r\n\t\t}\r\n\t\tVariable.for = function(subject) {\r\n\t\t\tif (subject != null) {\r\n\t\t\t\tif (subject.target && !subject.constructor.getForClass) {\r\n\t\t\t\t\t// makes HTML events work\r\n\t\t\t\t\tsubject = subject.target\r\n\t\t\t\t}\r\n\t\t\t\tvar instance\r\n\t\t\t\tinstance = new Context(subject).specify(this)\r\n\t\t\t\tif (instance && !instance.subject) {\r\n\t\t\t\t\tinstance.subject = subject\r\n\t\t\t\t}\r\n\t\t\t\t// TODO: Do we have a global context that we set on defaultInstance?\r\n\t\t\t\treturn instance || this.defaultInstance\r\n\t\t\t} else {\r\n\t\t\t\treturn this.defaultInstance\r\n\t\t\t}\r\n\t\t}\r\n\t\tVariable.from = function(value) {\r\n\t\t\tif (value && typeof value === 'object') {\r\n\t\t\t\t// a plain object, we use our own map to retrieve the instance (or create one)\r\n\t\t\t\tvar instanceMap = this.instanceMap || (this.instanceMap = new lang.WeakMap())\r\n\t\t\t\tvar instance = instanceMap.get(value)\r\n\t\t\t\tif (!instance) {\r\n\t\t\t\t\tinstanceMap.set(value, instance = new this(value))\r\n\t\t\t\t}\r\n\t\t\t\treturn instance\r\n\t\t\t} else {\r\n\t\t\t\t// a primitive, just unconditionally create a new variable for it\r\n\t\t\t\treturn new this(value)\r\n\t\t\t}\r\n\t\t}\r\n\t\tVariable.notifies = function(target) {\r\n\t\t\tvar instance = instanceForContext(this, context)\r\n\t\t\tinstance.notifies(target)\r\n\t\t\treturn instance\r\n\t\t}\r\n\t\tVariable.stopNotifies = function(target) {\r\n\t\t\tthis.defaultInstance.stopNotifies(target)\r\n\t\t}\r\n\t\tVariable.getCollectionOf = function () {\r\n\t\t\treturn this.collectionOf\r\n\t\t}\r\n\t\tVariable.updated = function(updateEvent, by) {\r\n\t\t\treturn instanceForContext(this, context).updated(updateEvent, by)\r\n\t\t}\r\n\t\tVariable._Transform = ContextualTransform\r\n\t\tvar proxyHandler = {\r\n\t\t\tget: function(target, name) {\r\n\t\t\t\tvar value = target[name]\r\n\t\t\t\treturn value === undefined ? target.property(name) : value\r\n\t\t\t},\r\n\t\t\tset: function(target, name, value) {\r\n\t\t\t\tvar oldValue = target[name]\r\n\t\t\t\tif (oldValue && oldValue.put) {\r\n\t\t\t\t\t// own property available to put into\r\n\t\t\t\t\toldValue.put(value)\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttarget.set(name, value)\r\n\t\t\t\t}\r\n\t\t\t\treturn true\r\n\t\t\t},\r\n\t\t\thas: function(target, name) {\r\n\t\t\t\treturn (name in target) || (name in target.valueOf())\r\n\t\t\t},\r\n\t\t\tdeleteProperty: function(target, name) {\r\n\t\t\t\treturn proxyHandler.set(target, name, undefined)\r\n\t\t\t},\r\n\t\t\townKeys: function(target) {\r\n\t\t\t\treturn Object.getOwnPropertyNames(target.valueOf())\r\n\t\t\t}\r\n\t\t}\r\n\t\tVariable.proxy = function(source) {\r\n\t\t\t// should we memoize?\r\n\t\t\treturn new Proxy(source instanceof this ? source : this.from(source), proxyHandler)\r\n\t\t}\r\n\t\tObject.defineProperty(Variable, 'collectionOf', {\r\n\t\t\tget: function() {\r\n\t\t\t\treturn this._collectionOf\r\n\t\t\t},\r\n\t\t\tset: function(ItemClass) {\r\n\t\t\t\tif (this._collectionOf != ItemClass) {\r\n\t\t\t\t\tthis._collectionOf = ItemClass\r\n\t\t\t\t\tItemClass.collection = this\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t\tObject.defineProperty(Variable, 'collection', {\r\n\t\t\tget: function() {\r\n\t\t\t\treturn this._collection\r\n\t\t\t},\r\n\t\t\tset: function(Collection) {\r\n\t\t\t\tif (this._collection != Collection) {\r\n\t\t\t\t\tthis._collection = Collection\r\n\t\t\t\t\tCollection.collectionOf = this\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t\tVariable.nextVersion = Date.now()\r\n\t\tVariable.generalize = generalizeClass\r\n\t\tVariable.call = Function.prototype.call // restore these\r\n\t\tVariable.apply = Function.prototype.apply\r\n\t\r\n\t\tfunction VFunction() {\r\n\t\t}\r\n\t\t(VFunction.returns = function(Type){\r\n\t\t\tfunction VFunction() {}\r\n\t\t\tVFunction.defineAs = function(method)\t{\r\n\t\t\t\treturn {\r\n\t\t\t\t\tvalue: function() {\r\n\t\t\t\t\t\tvar args = arguments\r\n\t\t\t\t\t\t// TODO: make these args part of the call so variables can be resolved\r\n\t\t\t\t\t\t// TODO: may actually want to do getValue().invoke()\r\n\t\t\t\t\t\treturn new Type(new Transform(this, function(value) {\r\n\t\t\t\t\t\t\t\treturn value == null ? undefined : value[method].apply(value, args)\r\n\t\t\t\t\t\t}))\r\n\t\t\t\t\t},\r\n\t\t\t\t\twritable: true,\r\n\t\t\t\t\tconfigurable: true\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn VFunction\r\n\t\t})\r\n\t\r\n\t\tfunction VMethod() {\r\n\t\t}\r\n\t\tVMethod.defineAs = function(method) {\r\n\t\t\treturn {\r\n\t\t\t\tvalue: function() {\r\n\t\t\t\t\tvar args = arguments\r\n\t\t\t\t\t// TODO: make these args part of the call so variables can be resolved\r\n\t\t\t\t\t// TODO: may actually want to do getValue().invoke()\r\n\t\t\t\t\tvar variable = this\r\n\t\t\t\t\treturn when(this.valueOf(), function(value) {\r\n\t\t\t\t\t\tvar returnValue = value[method].apply(value, args)\r\n\t\t\t\t\t\treturn when(variable.put(value), function() {\r\n\t\t\t\t\t\t\treturn returnValue\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t})\r\n\t\t\t\t},\r\n\t\t\t\twritable: true,\r\n\t\t\t\tconfigurable: true\t\t\t\r\n\t\t\t}\t\t\r\n\t\t}\r\n\t\r\n\t\tfunction VString(value) {\r\n\t\t\treturn makeSubVar(this, (typeof value === 'object' || value == null) ? value : String(value), VString)\r\n\t\t}\r\n\t\r\n\t\tfunction VNumber(value) {\r\n\t\t\treturn makeSubVar(this, typeof value === 'object' ? value : Number(value), VNumber)\r\n\t\t}\r\n\t\t\r\n\t\tVString = Variable.with({\r\n\t\t\tcharAt: VFunction.returns(VString),\r\n\t\t\tcodeCharAt: VFunction.returns(VNumber),\r\n\t\t\tindexOf: VFunction.returns(VNumber),\r\n\t\t\tlastIndexOf: VFunction.returns(VNumber),\r\n\t\t\tmatch: VFunction.returns(VArray),\r\n\t\t\treplace: VFunction.returns(VString),\r\n\t\t\tsubstr: VFunction.returns(VString),\r\n\t\t\tslice: VFunction.returns(VString),\r\n\t\t\ttoUpperCase: VFunction.returns(VString),\r\n\t\t\ttoLowerCase: VFunction.returns(VString),\r\n\t\t\tlength: VNumber\r\n\t\t}, VString)\r\n\t\r\n\t\tVNumber = Variable.with({\r\n\t\t\ttoFixed: VFunction.returns(VString),\r\n\t\t\ttoExponential: VFunction.returns(VString),\r\n\t\t\ttoPrecision: VFunction.returns(VString),\r\n\t\t\ttoLocaleString: VFunction.returns(VString)\r\n\t\t}, VNumber)\r\n\t\r\n\t\tfunction VBoolean(value) {\r\n\t\t\treturn makeSubVar(this, typeof value === 'object' ? value : Boolean(value), VBoolean)\r\n\t\t}\r\n\t\tVBoolean = Variable.with({}, VBoolean)\r\n\t\r\n\t\tfunction VSet(value) {\r\n\t\t\treturn makeSubVar(this, value instanceof Array ? new lang.Set(value) : value, VSet)\r\n\t\t}\r\n\t\tVSet = Variable.with({\r\n\t\t\thas: VFunction.returns(VBoolean),\r\n\t\t\tadd: VMethod,\r\n\t\t\tclear: VMethod,\r\n\t\t\tdelete: VMethod\r\n\t\t}, VSet)\r\n\t\tObject.defineProperty(VSet.prototype, 'array', {\r\n\t\t\tget: function() {\r\n\t\t\t\treturn this._array || (this._array = this.to(toArray).as(VArray))\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\tfunction VDate(value) {\r\n\t\t\treturn makeSubVar(this, typeof value === 'object' ? value : new Date(value), VDate)\r\n\t\t}\r\n\t\tVDate = Variable.with({\r\n\t\t\ttoDateString: VFunction.returns(VString),\r\n\t\t\ttoTimeString: VFunction.returns(VString),\r\n\t\t\ttoGMTString: VFunction.returns(VString),\r\n\t\t\ttoUTCString: VFunction.returns(VString),\r\n\t\t\tgetTime: VFunction.returns(VNumber),\r\n\t\t\tsetTime: VMethod\r\n\t\t}, VDate)\r\n\t\r\n\t\tvar VPromise = lang.compose(Variable, function VPromise(value) {\r\n\t\t\treturn makeSubVar(this, value, VPromise)\r\n\t\t}, {\r\n\t\t\tvalueOf: function() {\r\n\t\t\t\treturn this.then()\r\n\t\t\t},\r\n\t\t})\r\n\t\tvar exports = {\r\n\t\t\t__esModule: true,\r\n\t\t\tVariable: Variable,\r\n\t\t\tVArray: VArray,\r\n\t\t\tdefault: Variable,\r\n\t\t\tVString: VString,\r\n\t\t\tVNumber: VNumber,\r\n\t\t\tVBoolean: VBoolean,\r\n\t\t\tVPromise: VPromise,\r\n\t\t\tVDate: VDate,\r\n\t\t\tVSet: VSet,\r\n\t\t\tVMap: VMap,\r\n\t\t\tGeneratorVariable: GeneratorVariable,\r\n\t\t\tTransform: Transform,\r\n\t\t\tdeny: deny,\r\n\t\t\tnoChange: noChange,\r\n\t\t\tContext: Context,\r\n\t\t\tItem: Item,\r\n\t\t\tNotifyingContext: NotifyingContext,\r\n\t\t\tall: all,\r\n\t\t\treact: react,\r\n\t\t\tobjectUpdated: objectUpdated,\r\n\t\t\tNOT_MODIFIED: NOT_MODIFIED\r\n\t\t}\r\n\t\tObject.defineProperty(exports, 'currentContext', {\r\n\t\t\tget: function() {\r\n\t\t\t\treturn context\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\tvar IterativeMethod = lang.compose(Transform, function(source, method, args) {\r\n\t\t\tthis.source = source\r\n\t\t\t// source.interestWithin = true\r\n\t\t\tthis.method = method\r\n\t\t\tthis.arguments = args\r\n\t\t}, {\r\n\t\t\ttransform: function(array) {\r\n\t\t\t\tvar method = this.method\r\n\t\t\t\tvar isStrictArray = this.source && this.source._isStrictArray\r\n\t\t\t\tif (array && array.forEach) {\r\n\t\t\t\t\t// already an array\r\n\t\t\t\t\t//array = this._mappedItems(array)\r\n\t\t\t\t} else if (isStrictArray) {\r\n\t\t\t\t\tarray = []\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// if not an array convert to an array\r\n\t\t\t\t\tarray = [array]\r\n\t\t\t\t}\r\n\t\t\t\tif (typeof method === 'string') {\r\n\t\t\t\t\t// apply method\r\n\t\t\t\t\treturn array[method].apply(array, this.arguments)\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn method(array, this.arguments)\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\t_mappedItems: function(array) {\r\n\t\t\t\tvar source = this.source\r\n\t\t\t\tvar collectionOf = source && source.collectionOf\r\n\t\t\t\treturn collectionOf ? array.map(function(item, i) {\r\n\t\t\t\t\tvar wrapped = collectionOf.from(item)\r\n\t\t\t\t\twrapped.collection = source\r\n\t\t\t\t\treturn wrapped\r\n\t\t\t\t}) : array\r\n\t\t\t},\r\n\t\r\n\t\t\tgetCollectionOf: function(){\r\n\t\t\t\treturn this.source.getCollectionOf()\r\n\t\t\t},\r\n\t\t\t_isStrictArray: true\r\n\t\t})\r\n\t\r\n\t\tfunction defineArrayMethod(method, constructor, properties, returns) {\r\n\t\t\tvar IterativeResults = lang.compose(returns ? returns.as(IterativeMethod) : IterativeMethod, constructor, properties)\r\n\t\t\tIterativeResults.prototype.method || (IterativeResults.prototype.method = method)\r\n\t\t\tObject.defineProperty(IterativeResults.prototype, 'isIterable', {value: true});\r\n\t\t\tVArray[method] = VArray.prototype[method] = function() {\r\n\t\t\t\tvar results = new IterativeResults(this)\r\n\t\t\t\tresults.source = this\r\n\t\t\t\tresults.arguments = arguments\r\n\t\t\t\treturn results\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tdefineArrayMethod('filter', function Filtered() {}, {\r\n\t\t\tupdated: function(event, by, isDownstream) {\r\n\t\t\t\tif (!event || event.modifier === this || (event.modifier && event.modifier.constructor === this)) {\r\n\t\t\t\t\treturn Transform.prototype.updated.call(this, event, by)\r\n\t\t\t\t}\r\n\t\t\t\tvar contextualizedVariable = context && context.getContextualized(this) || this\r\n\t\t\t\tif (event.type === 'array-update') {\r\n\t\t\t\t\tfor (var i = 0, l = event.actions.length; i < l; i++) {\r\n\t\t\t\t\t\tvar action = event.actions[i]\r\n\t\t\t\t\t\tif (action.oldValue) {\r\n\t\t\t\t\t\t\tvar index = contextualizedVariable.cachedValue.indexOf(event.oldValue)\r\n\t\t\t\t\t\t\tif (index > -1) {\r\n\t\t\t\t\t\t\t\tcontextualizedVariable.splice(index, 1)\r\n\t\t\t\t\t\t\t}\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (action.value) {\r\n\t\t\t\t\t\t\tif ([event.value].filter(this.arguments[0]).length > 0) {\r\n\t\t\t\t\t\t\t\tcontextualizedVariable.push(event.value)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (event.type === 'update') {\r\n\t\t\t\t\tvar object = event.parent.valueOf()\r\n\t\t\t\t\tvar index = contextualizedVariable.cachedValue.indexOf(object)\r\n\t\t\t\t\tvar matches = [object].filter(this.arguments[0]).length > 0\r\n\t\t\t\t\tif (index > -1) {\r\n\t\t\t\t\t\tif (matches) {\r\n\t\t\t\t\t\t\treturn new PropertyChangeEvent(index, event, contextualizedVariable.cachedValue,\r\n\t\t\t\t\t\t\t\t// might need to do something with this\r\n\t\t\t\t\t\t\t\tobject)\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tcontextualizedVariable.splice(index, 1)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\telse {\r\n\t\t\t\t\t\tif (matches) {\r\n\t\t\t\t\t\t\tcontextualizedVariable.push(object)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// else nothing mactches\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn Transform.prototype.updated.call(this, event, by, isDownstream)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}, VArray)\r\n\t\tdefineArrayMethod('map', function Mapped(source) {\r\n\t\t\tthis._isStrictArray = source._isStrictArray\r\n\t\t}, {\r\n\t\t\ttransform: function(array) {\r\n\t\t\t\tvar isStrictArray = this.source && this.source._isStrictArray\r\n\t\t\t\tvar mapFunction = this.arguments[0]\r\n\t\t\t\tif (array && array.map) {\r\n\t\t\t\t\tvar source = this.source\r\n\t\t\t\t\tvar collectionOf = source && source.collectionOf\r\n\t\t\t\t\treturn array.map(collectionOf ? function(item, i) {\r\n\t\t\t\t\t\treturn mapFunction(source.property(i), i)\r\n\t\t\t\t\t} : mapFunction)\r\n\t\t\t\t} else if (!isStrictArray) {\r\n\t\t\t\t\tif (method === 'map'){\r\n\t\t\t\t\t\t// fast path, and special behavior for map\r\n\t\t\t\t\t\treturn mapFunction(array)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn IterativeMethod.prototype.transform.call(this, array)\r\n\t\t\t},\r\n\t\t\tupdated: function(event, by, isDownstream) {\r\n\t\t\t\tif (!event || event.modifier === this || (event.modifier && event.modifier.constructor === this)) {\r\n\t\t\t\t\treturn Variable.prototype.updated.call(this, event, by)\r\n\t\t\t\t}\r\n\t\t\t\tvar contextualizedVariable = context && context.getContextualized(this) || this\r\n\t\t\t\tif (event.type === 'array-update') {\r\n\t\t\t\t\tfor (var i = 0, l = event.actions.length; i < l; i++) {\r\n\t\t\t\t\t\tvar action = event.actions[i]\r\n\t\t\t\t\t\tif (action.previousIndex > -1) {\r\n\t\t\t\t\t\t\tcontextualizedVariable.splice(action.previousIndex, 1)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (action.value) {\r\n\t\t\t\t\t\t\tvar array = contextualizedVariable.cachedValue\r\n\t\t\t\t\t\t\tcontextualizedVariable.push(this.arguments[0].call(this.arguments[1], this.source.property(array && array.length)))\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t/*\t\t\tif (event.type === 'delete') {\r\n\t\t\t\t\tcontextualizedVariable.splice(event.previousIndex, 1)\r\n\t\t\t\t} else if (event.type === 'add') {\r\n\t\t\t\t\tvar array = contextualizedVariable.cachedValue\r\n\t\t\t\t\tcontextualizedVariable.push(this.arguments[0].call(this.arguments[1], this.source.property(array && array.length)))*/\r\n\t\t\t\t} else if (event.type === 'update') {\r\n\t\t\t\t\tif (this.getCollectionOf()) {\r\n\t\t\t\t\t\treturn // if it has typed items, we don't need to propagate update events, since they will be handled by the variable item.\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar object = event.parent.valueOf()\r\n\t\t\t\t\tvar array = contextualizedVariable.cachedValue\r\n\t\t\t\t\tvar index = event.key\r\n\t\t\t\t\tvar value = event.value\r\n\t\t\t\t\tif (index > -1) {\r\n\t\t\t\t\t\t// update was to an index property of this array variable\r\n\t\t\t\t\t\tvalue = object[index]\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// update was inside an object inside of our array\r\n\t\t\t\t\t\tindex = array && array.map && array.indexOf(object)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (index > -1) {\r\n\t\t\t\t\t\tcontextualizedVariable.splice(index, 1, this.arguments[0].call(this.arguments[1], this.source.property(index)))\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn Transform.prototype.updated.call(this, event, by, isDownstream)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn Transform.prototype.updated.call(this, event, by, isDownstream)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}, VArray)\r\n\t\tdefineArrayMethod('reduce', function Reduced() {})\r\n\t\tdefineArrayMethod('reduceRight', function Reduced() {})\r\n\t\tdefineArrayMethod('some', function Aggregated() {}, {}, VBoolean)\r\n\t\tdefineArrayMethod('every', function Aggregated() {}, {}, VBoolean)\r\n\t\tdefineArrayMethod('slice', function Aggregated() {}, {}, VArray)\r\n\t\tdefineArrayMethod('keyBy', function UniqueIndex(source, args) {}, {\r\n\t\t\tproperty: VMap.prototype.property,\r\n\t\t\tmethod: function(array, args) {\r\n\t\t\t\tvar index = new Map()\r\n\t\t\t\tvar keyGenerator = args[0]\r\n\t\t\t\tvar valueGenerator = args[1]\r\n\t\t\t\tvar hasKeyFunction = typeof keyGenerator === 'function'\r\n\t\t\t\tvar hasValueFunction = typeof valueGenerator === 'function'\r\n\t\t\t\tvar hasKey = !!keyGenerator\r\n\t\t\t\tfor (var i = 0, l = array.length; i < l; i++) {\r\n\t\t\t\t\tvar element = array[i]\r\n\t\t\t\t\tindex.set(\r\n\t\t\t\t\t\thasKeyFunction ? keyGenerator(element, emit) :\r\n\t\t\t\t\t\t\thasKey ? element[keyGenerator] : element,\r\n\t\t\t\t\t\thasValueFunction ? valueGenerator(element) : element)\r\n\t\t\t\t}\r\n\t\t\t\tfunction emit(key, value) {\r\n\t\t\t\t\tindex.set(key, value)\r\n\t\t\t\t}\r\n\t\t\t\treturn index\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\tdefineArrayMethod('groupBy', function UniqueIndex(source, args) {}, {\r\n\t\t\tproperty: VMap.prototype.property,\r\n\t\t\tmethod: function(array, args) {\r\n\t\t\t\tvar index = new Map()\r\n\t\t\t\tvar keyGenerator = args[0]\r\n\t\t\t\tvar valueGenerator = args[1]\r\n\t\t\t\tvar hasKeyFunction = typeof keyGenerator === 'function'\r\n\t\t\t\tvar hasValueFunction = typeof valueGenerator === 'function'\r\n\t\t\t\tvar hasKey = !!keyGenerator\r\n\t\t\t\tfor (var i = 0, l = array.length; i < l; i++) {\r\n\t\t\t\t\tvar element = array[i]\r\n\t\t\t\t\tvar key = hasKeyFunction ? keyGenerator(element) :\r\n\t\t\t\t\t\t\thasKey ? element[keyGenerator] : element\r\n\t\t\t\t\tvar group = index.get(key)\r\n\t\t\t\t\tif (!group) {\r\n\t\t\t\t\t\tindex.set(key, group = [])\r\n\t\t\t\t\t}\r\n\t\t\t\t\tgroup.push(hasValueFunction ? valueGenerator(element) : element)\r\n\t\t\t\t}\r\n\t\t\t\tfunction emit(key, value) {\r\n\t\t\t\t\tvar group = index.get(key)\r\n\t\t\t\t\tif (!group) {\r\n\t\t\t\t\t\tindex.set(key, group = [])\r\n\t\t\t\t\t}\r\n\t\t\t\t\tgroup.push(value)\r\n\t\t\t\t}\r\n\t\t\t\treturn index\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\tvar getGeneratorDescriptor = Variable.getGeneratorDescriptor = function(value) {\r\n\t\t\tvar variables\r\n\t\t\treturn {\r\n\t\t\t\tget: function() {\r\n\t\t\t\t\tif (!variables) {\r\n\t\t\t\t\t\t variables = new lang.WeakMap()\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar variable = variables.get(this)\r\n\t\t\t\t\tif (!variable) {\r\n\t\t\t\t\t\tvariables.set(this, variable = new GeneratorVariable(value.bind(this)))\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn variable\r\n\t\t\t\t},\r\n\t\t\t\tenumerable: true\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction react(generator, options) {\r\n\t\t\tif (typeof generator !== 'function') {\r\n\t\t\t\tthrow new Error('react() must be called with a generator.')\r\n\t\t\t}\r\n\t\t\tif (options && options.reverse) {\r\n\t\t\t\tgenerator.reverse = options.reverse\r\n\t\t\t}\r\n\t\t\treturn new GeneratorVariable(generator)\r\n\t\t}\r\n\t\r\n\t\tVariable.all = all\r\n\t\tVariable.Context = Context\r\n\t\r\n\t\treturn exports\r\n\t}))\r\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) { if (true) {\r\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(6), __webpack_require__(4)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) } else if (typeof module === 'object' && module.exports) {\t\t\t\t\r\n\t\tmodule.exports = factory(require('./util/lang'), require('./operators'), require('./Variable')) // Node\r\n\t}}(this, function (lang, operators, VariableExports) {\r\n\t\r\n\t\tvar Transform = VariableExports.Transform\r\n\t\tvar Variable = VariableExports.Variable\r\n\t\tvar VArray = VariableExports.VArray\r\n\t\tvar isGenerator = lang.isGenerator\r\n\t\tvar ObjectTransform = lang.compose(Transform, function ObjectTransform(source, transform, sources) {\r\n\t\t\tthis.sources = sources\r\n\t\t\tTransform.apply(this, arguments)\r\n\t\t}, {\r\n\t\t\t_getAsObject: function() {\r\n\t\t\t\treturn this.transform.apply(this, preserveObjects(this.sources))\r\n\t\t\t}\r\n\t\t})\r\n\t\tfunction preserveObjects(sources) {\r\n\t\t\tfor (var i = 0, l = sources.length; i < l; i++) {\r\n\t\t\t\tvar source = sources[i]\r\n\t\t\t\tif (source && source._getAsObject) {\r\n\t\t\t\t\tsources[i] = source._getAsObject()\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn sources\r\n\t\t}\r\n\t\r\n\t\tvar reactive = {\r\n\t\t\tfrom: function(value, options) {\r\n\t\t\t\tif (value && value.property) {\r\n\t\t\t\t\treturn value\r\n\t\t\t\t}\r\n\t\t\t\tif (typeof value === 'function' && isGenerator(value)) {\r\n\t\t\t\t\treturn VariableExports.react(value, options)\r\n\t\t\t\t}\r\n\t\t\t\treturn Variable.from(value)\r\n\t\t\t},\r\n\t\t\tgetp: function(object, property) {\r\n\t\t\t\tif (object) {\r\n\t\t\t\t\t// TODO: Use a static set of public methods/properties that can be accessed\r\n\t\t\t\t\tif (object.property) {\r\n\t\t\t\t\t\t// it is a variable already, but check to see if we are using a method/property directly on the variable\r\n\t\t\t\t\t\tvar directPropertyValue = object[property]\r\n\t\t\t\t\t\treturn directPropertyValue !== undefined ? directPropertyValue : object.property(property)\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn object[property]\r\n\t\t\t\t}\r\n\t\t\t\t// not even truthy, return undefined\r\n\t\t\t},\r\n\t\t\tget: function(target, key, Type) { // for babel decorators\r\n\t\t\t\tvar property = (target._properties || (target._properties = {}))[key]\r\n\t\t\t\tif (!property) {\r\n\t\t\t\t\ttarget._properties[key] = property = new (getType(Type))()\r\n\t\t\t\t\tif (target.getValue) {\r\n\t\t\t\t\t\tproperty.key = key\r\n\t\t\t\t\t\tproperty.parent = target\r\n\t\t\t\t\t\tif (property.listeners) {\r\n\t\t\t\t\t\t\t// if it already has listeners, need to reinit it with the parent\r\n\t\t\t\t\t\t\tproperty.init()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn property\r\n\t\t\t},\r\n\t\t\tset: function(target, key, value) {\r\n\t\t\t\tvar property = target[key]\r\n\t\t\t\tproperty.parent ? property._changeValue(3, value) : property.put(value)\r\n\t\t\t},\r\n\t\t\tprop: function(Type) {\r\n\t\t\t\treturn function(prototype, key) {\r\n\t\t\t\t\tdefineProperty(prototype, key, Type)\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tcond: function(test, consequent, alternate) {\r\n\t\t\t\treturn operators.if(test, operators.choose(consequent, alternate))\r\n\t\t\t},\r\n\t\t\tfcall: function(target, args) {\r\n\t\t\t\tif (target.property && typeof target === 'function') {\r\n\t\t\t\t\treturn target.apply(null, preserveObjects(args))\r\n\t\t\t\t}\r\n\t\t\t\treturn new Transform(args[0], target, args)\r\n\t\t\t},\r\n\t\t\tmcall: function(target, key, args) {\r\n\t\t\t\tvar method = target[key]\r\n\t\t\t\tif (typeof method === 'function' && method.property || key === 'bind') {\r\n\t\t\t\t\t// for now we check to see if looks like it could handle a variable, or is a bind call\r\n\t\t\t\t\treturn method.apply(target, preserveObjects(args))\r\n\t\t\t\t}\r\n\t\t\t\treturn new Transform(args[0], target[key].bind(target), args)\r\n\t\t\t},\r\n\t\t\tncall: function(target, args) {\r\n\t\t\t\tif (target.property && typeof target === 'function') {\r\n\t\t\t\t\treturn new (target.bind.apply(target, [null].concat(preserveObjects(args))))()\r\n\t\t\t\t}\r\n\t\t\t\treturn new Transform(args[0], function() {\r\n\t\t\t\t\treturn new (target.bind.apply(target, [null].concat(arguments)))()\r\n\t\t\t\t}, args)\r\n\t\t\t},\r\n\t\r\n\t\t\tobj: function(sources) {\r\n\t\t\t\treturn sources\r\n\t\t\t\t//return new ObjectTransform(sources[0], transform, sources)\r\n\t\t\t},\r\n\t\r\n\t\t\tval: function(value) {\r\n\t\t\t\treturn value && value.valueOf()\r\n\t\t\t},\r\n\t\t\tcls: function(definitions) {\r\n\t\t\t\treactive = this // TODO: clean this up\r\n\t\t\t\treturn function(Class) {\r\n\t\t\t\t\tvar prototype = Class.prototype\r\n\t\t\t\t\tif (!(prototype instanceof Variable)) {\r\n\t\t\t\t\t\tif (Object.getPrototypeOf(prototype) == Object.prototype) {\r\n\t\t\t\t\t\t\tObject.setPrototypeOf(Class, Variable)\r\n\t\t\t\t\t\t\tObject.setPrototypeOf(prototype, Variable.prototype)\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tconsole.warn('Unable to make class a reactive variable')\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfor (var key in definitions) {\r\n\t\t\t\t\t\tdefineProperty(prototype, key, definitions[key])\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tlang.copy(reactive, operators)\r\n\t\r\n\t\tvar typeMappings = new Map()\r\n\t\ttypeMappings.set('string', VariableExports.VString)\r\n\t\ttypeMappings.set('number', VariableExports.VNumber)\r\n\t\ttypeMappings.set('boolean', VariableExports.VBoolean)\r\n\t\ttypeMappings.set(Array, VArray)\r\n\t\ttypeMappings.set(Map, VariableExports.VMap)\r\n\t\ttypeMappings.set(Set, VariableExports.VSet)\r\n\t\tfunction getType(Type) {\r\n\t\t\tif (typeMappings.has(Type)) {\r\n\t\t\t\treturn typeMappings.get(Type)\r\n\t\t\t} else if (typeof Type === 'object') {\r\n\t\t\t\tif (Type instanceof Array) {\r\n\t\t\t\t\treturn VArray.of(getType(Type[0]))\r\n\t\t\t\t}\r\n\t\t\t\tvar typedObject = {}\r\n\t\t\t\tfor (var key in Type) {\r\n\t\t\t\t\ttypedObject[key] = getType(Type[key])\r\n\t\t\t\t}\r\n\t\t\t\treturn Variable.with(typedObject)\r\n\t\t\t}\r\n\t\t\treturn Type\r\n\t\t}\r\n\t\r\n\t\tfunction defineProperty(target, key, Type) {\r\n\t\t\tif (!Type) {\r\n\t\t\t\tconsole.warn('Invalid type specified for', target && target.constructor.name, 'property', key, '(ensure you are using a concrete type, not an interface)')\r\n\t\t\t} else if (!Type.notifies) {\r\n\t\t\t\tType = getType(Type) || Variable\r\n\t\t\t}\r\n\t\t\tObject.defineProperty(target, key, {\r\n\t\t\t\tget: function() {\r\n\t\t\t\t\treturn reactive.get(this, key, Type)\r\n\t\t\t\t},\r\n\t\t\t\tset: function(value) {\r\n\t\t\t\t\treactive.set(this, key, value)\r\n\t\t\t\t},\r\n\t\t\t\tenumerable: true\r\n\t\t\t})\r\n\t\t}\r\n\t\r\n\t\treturn reactive\r\n\t}))\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) { if (true) {\r\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(4)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) } else if (typeof module === 'object' && module.exports) {        \r\n\t  module.exports = factory(require('./Variable')) // Node\r\n\t}}(this, function (VariableExports) {\r\n\t\r\n\t\tvar VBoolean = VariableExports.VBoolean\r\n\t\tvar VNumber = VariableExports.VNumber\r\n\t\tvar operatingFunctions = {};\r\n\t\tvar operators = {};\r\n\t\tfunction getOperatingFunction(expression){\r\n\t\t\t// jshint evil: true\r\n\t\t\treturn operatingFunctions[expression] ||\r\n\t\t\t\t(operatingFunctions[expression] =\r\n\t\t\t\t\tnew Function('a', 'b', 'return ' + expression));\r\n\t\t}\r\n\t\tfunction operator(operator, type, name, precedence, forward, reverseA, reverseB){\r\n\t\t\t// defines the standard operators\r\n\t\t\tvar reverse = function(output, inputs){\r\n\t\t\t\tvar a = inputs[0],\r\n\t\t\t\t\tb = inputs[1]\r\n\t\t\t\tvar firstError\r\n\t\t\t\tif(a && a.put){\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\treturn a.put(reverseA(output, b && b.valueOf()))\r\n\t\t\t\t\t} catch(error) {\r\n\t\t\t\t\t\tif (error.deniedPut) {\r\n\t\t\t\t\t\t\tfirstError = error\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthrow error\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif(b && b.put){\r\n\t\t\t\t\tb.put(reverseB(output, a && a.valueOf()))\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow (firstError && firstError.message ? firstError : new Error('Can not assign change value to constant operators'))\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\t// define a function that can lazily ensure the operating function\r\n\t\t\t// is available\r\n\t\t\tvar operatorHandler = {\r\n\t\t\t\tapply: function(instance, args){\r\n\t\t\t\t\tforward = getOperatingFunction(forward);\r\n\t\t\t\t\treverseA = reverseA && getOperatingFunction(reverseA);\r\n\t\t\t\t\treverseB = reverseB && getOperatingFunction(reverseB);\r\n\t\t\t\t\tforward.reverse = reverse;\r\n\t\t\t\t\toperators[operator] = operatorHandler = new VariableExports.Variable(forward);\r\n\t\r\n\t\t\t\t\taddFlags(operatorHandler);\r\n\t\t\t\t\targs = Array.prototype.slice.call(args);\r\n\t\t\t\t\treturn operatorHandler.apply(instance, args);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\tfunction addFlags(operatorHandler){\r\n\t\t\t\toperatorHandler.precedence = precedence;\r\n\t\t\t\toperatorHandler.infix = reverseB !== false;\r\n\t\t\t}\r\n\t\t\taddFlags(operatorHandler);\r\n\t\t\toperators[operator] = operatorHandler;\r\n\t\t\toperators[name] = function() {\r\n\t\t\t\tvar result = operatorHandler.apply(null, arguments)\r\n\t\t\t\treturn type ? result.as(type) : result\r\n\t\t\t}\r\n\t\t}\r\n\t\t// using order precedence from:\r\n\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence\r\n\t\toperator('+', VNumber, 'add', 6, 'a+b', 'a-b', 'a-b');\r\n\t\toperator('-', VNumber, 'subtract', 6, 'a-b', 'a+b', 'b-a');\r\n\t\toperator('*', VNumber, 'multiply', 5, 'a*b', 'a/b', 'a/b');\r\n\t\toperator('/', VNumber, 'divide', 5, 'a/b', 'a*b', 'b/a');\r\n\t//\toperator('^', 7, 'a^b', 'a^(-b)', 'Math.log(a)/Math.log(b)');\r\n\t\toperator('?', null, 'if', 16, 'b[a?0:1]', 'a===b[0]||(a===b[1]?false:(function(){throw new Error()})())', '[a,b]');\r\n\t\toperator(':', null, 'choose', 15, '[a,b]', 'a[0]?a[1]:(function(){throw new Error()})()', 'a[1]');\r\n\t\toperator('!', VBoolean, 'not', 4, '!a', '!a', false);\r\n\t\toperator('%', VNumber, 'remainder', 5, 'a%b');\r\n\t\toperator('>', VBoolean, 'greater', 8, 'a>b');\r\n\t\toperator('>=', VBoolean, 'greaterOrEqual', 8, 'a>=b');\r\n\t\toperator('<', VBoolean, 'less', 8, 'a<b');\r\n\t\toperator('<=', VBoolean, 'lessOrEqual', 8, 'a<=b');\r\n\t\toperator('===', VBoolean, 'strictEqual', 9, 'a===b');\r\n\t\toperator('==', VBoolean, 'equal', 9, 'a==b');\r\n\t\toperator('&', VBoolean, 'and', 8, 'a&&b');\r\n\t\toperator('|', VBoolean, 'or', 8, 'a||b');\r\n\t\toperator('round', 'round', 8, 'Math.round(a*Math.pow(10,b||1))/Math.pow(10,b||1)', 'a', 'a');\r\n\t\treturn operators;\r\n\t}))\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) { if (true) {\r\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(4)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) } else if (typeof module === 'object' && module.exports) {        \r\n\t  module.exports = factory(require('./util/lang'), require('./Variable')) // Node\r\n\t}}(this, function (lang, VariableExports) {\r\n\t\tvar Variable = VariableExports.Variable\r\n\t\t\r\n\t\tfunction deepCopy(source, target, derivativeMap) {\r\n\t\t\tif (source && typeof source == 'object') {\r\n\t\t\t\tif (source instanceof Array) {\r\n\t\t\t\t\ttarget = [] // always create a new array for array targets\r\n\t\t\t\t\tfor(var i = 0, l = source.length; i < l; i++) {\r\n\t\t\t\t\t\ttarget[i] = deepCopy(source[i], null, derivativeMap)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (!target || typeof target !== 'object') {\r\n\t\t\t\t\t\ttarget = derivativeMap && derivativeMap.get(source)\r\n\t\t\t\t\t\tif (!target) {\r\n\t\t\t\t\t\t\ttarget = {}\r\n\t\t\t\t\t\t\tderivativeMap && derivativeMap.set(source, target)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfor (var i in source) {\r\n\t\t\t\t\t\ttarget[i] = deepCopy(source[i], target[i], derivativeMap)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn target\r\n\t\t\t}\r\n\t\t\treturn source\r\n\t\t}\r\n\t\r\n\t\tvar Copy = lang.compose(Variable, function(copiedFrom) {\r\n\t\t\t// this is the variable that we derive from\r\n\t\t\tthis.copiedFrom = copiedFrom\r\n\t\t\tthis.derivativeMap = new lang.WeakMap(null, 'derivative')\r\n\t\t\tthis.isDirty = new Variable(false)\r\n\t\t}, {\r\n\t\t\tgetValue: function(sync, forModification, forChild) {\r\n\t\t\t\tif(this.state) {\r\n\t\t\t\t\tthis.state = null\r\n\t\t\t\t}\r\n\t\t\t\tvar value = this.copiedFrom.valueOf()\r\n\t\t\t\tif(value && typeof value == 'object') {\r\n\t\t\t\t\tvar derivative = this.derivativeMap.get(value)\r\n\t\t\t\t\tif (derivative == null) {\r\n\t\t\t\t\t\tthis.derivativeMap.set(value, derivative = deepCopy(value, undefined, this.derivativeMap))\r\n\t\t\t\t\t\tthis.setValue(derivative)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif(this.value === undefined) {\r\n\t\t\t\t\treturn value\r\n\t\t\t\t}\r\n\t\t\t\treturn Variable.prototype.getValue.call(this, sync, forModification, forChild)\r\n\t\t\t},\r\n\t\t\tgetCopyOf: function(value) {\r\n\t\t\t\tvar derivative = this.derivativeMap.get(value)\r\n\t\t\t\tif (derivative == null) {\r\n\t\t\t\t\tthis.derivativeMap.set(value, derivative = deepCopy(value, undefined, this.derivativeMap))\r\n\t\t\t\t}\r\n\t\t\t\treturn derivative\r\n\t\t\t},\r\n\t\t\tsave: function() {\r\n\t\t\t\t// copy back to the original object\r\n\t\t\t\tvar original = this.copiedFrom.valueOf()\r\n\t\t\t\tvar newCopiedFrom = deepCopy(this.valueOf(), original)\r\n\t\t\t\tif (this.copiedFrom.put) { // copiedFrom doesn't have to be a variable, it can be a plain object\r\n\t\t\t\t\t// assign it now\r\n\t\t\t\t\tthis.copiedFrom.put(newCopiedFrom)\r\n\t\t\t\t}\r\n\t\t\t\tthis.isDirty.put(false)\r\n\t\t\t\tthis.onSave && this.onSave()\r\n\t\t\t},\r\n\t\t\trevert: function() {\r\n\t\t\t\tvar original = this.copiedFrom.valueOf()\r\n\t\t\t\tthis.derivativeMap = new lang.WeakMap(null, 'derivative') // clear out the mapping, so we can start fresh\r\n\t\t\t\tthis.put(deepCopy(original, undefined, this.derivativeMap))\r\n\t\t\t\tthis.isDirty.put(false)\r\n\t\t\t},\r\n\t\t\tupdated: function() {\r\n\t\t\t\tthis.isDirty.put(true)\r\n\t\t\t\treturn Variable.prototype.updated.apply(this, arguments)\r\n\t\t\t}\r\n\t\t})\r\n\t\treturn Copy\r\n\t}))\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** index.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap bb068071d0ad95897dbb\n **/","/// <reference path=\"./typings.d.ts\" />\r\n(function (root, factory) { if (typeof define === 'function' && define.amd) {\r\n  define(['./Element', './Renderer', './reactive', './Copy', './operators', './Variable', './util/lang'], factory) } else if (typeof module === 'object' && module.exports) {        \r\n  module.exports = factory(require('./Element'), require('./Renderer'), require('./reactive'), require('./Copy'), require('./operators'), require('./Variable'), require('./util/lang')) // Node\r\n}}(this, function (Element, Renderer, reactive, Copy, operators, VariableExports, lang) {\r\n\r\n\tvar main = Object.create(Element)\r\n\tmain.Copy = Copy\r\n\tmain.Element = Element\r\n\tlang.copy(main, VariableExports)\r\n\tObject.defineProperty(main, 'currentContext', Object.getOwnPropertyDescriptor(VariableExports, 'currentContext'))\r\n\tmain.reactive = reactive\r\n\tlang.copy(main.react, reactive) // For backwards compatibility with babel transform\r\n\tmain.spawn = lang.spawn\r\n\tmain.Renderer = Renderer.ElementRenderer\r\n\tlang.copy(main, Renderer)\r\n\tlang.copy(main, operators)\r\n\tmain.default = undefined // no default export\r\n\treturn main\r\n}))\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./index.js\n ** module id = 0\n ** module chunks = 0\n **/","(function (root, factory) { if (typeof define === 'function' && define.amd) {\r\n\tdefine(['./util/lang', './Renderer', './Variable'], factory) } else if (typeof module === 'object' && module.exports) {\t\t\t\t\r\n\tmodule.exports = factory(require('./util/lang'), require('./Renderer'), require('./Variable')) // Node\r\n}}(this, function (lang, Renderer, VariableExports) {\r\n\tvar Variable = VariableExports.Variable\r\n\tvar knownElementProperties = [\r\n\t\t'textContent', // Node\r\n\t\t'id', 'className', 'innerHTML', // Element\r\n\t\t'title', 'lang', 'translate', 'dir', 'tabIndex', 'accessKey', 'draggable', 'spellcheck', 'contentEditable', 'innerText', 'webkitdropzone'] // HTMLElement\r\n\r\n\tvar SELECTOR_REGEX = /^(\\.|#)([-\\w]+)(.+)?/\r\n\tvar isGenerator = lang.isGenerator\r\n\tvar Context = VariableExports.Context\r\n\tvar PropertyRenderer = Renderer.PropertyRenderer\r\n\tvar InputPropertyRenderer = Renderer.InputPropertyRenderer\r\n\tvar AttributeRenderer = Renderer.AttributeRenderer\r\n\tvar StyleRenderer = lang.compose(Renderer.StyleRenderer, function StyleRenderer() {\r\n\t\tRenderer.StyleRenderer.apply(this, arguments)\r\n\t}, {\r\n\t\trenderUpdate: function(newValue, element) {\r\n\t\t\tvar definition = styleDefinitions[this.name]\r\n\t\t\tif (definition) {\r\n\t\t\t\tdefinition(element, newValue, this.name)\r\n\t\t\t} else {\r\n\t\t\t\telement.style[this.name] = newValue\r\n\t\t\t}\r\n\t\t}\r\n\t})\r\n\r\n\tvar construct = typeof Reflect !== 'undefined' ? Reflect.construct :\r\n\t\tfunction(Constructor, args, Class) {\r\n\t\t\treturn Constructor.apply(Object.create(Class.prototype), args)\r\n\t\t}\r\n\r\n\tvar constructOrCall = lang.constructOrCall\r\n\tvar ClassNameRenderer = lang.compose(Renderer.ElementRenderer, function ClassNameRenderer(options) {\r\n\t\tthis.name = options.name\r\n\t\tRenderer.apply(this, arguments)\r\n\t}, {\r\n\t\trenderUpdate: function(newValue, element) {\r\n\t\t\tvar currentClassName = element.className\r\n\t\t\tvar changingClassName = this.name\r\n\t\t\t// remove the className (needed for addition or removal)\r\n\t\t\t// see http://jsperf.com/remove-class-name-algorithm/2 for some tests on this\r\n\t\t\tvar removed = currentClassName && (' ' + currentClassName + ' ').replace(' ' + changingClassName + ' ', ' ')\r\n\t\t\tif (newValue) {\r\n\t\t\t\t// addition, add the className\r\n\t\t\t\tchangingClassName = currentClassName ? (removed + changingClassName).slice(1) : changingClassName;\r\n\t\t\t} else {\r\n\t\t\t\t// we already have removed the class, just need to trim\r\n\t\t\t\tchangingClassName = removed.slice(1, removed.length - 1)\r\n\t\t\t}\r\n\t\t\t// only assign if it changed, this can save a lot of time\r\n\t\t\tif (changingClassName != currentClassName) {\r\n\t\t\t\telement.className = changingClassName\r\n\t\t\t}\r\n\t\t}\r\n\t})\r\n\tvar PropertiesRenderer = lang.compose(Renderer.ElementRenderer, function PropertiesRenderer(options) {\r\n\t\tthis.PropertyRenderer = options.PropertyRenderer\r\n\t\tRenderer.apply(this, arguments)\r\n\t}, {\r\n\t\trenderUpdate: function(newValue, element) {\r\n\t\t\tvar newProperties = []\r\n\t\t\t// assign properties based on object properties\r\n\t\t\tfor (var name in newValue) {\r\n\t\t\t\tthis.PropertyRenderer.prototype.renderUpdate.call({\r\n\t\t\t\t\tname: name\r\n\t\t\t\t}, newValue[name], element)\r\n\t\t\t\tnewProperties.push(name)\r\n\t\t\t}\r\n\t\t\tvar lastProperties = this.lastProperties\r\n\t\t\tif (lastProperties) {\r\n\t\t\t\t// if previous state existed, remove old names of any properties that don't exist anymore\r\n\t\t\t\tfor (var i = 0, l = lastProperties.length; i < l; i++) {\r\n\t\t\t\t\tvar name = lastProperties[i]\r\n\t\t\t\t\tif (!(name in newValue)) {\r\n\t\t\t\t\t\tthis.PropertyRenderer.prototype.renderUpdate.call({\r\n\t\t\t\t\t\t\tname: name\r\n\t\t\t\t\t\t}, undefined, element)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.lastProperties = newProperties // store the class names if we need to remove any on next state change\r\n\t\t}\r\n\t})\r\n\r\n\t// TODO: check for renderContent with text updater\r\n\tvar TextRenderer = Renderer.TextRenderer\r\n\tvar ListRenderer = Renderer.ListRenderer\r\n\r\n\tvar doc = typeof document !== 'undefined' ? document : {\r\n\t\tcreateElement: function(tag) {\r\n\t\t\treturn {}\r\n\t\t},\r\n\t\taddEventListener: function() {\r\n\t\t}\r\n\t}\r\n\r\n\tvar inputs = {\r\n\t\tINPUT: 1,\r\n\t\tTEXTAREA: 1\r\n\t\t// SELECT: 1, we exclude this, so the default \"content\" of the element can be the options\r\n\t}\r\n\r\n\tvar buggyConstructorSetter = false\r\n\tvar testElement = doc.createElement('font')\r\n\tvar originalConstructor = testElement.constructor\r\n\ttestElement.constructor = function(){}\r\n\tif (doc.createElement('font').constructor == testElement.constructor) {\r\n\t\t// In safari, setting the constructor can actually assign it at the prototype level, instead of at the instance\r\n\t\ttestElement.__proto__.constructor = originalConstructor // restore the original constructor\r\n\t\tbuggyConstructorSetter = true\r\n\t\tlang.buggyConstructorSetter = buggyConstructorSetter\r\n\t}\r\n\r\n\r\n\tfunction booleanStyle(options) {\r\n\t\treturn function(element, value, key) {\r\n\t\t\tif (typeof value !== 'string') {\r\n\t\t\t\t// use the boolean conversion\r\n\t\t\t\tvalue = options[value ? 0 : 1]\r\n\t\t\t}\r\n\t\t\telement.style[key] = value\r\n\t\t}\r\n\t}\r\n\r\n\tfunction defaultStyle(element, value, key) {\r\n\t\tif (typeof value === 'number') {\r\n\t\t\tvalue = value + 'px'\r\n\t\t}\r\n\t\telement.style[key] = value\r\n\t}\r\n\tfunction directStyle(element, value, key) {\r\n\t\telement.style[key] = value\r\n\t}\r\n\r\n\tvar styleDefinitions = {\r\n\t\tdisplay: booleanStyle(['', 'none']),\r\n\t\tvisibility: booleanStyle(['visible', 'hidden']),\r\n\t\tcolor: directStyle,\r\n\t\topacity: directStyle,\r\n\t\tzoom: directStyle,\r\n\t\tminZoom: directStyle,\r\n\t\tmaxZoom: directStyle,\r\n\t\tfontWeight: directStyle,\r\n\t\tposition: booleanStyle(['absolute', '']),\r\n\t\ttextDecoration: booleanStyle(['underline', '']),\r\n\t\tfontWeight: directStyle // numbers are allowed here (TODO: eventually allow booleans too)\r\n\t}\r\n\t;[\"alignContent\",\"alignItems\",\"alignSelf\",\"animation\",\"animationDelay\",\"animationDirection\",\"animationDuration\",\"animationFillMode\",\"animationIterationCount\",\"animationName\",\"animationPlayState\",\"animationTimingFunction\",\"backfaceVisibility\",\"background\",\"backgroundAttachment\",\"backgroundBlendMode\",\"backgroundClip\",\"backgroundColor\",\"backgroundImage\",\"backgroundOrigin\",\"backgroundPosition\",\"backgroundPositionX\",\"backgroundPositionY\",\"backgroundRepeat\",\"backgroundRepeatX\",\"backgroundRepeatY\",\"backgroundSize\",\"baselineShift\",\"border\",\"borderBottom\",\"borderBottomColor\",\"borderBottomLeftRadius\",\"borderBottomRightRadius\",\"borderBottomStyle\",\"borderBottomWidth\",\"borderCollapse\",\"borderColor\",\"borderImage\",\"borderImageOutset\",\"borderImageRepeat\",\"borderImageSlice\",\"borderImageSource\",\"borderImageWidth\",\"borderLeft\",\"borderLeftColor\",\"borderLeftStyle\",\"borderLeftWidth\",\"borderRadius\",\"borderRight\",\"borderRightColor\",\"borderRightStyle\",\"borderRightWidth\",\"borderSpacing\",\"borderStyle\",\"borderTop\",\"borderTopColor\",\"borderTopLeftRadius\",\"borderTopRightRadius\",\"borderTopStyle\",\"borderTopWidth\",\"borderWidth\",\"bottom\",\"boxShadow\",\"boxSizing\",\"bufferedRendering\",\"captionSide\",\"clear\",\"clip\",\"clipPath\",\"clipRule\",\"color\",\"colorInterpolation\",\"colorInterpolationFilters\",\"colorRendering\",\"counterIncrement\",\"counterReset\",\"cursor\",\"direction\",\"display\",\"emptyCells\",\"fill\",\"fillOpacity\",\"fillRule\",\"filter\",\"flex\",\"flexBasis\",\"flexDirection\",\"flexFlow\",\"flexGrow\",\"flexShrink\",\"flexWrap\",\"float\",\"floodColor\",\"floodOpacity\",\"font\",\"fontFamily\",\"fontFeatureSettings\",\"fontKerning\",\"fontSize\",\"fontStretch\",\"fontStyle\",\"fontVariant\",\"fontVariantLigatures\",\"fontWeight\",\"height\",\"imageRendering\",\"isolation\",\"justifyContent\",\"left\",\"letterSpacing\",\"lightingColor\",\"lineHeight\",\"listStyle\",\"listStyleImage\",\"listStylePosition\",\"listStyleType\",\"margin\",\"marginBottom\",\"marginLeft\",\"marginRight\",\"marginTop\",\"marker\",\"markerEnd\",\"markerMid\",\"markerStart\",\"mask\",\"maskType\",\"maxHeight\",\"maxWidth\",\"maxZoom\",\"minHeight\",\"minWidth\",\"minZoom\",\"mixBlendMode\",\"motion\",\"motionOffset\",\"motionPath\",\"motionRotation\",\"objectFit\",\"objectPosition\",\"opacity\",\"order\",\"orientation\",\"orphans\",\"outline\",\"outlineColor\",\"outlineOffset\",\"outlineStyle\",\"outlineWidth\",\"overflow\",\"overflowWrap\",\"overflowX\",\"overflowY\",\"padding\",\"paddingBottom\",\"paddingLeft\",\"paddingRight\",\"paddingTop\",\"page\",\"pageBreakAfter\",\"pageBreakBefore\",\"pageBreakInside\",\"paintOrder\",\"perspective\",\"perspectiveOrigin\",\"pointerEvents\",\"position\",\"quotes\",\"resize\",\"right\",\"shapeImageThreshold\",\"shapeMargin\",\"shapeOutside\",\"shapeRendering\",\"size\",\"speak\",\"src\",\"stopColor\",\"stopOpacity\",\"stroke\",\"strokeDasharray\",\"strokeDashoffset\",\"strokeLinecap\",\"strokeLinejoin\",\"strokeMiterlimit\",\"strokeOpacity\",\"strokeWidth\",\"tabSize\",\"tableLayout\",\"textAlign\",\"textAlignLast\",\"textAnchor\",\"textCombineUpright\",\"textDecoration\",\"textIndent\",\"textOrientation\",\"textOverflow\",\"textRendering\",\"textShadow\",\"textTransform\",\"top\",\"touchAction\",\"transform\",\"transformOrigin\",\"transformStyle\",\"transition\",\"transitionDelay\",\"transitionDuration\",\"transitionProperty\",\"transitionTimingFunction\",\"unicodeBidi\",\"unicodeRange\",\"userZoom\",\"vectorEffect\",\"verticalAlign\",\"visibility\",\"whiteSpace\",\"widows\",\"width\",\"willChange\",\"wordBreak\",\"wordSpacing\",\"wordWrap\",\"writingMode\",\"zIndex\",\"zoom\"].forEach(function(property) {\r\n\t\tstyleDefinitions[property] = styleDefinitions[property] || defaultStyle\r\n\t})\r\n\tvar styleSheet\r\n\tvar presumptiveParentMap = new lang.WeakMap()\r\n\r\n\tvar setPrototypeOf = lang.setPrototypeOf\r\n\tvar getPrototypeOf = Object.getPrototypeOf || (function(base) { return base.__proto__ })\r\n\tfunction createCssRule(selector) {\r\n\t\tif (!styleSheet) {\r\n\t\t\tvar styleSheetElement = doc.createElement(\"style\")\r\n\t\t\tstyleSheetElement.setAttribute(\"type\", \"text/css\")\r\n//\t\t\tstyleSheet.appendChild(doc.createTextNode(css))\r\n\t\t\tdoc.head.insertBefore(styleSheetElement, doc.head.firstChild)\r\n\t\t\tstyleSheet = styleSheetElement.sheet\r\n\t\t}\r\n\t\tvar cssRules = styleSheet.cssRules || styleSheet.rules\r\n\t\treturn cssRules[styleSheet.addRule(selector, ' ', cssRules.length)]\r\n\t}\r\n\r\n\t// TODO: Need to do some more testing to see if that would improve performance:\r\n\t// var fragmentThresholdHeuristic = (typeof navigator !== 'undefined' && navigator.userAgent.indexOf('Chrome') > 0) ? 1 : 3\r\n\r\n\tfunction layoutChildren(parent, children, container, prepend) {\r\n\t\tvar fragment = (children.length > 1 || prepend) ? doc.createDocumentFragment() : parent\r\n\t\tfor(var i = 0, l = children.length; i < l; i++) {\r\n\t\t\tvar child = children[i]\r\n\t\t\tvar childNode\r\n\t\t\tif (child != null) { // we just skip nulls and undefined, helps make it easier to write conditional element logic\r\n\t\t\t\tif (typeof child === 'function') {\r\n\t\t\t\t\t// an element constructor\r\n\t\t\t\t\tcurrentParent = parent\r\n\t\t\t\t\tchildNode = new child()\r\n\t\t\t\t\tfragment.appendChild(childNode)\r\n\t\t\t\t\tif (child.isContentNode) {\r\n\t\t\t\t\t\tcontainer.contentNode = childNode\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (child.notifies) {\r\n\t\t\t\t\t// a variable\r\n\t\t\t\t\tvar ref = child.isIterable ? fragment : parent\r\n\t\t\t\t\tfragment.appendChild(childNode = variableAsContent(ref, child))\r\n\t\t\t\t} else if (typeof child == 'object') {\r\n\t\t\t\t\tif (child instanceof Array) {\r\n\t\t\t\t\t\t// array of sub-children\r\n\t\t\t\t\t\tcontainer = container || parent\r\n\t\t\t\t\t\tchildNode = childNode || parent\r\n\t\t\t\t\t\tlayoutChildren(childNode.contentNode || childNode, child, container)\r\n\t\t\t\t\t} else if (child.nodeType) {\r\n\t\t\t\t\t\t// an element itself\r\n\t\t\t\t\t\tfragment.appendChild(childNode = child)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// TODO: apply properties to last child, but with binding to the parent (for events)\r\n\t\t\t\t\t\tthrow new Error('Unknown child type ' + child)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// a primitive value\r\n\t\t\t\t\tchildNode = doc.createTextNode(child)\r\n\t\t\t\t\tfragment.appendChild(childNode)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (fragment != parent) {\r\n\t\t\tif (prepend) {\r\n\t\t\t\tparent.insertBefore(fragment, parent.firstChild)\r\n\t\t\t} else {\r\n\t\t\t\tparent.appendChild(fragment)\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn childNode\r\n\t}\r\n\tfunction variableAsContent(parent, content) {\r\n\t\tif (content == null) {\r\n\t\t\treturn doc.createTextNode('')\r\n\t\t}\r\n\t\tvar textNode\r\n\t\tif (content.notifies) {\r\n\t\t\ttextNode = doc.createTextNode('')\r\n\t\t\tvar renderer = new TextRenderer({\r\n\t\t\t\telement: parent,\r\n\t\t\t\ttextNode: textNode,\r\n\t\t\t\tvariable: content\r\n\t\t\t})\r\n\t\t\ttextNode = renderer.textNode // it can be swapped for another node\r\n\t\t} else {\r\n\t\t\ttextNode = doc.createTextNode(content)\r\n\t\t}\r\n\t\treturn textNode\r\n\t}\r\n\r\n\tfunction bidirectionalHandler(element, value, key) {\r\n\t\tif (value && value.notifies) {\r\n\t\t\tnew InputPropertyRenderer({\r\n\t\t\t\tname: key,\r\n\t\t\t\tvariable: value,\r\n\t\t\t\telement: element\r\n\t\t\t})\r\n\t\t\tif (inputs[element.tagName] || element.tagName === 'SELECT') {\r\n\t\t\t\tbindChanges(element, value, key)\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (element.tagName === 'SELECT' && key === 'value') {\r\n\t\t\t\t// use the deferred <select> value assignment\r\n\t\t\t\tInputPropertyRenderer.prototype.renderSelectValueUpdate(value, element)\r\n\t\t\t} else {\r\n\t\t\t\tif (element.type === 'number') {\r\n\t\t\t\t\tif (isNaN(value)) {\r\n\t\t\t\t\t\tvalue = ''\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telement[key] = value\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction noop() {}\r\n\tvar propertyHandlers = {\r\n\t\tchildren: noop,\r\n\t\ttagName: noop,\r\n\t\t_generators: noop,\r\n\t\tclasses: function(element, classes) {\r\n\t\t\tif (classes.notifies && classes.put) {\r\n\t\t\t\t// it is a variable\r\n\t\t\t\tnew PropertiesRenderer({\r\n\t\t\t\t\tPropertyRenderer: ClassNameRenderer,\r\n\t\t\t\t\telement: element,\r\n\t\t\t\t\tvariable: classes\r\n\t\t\t\t})\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tif (!(classes.length > -1)) {\r\n\t\t\t\t// index the classes, if necessary\r\n\t\t\t\tvar i = 0\r\n\t\t\t\tfor (var key in classes) {\r\n\t\t\t\t\tif (!classes[i]) {\r\n\t\t\t\t\t\tclasses[i] = key\r\n\t\t\t\t\t}\r\n\t\t\t\t\ti++\r\n\t\t\t\t}\r\n\t\t\t\tclasses.length = i\r\n\t\t\t}\r\n\t\t\tfor (var i = 0, l = classes.length; i < l; i++) {\r\n\t\t\t\t// find each class name\r\n\t\t\t\tvar className = classes[i]\r\n\t\t\t\tvar flag = classes[className]\r\n\t\t\t\tif (flag && flag.notifies) {\r\n\t\t\t\t\t// if it is a variable, we react to it\r\n\t\t\t\t\tnew ClassNameRenderer({\r\n\t\t\t\t\t\telement: element,\r\n\t\t\t\t\t\tname: className,\r\n\t\t\t\t\t\tvariable: flag\r\n\t\t\t\t\t})\r\n\t\t\t\t} else if (flag || flag === undefined) {\r\n\t\t\t\t\telement.className += ' ' + className\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tclass: applyAttribute,\r\n\t\tfor: applyAttribute, // TODO: move to label?\r\n\t\trole: applyAttribute,\r\n\t\trender: function(element, value, key, properties) {\r\n\t\t\t// TODO: This doesn't need to be a property updater (is in place for *render())\r\n\t\t\t// we should also verify it is a generator\r\n\t\t\t// and maybe, at some point, find an optimization to eliminate the bind()\r\n\t\t\tnew PropertyRenderer({\r\n\t\t\t\tname: key,\r\n\t\t\t\tvariable: typeof value === 'function' ? new VariableExports.GeneratorVariable(value.bind(element, properties)) : value, // if it was defined on the constructor, it should already be bound\r\n\t\t\t\telement: element\r\n\t\t\t})\r\n\t\t},\r\n\t\tdataset: applySubProperties(function(newValue, element, key) {\r\n\t\t\tkey = key || this.name\r\n\t\t\tif (newValue == null) {\r\n\t\t\t\tdelete element.dataset[key]\t\r\n\t\t\t} else {\r\n\t\t\t\telement.dataset[key] = newValue\r\n\t\t\t}\r\n\t\t}),\r\n\t\tattributes: applySubProperties(function(newValue, element, key) {\r\n\t\t\tAttributeRenderer.prototype.renderUpdate.call({\r\n\t\t\t\tname: key || this.name\r\n\t\t\t}, newValue, element)\r\n\t\t}),\r\n\t\tstyle: function(element, value, key) {\r\n\t\t\tif (typeof value === 'string') {\r\n\t\t\t\telement.setAttribute('style', value)\r\n\t\t\t} else if (value && value.notifies) {\r\n\t\t\t\tnew AttributeRenderer({\r\n\t\t\t\t\tname: 'style',\r\n\t\t\t\t\tvariable: value,\r\n\t\t\t\t\telement: element\r\n\t\t\t\t})\r\n\t\t\t} else {\r\n\t\t\t\tstyleObjectHandler(element, value, key)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tknownElementProperties.forEach(function(property) {\r\n\t\tpropertyHandlers[property] = true\r\n\t})\r\n\tif (typeof HTMLElement !== 'undefined') {\r\n\t\tHTMLElement.prototype._propertyHandlers = propertyHandlers // inherit this, at least for now\r\n\t}\r\n\tvar elementPropertyHandlers = {\r\n\t\tinput: lang.copy(['accept', 'alt', 'autocomplete', 'autofocus', 'capture', 'defaultChecked', 'dirName', 'disabled', 'form', 'files', 'formAction', 'formEnctype', 'formMethod', 'formNoValidate', 'formTarget', 'indeterminate', 'inputMode', 'list', 'max', 'maxLength', 'min', 'minLength', 'multiple', 'name', 'pattern', 'placeholder', 'readOnly', 'required', 'size', 'src', 'step', 'type', 'defaultValue', 'willValidate', 'validity', 'validationMessage', 'useMap', 'autocapitalize', 'webkitdirectory', 'incremental', 'stepUp', 'stepDown'], {\r\n\t\t\tvalue: bidirectionalHandler,\r\n\t\t\tvalueAsNumber: bidirectionalHandler,\r\n\t\t\tvalueAsDate: bidirectionalHandler,\r\n\t\t\tchecked: bidirectionalHandler,\r\n\t\t\ttype: function(element, value) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\telement.type = value\r\n\t\t\t\t} catch(e) {\r\n\t\t\t\t\t// IE 11 will throw an error here\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}),\r\n\t\tselect: lang.copy(['name', 'size', 'type', 'selectedIndex', 'validationMessage'], {\r\n\t\t\tvalue: bidirectionalHandler\r\n\t\t}),\r\n\t\ttextarea: lang.copy(['cols', 'dirName', 'maxLength', 'minLength', 'name', 'placeholder', 'rows', 'wrap', 'type', 'defaultValue', 'textLength', 'validationMessage', 'autocapitalize'], {\r\n\t\t\tvalue: bidirectionalHandler\r\n\t\t}),\r\n\t\ta: ['target', 'download', 'ping', 'rel', 'hreflang', 'type', 'referrerPolicy', 'href', 'media'],\r\n\t\tarea: ['target', 'download', 'coords', 'rel', 'hreflang', 'type', 'referrerPolicy', 'href', 'media', 'alt', 'shape'],\r\n\t\tbutton: ['disabled', 'formAction', 'formEnctype', 'formMethod', 'formTarget', 'name', 'type', 'value', 'validationMessage'],\r\n\t\tdialog: ['open'],\r\n\t\tembed: ['src', 'type', 'name'],\r\n\t\tform: ['acceptCharset', 'action', 'autocomplete', 'enctype', 'encoding', 'method', 'name', 'target', 'novalidate'],\r\n\t\tframe: ['name', 'scrolling', 'src', 'frameBorder'],\r\n\t\tframeset: ['cols', 'rows'],\r\n\t\tiframe: ['src', 'srcdoc', 'name', 'referrerPolicy', 'align', 'scrolling', 'frameBorder', 'longDesc'],\r\n\t\timg: ['src', 'alt', 'crossorigin', 'ismap', 'longdesc', 'sizes', 'srcset', 'usemap', 'referrerpolicy'],\r\n\t\toption: ['label', 'value', 'text', 'index'],\r\n\t\toptgroup: ['label'],\r\n\t\toutput: ['name', 'type', 'defaultValue', 'value', 'validationMessage'],\r\n\t\tlabel: ['htmlFor'],\r\n\t\ttd: ['colSpan', 'rowSpan'],\r\n\t\tth: ['colSpan', 'rowSpan'],\r\n\t\tscript: ['src', 'type', 'charset', 'text', 'event', 'htmlFor', 'integrity'],\r\n\t\tstyle: ['media', 'type'],\r\n\t\ttrack: ['kind', 'src', 'srclang', 'label'],\r\n\t\tlink: ['href', 'rel', 'media', 'hreflang', 'type', 'charset', 'rev', 'target', 'integrity', 'as'],\r\n\t\tmeta: ['name', 'httpEquiv', 'content', 'scheme'],\r\n\t\tmeter: ['value', 'min', 'max', 'low', 'high', 'optimum'],\r\n\t\tprogress: ['value', 'max', 'position'],\r\n\t\tdel: ['cite', 'dateTime'],\r\n\t\tins: ['cite', 'dateTime'],\r\n\t\tsource: ['src', 'type', 'srcset', 'sizes', 'media'],\r\n\t\tvideo: ['videoWidth', 'videoHeight', 'poster', 'webkitDecodedFrameCount', 'webkitDroppedFrameCount'],\r\n\t\tkeygen: ['challenge', 'keytype', 'name', 'type', 'validationMessage'],\r\n\t\tobject: ['data', 'type', 'name', 'useMap', 'validationMessage', 'archive', 'code', 'hspace', 'standby', 'vspace', 'codeBase', 'codeType'],\r\n\t\tparam: ['name', 'value', 'type', 'valueType']\r\n\t}\r\n\r\n\tfunction applyAttribute(element, value, key) {\r\n\t\tif (value && value.notifies) {\r\n\t\t\tnew AttributeRenderer({\r\n\t\t\t\tname: key,\r\n\t\t\t\tvariable: value,\r\n\t\t\t\telement: element\r\n\t\t\t})\r\n\t\t} else {\r\n\t\t\telement.setAttribute(key, value)\r\n\t\t}\r\n\t}\r\n\r\n\tvar styleObjectHandler = applySubProperties(function(newValue, element, key) {\r\n\t\telement.style[key || this.name] = newValue\r\n\t})\r\n\r\n\tfunction applySubProperties(renderer) {\r\n\t\tvar SubPropertyRenderer = lang.compose(PropertyRenderer, function SubPropertyRenderer(options) {\r\n\t\t\tPropertyRenderer.apply(this, arguments)\r\n\t\t}, {\r\n\t\t\trenderUpdate: renderer\r\n\t\t})\r\n\t\treturn function(element, value, key) {\r\n\t\t\tif (value.notifies && value.put) {\r\n\t\t\t\tnew PropertiesRenderer({\r\n\t\t\t\t\tPropertyRenderer: SubPropertyRenderer,\r\n\t\t\t\t\tvariable: value,\r\n\t\t\t\t\telement: element\r\n\t\t\t\t})\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tfor (var subKey in value) {\r\n\t\t\t\tvar subValue = value[subKey]\r\n\t\t\t\tif (subValue && subValue.notifies) {\r\n\t\t\t\t\tnew SubPropertyRenderer({\r\n\t\t\t\t\t\tname: subKey,\r\n\t\t\t\t\t\tvariable: subValue,\r\n\t\t\t\t\t\telement: element\r\n\t\t\t\t\t})\r\n\t\t\t\t} else {\r\n\t\t\t\t\trenderer(subValue, element, subKey)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction assignProperties(element, properties) {\r\n\t\tvar propertyHandlers = element._propertyHandlers\r\n\t\tvar Element = element.constructor\r\n\t\tfor (var key in properties) {\r\n\t\t\tvar value = properties[key]\r\n\t\t\tvar VariableClass = Element[key]\r\n\t\t\tif (typeof VariableClass === 'function' && VariableClass.notifies && VariableClass !== value) {\r\n\t\t\t\thasOwn(Element, VariableClass)\r\n\t\t\t\t// if (value instanceof VariableClass) { TODO: assign the value as the owned instance\r\n\t\t\t\tVariableClass.for(element).put(value)\r\n\t\t\t}\r\n\t\t\tvar styleDefinition\r\n\t\t\tvar propertyHandler = propertyHandlers[key]\r\n\t\t\tif (propertyHandler) {\r\n\t\t\t\tif (propertyHandler === true) {\r\n\t\t\t\t\tif (value && value.notifies) {\r\n\t\t\t\t\t// a standard, known element property\r\n\t\t\t\t\t\tnew PropertyRenderer({\r\n\t\t\t\t\t\t\tname: key,\r\n\t\t\t\t\t\t\tvariable: value,\r\n\t\t\t\t\t\t\telement: element\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\telement[key] = value\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tpropertyHandler(element, value, key, properties)\r\n\t\t\t\t}\r\n\t\t\t} else if ((styleDefinition = styleDefinitions[key])) {\r\n\t\t\t\tif (value && value.notifies) {\r\n\t\t\t\t\tnew StyleRenderer({\r\n\t\t\t\t\t\tname: key,\r\n\t\t\t\t\t\tvariable: value,\r\n\t\t\t\t\t\telement: element\r\n\t\t\t\t\t})\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstyleDefinition(element, value, key)\r\n\t\t\t\t}\r\n\t\t\t} else if (element[key] == null) {\r\n\t\t\t\t// we are working an unknown/unstandard property (or an event listener)\r\n\t\t\t\t// undefined or null means we can safely set\r\n\t\t\t\t// TODO: we may want to do the event listener check first so we can handle oncustomevent (that needs an addEventListener call to work)\r\n\t\t\t\telement[key] = value\r\n\t\t\t} else if (typeof value === 'function' && key.slice(0, 2) === 'on') {\r\n\t\t\t\t// event listener with one already defined on the prototype\r\n\t\t\t\telement.addEventListener(key.slice(2), value)\r\n\t\t\t} else {\r\n\t\t\t\t// otherwise bypass/override the native getter/setter\r\n\t\t\t\tObject.defineProperty(element, key, {\r\n\t\t\t\t\tvalue: value,\r\n\t\t\t\t\tenumerable: true,\r\n\t\t\t\t\tconfigurable: true,\r\n\t\t\t\t\twritable: true\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction assignGenerators(element, properties) {\r\n\t\tvar generators = properties._generators\r\n\t\tvar customGenerators\r\n\t\tvar styleGenerators\r\n\t\tvar nativeGenerators\r\n\t\tvar propertyHandlers = element._propertyHandlers\r\n\t\tfor (var key in generators) {\r\n\t\t\tvar variable = new VariableExports.GeneratorVariable(generators[key].bind(element, properties))\r\n\t\t\tif (propertyHandlers[key]) {\r\n\t\t\t\t(nativeGenerators || (nativeGenerators = {}))[key] = variable\r\n\t\t\t} else if (styleDefinitions[key]) {\r\n\t\t\t\t(styleGenerators || (styleGenerators = {}))[key] = variable\r\n\t\t\t} else {\r\n\t\t\t\t(customGenerators || (customGenerators = {}))[key] = variable\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (customGenerators) {\r\n\t\t\t// custom ones must go first\r\n\t\t\tassignProperties(element, customGenerators)\r\n\t\t}\r\n\t\tif (styleGenerators) {\r\n\t\t\tassignProperties(element, styleGenerators)\r\n\t\t}\r\n\t\tif (nativeGenerators) {\r\n\t\t\t// native ones must come last so they can access custom ones\r\n\t\t\tassignProperties(element, nativeGenerators)\r\n\t\t}\r\n\t}\r\n\r\n\tfunction buildContent(element, content, key, properties) {\r\n\t\tvar each = element.each || properties.each\r\n\t\tif (each && content) {\r\n\t\t\t// render as list\r\n\t\t\tif (each.create) {\r\n\t\t\t\teach.defineHasOwn = function () {\r\n\t\t\t\t\tvar ItemClass = content.getCollectionOf && content.getCollectionOf() || Item\r\n\t\t\t\t\thasOwn(each, ItemClass, function (element) {\r\n\t\t\t\t\t\tvar itemVariable = ItemClass.from(element._item)\r\n\t\t\t\t\t\treturn itemVariable\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (content.notifies) {\r\n\t\t\t\tnew ListRenderer({\r\n\t\t\t\t\teach: each,\r\n\t\t\t\t\tvariable: content,\r\n\t\t\t\t\telement: element\r\n\t\t\t\t})\r\n\t\t\t} else {\r\n\t\t\t\tvar fragment = doc.createDocumentFragment()\r\n\t\t\t\tif (each.defineHasOwn) {\r\n\t\t\t\t\teach.defineHasOwn()\r\n\t\t\t\t}\r\n\t\t\t\tcontent.forEach(function(item) {\r\n\t\t\t\t\tif (each.create) {\r\n\t\t\t\t\t\tchildElement = each.create({parent: element, _item: item}) // TODO: make a faster object here potentially\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tchildElement = each(item, element)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfragment.appendChild(childElement)\r\n\t\t\t\t})\r\n\t\t\t\telement.appendChild(fragment)\r\n\t\t\t}\r\n\t\t} else if (inputs[element.tagName]) {\r\n\t\t\t// render into input\r\n\t\t\tbuildInputContent(element, content)\r\n\t\t} else if (content instanceof Array) {\r\n\t\t\t// treat array as children (potentially of the content node)\r\n\t\t\telement = element.contentNode || element\r\n\t\t\tlayoutChildren(element, content, element)\r\n\t\t} else {\r\n\t\t\t// render as string\r\n\t\t\telement.appendChild(variableAsContent(element, content))\r\n\t\t}\r\n\t}\r\n\r\n\tfunction bindChanges(element, variable, key, conversion) {\r\n\t\tlang.nextTurn(function() { // wait for next turn in case inputChanges isn't set yet\r\n\t\t\tvar inputEvents = element.inputEvents || ['change', 'alkali-change']\r\n\t\t\tfor (var i = 0, l = inputEvents.length; i < l; i++) {\r\n\t\t\t\telement.addEventListener(inputEvents[i], function (event) {\r\n\t\t\t\t\tvar value = element[key]\r\n\t\t\t\t\tnew Context(element).executeWithin(function() {\r\n\t\t\t\t\t\tvar result = variable.put(conversion ? conversion(value, element) : value)\r\n\t\t\t\t\t\tif (result === VariableExports.deny) {\r\n\t\t\t\t\t\t\tthrow new Error('Variable change denied')\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n\r\n\tdoc.addEventListener('click', function(event) {\r\n\t\tvar target = event.target\r\n\t\tif (target.type === 'radio') {\r\n\t\t\tvar radios = doc.querySelectorAll('input[type=radio]')\r\n\t\t\tfor (var i = 0, l = radios.length; i < l; i++) {\r\n\t\t\t\tvar radio = radios[i]\r\n\t\t\t\tif (radio.name === target.name && radio !== target) {\r\n\t\t\t\t\tradio.dispatchEvent(new Event('alkali-change', {}))\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t})\r\n\r\n\tfunction conversion(value, element) {\r\n\t\tif (element.type == 'number') {\r\n\t\t\treturn parseFloat(value)\r\n\t\t}\r\n\t\treturn value\r\n\t}\r\n\r\n\tfunction buildInputContent(element, content) {\r\n\t\tvar inputType = element.type\r\n\t\tvar inputProperty = inputType in {date: 1, datetime: 1, time: 1} ?\r\n\t\t\t\t'valueAsDate' : (inputType === 'checkbox' || inputType === 'radio') ?\r\n\t\t\t\t\t'checked' : 'value'\r\n\r\n\t\tif (content && content.notifies) {\r\n\t\t\t// a variable, respond to changes\r\n\t\t\tnew InputPropertyRenderer({\r\n\t\t\t\tvariable: content,\r\n\t\t\t\tname: inputProperty,\r\n\t\t\t\telement: element\r\n\t\t\t})\r\n\t\t\t// and bind the other way as well, updating the variable in response to input changes\r\n\t\t\tbindChanges(element, content, inputProperty, conversion)\r\n\t\t} else {\r\n\t\t\t// primitive\r\n\t\t\telement[inputProperty] = content\r\n\t\t}\r\n\t}\r\n\r\n\tfunction mergeObject(Element, value, key, properties) {\r\n\t\tvar existing = properties[key]\r\n\t\tif (existing) {\r\n\t\t\tfor (var subKey in value) {\r\n\t\t\t\texisting[subKey] = value[subKey]\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tproperties[key] = value\r\n\t\t}\r\n\t}\r\n\r\n\tvar classHandlers = {\r\n\t\tclasses: mergeObject,\r\n\t\t_generators: mergeObject,\r\n\t\tdataset: mergeObject,\r\n\t\tattributes: mergeObject,\r\n\t\tstyle: mergeObject,\r\n\t\thasOwn: function(Element, value) {\r\n\t\t\thasOwn(Element, value)\r\n\t\t},\r\n\t\tchildren: function(Element, value) {\r\n\t\t\tElement.children = value\r\n\t\t},\r\n\t\tshadow: function(Element, value) {\r\n\t\t\tElement.shadow = value\r\n\t\t}\r\n\t}\r\n\r\n\tfunction applyToConstructor(argument, Element) {\r\n\t\tvar applyOnCreate = Element._applyOnCreate\r\n\t\tif (argument && typeof argument === 'object') {\r\n\t\t\tif (argument instanceof Array || argument.notifies) {\r\n\t\t\t\tapplyOnCreate.content = argument\r\n\t\t\t} else {\r\n\t\t\t\tfor (var key in argument) {\r\n\t\t\t\t// TODO: eventually we want to be able to set these as rules statically per element\r\n\t\t\t\t/*if (styleDefinitions[key]) {\r\n\t\t\t\t\tvar styles = Element.styles || (Element.styles = [])\r\n\t\t\t\t\tstyles.push(key)\r\n\t\t\t\t\tstyles[key] = descriptor.value\r\n\t\t\t\t} else {*/\r\n\t\t\t\t\tvar value = argument[key]\r\n\t\t\t\t\tvar VariableClass = Element[key]\r\n\t\t\t\t\tif (typeof value === 'function') {\r\n\t\t\t\t\t\tif (value.notifies) {\r\n\t\t\t\t\t\t\tif (value === Variable) {\r\n\t\t\t\t\t\t\t\tvalue = Variable() // create a branded variable if we are using a generic one\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t// for Variable classes we make them statically available on the element\r\n\t\t\t\t\t\t\tElement[key] = value\r\n\t\t\t\t\t\t} else if (isGenerator(value)) {\r\n\t\t\t\t\t\t\tif (key.slice(0, 4) === 'get_') {\r\n\t\t\t\t\t\t\t\tkey = key.slice(4)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t(applyOnCreate._generators || (applyOnCreate._generators = {}))[key] = value\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (value && value.notifies) {\r\n\t\t\t\t\t\t// also store any variables as statically available properties\r\n\t\t\t\t\t\tElement[key] = value\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (classHandlers[key]) { // Could eliminate this if we got rid of hasOwn\r\n\t\t\t\t\t\tclassHandlers[key](Element, value, key, applyOnCreate)\r\n\t\t\t\t\t} else if (typeof VariableClass === 'function' && VariableClass.notifies) {\r\n\t\t\t\t\t\tapplyOnCreate[key] = new VariableClass(value)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tapplyOnCreate[key] = value\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (typeof argument === 'function' && !argument.for) {\r\n\t\t\tthrow new TypeError('Function as argument not supported')\r\n\t\t} else {\r\n\t\t\tapplyOnCreate.content = argument\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getApplySet(Class) {\r\n\t\tif (Class.hasOwnProperty('_applyOnCreate')) {\r\n\t\t\treturn Class._applyOnCreate\r\n\t\t}\r\n\t\t// this means we didn't extend and evaluate the prototype yet\r\n\t\tif (Class.getForClass) {\r\n\t\t\t// we are extending an alkali constructor\r\n\t\t\t// if this class is inheriting from an alkali constructor, work our way up the chain\r\n\t\t\tvar applyOnCreate = Class._applyOnCreate = {}\r\n\t\t\tvar parentApplySet = getApplySet(getPrototypeOf(Class))\r\n\t\t\tfor (var key in parentApplySet) {\r\n\t\t\t\tapplyOnCreate[key] = classHandlers[key] ? Object.create(parentApplySet[key]) : parentApplySet[key]\r\n\t\t\t}\r\n\t\t\t// we need to check the prototype for event handlers\r\n\t\t\tvar prototype = Class.prototype\r\n\t\t\tvar propertyHandlers\r\n\t\t\tvar keys = Object.getOwnPropertyNames(prototype)\r\n\t\t\tfor (var i = 0, l = keys.length; i < l; i++) {\r\n\t\t\t\tvar key = keys[i]\r\n\t\t\t\tif (key.slice(0, 2) === 'on' || (key === 'render' && isGenerator(prototype[key]))) {\r\n\t\t\t\t\tapplyOnCreate[key] = prototype[key]\r\n\t\t\t\t} else if (key.slice(0, 6) === 'render') {\r\n\t\t\t\t\tvar propertyName = key[6].toLowerCase() + key.slice(7)\r\n\t\t\t\t\tif (!propertyHandlers) {\r\n\t\t\t\t\t\tpropertyHandlers = prototype._propertyHandlers = Object.create(prototype._propertyHandlers)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tpropertyHandlers[propertyName] = true // TODO: is it better to implement this with property handlers?\r\n\t\t\t\t\tObject.defineProperty(prototype, propertyName, renderDescriptor(key))\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn applyOnCreate\r\n\t\t}\r\n\t\treturn null\r\n\t}\r\n\r\n\tfunction renderDescriptor(renderMethod) {\r\n\t\tvar map = new lang.WeakMap()\r\n\t\treturn {\r\n\t\t\tget: function() {\r\n\t\t\t\treturn map.has(this) ? map.get(this) : null\r\n\t\t\t},\r\n\t\t\tset: function(value) {\r\n\t\t\t\tmap.set(this, value)\r\n\t\t\t\tthis[renderMethod](value)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction makeElementConstructor(BaseClass) {\r\n\t\tvar isNativeElement = !BaseClass.with // TODO: Create a separate constructor for this\r\n\t\t// this is an optimization to allow consecutive alkali constructors to bypass each other\r\n\t\tif (Object.setPrototypeOf) {\r\n\t\t\twhile (BaseClass.prototype.constructor !== BaseClass && !BaseClass.hasOwnProperty('with')) {\r\n\t\t\t\tBaseClass = getPrototypeOf(BaseClass)\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar isNativeClass = Object.getOwnPropertyDescriptor(BaseClass, 'prototype').writable === false\r\n\t\treturn constructOrCall(BaseClass, isNativeElement && create, withProperties, isNativeClass)\r\n\t}\r\n\r\n\tfunction withProperties(selector, properties) {\r\n\t\tvar Element = makeElementConstructor(this)\r\n\t\tif (this.with) {\r\n\t\t\t// TODO: Might consider only doing this for derivatives of derivatives, since we don't need to inherit from base constructors\r\n\t\t\t// or only doing this in the case of element having custom properties (could mark it with a flag)\r\n\t\t\tsetPrototypeOf(Element, this)\r\n\t\t\tElement.ownedClasses = null\r\n\t\t} else {\r\n\t\t\tElement.create = create\r\n\t\t\tElement.with = withProperties\r\n\t\t\tElement.for = forTarget\r\n\t\t\tElement.property = propertyForElement\r\n\t\t\tElement.getForClass = getForClass\r\n\t\t}\r\n\t\tElement.prototype = this.prototype\r\n\r\n\t\tvar applyOnCreate = Element._applyOnCreate = {}\r\n\t\tvar parentApplySet = getApplySet(this)\r\n\t\t// copy parent properties\r\n\t\tfor (var key in parentApplySet) {\r\n\t\t\tapplyOnCreate[key] = classHandlers[key] ? Object.create(parentApplySet[key]) : parentApplySet[key]\r\n\t\t}\r\n\r\n\t\tvar i = 0 // for arguments\r\n\t\tif (typeof selector === 'string') {\r\n\t\t\tvar selectorMatch = selector.match(SELECTOR_REGEX)\r\n\t\t\tif (selectorMatch) {\r\n\t\t\t\tdo {\r\n\t\t\t\t\tvar operator = selectorMatch[1]\r\n\t\t\t\t\tvar name = selectorMatch[2]\r\n\t\t\t\t\tif (operator == '.') {\r\n\t\t\t\t\t\tif (applyOnCreate.className) {\r\n\t\t\t\t\t\t\tapplyOnCreate.className += ' ' + name\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tapplyOnCreate.className = name\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tapplyOnCreate.id = name\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar remaining = selectorMatch[3]\r\n\t\t\t\t\tselectorMatch = remaining && remaining.match(SELECTOR_REGEX)\r\n\t\t\t\t} while (selectorMatch)\r\n\t\t\t} else {\r\n\t\t\t\tapplyOnCreate.content = selector\r\n\t\t\t}\r\n\t\t\ti++ // skip the first argument\r\n\t\t}\r\n\r\n\t\tfor (var l = arguments.length; i < l; i++) {\r\n\t\t\tapplyToConstructor(arguments[i], Element)\r\n\t\t}\r\n\t\treturn Element\r\n\t}\r\n\tvar currentParent\r\n\tfunction create(selector, properties) {\r\n\t\t// TODO: make this a symbol\r\n\t\tvar applyOnCreate = getApplySet(this)\r\n\t\tif (currentParent) {\r\n\t\t\tvar parent = currentParent\r\n\t\t\tcurrentParent = null\r\n\t\t}\r\n/*\t\tif (this._initialized != this) {\r\n\t\t\tthis._initialized = this\r\n\t\t\tthis.initialize && this.initialize()\r\n\t\t\tvar styles = this.styles\r\n\t\t\tif (styles) {\r\n\t\t\t\tvar rule = createCssRule(getUniqueSelector(this))\r\n\t\t\t\tfor (var i = 0, l = styles.length; i < l; i++) {\r\n\t\t\t\t\tvar key = styles[i]\r\n\t\t\t\t\tvar value = styles[key]\r\n\t\t\t\t\t// TODO: if it is a contextualized variable, do this on the element\r\n\t\t\t\t\tvar styleDefinition = styleDefinitions[key]\r\n\t\t\t\t\tif (styleDefinition) {\r\n\t\t\t\t\t\tstyleDefinition(rule, value, key)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!this.hasOwnProperty('_applyOnCreate')) {\r\n\t\t\t\tapplyOnCreate = getApplySet(this)\r\n\t\t\t}\r\n\t\t}*/\r\n\t\tvar element = this._ElementClass ?\r\n\t\t\tconstruct(HTMLElement, arguments, this._ElementClass) : // does HTMLElement differ from any other constructors?\r\n\t\t\tdoc.createElement(this.tagName)\r\n\t\tif (selector && selector.parent) {\r\n\t\t\tparent = selector.parent\r\n\t\t}\r\n\t\tif (parent) {\r\n\t\t\tpresumptiveParentMap.set(element, parent)\r\n\t\t}\r\n\t\tif (!(element instanceof this)) {\r\n\t\t\t// ideally we want to avoid this call, as it is expensive, but for classes that\r\n\t\t\t// don't register a tag name, we have to make sure the prototype chain is correct\r\n\t\t\tsetPrototypeOf(element, this.prototype)\r\n\t\t}\r\n\t\tif (element.constructor != this) {\r\n\t\t\tif (buggyConstructorSetter) {\r\n\t\t\t\t// in safari, directly setting the constructor messes up the native prototype\r\n\t\t\t\tObject.defineProperty(element, 'constructor', { value: this })\r\n\t\t\t} else {\r\n\t\t\t\telement.constructor = this // need to do this for hasOwn contextualization to work\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (arguments.length > 0) {\r\n\t\t\t// copy applyOnCreate when we have arguments\r\n\t\t\tvar ElementApplyOnCreate = applyOnCreate\r\n\t\t\tapplyOnCreate = {}\r\n\t\t\tfor (var key in ElementApplyOnCreate) {\r\n\t\t\t\tapplyOnCreate[key] = classHandlers[key] ? Object.create(ElementApplyOnCreate[key]) : ElementApplyOnCreate[key]\r\n\t\t\t}\r\n\t\t\tvar i = 0\r\n\t\t\tif (typeof selector == 'string') {\r\n\t\t\t\ti++\r\n\t\t\t\tvar selectorMatch = selector.match(SELECTOR_REGEX)\r\n\t\t\t\tif (selectorMatch) {\r\n\t\t\t\t\tdo {\r\n\t\t\t\t\t\tvar operator = selectorMatch[1]\r\n\t\t\t\t\t\tvar name = selectorMatch[2]\r\n\t\t\t\t\t\tif (operator == '.') {\r\n\t\t\t\t\t\t\tif (applyOnCreate.className) {\r\n\t\t\t\t\t\t\t\tapplyOnCreate.className += ' ' + name\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tif (element.className) {\r\n\t\t\t\t\t\t\t\t\t\telement.className += ' ' + name\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\telement.className = name\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tif (applyOnCreate.id) {\r\n\t\t\t\t\t\t\t\tapplyOnCreate.id = name\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// just skip right to the element\r\n\t\t\t\t\t\t\t\telement.id = name\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar remaining = selectorMatch[3]\r\n\t\t\t\t\t\tselectorMatch = remaining && remaining.match(SELECTOR_REGEX)\r\n\t\t\t\t\t} while (selectorMatch)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tapplyOnCreate.content = selector\r\n\t\t\t\t}\r\n\t\t\t} else if (selector && selector._item) {\r\n\t\t\t\t// this is kind of hack, to get the Item available before the properties, eventually we may want to\r\n\t\t\t\t// order static properties before variable binding applications, but for now.\r\n\t\t\t\telement._item = selector._item\r\n\t\t\t}\r\n\t\t\tfor (var l = arguments.length; i < l; i++) {\r\n\t\t\t\tvar argument = arguments[i]\r\n\t\t\t\tif (argument && typeof argument === 'object') {\r\n\t\t\t\t\tif (argument instanceof Array || argument.notifies) {\r\n\t\t\t\t\t\tapplyOnCreate.content = argument\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tfor (var key in argument) {\r\n\t\t\t\t\t\t\tif (classHandlers[key]) {\r\n\t\t\t\t\t\t\t\tclassHandlers[key](this, argument[key], key, applyOnCreate)\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tapplyOnCreate[key] = argument[key]\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (typeof argument === 'function' && argument.for) {\r\n\t\t\t\t\tapplyOnCreate.content = argument.for(element)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tapplyOnCreate.content = argument\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (element.created) {\r\n\t\t\tapplyOnCreate = element.created(applyOnCreate) || applyOnCreate\r\n\t\t} else if (applyOnCreate.created) {\r\n\t\t\tapplyOnCreate = applyOnCreate.created.call(element, applyOnCreate) || applyOnCreate\r\n\t\t}\r\n\t\t// TODO: inline this for better performance, possibly\r\n\t\tassignProperties(element, applyOnCreate)\r\n\r\n\t\tif (applyOnCreate._generators) {\r\n\t\t\tassignGenerators(element, applyOnCreate)\r\n\t\t}\r\n\r\n\t\tif (this.children) {\r\n\t\t\tlayoutChildren(element, this.children, element)\r\n\t\t}\r\n\t\tif (this.shadow) {\r\n\t\t\tlayoutChildren(element.attachShadow({mode: 'open'}), this.shadow, element)\r\n\t\t}\r\n\t\t// always do this last, so it can be properly inserted inside the children\r\n\t\tif (element.content != null) {\r\n\t\t\tbuildContent(element, element.content, 'content', applyOnCreate)\r\n\t\t}\r\n\t\telement.ready && element.ready(applyOnCreate)\r\n\t\treturn element\r\n\t}\r\n\r\n\tvar slice = [].slice\r\n\tfunction append(parent){\r\n\t\treturn this.nodeType ?\r\n\t\t\tlayoutChildren(this, arguments, this) : // called as a method\r\n\t\t\tlayoutChildren(parent, slice.call(arguments, 1), parent) // called as a function\r\n\t}\r\n\r\n\tfunction prepend(parent){\r\n\t\treturn this.nodeType ?\r\n\t\t\tlayoutChildren(this, arguments, this, true) : // called as a method\r\n\t\t\tlayoutChildren(parent, slice.call(arguments, 1), parent, true) // called as a function\r\n\t}\r\n\r\n\tfunction defineElement(tagSelector, Element) {\r\n\t\tif (!Element) {\r\n\t\t\t// allow optional first param\r\n\t\t\treturn tagSelector.with()\r\n\t\t}\r\n\t\tvar extendElement = Element.tagName\r\n\t\tvar selector = tagSelector.match(/[\\.\\#].+/)\r\n\t\tvar tagName = selector ? tagSelector.slice(0, tagSelector.length - (selector = selector[0]).length) : tagSelector\r\n\t\tElement.tagName = tagName\r\n\t\tif (typeof customElements === 'object') {\r\n\t\t\ttry {\r\n\t\t\t\tif (Element._ElementClass = customElements.get(tagName)) {\r\n\t\t\t\t\tconsole.warn('Element', tagName, 'already registered')\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcustomElements.define(tagName, Element, { extends: extendElement })\r\n\t\t\t\t\tElement._ElementClass = Element\r\n\t\t\t\t}\r\n\t\t\t} catch(error) {\r\n\t\t\t\tconsole.warn(error)\r\n\t\t\t}\r\n\t\t} else if (extendElement && extendElement != 'div' && extendElement != 'span') {\r\n\t\t\tconsole.warn('This browser does not support customized built-in elements, make sure to only extend Element, Div, or Span')\r\n\t\t}\r\n\t\tif (!Element.with) {\r\n\t\t\tElement.with = withProperties\r\n\t\t}\r\n\t\treturn selector ? Element.with(selector) : Element.with()\r\n\t}\r\n\r\n\tvar Element = setupElement(typeof HTMLElement !== 'undefined' ? HTMLElement : function() {})\r\n\r\n\tElement.defineElement = defineElement\r\n\tElement.assign = function(target, properties) {\r\n\t\tif (typeof target === 'function') {\r\n\t\t\t// assign properties to an existing constructor/class\r\n\t\t\tgetApplySet(target) // make sure we have our own applyOnCreate first\r\n\t\t\tapplyToConstructor(properties, target)\r\n\t\t} else {\r\n\t\t\t// assign to an element\r\n\t\t\t// TODO: Handle content property separately\r\n\t\t\treturn assignProperties(target, properties)\r\n\t\t}\r\n\t}\r\n\r\n\tElement.within = function(element){\r\n\t\t// find closest child\r\n\t}\r\n\r\n\tgenerate([\r\n\t\t'Video',\r\n\t\t'Source',\r\n\t\t'Media',\r\n\t\t'Audio',\r\n\t\t'UL',\r\n\t\t'U',\r\n\t\t'Track',\r\n\t\t'Title',\r\n\t\t'TextArea',\r\n\t\t'Template',\r\n\t\t'TBody',\r\n\t\t'THead',\r\n\t\t'TFoot',\r\n\t\t'TR',\r\n\t\t'Table',\r\n\t\t'Col',\r\n\t\t'ColGroup',\r\n\t\t'TH',\r\n\t\t'TD',\r\n\t\t'Caption',\r\n\t\t'Sup',\r\n\t\t'Sub',\r\n\t\t'Style',\r\n\t\t'Strong',\r\n\t\t'Span',\r\n\t\t'Small',\r\n\t\t'Shadow',\r\n\t\t'Select',\r\n\t\t'Script',\r\n\t\t'S',\r\n\t\t'Quote',\r\n\t\t'Progress',\r\n\t\t'Pre',\r\n\t\t'Picture',\r\n\t\t'Param',\r\n\t\t'P',\r\n\t\t'Output',\r\n\t\t'Option',\r\n\t\t'Optgroup',\r\n\t\t'Object',\r\n\t\t'OL',\r\n\t\t'Ins',\r\n\t\t'I',\r\n\t\t'Del',\r\n\t\t'Meter',\r\n\t\t'Meta',\r\n\t\t'Menu',\r\n\t\t'Map',\r\n\t\t'Link',\r\n\t\t'Legend',\r\n\t\t'Label',\r\n\t\t'LI',\r\n\t\t'KeyGen',\r\n\t\t'Input',\r\n\t\t'Img',\r\n\t\t'IFrame',\r\n\t\t'H1',\r\n\t\t'H2',\r\n\t\t'H3',\r\n\t\t'H4',\r\n\t\t'H5',\r\n\t\t'H6',\r\n\t\t'Hr',\r\n\t\t'FrameSet',\r\n\t\t'Frame',\r\n\t\t'Form',\r\n\t\t'Font',\r\n\t\t'Embed',\r\n\t\t'Em',\r\n\t\t'Code',\r\n\t\t'Cite',\r\n\t\t'Dfn',\r\n\t\t'B',\r\n\t\t'Article',\r\n\t\t'Aside',\r\n\t\t'Abbr',\r\n\t\t'Footer',\r\n\t\t'Figure',\r\n\t\t'FigCaption',\r\n\t\t'Header',\r\n\t\t'Main',\r\n\t\t'Mark',\r\n\t\t'MenuItem',\r\n\t\t'Nav',\r\n\t\t'Section',\r\n\t\t'Slot',\r\n\t\t'Summary',\r\n\t\t'WBr',\r\n\t\t'Div',\r\n\t\t'Dialog',\r\n\t\t'Details',\r\n\t\t'DataList',\r\n\t\t'DL',\r\n\t\t'Canvas',\r\n\t\t'Button',\r\n\t\t'Base',\r\n\t\t'Br',\r\n\t\t'Area',\r\n\t\t'A'\r\n\t])\r\n\tgenerateInputs([\r\n\t\t'Checkbox',\r\n\t\t'Password',\r\n\t\t'Submit',\r\n\t\t'Radio',\r\n\t\t'Color',\r\n\t\t'Date',\r\n\t\t'DateTime',\r\n\t\t'Email',\r\n\t\t'Month',\r\n\t\t'Number',\r\n\t\t'Range',\r\n\t\t'Search',\r\n\t\t'Tel',\r\n\t\t'Time',\r\n\t\t'Url',\r\n\t\t'Week'])\r\n\r\n\tvar tags = {}\r\n\tfunction getConstructor(tagName) {\r\n\t\ttagName = tagName.toLowerCase()\r\n\t\treturn tags[tagName] ||\r\n\t\t\t(tags[tagName] =\r\n\t\t\t\tsetupElement(doc.createElement(tagName).constructor, tagName))\r\n\t}\r\n\r\n\tfunction setupElement(HTMLConstructor, tagName, type) {\r\n\t\tvar Element = type ?\r\n\t\t\twithProperties.call(HTMLConstructor, { type: type }) :\r\n\t\t\twithProperties.call(HTMLConstructor)\r\n\t\tvar props = elementPropertyHandlers[tagName]\r\n\t\tif (props && !props.assigned) {\r\n\t\t\tvar handlers = Element.prototype._propertyHandlers = Object.create(propertyHandlers)\r\n\t\t\tfor (var i = 0, l = props.length; i < l; i++) {\r\n\t\t\t\thandlers[props[i]] = true\r\n\t\t\t}\r\n\t\t\tif (props.value) {\r\n\t\t\t\tfor (var i in props) {\r\n\t\t\t\t\tif (!(i > -1)) { // assign any string properties if necessary\r\n\t\t\t\t\t\thandlers[i] = props[i]\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tprops.assigned = true\r\n\t\t}\r\n\t\tElement.tagName = tagName\r\n\t\t// once https://bugs.chromium.org/p/chromium/issues/detail?id=648828&desc=4 is implemented we can do:\r\n\t\t// Element._HTMLConstructor = HTMLConstructor\r\n\t\treturn Element\r\n\t}\r\n\tfunction generate(elements) {\r\n\t\telements.forEach(function(elementName) {\r\n\t\t\tvar ElementClass\r\n\t\t\tObject.defineProperty(Element, elementName, {\r\n\t\t\t\tget: function() {\r\n\t\t\t\t\treturn ElementClass || (ElementClass = getConstructor(elementName))\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t})\r\n\t}\r\n\tfunction generateInputs(elements) {\r\n\t\telements.forEach(function(inputType) {\r\n\t\t\tvar ElementClass\r\n\t\t\tObject.defineProperty(Element, inputType, {\r\n\t\t\t\tget: function() {\r\n\t\t\t\t\t// TODO: make all inputs extend from input generated from generate\r\n\t\t\t\t\treturn ElementClass || (ElementClass = setupElement(HTMLInputElement, 'input', inputType.toLowerCase()))\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\t// alias all the inputs with an Input suffix\r\n\t\t\tObject.defineProperty(Element, inputType + 'Input', {\r\n\t\t\t\tget: function() {\r\n\t\t\t\t\treturn this[inputType]\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t})\r\n\t}\r\n\r\n\tvar aliases = {\r\n\t\tAnchor: 'A',\r\n\t\tImage: 'Img',\r\n\t\tParagraph: 'P',\r\n\t\tTextarea: 'TextArea',\r\n\t\tDList: 'DL',\r\n\t\tUList: 'UL',\r\n\t\tOList: 'OL',\r\n\t\tListItem: 'LI',\r\n\t\tText: 'Input',\r\n\t\tTextInput: 'Input',\r\n\t\tTableRow: 'TR',\r\n\t\tTableCell: 'TD',\r\n\t\tTableHeaderCell: 'TH',\r\n\t\tTableHeader: 'THead',\r\n\t\tTableBody: 'TBody'\r\n\t}\r\n\tfor (var alias in aliases) {\r\n\t\t(function(alias, to) {\r\n\t\t\tObject.defineProperty(Element, alias, {\r\n\t\t\t\tget: function() {\r\n\t\t\t\t\treturn this[to]\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t})(alias, aliases[alias])\r\n\t}\r\n\r\n\tElement.append = append\r\n\tRenderer.append = append // make it available to the renderer\r\n\tElement.prepend = prepend\r\n\tElement.refresh = Renderer.refresh\r\n\tElement.options = {\r\n\t\tmoveLiveElementsEnabled: true,\r\n\t}\r\n\tElement.content = function(Element){\r\n\t\t// container marker\r\n\t\tfunction Content() {\r\n\t\t\treturn new Element()\r\n\t\t}\r\n\t\tContent.isContentNode = true\r\n\t\treturn Content\r\n\t}\r\n\r\n\tElement.ElementClass = function() {}\r\n\tif (typeof Symbol !== 'undefined') {\r\n\t\t// make instanceof work for Element\r\n\t\tObject.defineProperty(Element.ElementClass, Symbol.hasInstance, { value: function(target) {\r\n\t\t\treturn target && (target.create && target.with)\r\n\t\t}})\r\n\t}\r\n\r\n\t// TODO: unify this in lang\r\n\tElement.extend = function(Class, properties) {\r\n\t\tfunction ExtendedElement() {\r\n\t\t\treturn Class.apply(this, arguments)\r\n\t\t}\r\n\t\tsetPrototypeOf(ExtendedElement, Class)\r\n\t\tvar prototype = ExtendedElement.prototype = Object.create(Class.prototype, {\r\n\t\t\tconstructor: { value: ExtendedElement }\r\n\t\t})\r\n\t\tObject.getOwnPropertyNames(properties).forEach(function(key) {\r\n\t\t\tvar descriptor = Object.getOwnPropertyDescriptor(properties, key)\r\n\t\t\tif (classHandlers[key]) {\r\n\t\t\t\tclassHandlers[key](ExtendedElement, descriptor.value, key, properties)\r\n\t\t\t} else {\r\n\t\t\t\tObject.defineProperty(prototype, key, descriptor)\r\n\t\t\t}\r\n\t\t})\r\n\t\treturn ExtendedElement\r\n\t}\r\n\r\n\tfunction forTarget(target) {\r\n\t\treturn target.constructor.getForClass(target, this)\r\n\t}\r\n\r\n\tfunction hasOwn(From, Target, createInstance) {\r\n\t\tif (typeof Target === 'object') {\r\n\t\t\t// we were given an actual instance, use that\r\n\t\t\tvar elementMap = From.ownedClasses || (From.ownedClasses = new lang.WeakMap())\r\n\t\t\tvar instanceMap = {get: function () {\r\n\t\t\t\treturn Target\r\n\t\t\t}}\r\n\t\t\telementMap.set(Target.constructor, instanceMap)\r\n\t\t\treturn hasOwn(From, Target.Class, Target.createInstance)\r\n\t\t}\r\n\t\tif (Target instanceof Array) {\r\n\t\t\treturn Target.forEach(function(Target) {\r\n\t\t\t\thasOwn(From, Target)\r\n\t\t\t})\r\n\t\t}\r\n\t\tvar elementMap = From.ownedClasses || (From.ownedClasses = new lang.WeakMap())\r\n\t\t// TODO: Go up through prototype chain of Target and set each one\r\n\t\tif (!elementMap.has(Target)) {\r\n\t\t\tvar instanceMap = new lang.WeakMap()\r\n\t\t\tinstanceMap.createInstance = createInstance\r\n\t\t\telementMap.set(Target, instanceMap)\r\n\t\t}\r\n\t\treturn From\r\n\t}\r\n\r\n\tfunction getForClass(element, Target) {\r\n\t\tvar createInstance\r\n\t\twhile (element && !(createInstance = element.constructor.ownedClasses && element.constructor.ownedClasses.get(Target))) {\r\n\t\t\telement = element.parentNode || presumptiveParentMap.get(element)\r\n\t\t}\r\n\t\tif (createInstance) {\r\n\t\t\tvar ownedInstances = element.ownedInstances || (element.ownedInstances = new lang.WeakMap())\r\n\t\t\tvar instance = ownedInstances.get(Target)\r\n\t\t\tif (instance === undefined) {\r\n\t\t\t\townedInstances.set(Target, instance = createInstance(element))\r\n\t\t\t\tinstance.subject = element\r\n\t\t\t}\r\n\t\t\treturn instance\r\n\t\t}\r\n\t}\r\n\r\n\tfunction propertyForElement(key) {\r\n\t\t// we just need to establish one Variable class for each element, so we cache it\r\n\t\tThisElementVariable = this._Variable\r\n\t\tif (!ThisElementVariable) {\r\n\t\t\t// need our own branded variable class for this element class\r\n\t\t\tThisElementVariable = this._Variable = Variable()\r\n\r\n\t\t\thasOwn(this, ThisElementVariable, function(element) {\r\n\t\t\t\t// TODO: we might want to do this in init instead\r\n\t\t\t\tvar elementOverlay\r\n\t\t\t\tif (element.alkaliRenderers) {\r\n\t\t\t\t\tvar variableProperties = {}\r\n\t\t\t\t\tfor (var i = 0; i < element.alkaliRenderers.length; i++){\r\n\t\t\t\t\t\tvar renderer = element.alkaliRenderers[i]\r\n\t\t\t\t\t\tif (renderer.name) {\r\n\t\t\t\t\t\t\tvariableProperties[renderer.name] = {value: renderer.variable}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telementOverlay = Object.create(element, variableProperties)\r\n\t\t\t\t} else {\r\n\t\t\t\t\telementOverlay = element\r\n\t\t\t\t}\r\n\t\t\t\tvar instance = new ThisElementVariable(elementOverlay)\r\n\t\t\t\t// we are not observing, because you can't delegate getters and setters in safari\r\n\t\t\t\t// instance.observeObject()\r\n\t\t\t\treturn instance\r\n\t\t\t})\r\n\t\t}\r\n\t\t// now actually get the property class\r\n\t\treturn ThisElementVariable.property(key)\r\n\t}\r\n\r\n\tvar Item = Element.Item = VariableExports.Item\r\n\r\n\tfunction enterRenderer(Renderer, options/*, target*/) {\r\n\t\t// this will be used for optimized class-level variables\r\n\t\t/*if (target.started) { // TODO: Might want to pass in started as a parameter\r\n\t\t\t// this means that the renderer has already been created, so we just need to add this instance\r\n\t\t\tRenderer.prototype.renderUpdate.call(options, element)\r\n\t\t} else {*/\r\n\t\tnew Renderer(options)\r\n\t\t//}\r\n\t}\r\n\r\n\tfunction cleanup(target) {\r\n\t\tvar renderers = target.alkaliRenderers\r\n\t\tif (renderers) {\r\n\t\t\tfor (var i = 0, l = renderers.length; i < l; i++) {\r\n\t\t\t\trenderers[i].stop()\r\n\t\t\t}\r\n\t\t\ttarget.needsRestart = true\r\n\t\t}\r\n\t}\r\n\tfunction restart(target) {\r\n\t\tvar renderers = target.alkaliRenderers\r\n\t\tif (renderers) {\r\n\t\t\tfor (var i = 0, l = renderers.length; i < l; i++) {\r\n//\t\t\t\tupdaters[i].start()\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t// setup the mutation observer so we can be notified of attachments and removals\r\n\tfunction elementAttached(element) {\r\n\t\tvar Class = element.constructor\r\n\t\tif (Class.create) {\r\n/*\t\t\tif (Class.attachedInstances) {\r\n\t\t\t\tClass.attachedInstances.push(element)\r\n\t\t\t\tif (Class.attachedInstances.length === 1 && Class.needsRestart) {\r\n\t\t\t\t\trestart(Class)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tClass.attachedInstances = [element]\r\n\t\t\t}*/\r\n\t\t\tif (element.attached) {\r\n\t\t\t\telement.attached()\r\n\t\t\t}\r\n\t\t\tif (element.needsRestart) {\r\n\t\t\t\trestart(element)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfunction elementDetached(element) {\r\n\t\t/*var attachedInstances = element.constructor.attachedInstances\r\n\t\tif (attachedInstances) {\r\n\t\t\tvar index = attachedInstances.indexOf(element)\r\n\t\t\tif (index > -1) {\r\n\t\t\t\tattachedInstances.splice(index, 1)\r\n\t\t\t\tif (attachedInstances.length === 0) {\r\n\t\t\t\t\tcleanup(Class)\r\n\t\t\t\t}\r\n\t\t\t}*/\r\n\t\t\tif (element.detached) {\r\n\t\t\t\telement.detached()\r\n\t\t\t}\r\n\t\t\tcleanup(element)\r\n\t\t//}\r\n\t}\r\n\tif (typeof MutationObserver === 'function') {\r\n\t\tvar lifeStates = [{\r\n\t\t\tname: 'detached',\r\n\t\t\tnodes: 'removedNodes',\r\n\t\t\taction: elementDetached\r\n\t\t}, {\r\n\t\t\tname: 'attached',\r\n\t\t\tnodes: 'addedNodes',\r\n\t\t\taction: elementAttached\r\n\t\t}]\r\n\t\tfunction firstVisit(node, state) {\r\n\t\t\tif (state.name === 'attached') {\r\n\t\t\t\tif (node.__alkaliAttached__) {\r\n\t\t\t\t\treturn false\r\n\t\t\t\t} else {\r\n\t\t\t\t\tnode.__alkaliAttached__ = true\r\n\t\t\t\t\tstate.action(node)\r\n\t\t\t\t\treturn true\r\n\t\t\t\t}\r\n\t\t\t} else if (node.__alkaliAttached__) {\r\n\t\t\t\tif (doc.body.contains(node)) {\r\n\t\t\t\t\t// detached event, but it is actually still attached (will get attached in a later mutation record)\r\n\t\t\t\t\t// so don't get through the detached/attached lifecycle\r\n\t\t\t\t\treturn false\r\n\t\t\t\t}\r\n\t\t\t\tnode.__alkaliAttached__ = false\r\n\t\t\t\tstate.action(node)\r\n\t\t\t}\r\n\t\t\treturn true\r\n\t\t}\r\n\t\tvar observer = new MutationObserver(function(mutations) {\r\n\t\t\tfor (var i = 0, il = mutations.length; i < il; i++) {\r\n\t\t\t\tvar mutation = mutations[i]\r\n\t\t\t\t// invoke action on element if we haven't already\r\n\t\t\t\tactionIteration:\r\n\t\t\t\tfor (var j = 0, jl = lifeStates.length; j < jl; j++) { // two steps, removed nodes and added nodes\r\n\t\t\t\t\tvar state = lifeStates[j]\r\n\t\t\t\t\tvar nodes = mutation[state.nodes]\r\n\t\t\t\t\t// iterate over node list\r\n\t\t\t\t\tnodeIteration:\r\n\t\t\t\t\tfor (var k = 0, kl = nodes.length; k < kl; k++) {\r\n\t\t\t\t\t\tvar baseNode = nodes[k]\r\n\t\t\t\t\t\tif (firstVisit(baseNode, state)) {\r\n\t\t\t\t\t\t\t// start traversal with child, if it exists\r\n\t\t\t\t\t\t\tvar currentNode = baseNode.firstChild\r\n\t\t\t\t\t\t\tif (currentNode) {\r\n\t\t\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\t\t\tvar nextNode\r\n\t\t\t\t\t\t\t\t\tif (currentNode.nodeType === 1 && firstVisit(currentNode, state)) {\r\n\t\t\t\t\t\t\t\t\t\t// depth-first search\r\n\t\t\t\t\t\t\t\t\t\tnextNode = currentNode.firstChild\r\n\t\t\t\t\t\t\t\t\t\tif (!nextNode) {\r\n\t\t\t\t\t\t\t\t\t\t\tnextNode = currentNode.nextSibling\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\tnextNode = currentNode.nextSibling\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tif (!nextNode) {\r\n\t\t\t\t\t\t\t\t\t\t// come back out to parents\r\n\t\t\t\t\t\t\t\t\t\t// TODO: try keeping a stack to make this faster\r\n\t\t\t\t\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\t\t\t\t\tcurrentNode = currentNode.parentNode\r\n\t\t\t\t\t\t\t\t\t\t\tif (currentNode === baseNode) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tcontinue nodeIteration\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t} while (!(nextNode = currentNode.nextSibling))\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tcurrentNode = nextNode\r\n\t\t\t\t\t\t\t\t} while (true)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// if (options.moveLiveElementsEnabled) {\r\n\t\t\t\t\t\t// TODO: any options that we can really do here?\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t\tobserver.observe(doc.body || doc, {\r\n\t\t\tchildList: true,\r\n\t\t\tsubtree: true\r\n\t\t})\r\n\t}\r\n\r\n\tlang.copy(VariableExports.Context.prototype, {\r\n\t\tspecify: function(Variable) {\r\n\t\t\tvar element = this.subject\r\n\t\t\tvar distinctive = true\r\n\t\t\t;(this.generics || (this.generics = [])).push(Variable)\r\n\t\t\tdo {\r\n\t\t\t\tif (this.distinctSubject === element) {\r\n\t\t\t\t\tdistinctive = false\r\n\t\t\t\t}\r\n\t\t\t\tvar subjectMap = element.constructor.ownedClasses\r\n\t\t\t\tif (subjectMap) {\r\n\t\t\t\t\tvar instanceMap = subjectMap.get(Variable)\r\n\t\t\t\t\tif (instanceMap) {\r\n\t\t\t\t\t\tif (distinctive) {\r\n\t\t\t\t\t\t\tthis.distinctSubject = element\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tspecifiedInstance = instanceMap.get(element)\r\n\t\t\t\t\t\tif (!specifiedInstance) {\r\n\t\t\t\t\t\t\tinstanceMap.set(element, specifiedInstance = instanceMap.createInstance ?\r\n\t\t\t\t\t\t\t\tinstanceMap.createInstance(element) : new Variable())\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn specifiedInstance\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} while ((element = element.parentNode || presumptiveParentMap.get(element)))\r\n\t\t\t// else if no specific context is found, return default instance\r\n\t\t\treturn Variable.defaultInstance\r\n\t\t},\r\n\r\n\t\tgetContextualized: function(variable) {\r\n\t\t\t// returns a variable that has already been contextualized\r\n\t\t\tvar element = this.subject\r\n\t\t\tif (!element) {\r\n\t\t\t\t// no element, just use the default variable\r\n\t\t\t\treturn variable\r\n\t\t\t}\r\n\t\t\tif (variable._contextMap) {\r\n\t\t\t\tdo {\r\n\t\t\t\t\tvar instance = variable._contextMap.get(element)\r\n\t\t\t\t\tif (instance && instance.context.matches(element)) {\r\n\t\t\t\t\t\treturn instance\r\n\t\t\t\t\t}\r\n\t\t\t\t} while ((element = element.parentNode || presumptiveParentMap.get(element)))\r\n\t\t\t}\r\n\t\t\tif (variable.context && variable.context.matches(this.subject)) {\r\n\t\t\t\t// check if the default variable is allowed\r\n\t\t\t\treturn variable\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tmerge: function(childContext) {\r\n\t\t\tif (!this.distinctSubject ||\r\n\t\t\t\t\t(this.distinctSubject !== childContext.distinctSubject && this.distinctSubject.contains(childContext.distinctSubject))) {\r\n\t\t\t\tthis.distinctSubject = childContext.distinctSubject\r\n\t\t\t}\r\n\t\t\t[].push.apply(this.generics || (this.generics = []), childContext.generics)\r\n\t\t},\r\n\t\tgetDistinctElement: function(Variable, element) {\r\n\t\t\tdo {\r\n\t\t\t\tvar subjectMap = element.constructor.ownedClasses\r\n\t\t\t\tif (subjectMap) {\r\n\t\t\t\t\tvar instanceMap = subjectMap.get(Variable)\r\n\t\t\t\t\tif (instanceMap && instanceMap.has(element)) {\r\n\t\t\t\t\t\treturn element\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} while ((element = element.parentNode || presumptiveParentMap.get(element)))\r\n\t\t},\r\n\t\tmatches: function(element) {\r\n\t\t\tvar generics = this.generics\r\n\t\t\tif (generics) {\r\n\t\t\t\tfor (var i = 0, l = generics.length; i < l; i++) {\r\n\t\t\t\t\tif (this.getDistinctElement(generics[i], element) !== this.distinctSubject) {\r\n\t\t\t\t\t\treturn false\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn true\r\n\t\t}\r\n\t})\r\n\r\n\treturn Element\r\n}))\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./Element.js\n ** module id = 1\n ** module chunks = 0\n **/","(function (root, factory) { if (typeof define === 'function' && define.amd) {\r\n\tdefine([], factory) } else if (typeof module === 'object' && module.exports) {\t\t\t\t\r\n\tmodule.exports = factory() // Node\r\n}}(this, function () {\r\n\tvar getPrototypeOf = Object.getPrototypeOf || (function(base) { return base.__proto__ })\r\n\tvar setPrototypeOf = Object.setPrototypeOf || (function(base, proto) {\r\n\t\tfor (var key in proto) {\r\n\t\t\ttry {\r\n\t\t\t\tif (!base.hasOwnProperty(key)) {\r\n\t\t\t\t\tif (proto.hasOwnProperty(key)) {\r\n\t\t\t\t\t\tObject.defineProperty(base, key, \r\n\t\t\t\t\t\t\tObject.getOwnPropertyDescriptor(proto, key))\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tbase[key] = proto[key]\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} catch(error) {}\r\n\t\t}\r\n\t})\r\n\tvar hasFeatures = {\r\n\t\trequestAnimationFrame: typeof requestAnimationFrame != 'undefined',\r\n\t\tdefineProperty: Object.defineProperty && (function() {\r\n\t\t\ttry{\r\n\t\t\t\tObject.defineProperty({}, 't', {})\r\n\t\t\t\treturn true\r\n\t\t\t}catch(e) {\r\n\t\t\t}\r\n\t\t})(),\r\n\t\tpromise: typeof Promise !== 'undefined',\r\n\t\tMutationObserver: typeof MutationObserver !== 'undefined',\r\n\t\t'WeakMap': typeof WeakMap === 'function'\r\n\t}\r\n\tfunction has(feature) {\r\n\t\treturn hasFeatures[feature]\r\n\t}\r\n\r\n\tfunction SyncPromise(value) {\r\n\t\tthis.value = value\r\n\t}\r\n\tSyncPromise.prototype = {\r\n\t\tthen: function(onFulfilled, onRejected) {\r\n\t\t\tif (!onFulfilled) {\r\n\t\t\t\treturn new SyncPromise(this.value)\r\n\t\t\t}\r\n\t\t\ttry {\r\n\t\t\t\tvar result = onFulfilled(this.value)\r\n\t\t\t\treturn (result && result.then) ? result : new SyncPromise(result)\r\n\t\t\t} catch(error) {\r\n\t\t\t\treturn new SyncErrorPromise(error)\r\n\t\t\t}\r\n\t\t},\r\n\t\tcatch: function(handler) {\r\n\t\t\treturn this.then(null, handler)\r\n\t\t}\r\n\t}\r\n\tfunction SyncErrorPromise(error) {\r\n\t\tthis.value = error\r\n\t\tthis.unhandledTimeout = setTimeout(function() {\r\n\t\t\tconsole.error('Uncaught (in promise)', error)\r\n\t\t})\r\n\t}\r\n\tSyncErrorPromise.prototype = new SyncPromise()\r\n\tSyncErrorPromise.prototype.then = function(onFulfilled, onRejected) {\r\n\t\tclearTimeout(this.unhandledTimeout)\r\n\t\tif (!onRejected) {\r\n\t\t\treturn new SyncErrorPromise(this.value)\r\n\t\t}\r\n\t\treturn SyncPromise.prototype.then.call(this, onRejected)\r\n\t}\r\n\t// This is an polyfill for Object.observe with just enough functionality\r\n\t// for what Variables need\r\n\t// An observe function, with polyfile\r\n\tvar observe =\r\n\t\thas('defineProperty') ? \r\n\t\tfunction observe(target, listener) {\r\n\t\t\t/*for(var i in target) {\r\n\t\t\t\taddKey(i)\r\n\t\t\t}*/\r\n\t\t\tlistener.addKey = addKey\r\n\t\t\tlistener.remove = function() {\r\n\t\t\t\tlistener = null\r\n\t\t\t}\r\n\t\t\treturn listener\r\n\t\t\tfunction addKey(key) {\r\n\t\t\t\tvar keyFlag = 'key' + key\r\n\t\t\t\tif(this[keyFlag]) {\r\n\t\t\t\t\treturn\r\n\t\t\t\t}else{\r\n\t\t\t\t\tthis[keyFlag] = true\r\n\t\t\t\t}\r\n\t\t\t\tvar currentValue = target[key]\r\n\t\t\t\tvar targetAncestor = target\r\n\t\t\t\tvar descriptor\r\n\t\t\t\tdo {\r\n\t\t\t\t\tdescriptor = Object.getOwnPropertyDescriptor(targetAncestor, key)\r\n\t\t\t\t} while(!descriptor && (targetAncestor = getPrototypeOf(targetAncestor)))\r\n\r\n\t\t\t\tif(descriptor && descriptor.set) {\r\n\t\t\t\t\tvar previousSet = descriptor.set\r\n\t\t\t\t\tvar previousGet = descriptor.get\r\n\t\t\t\t\tObject.defineProperty(target, key, {\r\n\t\t\t\t\t\tget: function() {\r\n\t\t\t\t\t\t\treturn (currentValue = previousGet.call(this))\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tset: function(value) {\r\n\t\t\t\t\t\t\tpreviousSet.call(this, value)\r\n\t\t\t\t\t\t\tif(currentValue !== value) {\r\n\t\t\t\t\t\t\t\tcurrentValue = value\r\n\t\t\t\t\t\t\t\tif(listener) {\r\n\t\t\t\t\t\t\t\t\tlistener([{target: this, name: key}])\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tenumerable: descriptor.enumerable\r\n\t\t\t\t\t})\r\n\t\t\t\t}else{\r\n\t\t\t\t\tObject.defineProperty(target, key, {\r\n\t\t\t\t\t\tget: function() {\r\n\t\t\t\t\t\t\treturn currentValue\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tset: function(value) {\r\n\t\t\t\t\t\t\tif(currentValue !== value) {\r\n\t\t\t\t\t\t\t\tcurrentValue = value\r\n\t\t\t\t\t\t\t\tif(listener) {\r\n\t\t\t\t\t\t\t\t\tlistener([{target: this, name: key}])\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tenumerable: !descriptor || descriptor.enumerable\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} :\r\n\t\t// and finally a polling-based solution, for the really old browsers\r\n\t\tfunction(target, listener) {\r\n\t\t\tif(!timerStarted) {\r\n\t\t\t\ttimerStarted = true\r\n\t\t\t\tsetInterval(function() {\r\n\t\t\t\t\tfor(var i = 0, l = watchedObjects.length; i < l; i++) {\r\n\t\t\t\t\t\tdiff(watchedCopies[i], watchedObjects[i], listeners[i])\r\n\t\t\t\t\t}\r\n\t\t\t\t}, 20)\r\n\t\t\t}\r\n\t\t\tvar copy = {}\r\n\t\t\tfor(var i in target) {\r\n\t\t\t\tif(target.hasOwnProperty(i)) {\r\n\t\t\t\t\tcopy[i] = target[i]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\twatchedObjects.push(target)\r\n\t\t\twatchedCopies.push(copy)\r\n\t\t\tlisteners.push(listener)\r\n\t\t}\r\n\tvar queuedListeners\r\n\tfunction queue(listener, object, name) {\r\n\t\tif(queuedListeners) {\r\n\t\t\tif(queuedListeners.indexOf(listener) === -1) {\r\n\t\t\t\tqueuedListeners.push(listener)\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\tqueuedListeners = [listener]\r\n\t\t\tlang.nextTurn(function() {\r\n\t\t\t\tqueuedListeners.forEach(function(listener) {\r\n\t\t\t\t\tvar events = []\r\n\t\t\t\t\tlistener.properties.forEach(function(property) {\r\n\t\t\t\t\t\tevents.push({target: listener.object, name: property})\r\n\t\t\t\t\t})\r\n\t\t\t\t\tlistener(events)\r\n\t\t\t\t\tlistener.object = null\r\n\t\t\t\t\tlistener.properties = null\r\n\t\t\t\t})\r\n\t\t\t\tqueuedListeners = null\r\n\t\t\t}, 0)\r\n\t\t}\r\n\t\tlistener.object = object\r\n\t\tvar properties = listener.properties || (listener.properties = [])\r\n\t\tif(properties.indexOf(name) === -1) {\r\n\t\t\tproperties.push(name)\r\n\t\t}\r\n\t}\r\n\tvar unobserve = has('observe') ? Object.unobserve :\r\n\t\tfunction(target, listener) {\r\n\t\t\tif(listener.remove) {\r\n\t\t\t\tlistener.remove()\r\n\t\t\t}\r\n\t\t\tfor(var i = 0, l = watchedObjects.length; i < l; i++) {\r\n\t\t\t\tif(watchedObjects[i] === target && listeners[i] === listener) {\r\n\t\t\t\t\twatchedObjects.splice(i, 1)\r\n\t\t\t\t\twatchedCopies.splice(i, 1)\r\n\t\t\t\t\tlisteners.splice(i, 1)\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\tvar watchedObjects = []\r\n\tvar watchedCopies = []\r\n\tvar listeners = []\r\n\tvar timerStarted = false\r\n\tfunction diff(previous, current, callback) {\r\n\t\t// TODO: keep an array of properties for each watch for faster iteration\r\n\t\tvar queued\r\n\t\tfor(var i in previous) {\r\n\t\t\tif(previous.hasOwnProperty(i) && previous[i] !== current[i]) {\r\n\t\t\t\t// a property has changed\r\n\t\t\t\tprevious[i] = current[i]\r\n\t\t\t\t(queued || (queued = [])).push({name: i})\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor(var i in current) {\r\n\t\t\tif(current.hasOwnProperty(i) && !previous.hasOwnProperty(i)) {\r\n\t\t\t\t// a property has been added\r\n\t\t\t\tprevious[i] = current[i]\r\n\t\t\t\t(queued || (queued = [])).push({name: i})\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(queued) {\r\n\t\t\tcallback(queued)\r\n\t\t}\r\n\t}\r\n\r\n\tvar id = 1\r\n\t// a function that returns a function, to stop JSON serialization of an\r\n\t// object\r\n\tfunction toJSONHidden() {\r\n\t\treturn toJSONHidden\r\n\t}\r\n\t// An object that will be hidden from JSON serialization\r\n\tvar Hidden = function () {\r\n\t}\r\n\tHidden.prototype.toJSON = toJSONHidden\r\n\r\n\tvar extendClass, constructOrCall\r\n\ttry {\r\n\t\t// do this with an eval to avoid syntax errors in browsers that do not support class and new.target\r\n\t\textendClass = eval('(function(Base){ return class extends Base {}})')\r\n\t\tvar possibleConstructOrCall = eval('\"use strict\";(function(BaseClass, constructHandler, callHandler, constructClass){ return function Element() { return this instanceof Element ? constructHandler ? constructHandler.apply(new.target || this.constructor, arguments) : constructClass ? Reflect.construct(BaseClass, arguments, new.target || this.constructor) : lang.functionConstruct(BaseClass, arguments, new.target || this.constructor, this) : callHandler.apply(Element, arguments) } })')\r\n\t\t// actually using new.target bombs in Edge, so it is basically unusable\r\n\t\tnew (possibleConstructOrCall(function() {}, function() {}))()\r\n\t\tconstructOrCall = possibleConstructOrCall\r\n\t} catch(e) {\r\n\t}\r\n\r\n\tvar lang = {\r\n\t\trequestAnimationFrame: has('requestAnimationFrame') ? requestAnimationFrame :\r\n\t\t\t(function() {\r\n\t\t\t\tvar toRender = []\r\n\t\t\t\tvar queued = false\r\n\t\t\t\tfunction processAnimationFrame() {\r\n\t\t\t\t\tfor (var i = 0; i < toRender.length; i++) {\r\n\t\t\t\t\t\ttoRender[i]()\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttoRender = []\r\n\t\t\t\t\tqueued = false\r\n\t\t\t\t}\r\n\t\t\t\tfunction requestAnimationFrame(renderer) {\r\n\t\t\t\t \tif (!queued) {\r\n\t\t\t\t\t\tsetTimeout(processAnimationFrame)\r\n\t\t\t\t\t\tqueued = true\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttoRender.push(renderer)\r\n\t\t\t\t}\r\n\t\t\t\treturn requestAnimationFrame\r\n\t\t\t})(),\r\n\t\tSyncPromise: SyncPromise,\r\n\t\tPromise: has('promise') ? Promise : (function() {\r\n\t\t\tfunction Promise(execute) {\r\n\t\t\t\tvar isResolved, resolution, errorResolution\r\n\t\t\t\tvar queue = 0\r\n\t\t\t\tfunction resolve(value) {\r\n\t\t\t\t\t// resolve function\r\n\t\t\t\t\tif(value && value.then) {\r\n\t\t\t\t\t\t// received a promise, wait for it\r\n\t\t\t\t\t\tvalue.then(resolve, reject)\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tresolution = value\r\n\t\t\t\t\t\tfinished()\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tfunction reject(error) {\r\n\t\t\t\t\t// reject function\r\n\t\t\t\t\terrorResolution = error\r\n\t\t\t\t\tfinished()\r\n\t\t\t\t}\r\n\t\t\t\texecute(resolve, reject)\r\n\t\t\t\tfunction finished() {\r\n\t\t\t\t\tisResolved = true\r\n\t\t\t\t\tfor(var i = 0, l = queue.length; i < l; i++) {\r\n\t\t\t\t\t\tqueue[i]()\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// clean out the memory\r\n\t\t\t\t\tqueue = 0\r\n\t\t\t\t}\r\n\t\t\t\treturn {\r\n\t\t\t\t\tthen: function(callback, errback) {\r\n\t\t\t\t\t\treturn new Promise(function(resolve, reject) {\r\n\t\t\t\t\t\t\tfunction handle() {\r\n\t\t\t\t\t\t\t\t// promise fulfilled, call the appropriate callback\r\n\t\t\t\t\t\t\t\ttry{\r\n\t\t\t\t\t\t\t\t\tif(errorResolution && !errback) {\r\n\t\t\t\t\t\t\t\t\t\t// errors without a handler flow through\r\n\t\t\t\t\t\t\t\t\t\treject(errorResolution)\r\n\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t// resolve to the callback's result\r\n\t\t\t\t\t\t\t\t\t\tresolve(errorResolution ?\r\n\t\t\t\t\t\t\t\t\t\t\terrback(errorResolution) :\r\n\t\t\t\t\t\t\t\t\t\t\tcallback ?\r\n\t\t\t\t\t\t\t\t\t\t\t\tcallback(resolution) : resolution)\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}catch(newError) {\r\n\t\t\t\t\t\t\t\t\t// caught an error, reject the returned promise\r\n\t\t\t\t\t\t\t\t\treject(newError)\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif(isResolved) {\r\n\t\t\t\t\t\t\t\t// already resolved, immediately handle\r\n\t\t\t\t\t\t\t\thandle()\r\n\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t(queue || (queue = [])).push(handle)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn Promise\r\n\t\t}()),\r\n\t\tSet: typeof Set !== 'undefined' ? Set : function () {\r\n\t\t\tvar elements = []\r\n\t\t\treturn {\r\n\t\t\t\tadd: function(element) {\r\n\t\t\t\t\tif (!this.has(element)) {\r\n\t\t\t\t\t\telements.push(element)\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\thas: function(element) {\r\n\t\t\t\t\treturn elements.indexOf(element) > -1\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tWeakMap: has('WeakMap') ? WeakMap :\r\n\t \tfunction (values, name) {\r\n\t \t\tvar mapProperty = '__' + (name || '') + id++\r\n\t \t\treturn has('defineProperty') ?\r\n\t \t\t{\r\n\t \t\t\tget: function (key) {\r\n\t \t\t\t\treturn key[mapProperty]\r\n\t \t\t\t},\r\n\t \t\t\tset: function (key, value) {\r\n\t \t\t\t\tObject.defineProperty(key, mapProperty, {\r\n\t \t\t\t\t\tvalue: value,\r\n\t \t\t\t\t\tenumerable: false\r\n\t \t\t\t\t})\r\n\t \t\t\t}\r\n\t \t\t} :\r\n\t \t\t{\r\n\t \t\t\tget: function (key) {\r\n\t \t\t\t\tvar intermediary = key[mapProperty]\r\n\t \t\t\t\treturn intermediary && intermediary.value\r\n\t \t\t\t},\r\n\t \t\t\tset: function (key, value) {\r\n\t \t\t\t\t// we use an intermediary that is hidden from JSON serialization, at least\r\n\t \t\t\t\tvar intermediary = key[mapProperty] || (key[mapProperty] = new Hidden())\r\n\t \t\t\t\tintermediary.value = value\r\n\t \t\t\t}\r\n\t \t\t}\r\n\t \t},\r\n\r\n\t\tobserve: observe,\r\n\t\tunobserve: unobserve,\r\n\t\textendClass: extendClass,\r\n\t\twhen: function(value, callback, errorHandler) {\r\n\t\t\treturn value && value.then ?\r\n\t\t\t\t(value.then(callback, errorHandler) || value) : callback(value)\r\n\t\t},\r\n\t\tcompose: function(Base, constructor, properties) {\r\n\t\t\tvar prototype = constructor.prototype = Object.create(Base.prototype)\r\n\t\t\tsetPrototypeOf(constructor, Base)\r\n\t\t\tfor(var i in properties) {\r\n\t\t\t\tprototype[i] = properties[i]\r\n\t\t\t}\r\n\t\t\tprototype.constructor = constructor\r\n\t\t\treturn constructor\r\n\t\t},\r\n\t\tsetPrototypeOf: setPrototypeOf,\r\n\t\tnextTurn: has('MutationObserver') ?\r\n\t\t\tfunction (callback) {\r\n\t\t\t\t// promises don't resolve consistently on the next micro turn (Edge doesn't do it right),\r\n\t\t\t\t// so use mutation observer\r\n\t\t\t\t// TODO: make a faster mode that doesn't recreate each time\r\n\t\t\t\tvar div = document.createElement('div')\r\n\t\t\t\tvar observer = new MutationObserver(callback)\r\n\t\t\t\tobserver.observe(div, {\r\n\t\t\t\t\tattributes: true\r\n\t\t\t\t})\r\n\t\t\t\tdiv.setAttribute('a', id++)\r\n\t\t\t} :\r\n\t\t\tfunction (callback) {\r\n\t\t\t\t// TODO: we can do better for other, older browsers\r\n\t\t\t\tsetTimeout(callback, 0)\r\n\t\t\t},\r\n\t\tcopy: Object.assign || function(target, source) {\r\n\t\t\tfor(var i in source) {\r\n\t\t\t\ttarget[i] = source[i]\r\n\t\t\t}\r\n\t\t\treturn target\r\n\t\t},\r\n\t\tdeepCopy: function(source) {\r\n\t\t\tif (source && typeof source == 'object') {\r\n\t\t\t\tif (source instanceof Array) {\r\n\t\t\t\t\tvar target = [] // always create a new array for array targets\r\n\t\t\t\t\tfor(var i = 0, l = source.length; i < l; i++) {\r\n\t\t\t\t\t\ttarget[i] = lang.deepCopy(source[i])\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar target = {}\r\n\t\t\t\t\tfor (var i in source) {\r\n\t\t\t\t\t\ttarget[i] = lang.deepCopy(source[i])\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn target\r\n\t\t\t}\r\n\t\t\treturn source\r\n\t\t},\r\n\t\tconstructOrCall: constructOrCall || function(BaseClass, constructHandler, callHandler) {\r\n\t\t\treturn function Element() {\r\n\t\t\t\tif (this instanceof Element) {\r\n\t\t\t\t\tif (!this.hasOwnProperty('constructor') && Element.prototype === getPrototypeOf(this)) {\r\n\t\t\t\t\t\tif (constructHandler) {\r\n\t\t\t\t\t\t\treturn constructHandler.apply(Element, arguments)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (lang.buggyConstructorSetter) {\r\n\t\t\t\t\t\t\t// in safari, directly setting the constructor messes up the native prototype\r\n\t\t\t\t\t\t\tObject.defineProperty(this, 'constructor', { value: Element })\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthis.constructor = Element\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (constructHandler) {\r\n\t\t\t\t\t\treturn constructHandler.apply(this.constructor, arguments)\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn BaseClass.apply(this, arguments)\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn callHandler.apply(Element, arguments)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tfunctionConstruct: function(BaseClass, args, SubClass, instance) {\r\n\t\t\tif (!instance.hasOwnProperty('constructor') && SubClass.prototype === Object.getPrototypeOf(instance)) {\r\n\t\t\t\tinstance = Object.create(SubClass.prototype)\r\n\t\t\t\tif (lang.buggyConstructorSetter) {\r\n\t\t\t\t\t// in safari, directly setting the constructor messes up the native prototype\r\n\t\t\t\t\tObject.defineProperty(instance, 'constructor', { value: SubClass })\r\n\t\t\t\t} else {\r\n\t\t\t\t\tinstance.constructor = SubClass\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn BaseClass.apply(instance, args)\r\n\t\t}\r\n\t}\r\n\tfunction isGenerator(func) {\r\n\t\tif (typeof func === 'function') {\r\n\t\t\tvar constructor = func.constructor\r\n\t\t\t// this is used to handle both native generators and transpiled generators\r\n\t\t\treturn (constructor.displayName || constructor.name) === 'GeneratorFunction'\r\n\t\t}\r\n\t}\r\n\tfunction isGeneratorIterator(iterator) {\r\n\t\tif (iterator && iterator.next) {\r\n\t\t\tvar constructor = iterator.constructor.constructor\r\n\t\t\treturn (constructor.displayName || constructor.name) === 'GeneratorFunction'\r\n\t\t}\r\n\t}\r\n\tlang.isGenerator = isGenerator\r\n\r\n\tfunction spawn(generator) {\r\n\t\tvar generatorIterator = typeof generator === 'function' ? generator() : generator\r\n\t\tvar resuming\r\n\t\tvar nextValue\r\n\t\tvar isThrowing\r\n\t\treturn next()\r\n\t\tfunction next() {\r\n\t\t\tdo {\r\n\t\t\t\tvar stepReturn = generatorIterator[isThrowing ? 'throw' : 'next'](nextValue)\r\n\t\t\t\tif (stepReturn.done) {\r\n\t\t\t\t\treturn stepReturn.value\r\n\t\t\t\t}\r\n\t\t\t\tnextValue = stepReturn.value\r\n\t\t\t\t// if the return value is a (generator) iterator, execute it\r\n\t\t\t\tif (nextValue && nextValue.next && isGeneratorIterator(nextValue)) {\r\n\t\t\t\t\tnextValue = spawn(nextValue)\r\n\t\t\t\t}\r\n\t\t\t\tif (nextValue && nextValue.then) {\r\n\t\t\t\t\t// if it is a promise, we will wait on it\r\n\t\t\t\t\t// and return the promise so that the next caller can wait on this\r\n\t\t\t\t\tvar resolved\r\n\t\t\t\t\tvar isSync = null\r\n\t\t\t\t\tvar result = nextValue.then(function(value) {\r\n\t\t\t\t\t\tnextValue = value\r\n\t\t\t\t\t\tif (isSync === false) {\r\n\t\t\t\t\t\t\treturn next()\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tisSync = true\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}, function(error) {\r\n\t\t\t\t\t\tnextValue = error\r\n\t\t\t\t\t\tisThrowing = true\r\n\t\t\t\t\t\treturn next()\r\n\t\t\t\t\t})\r\n\t\t\t\t\tif (!isSync) {\r\n\t\t\t\t\t\tisSync = false\r\n\t\t\t\t\t\treturn result\r\n\t\t\t\t\t} // else keeping looping to avoid recursion\r\n\t\t\t\t}\r\n\t\t\t\tisThrowing = false\r\n\t\t\t} while(true)\r\n\t\t}\r\n\t}\r\n\tlang.spawn = spawn\r\n\treturn lang\r\n}))\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./util/lang.js\n ** module id = 2\n ** module chunks = 0\n **/","(function (root, factory) { if (typeof define === 'function' && define.amd) {\r\n\tdefine(['./util/lang', './Variable'], factory) } else if (typeof module === 'object' && module.exports) {        \r\n  module.exports = factory(require('./util/lang'), require('./Variable')) // Node\r\n}}(this, function (lang, VariableExports) {\r\n\tvar doc = typeof document !== 'undefined' && document\r\n\tvar invalidatedElements\r\n\tvar queued\r\n\tvar toRender = []\r\n\tvar nextId = 1\r\n\tvar requestAnimationFrame = lang.requestAnimationFrame\r\n\tvar Context = VariableExports.Context\r\n\r\n\tfunction Renderer(options) {\r\n\t\tvar variable = options.variable\r\n\r\n\t\tthis.variable = variable\r\n\t\tif (options.selector) {\r\n\t\t\tthis.selector = options.selector\r\n\t\t}\r\n\t\tif (options.elements) {\r\n\t\t\tthis.elements = options.elements\r\n\t\t\tthis.element = this.elements[0]\r\n\t\t\tfor(var i = 0, l = this.elements.length; i < l; i++) {\r\n\t\t\t\t(this.elements[i].alkaliRenderers || (this.elements[i].alkaliRenderers = [])).push(this)\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (options.element) {\r\n\t\t\tvar element = this.element = options.element;\r\n\t\t\t(element.alkaliRenderers || (element.alkaliRenderers = [])).push(this)\r\n\t\t} else {\r\n\t\t\tthrow new Error('No element provided to Renderer')\r\n\t\t}\r\n\t\tif (options.update) {\r\n\t\t\tthis.updateRendering = options.update\r\n\t\t}\r\n\t\tif (options.shouldRender) {\r\n\t\t\tthis.shouldRender = options.shouldRender\r\n\t\t}\r\n\t\tif (options.renderUpdate) {\r\n\t\t\tthis.renderUpdate = options.renderUpdate\r\n\t\t}\r\n\t\tif (options.alwaysUpdate) {\r\n\t\t\tthis.alwaysUpdate = options.alwaysUpdate\r\n\t\t}\r\n\t\tif (!variable.updated) {\r\n\t\t\t// baconjs-esqe API\r\n\t\t\tvar renderer = this\r\n\t\t\tvariable.subscribe(function (event) {\r\n\t\t\t\t// replace the variable with an object\r\n\t\t\t\t// that returns the value from the event\r\n\t\t\t\trenderer.variable = {\r\n\t\t\t\t\tvalueOf: function () {\r\n\t\t\t\t\t\treturn event.value()\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\trenderer.updated()\r\n\t\t\t})\r\n\t\t}\r\n\t\tif (options.updateOnStart === false){\r\n\t\t\tvar contextualized = this.contextualized || this.variable\r\n\t\t\tthis.variable.valueOf(this)\r\n\t\t\t// even if we don't render on start, we still need to compute the value so we can depend on the computed \r\n\t\t\t// TODO: we may need to handle recontextualization if it returns a promise\r\n\t\t\tcontextualized.notifies(this)\r\n\t\t} else {\r\n\t\t\tthis.updateRendering(true)\r\n\t\t}\r\n\t}\r\n\tRenderer.prototype = {\r\n\t\tconstructor: Renderer,\r\n\t\tversion: 0,\r\n\t\tnotifies: true,\r\n\t\tupdateRendering: function () {\r\n\t\t\tthrow new Error ('updateRendering must be implemented by sub class of Renderer')\r\n\t\t},\r\n\t\tupdated: function (updateEvent, by, context) {\r\n\t\t\tif (!this.invalidated) {\r\n\t\t\t\tif (!context || this.contextMatches(context)) {\r\n\t\t\t\t\t// do this only once, until we render again\r\n\t\t\t\t\tthis.invalidated = true\r\n\t\t\t\t\tif (this.deferredRender) {\r\n\t\t\t\t\t\tthis.deferredRender.isCanceled = true\r\n\t\t\t\t\t\tthis.deferredRender = null\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar renderer = this\r\n\t\t\t\t\trequestAnimationFrame(function(){\r\n\t\t\t\t\t\tinvalidatedElements = null\r\n\t\t\t\t\t\trenderer.updateRendering(renderer.alwaysUpdate)\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\texecuteWithin: Context.prototype.executeWithin,\r\n\t\tsetVersion: function(){\r\n\t\t\t// this doesn't need its own version/hash\r\n\t\t},\r\n\t\tnewContext: function() {\r\n\t\t\treturn new Context(this.element, true)\r\n\t\t},\r\n\t\tintegrate: function(context, contextualized) {\r\n\t\t\tthis.addInput(contextualized)\r\n\t\t},\r\n\t\taddInput: function(contextualized) {\r\n\t\t\tif (this.variable !== contextualized) {\r\n\t\t\t\tthis.contextualized = contextualized\r\n\t\t\t}\r\n\t\t},\r\n\t\tgetContextualized: function(Variable) {\r\n\t\t\treturn Context.prototype.getContextualized.call(this, Variable)\r\n\t\t\t//return this.contextualized || this.variable\r\n\t\t},\r\n\t\tspecify: function(Variable) {\r\n\t\t\treturn this.contextualized = Context.prototype.specify.call(this, Variable)\r\n\t\t\t// a new context to get this\r\n\t\t\tthis.contextualized = this.newContext(null, true).specify(Variable)\r\n\r\n\t\t},\r\n\t\tmerge: function(){\r\n\t\t\t// noop\r\n\t\t},\r\n\t\tcontextMatches: function(context) {\r\n\t\t\treturn true\r\n\t\t},\r\n\t\tinvalidateElement: function(element) {\r\n\t\t\tif(!invalidatedElements){\r\n\t\t\t\tinvalidatedElements = new WeakMap(null, 'invalidated')\r\n\t\t\t}\r\n\t\t\tvar invalidatedParts = invalidatedElements.get(element)\r\n\t\t\tinvalidatedElements.set(element, invalidatedParts = {})\r\n\t\t\tif (!invalidatedParts[id]) {\r\n\t\t\t\tinvalidatedParts[id] = true\r\n\t\t\t}\r\n\t\t\tif (!queued) {\r\n\t\t\t\tlang.queueTask(processQueue)\r\n\t\t\t\tqueued = true\r\n\t\t\t}\r\n\t\t\tvar renderer = this\r\n\t\t\ttoRender.push(function(){\r\n\t\t\t\trenderer.invalidated = false\r\n\t\t\t\trenderer.updateElement(element)\r\n\t\t\t})\r\n\t\t},\r\n\t\tgetId: function(){\r\n\t\t\treturn this.id || (this.id = nextId++)\r\n\t\t},\r\n\t\tstop: function() {\r\n\t\t\tvar contextualized = this.contextualized || this.variable\r\n\t\t\tcontextualized.stopNotifies(this)\r\n\t\t}\r\n\t}\r\n\tObject.defineProperty(Renderer.prototype, 'subject', {\r\n\t\tget: function() {\r\n\t\t\treturn this.element\r\n\t\t}\r\n\t})\r\n\r\n\tfunction ElementRenderer(options) {\r\n\t\tRenderer.call(this, options)\r\n\t}\r\n\tElementRenderer.prototype = Object.create(Renderer.prototype)\r\n\tElementRenderer.prototype.shouldRender = function (element) {\r\n\t\treturn document.body.contains(element)\r\n\t}\r\n\tElementRenderer.prototype.getSubject = function () {\r\n\t\treturn this.element\r\n\t}\r\n\tElementRenderer.prototype.updateRendering = function (always, element) {\r\n\t\tif (!element && this.elements) {\r\n\t\t\tvar elements = this.elements\r\n\t\t\tif(!elements.length){\r\n\t\t\t\tif(this.selector){\r\n\t\t\t\t\telements = document.querySelectorAll(this.selector)\r\n\t\t\t\t}else{\r\n\t\t\t\t\tthrow new Error('No element or selector was provided to the Renderer')\r\n\t\t\t\t}\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tfor(var i = 0, l = elements.length; i < l; i++){\r\n\t\t\t\tthis.updateRendering(always, elements[i])\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvar thisElement = element || this.element\r\n\r\n\t\t\tif(always || this.shouldRender(thisElement)){\r\n\t\t\t\t// it is connected\r\n\t\t\t\tthis.updateElement(thisElement)\r\n\t\t\t} else {\r\n\t\t\t\tvar id = this.getId()\r\n\t\t\t\tvar renderers = thisElement.renderersOnShow\r\n\t\t\t\tif(!renderers){\r\n\t\t\t\t\trenderers = thisElement.renderersOnShow = []\r\n\t\t\t\t\tthisElement.className += ' needs-rerendering'\r\n\t\t\t\t}\r\n\t\t\t\tif (!renderers[id]) {\r\n\t\t\t\t\trenderers[id] = this\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tElementRenderer.prototype.addElement = function (element) {\r\n\t\tif (this.selector) {\r\n\t\t\telement.renderersOnShow = [this]\r\n\t\t} else {\r\n\t\t\tthis.elements.push(element)\r\n\t\t}\r\n\t\t// and immediately do an update\r\n\t\tthis.updateElement(element)\r\n\t}\r\n\tElementRenderer.prototype.updateElement = function(element) {\r\n\t\tthis.invalidated = false\r\n\t\tif (this.omitValueOf) {\r\n\t\t\tthis.started = true\r\n\t\t\tthis.renderUpdate(undefined, element)\r\n\t\t\treturn\r\n\t\t}\r\n\t\tvar resolved\r\n\t\tvar renderer = this\r\n\t\tvar deferredRender\r\n\t\tthis.executeWithin(function() {\r\n\t\t\tdeferredRender = renderer.variable.then(function(value) {\r\n\t\t\t\tresolved = true\r\n\t\t\t\tif (deferredRender) {\r\n\t\t\t\t\tif (deferredRender === renderer.deferredRender) {\r\n\t\t\t\t\t\trenderer.deferredRender = null\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (deferredRender.isCanceled) {\r\n\t\t\t\t\t\treturn\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (!renderer.invalidated) {\r\n\t\t\t\t\tif (renderer.contextualized && renderer.contextualized !== renderer.variable) {\r\n\t\t\t\t\t\trenderer.contextualized.stopNotifies(renderer)\r\n\t\t\t\t\t}\r\n\t\t\t\t\trenderer.executeWithin(function() {\r\n\t\t\t\t\t\trenderer.contextualized = renderer.variable.notifies(renderer)\r\n\t\t\t\t\t})\r\n\t\t\t\t\tif(value !== undefined || renderer.started){\r\n\t\t\t\t\t\trenderer.started = true\r\n\t\t\t\t\t\trenderer.renderUpdate(value, element)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}, function(error) {\r\n\t\t\t\tconsole.error('Error rendering', renderer, error)\r\n\t\t\t})\r\n\t\t})\r\n\t\tif(!resolved){\r\n\t\t\t// start listening for changes immediately\r\n\t\t\tthis.executeWithin(function() {\r\n\t\t\t\trenderer.contextualized = renderer.variable.notifies(renderer)\r\n\t\t\t})\r\n\t\t\tthis.deferredRender = deferredRender\r\n\t\t\tif (this.renderLoading) {\r\n\t\t\t\t// if we have loading renderer call it\r\n\t\t\t\tthis.renderLoading(deferredRender, element)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tElementRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\tthrow new Error('renderUpdate(newValue) must be implemented')\r\n\t}\r\n\tRenderer.Renderer = Renderer\r\n\tRenderer.ElementRenderer = ElementRenderer\r\n\r\n\tfunction AttributeRenderer(options) {\r\n\t\tif(options.name){\r\n\t\t\tthis.name = options.name\r\n\t\t}\r\n\t\tElementRenderer.apply(this, arguments)\r\n\t}\r\n\tAttributeRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\tAttributeRenderer.prototype.type = 'AttributeRenderer'\r\n\tAttributeRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\tif (typeof newValue == 'boolean' || newValue == null) {\r\n\t\t\t// for booleans or null/undefined, treat the attribute boolean-like, setting and removing\r\n\t\t\tif (newValue) {\r\n\t\t\t\telement.setAttribute(this.name, '') // \"set\" the attribute to enabled\r\n\t\t\t} else {\r\n\t\t\t\telement.removeAttribute(this.name) // disable the attribute, removing it\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// otherwise, assign value as string\r\n\t\t\telement.setAttribute(this.name, newValue)\r\n\t\t}\r\n\t}\r\n\tRenderer.AttributeRenderer = AttributeRenderer\r\n\r\n\tfunction PropertyRenderer(options) {\r\n\t\tif (options.name) {\r\n\t\t\tthis.name = options.name\r\n\t\t}\r\n\t\tElementRenderer.apply(this, arguments)\r\n\t}\r\n\tPropertyRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\tPropertyRenderer.prototype.type = 'PropertyRenderer'\r\n\tPropertyRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\telement[this.name] = newValue\r\n\t}\r\n\tRenderer.PropertyRenderer = PropertyRenderer\r\n\r\n\tfunction InputPropertyRenderer(options) {\r\n\t\tif (options.element && options.element.tagName === 'SELECT' && options.name === 'value') {\r\n\t\t\t// use the deferred value assignment for <select>\r\n\t\t\tthis.renderUpdate = this.renderSelectValueUpdate\r\n\t\t}\r\n\t\tPropertyRenderer.apply(this, arguments)\r\n\t}\r\n\tInputPropertyRenderer.prototype = Object.create(PropertyRenderer.prototype)\r\n\tInputPropertyRenderer.prototype.type = 'InputPropertyRenderer'\r\n\tInputPropertyRenderer.prototype.renderUpdate = function(newValue, element) {\r\n\t\tif (newValue == null || (element.type === 'number' && isNaN(newValue))) {\r\n\t\t\tnewValue = ''\r\n\t\t}\r\n\t\tvar oldValue = element[this.name]\r\n\t\tif (typeof oldValue === 'string' && typeof newValue !== 'string') {\r\n\t\t\tnewValue = newValue == null ? '' : String(newValue)\r\n\t\t}\r\n\t\tif (oldValue != newValue) {\r\n\t\t\telement[this.name] = newValue\r\n\t\t}\r\n\t}\r\n\tInputPropertyRenderer.prototype.renderSelectValueUpdate = function (newValue, element) {\r\n\t\telement.value = newValue\r\n\t\tif (element.value != newValue && !element.value) {\r\n\t\t\t// if we didn't successfully set the value of a <select>, we may need to wait until the children are constructed\r\n\t\t\telement.eventualValue = newValue\r\n\t\t\tlang.nextTurn(function() {\r\n\t\t\t\tif (element.eventualValue) {\r\n\t\t\t\t\telement.value = element.eventualValue\r\n\t\t\t\t\telement.eventualValue = undefined\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t} else {\r\n\t\t\telement.eventualValue = undefined\r\n\t\t}\r\n\t}\r\n\tRenderer.InputPropertyRenderer = InputPropertyRenderer\r\n\r\n\tfunction StyleRenderer(options) {\r\n\t\tif(options.name){\r\n\t\t\tthis.name = options.name\r\n\t\t}\r\n\t\tElementRenderer.apply(this, arguments)\r\n\t}\r\n\tStyleRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\tStyleRenderer.prototype.type = 'StyleRenderer'\r\n\tStyleRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\telement.style[this.name] = newValue\r\n\t}\r\n\tRenderer.StyleRenderer = StyleRenderer\r\n\r\n\tfunction ContentRenderer(options) {\r\n\t\tElementRenderer.apply(this, arguments)\r\n\t}\r\n\tContentRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\tContentRenderer.prototype.type = 'ContentRenderer'\r\n\tContentRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\telement.innerHTML = ''\r\n\t\tif (newValue === undefined){\r\n\t\t\tnewValue = ''\r\n\t\t}\r\n\t\telement.appendChild(document.createTextNode(newValue))\r\n\t}\r\n\tRenderer.ContentRenderer = ContentRenderer\r\n\r\n\tfunction TextRenderer(options) {\r\n\t\tthis.position = options.position\r\n\t\tthis.textNode = options.textNode\r\n\t\tElementRenderer.apply(this, arguments)\r\n\t}\r\n\tTextRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\tTextRenderer.prototype.type = 'TextRenderer'\r\n\tTextRenderer.prototype.updated = function (updateEvent, context) {\r\n\t\tif (this.builtList) {\r\n\t\t\tif (updateEvent.type === 'refresh') {\r\n\t\t\t\tthis.builtList = false\r\n\t\t\t\tthis.omitValueOf = false\r\n\t\t\t} else {\r\n\t\t\t\t(this.updates || (this.updates = [])).push(updateEvent)\r\n\t\t\t}\r\n\t\t}\r\n\t\tElementRenderer.prototype.updated.call(this, updateEvent, context)\r\n\t}\r\n\tTextRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\tif (newValue == null){\r\n\t\t\tnewValue = ''\r\n\t\t}\r\n\t\tif (newValue.create) {\r\n\t\t\tnewValue = newValue.create({parent: element})\r\n\t\t}\r\n\t\tif (newValue.nodeType) {\r\n\t\t\tif (this.textNode && this.textNode.parentNode == element) {\r\n\t\t\t\t// text node is attached, we can replace it with the node\r\n\t\t\t\telement.replaceChild(newValue, this.textNode)\r\n\t\t\t} else {\r\n\t\t\t\telement.appendChild(newValue)\r\n\t\t\t}\r\n\t\t\tthis.textNode = newValue\r\n\t\t} else if (newValue instanceof Array) {\r\n\t\t\tthis.renderUpdate = ListRenderer.prototype.renderUpdate\r\n\t\t\tthis.omitValueOf = true\r\n\t\t\tthis.renderUpdate(newValue, element)\r\n\t\t} else {\r\n\t\t\t(this.textNode || element.childNodes[this.position]).nodeValue = newValue\r\n\t\t}\r\n\t}\r\n\tRenderer.TextRenderer = TextRenderer\r\n\r\n\tfunction ListRenderer(options) {\r\n\t\tif (options.each) {\r\n\t\t\tthis.each = options.each\r\n\t\t}\r\n\t\tElementRenderer.apply(this, arguments)\r\n\t}\r\n\tListRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\tListRenderer.prototype.updated = function (updateEvent, context) {\r\n\t\tif (this.builtList) {\r\n\t\t\tif (updateEvent.type === 'refresh') {\r\n\t\t\t\tthis.builtList = false\r\n\t\t\t\tthis.omitValueOf = false\r\n\t\t\t} else {\r\n\t\t\t\t(this.updates || (this.updates = [])).push(updateEvent)\r\n\t\t\t}\r\n\t\t}\r\n\t\tElementRenderer.prototype.updated.call(this, updateEvent, context)\r\n\t}\r\n\tListRenderer.prototype.type = 'ListRenderer'\r\n\tListRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\tvar container\r\n\t\tvar each = this.each || function(item) { // TODO: make a single identity function\r\n\t\t\treturn item\r\n\t\t}\r\n\t\tvar thisElement = this.element\r\n\t\tvar renderer = this\r\n\t\tif (!this.builtList) {\r\n\t\t\tthis.builtList = true\r\n\t\t\tthis.omitValueOf = true\r\n\t\t\telement.innerHTML = ''\r\n\t\t\tvar childElements = this.childElements = []\r\n\t\t\tif (each.defineHasOwn) {\r\n\t\t\t\teach.defineHasOwn()\r\n\t\t\t}\r\n\t\t\tif (newValue) {\r\n\t\t\t\tnewValue.forEach(function(item) {\r\n\t\t\t\t\tchildElements.push(Renderer.append(thisElement, eachItem(item)))\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tvar contextualized = this.contextualized || this.variable\r\n\t\t\tcontextualized.notifies(this)\r\n\r\n\t\t\t// TODO: restore using a doc fragment to add these items:\r\n\t\t\t// thisElement.appendChild(container)\r\n\t\t} else {\r\n\t\t\tvar childElements = this.childElements\r\n\t\t\tvar updates = this.updates\r\n\t\t\tcontainer = thisElement\r\n\t\t\tupdates.forEach(function(update) {\r\n\t\t\t\tif (update.type === 'refresh') {\r\n\t\t\t\t\trenderer.builtList = false\r\n\t\t\t\t\tfor (var i = 0, l = childElements.length; i < l; i++) {\r\n\t\t\t\t\t\tthisElement.removeChild(childElements[i])\r\n\t\t\t\t\t}\r\n\t\t\t\t\trenderer.renderUpdate()\r\n\t\t\t\t} else {\r\n\t\t\t\t\tfor (var i = 0, l = update.actions.length; i < l; i++) {\r\n\t\t\t\t\t\tvar action = update.actions[i]\r\n\t\t\t\t\t\tif (action.previousIndex > -1) {\r\n\t\t\t\t\t\t\tthisElement.removeChild(childElements[action.previousIndex])\r\n\t\t\t\t\t\t\tchildElements.splice(action.previousIndex, 1)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (action.index > -1) {\r\n\t\t\t\t\t\t\tvar nextChild = childElements[action.index]\r\n\t\t\t\t\t\t\tvar newElement = Renderer.append(thisElement, eachItem(action.value))\r\n\t\t\t\t\t\t\tif (nextChild) {\r\n\t\t\t\t\t\t\t\tthisElement.insertBefore(newElement, nextChild)\r\n\t\t\t\t\t\t\t\tchildElements.splice(action.index, 0, newElement)\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tchildElements.push(newElement)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\tthis.updates = [] // clear the updates\r\n\t\t}\r\n\t\tfunction eachItem(item) {\r\n\t\t\tvar childElement\r\n\t\t\tif (each.create) {\r\n\t\t\t\tchildElement = each.create({parent: thisElement, _item: item}) // TODO: make a faster object here potentially\r\n\t\t\t} else {\r\n\t\t\t\tchildElement = each(item, thisElement)\r\n\t\t\t\tif (childElement.create) {\r\n\t\t\t\t\tchildElement = childElement.create({parent: thisElement, _item: item})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn childElement\r\n\t\t}\r\n\t}\r\n\tRenderer.ListRenderer = ListRenderer\r\n\r\n\tRenderer.onShowElement = function(shownElement){\r\n\t\trequestAnimationFrame(function(){\r\n\t\t\tinvalidatedElements = null\r\n\t\t\tvar elements = [].slice.call(shownElement.getElementsByClassName('needs-rerendering'))\r\n\t\t\tif (shownElement.className.indexOf('needs-rerendering') > 0){\r\n\t\t\t\tvar includingTop = [shownElement]\r\n\t\t\t\tincludingTop.push.apply(includingTop, elements)\r\n\t\t\t\telements = includingTop\r\n\t\t\t}\r\n\t\t\tfor (var i = 0, l = elements.length; i < l; i++){\r\n\t\t\t\tvar element = elements[i]\r\n\t\t\t\tvar renderers = element.renderersOnShow\r\n\t\t\t\tif(renderers){\r\n\t\t\t\t\telement.renderersOnShow = null\r\n\t\t\t\t\t// remove needs-rerendering class\r\n\t\t\t\t\telement.className = element.className.replace(/\\s?needs\\-rerendering\\s?/g, '')\r\n\t\t\t\t\tfor (var id in renderers) {\r\n\t\t\t\t\t\tvar renderer = renderers[id]\r\n\t\t\t\t\t\trenderer.updateElement(element)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n\r\n\tfunction onElementRemoval(element){\r\n\t\t// cleanup element renderers\r\n\t\tif(element.alkaliRenderers){\r\n\t\t\tvar renderers = element.alkaliRenderers\r\n\t\t\tfor(var i = 0; i < renderers.length; i++){\r\n\t\t\t\tvar renderer = renderers[i]\r\n\t\t\t\trenderer.variable.stopNotifies(renderer)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tRenderer.onElementRemoval = function(element, onlyChildren){\r\n\t\tif(!onlyChildren){\r\n\t\t\tonElementRemoval(element)\r\n\t\t}\r\n\t\tvar children = element.getElementsByTagName('*')\r\n\t\tfor(var i = 0, l = children.length; i < l; i++){\r\n\t\t\tvar child = children[i]\r\n\t\t\tif(child.alkaliRenderers){\r\n\t\t\t\tonElementRemoval(child)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn Renderer\r\n}))\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./Renderer.js\n ** module id = 3\n ** module chunks = 0\n **/","(function (root, factory) { if (typeof define === 'function' && define.amd) {\r\n\tdefine(['./util/lang'], factory) } else if (typeof module === 'object' && module.exports) {\t\t\t\t\r\n\tmodule.exports = factory(require('./util/lang')) // Node\r\n}}(this, function (lang) {\r\n\tvar deny = {}\r\n\tvar noChange = {}\r\n\tvar context\r\n\tvar WeakMap = lang.WeakMap\r\n\tvar setPrototypeOf = lang.setPrototypeOf\r\n\tvar getPrototypeOf = Object.getPrototypeOf || (function(base) { return base.__proto__ })\r\n\tvar isGenerator = lang.isGenerator\r\n\tvar undefined // makes it faster to be locally scoped\r\n\t// update types\r\n\tvar RequestChange = 3\r\n\tvar RequestSet = 4\r\n\tvar NOT_MODIFIED = {\r\n\t\tname: 'Not modified',\r\n\t\ttoString: function () {\r\n\t\t\treturn 'Marker for not-modified response'\r\n\t\t},\r\n\t}\r\n\r\n\tvar propertyListenersMap = new lang.WeakMap(null, 'propertyListenersMap')\r\n\tvar isStructureChecked = new lang.WeakMap()\r\n\tvar nextVersion = Date.now()\r\n\r\n\tvar CacheEntry = lang.compose(WeakMap, function() {\r\n\t},{\r\n\t\t_propertyChange: function(propertyName) {\r\n\t\t\tthis.variable._propertyChange(propertyName, contextFromCache(this))\r\n\t\t}\r\n\t})\r\n\tvar listenerId = 1\r\n\r\n\tfunction when(value, callback, errback) {\r\n\t\tif (value && value.then) {\r\n\t\t\treturn value.then(callback, errback)\r\n\t\t}\r\n\t\treturn callback(value)\r\n\t}\r\n\tfunction whenStrict(value, callback) {\r\n\t\tif (value && value.then && !value.notifies) {\r\n\t\t\treturn value.then(callback)\r\n\t\t}\r\n\t\treturn callback(value)\r\n\t}\r\n\r\n\tfunction Context(subject, notifies){\r\n\t\tthis.subject = subject\r\n\t\tif (notifies) {\r\n\t\t\tthis.notifies = notifies\r\n\t\t}\r\n\t}\r\n\tContext.prototype = {\r\n\t\tconstructor: Context,\r\n\t\tnewContext: function(variable) {\r\n\t\t\treturn new Context(this.subject, this.notifies)\r\n\t\t},\r\n\t\texecuteWithin: function(executor) {\r\n\t\t\tvar previousContext = context\r\n\t\t\ttry {\r\n\t\t\t\tcontext = this\r\n\t\t\t\treturn executor()\r\n\t\t\t} finally {\r\n\t\t\t\tcontext = previousContext\r\n\t\t\t}\r\n\t\t},\r\n\t\t//version: 2166136261, // FNV-1a prime seed\r\n\t\tversion: 0,\r\n\t\trestart: function() {\r\n\t\t\t//this.version = 2166136261\r\n\t\t},\r\n\t\tcontextualize: function(variable, parentContext) {\r\n\t\t\t// resolve the contextualization of a variable, and updates this context to be aware of what distinctive aspect of the context has\r\n\t\t\t// been used for resolution\r\n\t\t\tvar contextualized\r\n\t\t\tif (this.distinctSubject) {\r\n\t\t\t\tvar contextMap = variable._contextMap || (variable._contextMap = new lang.WeakMap())\r\n\t\t\t\tcontextualized = contextMap.get(this.distinctSubject)\r\n\t\t\t\tif (!contextualized) {\r\n\t\t\t\t\tcontextMap.set(this.distinctSubject, contextualized = Object.create(variable))\r\n\t\t\t\t\tcontextualized.listeners = false\r\n\t\t\t\t\tcontextualized.context = this\r\n\t\t\t\t\tvar sources = this.sources\r\n\t\t\t\t\tfor (var i = 0, l = sources.length; i < l; i++) {\r\n\t\t\t\t\t\tcontextualized[sources[i]] = sources[++i]\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tthis.contextualized = contextualized\r\n\t\t\t\t// do the merge\r\n\t\t\t\tif (parentContext) {\r\n\t\t\t\t\tparentContext.merge(this)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tcontextualized = variable\r\n\t\t\t}\r\n\t\t\t//if (this.contextualized && this.contextualized !== contextualized) {\r\n\t\t\t\t// TOOD: if it has previously been contextualized to a different context (can happen in a promise/async situation), stop previous notifiers and start new ones\r\n\t\t\t//}\r\n\t\t\treturn contextualized\r\n\t\t},\r\n\t\tsetVersion: function(version) {\r\n/*\t\t\t// FNV1a hash algorithm 32-bit\r\n\t\t\treturn this.version = (this.version ^ (version || 0)) * 16777619 >>> 0*/\r\n\r\n/*\t\t\t// 54 bit FNV1a hash algorithm\r\n\t\t\tvar xored = this.version ^ (version || 0)\r\n\t\t\t// 435 + 1099511627776 = 1099511628211 is 64 bit FNV prime\r\n\t\t\treturn this.version =\r\n\t\t\t\txored * 435 + // compute hash on lower 32 bits\r\n\t\t\t\t(xor & 16777215) * 1099511627776 + // compute hash on lower 24 bits that overflow into upper 32 bits\r\n\t\t\t\t((this.version / 4294967296 >>> 0) * 435 & 2097151) * 4294967296 // hash on upper 32 bits*/\r\n\t\t\t// 54 bit derivative of FNV1a that better uses JS numbers/operators\r\n\t\t\t\r\n\t\t\t// a fast, efficient hash\r\n\t\t\t//return this.version = (this.version ^ (version || 0)) * 1049011 + (this.version / 5555555 >>> 0)\r\n\t\t\t// if we are using globally monotonically increasing version, we can just use max\r\n\t\t\tif (isNaN(version)) {\r\n\t\t\t\tthrow new Error('Bad version')\r\n\t\t\t}\r\n\t\t\treturn this.version = Math.max(this.version, version)\r\n\t\t},\r\n\t\tmerge: function(childContext) {\r\n\t\t\tif (!this.distinctSubject) {\r\n\t\t\t\tthis.distinctSubject = childContext.distinctSubject\r\n\t\t\t}\r\n\t\t},\r\n\t\tspecify: function(Variable) {\r\n\t\t\t// specify a particular instance of a generic variable\r\n\t\t\tvar subject = this.subject\r\n\t\t\tvar subjectMap = subject.constructor.ownedClasses\r\n\t\t\tvar specifiedInstance\r\n\t\t\tif (subjectMap) {\r\n\t\t\t\tif (!this.distinctSubject) {\r\n\t\t\t\t\tthis.distinctSubject = subject\r\n\t\t\t\t}\r\n\t\t\t\tvar instanceMap = subjectMap.get(Variable)\r\n\t\t\t\tif (instanceMap) {\r\n\t\t\t\t\tspecifiedInstance = instanceMap.get(subject)\r\n\t\t\t\t\tif (!specifiedInstance) {\r\n\t\t\t\t\t\tinstanceMap.set(subject, specifiedInstance = instanceMap.createInstance ? instanceMap.createInstance(subject) : new Variable())\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn specifiedInstance\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// else if no specific context is found, return default instance\r\n\t\t\treturn Variable.defaultInstance\r\n\t\t},\r\n\t\tgetContextualized: function(variable) {\r\n\t\t\tif (!this.subject) {\r\n\t\t\t\t// no subject, just use the default variable\r\n\t\t\t\treturn variable\r\n\t\t\t}\r\n\t\t\t// returns a variable that has already been contextualized\r\n\t\t\tvar instance = variable._contextMap && this.subject && variable._contextMap.get(this.subject)\r\n\t\t\tif (instance && instance.context && instance.context.matches(this)) {\r\n\t\t\t\treturn instance\r\n\t\t\t}\r\n\t\t},\r\n\t\tmatches: function(context) {\r\n\t\t\t// does another context match the resolution of this one?\r\n\t\t\treturn context.subject === this.subject\r\n\t\t}\r\n\t}\r\n\r\n\tfunction NotifyingContext(listener, subject){\r\n\t\tthis.subject = subject\r\n\t\tthis.listener = listener\r\n\t}\r\n\tNotifyingContext.prototype = Object.create(Context.prototype)\r\n\tNotifyingContext.prototype.constructor = NotifyingContext\r\n\tNotifyingContext.prototype.addInput = function(contextualized) {\r\n\t\tcontextualized.notifies(this.listener)\r\n\t}\r\n\r\n\tfunction registerListener(value, listener) {\r\n\t\tvar listeners = propertyListenersMap.get(value)\r\n\t\tvar id = listener.listenerId || (listener.listenerId = ('-' + listenerId++))\r\n\t\tif (listeners) {\r\n\t\t\tif (listeners[id] === undefined) {\r\n\t\t\t\tlisteners[id] = listeners.push(listener) - 1\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\tpropertyListenersMap.set(value, listeners = [listener])\r\n\t\t\tlisteners[id] = 0\r\n\t\t\tif (Variable.autoObserveObjects) {\r\n\t\t\t\tobserve(value)\r\n\t\t\t}\r\n\t\t}\r\n\t\tlistener.listeningToObject = value\r\n\t}\r\n\tfunction deregisterListener(listener) {\r\n\t\tif (listener.listeningToObject) {\r\n\t\t\tvar value = listener.listeningToObject\r\n\t\t\tlistener.listeningToObject = null\r\n\t\t\tvar listeners = propertyListenersMap.get(value)\r\n\t\t\tif (listeners) {\r\n\t\t\t\tvar index = listeners[listener.listenerId]\r\n\t\t\t\tif (index > -1) {\r\n\t\t\t\t\tlisteners.splice(index, 1)\r\n\t\t\t\t\tdelete listeners[listener.listenerId]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction RefreshEvent() {\r\n\t\tthis.visited = new lang.Set()\r\n\t}\r\n\tRefreshEvent.prototype.type = 'refresh'\r\n\r\n\tfunction PropertyChangeEvent(key, childEvent, parent) {\r\n\t\tthis.key = key\r\n\t\tthis.childEvent = childEvent\r\n\t\tthis.parent = parent\r\n\t\tthis.visited = childEvent.visited\r\n\t}\r\n\tPropertyChangeEvent.prototype.type = 'update'\r\n\r\n\tfunction ArrayEvent(args) {\r\n\t\tthis.visited = new lang.Set()\r\n\t\tfor (var key in args) {\r\n\t\t\tthis[key] = args[key]\r\n\t\t}\r\n\t}\r\n\tArrayEvent.prototype.type = 'array-update'\r\n\tfunction DeleteEvent(args) {\r\n\t\tthis.visited = new lang.Set()\r\n\t\tfor (var key in args) {\r\n\t\t\tthis[key] = args[key]\r\n\t\t}\r\n\t}\r\n\tDeleteEvent.prototype.type = 'delete'\r\n\r\n\tfunction forPropertyNotifyingValues(variable, properties, callback) {\r\n\t\tif (variable === properties) {\r\n\t\t\tforPropertyNotifyingValues(variable, variable._properties, callback)\r\n\t\t}\r\n\t\tfor (var key in properties) {\r\n\t\t\tvar property = properties[key]\r\n\t\t\tif (property && property.parent == variable) {\r\n\t\t\t\tif (property.returnedVariable) {\r\n\t\t\t\t\tcallback(property.returnedVariable)\r\n\t\t\t\t}\r\n\t\t\t\tif (property.hasChildNotifiers) {\r\n\t\t\t\t\tvar subProperties = property._properties\r\n\t\t\t\t\tif (subProperties) {\r\n\t\t\t\t\t\tforPropertyNotifyingValues(property, property, callback)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction assignPromise(variable, promise, callback) {\r\n\t\tvar isSync\r\n\t\tpromise.then(function(value) {\r\n\t\t\tif (isSync !== false) {\r\n\t\t\t\t// synchronous resolution\r\n\t\t\t\tisSync = true\r\n\t\t\t} else if (variable.promise === promise) {\r\n\t\t\t\t// async resolution make sure we are the still the most recent promise\r\n\t\t\t\tvariable.promise = null\r\n\t\t\t} else {\r\n\t\t\t\t// if async and we are not the most recent, just return\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tif (callback) { // custom handler\r\n\t\t\t\tcallback(value) \r\n\t\t\t} else {\r\n\t\t\t\tvariable.value = value\r\n\t\t\t}\r\n\t\t}, function(error) {\r\n\t\t\tif (isSync !== false) {\r\n\t\t\t\t// synchronous resolution\r\n\t\t\t\tisSync = true\r\n\t\t\t} else if (variable.promise === promise) {\r\n\t\t\t\t// async resolution make sure we are the still the most recent promise\r\n\t\t\t\tvariable.promise = null\r\n\t\t\t} else {\r\n\t\t\t\t// if async and we are not the most recent, just return\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tvariable.error = error\r\n\t\t})\r\n\t\tif (!isSync) {\r\n\t\t\tisSync = false\r\n\t\t\tvariable.promise = promise\r\n\t\t}\r\n\t\treturn promise\r\n\t}\r\n\r\n\tfunction Variable(value) {\r\n\t\tif (this instanceof Variable) {\r\n\t\t\t// new call, may eventually use new.target\r\n\t\t\tif (value !== undefined) {\r\n\t\t\t\tif (value && value.then && !value.notifies) {\r\n\t\t\t\t\tassignPromise(this, value)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.value = value\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\treturn Variable.with(value)\r\n\t\t}\r\n\t}\r\n\r\n\tVariable._logStackTrace = function(v) {\r\n\t\tvar stack = (new Error().stack || '').split(/[\\r\\n]+/)\r\n\t\tif (stack[0] && /^Error\\s*/.test(stack[0])) stack.shift()\r\n\t\tif (stack[0] && /_logStackTrace/.test(stack[0])) stack.shift()\r\n\t\tvar coalesce = (this._debugOpts && this._debugOpts.coalesce) || []\r\n\t\tif (this._debugOpts && this._debugOpts.shortStackTrace) {\r\n\t\t\t// find the first non-coalesced line\r\n\t\t\tvar line\r\n\t\t\tstack.some(function(line) {\r\n\t\t\t\tif (!coalesce.some(function(re) {\r\n\t\t\t\t\treturn re.re.test(line)\r\n\t\t\t\t})) {\r\n\t\t\t\t\tline = stack[0]\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\tconsole.log('Variable ' + v.__debug + ' changed', line && line.replace(/^\\s+/, ''))\r\n\t\t} else {\r\n\t\t\tif (coalesce.length) {\r\n\t\t\t\tvar s = []\r\n\t\t\t\tvar re\r\n\t\t\t\tfor (var i = 0; i < stack.length; i++) {\r\n\t\t\t\t\tvar line = stack[i]\r\n\t\t\t\t\tif (re) {\r\n\t\t\t\t\t\tif (re.test(line)) continue\r\n\t\t\t\t\t\tre = null\r\n\t\t\t\t\t}\r\n\t\t\t\t\tre\r\n\t\t\t\t\tcoalesce.some(function(re) {\r\n\t\t\t\t\t\treturn re = re.re.test(line)\r\n\t\t\t\t\t})\r\n\t\t\t\t\tline = line.replace(/^\\s+/,'')\r\n\t\t\t\t\tif (re) {\r\n\t\t\t\t\t\ts.push('(' + re.name + ') ' + line)\r\n\t\t\t\t\t\tre = re.re\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\ts.push(line)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tstack = s\r\n\t\t\t}\r\n\t\t\tvar stackObject = this._debugOpts && this._debugOpts.stackObject\r\n\t\t\tif (stackObject) {\r\n\t\t\t\tconsole.log('Variable ' + v.__debug + ' changed', stack)\r\n\t\t\t} else {\r\n\t\t\t\tconsole.log('Variable ' + v.__debug + ' changed\\r\\n' + stack.join('\\r\\n'))\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tVariable._debugOpts = {\r\n\t\tcoalesce: [{ name: 'alkali', re: /\\/alkali\\// }, { name: 'Promise', re: /(Promise\\.)|(PromiseArray\\.)|(\\/bluebird\\/)/ }],\r\n\t\tstackObject: false\r\n\t}\r\n\r\n\tvar VariablePrototype = Variable.prototype = {\r\n\t\t// for debugging use\r\n\t\tget _currentValue() {\r\n\t\t\treturn this.valueOf(true)\r\n\t\t},\r\n\t\tset _currentValue(value) {\r\n\t\t\tthis.put(value)\r\n\t\t},\r\n\t\tconstructor: Variable,\r\n\t\tvalueOf: function(allowPromise) {\r\n\t\t\tvar result = this.gotValue(this.getValue())\r\n\t\t\treturn (allowPromise || !(result && result.then)) ? result : undefined\r\n\t\t},\r\n\t\tthen: function(onFulfilled, onRejected) {\r\n\t\t\tvar result = this.valueOf(true)\r\n\t\t\tif (!result || !result.then) {\r\n\t\t\t\tresult = new lang.SyncPromise(result) // ensure it is promise-like\r\n\t\t\t}\r\n\t\t\tif (onFulfilled || onRejected) { // call then if we have any callbacks\r\n\t\t\t\treturn result.then(onFulfilled, onRejected)\r\n\t\t\t}\r\n\t\t\treturn result\r\n\t\t},\r\n\t\tgetValue: function(forChild) {\r\n\t\t\tif (context) {\r\n\t\t\t\tcontext.setVersion(forChild ? this.version : Math.max(this.version || 0, this.versionWithChildren || 0))\r\n\t\t\t}\r\n\t\t\tvar key = this.key\r\n\t\t\tvar parent\r\n\t\t\tif (key != null && (parent = this.parent) != null) {\r\n\t\t\t\tif (context) {\r\n\t\t\t\t\tif (context.ifModifiedSince != null) {\r\n\t\t\t\t\t\t// just too complicated to handle NOT_MODIFED objects for now\r\n\t\t\t\t\t\t// TODO: Maybe handle this and delegate NOT_MODIFIED through this\r\n\t\t\t\t\t\t// chain and through gotValue\r\n\t\t\t\t\t\tcontext.ifModifiedSince = undefined \r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tvar property = this\r\n\t\t\t\tvar object\r\n\t\t\t\tif (parent.getValue) {\r\n\t\t\t\t\t// parent needs value context, might want to do separate context,\r\n\t\t\t\t\t// but would need to treat special so it retrieves the version\r\n\t\t\t\t\t// only and not the versionWithChildren\r\n\t\t\t\t\tobject = parent.getValue(true)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tobject = parent.value\r\n\t\t\t\t}\r\n\t\t\t\tif (object && object.then && !object.notifies) {\r\n\t\t\t\t\treturn when(object, function(object) {\r\n\t\t\t\t\t\tvar value = object == null ? undefined :\r\n\t\t\t\t\t\t\ttypeof object.property === 'function' ? object.property(key) :\r\n\t\t\t\t\t\t\ttypeof object.get === 'function' ? object.get(key) : object[key]\r\n\t\t\t\t\t\t//if (property.listeners) {\r\n\t\t\t\t\t\t\tvar listeners = propertyListenersMap.get(object)\r\n\t\t\t\t\t\t\tif (listeners && listeners.observer && listeners.observer.addKey) {\r\n\t\t\t\t\t\t\t\tlisteners.observer.addKey(key)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t//}\r\n\t\t\t\t\t\treturn value\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t\tvar value = object == null ? undefined :\r\n\t\t\t\t\ttypeof object.property === 'function' ? object.property(key) :\r\n\t\t\t\t\ttypeof object.get === 'function' ? object.get(key) : object[key]\r\n\t\t\t\t//if (property.listeners) {\r\n\t\t\t\t\tvar listeners = propertyListenersMap.get(object)\r\n\t\t\t\t\tif (listeners && listeners.observer && listeners.observer.addKey) {\r\n\t\t\t\t\t\tlisteners.observer.addKey(key)\r\n\t\t\t\t\t}\r\n\t\t\t\t//}\r\n\t\t\t\treturn value\r\n\t\t\t}\r\n\t\t\tif (this.promise) {\r\n\t\t\t\treturn this.promise\r\n\t\t\t}\r\n\t\t\tvar value = this.value\r\n\t\t\treturn value !== undefined ?\r\n\t\t\t\tthis.value : this.default\r\n\t\t},\r\n\t\tgotValue: function(value) {\r\n\t\t\tvar previousNotifyingValue = this.returnedVariable\r\n\t\t\tvar variable = this\r\n\t\t\tif (previousNotifyingValue) {\r\n\t\t\t\tif (value === previousNotifyingValue) {\r\n\t\t\t\t\t// nothing changed, immediately return valueOf\r\n\t\t\t\t\treturn value.valueOf(true)\r\n\t\t\t\t}\r\n\t\t\t\t// if there was a another value that we were dependent on before, stop listening to it\r\n\t\t\t\t// TODO: we may want to consider doing cleanup after the next rendering turn\r\n\t\t\t\tif (variable.listeners) {\r\n\t\t\t\t\tpreviousNotifyingValue.stopNotifies(variable)\r\n\t\t\t\t}\r\n\t\t\t\tvariable.returnedVariable = null\r\n\t\t\t}\r\n\t\t\tif (value && value.notifies) {\r\n\t\t\t\tvariable.returnedVariable = value\r\n\t\t\t\tif (variable.listeners) {\r\n\t\t\t\t\tvalue.notifies(variable)\r\n\t\t\t\t}\r\n\t\t\t\tvalue = value.valueOf(true)\r\n\t\t\t}\r\n\t\t\tif (value && value.then) {\r\n\t\t\t\tvar deferredContext = context\r\n\t\t\t\treturn value.then(function(value) {\r\n\t\t\t\t\tif (value) {\r\n\t\t\t\t\t\tif (value.__variable) {\r\n\t\t\t\t\t\t\tvalue = value.__variable\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (value.subscribe) {\r\n\t\t\t\t\t\t\tif (deferredContext) {\r\n\t\t\t\t\t\t\t\treturn deferredContext.executeWithin(function() {\r\n\t\t\t\t\t\t\t\t\treturn Variable.prototype.gotValue.call(variable, value)\r\n\t\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\treturn Variable.prototype.gotValue.call(variable, value)\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn value\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\treturn value\r\n\t\t},\r\n\t\tPropertyClass: Variable,\r\n\t\tproperty: function(key, PropertyClass) {\r\n\t\t\tvar propertyVariable = this[key]\r\n\t\t\tif (!propertyVariable || !propertyVariable.notifies) {\r\n\t\t\t\tpropertyVariable = this._properties && this._properties[key]\r\n\t\t\t}\r\n\t\t\tif (!propertyVariable) {\r\n\t\t\t\t// create the property variable\r\n\t\t\t\tvar Class = PropertyClass\r\n\t\t\t\tif (!Class) {\r\n\t\t\t\t\tClass = this.constructor[key]\r\n\t\t\t\t\tif (typeof Class !== 'function' || !Class.isPropertyClass) {\r\n\t\t\t\t\t\tClass = this.PropertyClass\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tpropertyVariable = new Class()\r\n\t\t\t\tpropertyVariable.key = key\r\n\t\t\t\tpropertyVariable.parent = this\r\n\t\t\t\tif (this[key] === undefined) {\r\n\t\t\t\t\tthis[key] = propertyVariable\r\n\t\t\t\t} else {\r\n\t\t\t\t\t(this._properties || (this._properties = {}))[key] = propertyVariable\r\n\t\t\t\t}\r\n\t\t\t} else if (PropertyClass) {\r\n\t\t\t\tif (!(propertyVariable instanceof PropertyClass)) {\r\n\t\t\t\t\tthrow new TypeError('Existing property variable does not match requested variable type')\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn propertyVariable\r\n\t\t},\r\n\t\tfor: function(subject) {\r\n\t\t\tif (subject && subject.target && !subject.constructor.getForClass) {\r\n\t\t\t\t// makes HTML events work\r\n\t\t\t\tsubject = subject.target\r\n\t\t\t}\r\n\t\t\tif (this.parent) {\r\n\t\t\t\treturn this.parent.for(subject).property(this.key)\r\n\t\t\t}\r\n\t\t\treturn new ContextualizedVariable(this, subject || defaultContext)\r\n\t\t},\r\n\t\tget isWritable() {\r\n\t\t\treturn this.fixed ? !this.value || this.value.isWritable : this._isWritable\r\n\t\t},\r\n\t\tset isWritable(isWritable) {\r\n\t\t\tthis._isWritable = isWritable\r\n\t\t},\r\n\t\t_isWritable: true,\r\n\t\t_changeValue: function(type, newValue, event) {\r\n\t\t\tvar key = this.key\r\n\t\t\tvar parent = this.parent\r\n\t\t\tif (!parent) {\r\n\t\t\t\treturn this.put(newValue, event)\r\n\t\t\t}\r\n\t\t\tvar variable = this\r\n\t\t\tvar object = parent.getValue ? parent.getValue(true) : parent.value\r\n\t\t\tif (object != null) {\r\n\t\t\t\tif (typeof object != 'object') {\r\n\t\t\t\t\t// if the parent is not an object, we can't set anything (that will be retained)\r\n\t\t\t\t\tvar error = new Error('Can not set property on non-object')\r\n\t\t\t\t\terror.deniedPut = true\r\n\t\t\t\t\tthrow error\r\n\t\t\t\t}\r\n\t\t\t\tvar oldValue = typeof object.get === 'function' ? object.get(key) : object[key]\r\n\t\t\t\tif (oldValue === newValue && typeof newValue != 'object') {\r\n\t\t\t\t\t// no actual change to make\r\n\t\t\t\t\treturn noChange\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (object && typeof object.set === 'function') {\r\n\t\t\t\tobject.set(key, newValue, event)\r\n\t\t\t} else {\r\n\t\t\t\tif (type == RequestChange && oldValue && oldValue.put && (!newValue && newValue.put)) {\r\n\t\t\t\t\t// if a put and the property value is a variable, assign it to that.\r\n\t\t\t\t\treturn oldValue.put(newValue, event)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (newValue && newValue.then && !newValue.notifies) {\r\n\t\t\t\t\t\t// wait for it to resolve and then assign\r\n\t\t\t\t\t\treturn newValue.then(function(newValue) {\r\n\t\t\t\t\t\t\treturn variable._changeValue(type, newValue, event)\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// copy, if this is a copy-on-write variable\r\n\t\t\t\t\t\t// nothing there yet, create an object to hold the new property\r\n\t\t\t\t\t\tvar newObject = object == null\r\n\t\t\t\t\t\t\t? typeof key == 'number' ? [] : {}\r\n\t\t\t\t\t\t\t: parent.isWritable\r\n\t\t\t\t\t\t\t\t? lang.copy(\r\n\t\t\t\t\t\t\t\t\tobject.constructor === Object\r\n\t\t\t\t\t\t\t\t\t?\t{}\r\n\t\t\t\t\t\t\t\t\t:\tobject.constructor === Array\r\n\t\t\t\t\t\t\t\t\t\t?\t[]\r\n\t\t\t\t\t\t\t\t\t\t: Object.create(Object.getPrototypeOf(object)), object)\r\n\t\t\t\t\t\t\t\t: object\r\n\t\t\t\t\t\tnewObject[key] = newValue\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// or set the setter/getter\r\n\t\t\t\t}\r\n\t\t\t\tevent = event || new RefreshEvent()\r\n\t\t\t\tvar parentEvent = new PropertyChangeEvent(key, event, this)\r\n\t\t\t\tparentEvent.oldValue = oldValue\r\n\t\t\t\tparentEvent.target = variable\r\n\t\t\t\treturn when(newObject === object ?\r\n\t\t\t\t\t\tparent.updated(parentEvent, this) :\r\n\t\t\t\t\t\tparent.put(newObject, parentEvent), function() {\r\n\t\t\t\t\tvariable.updated(event, variable)\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tvariable.updated(event, variable)\r\n\r\n\t\t\t// now notify any object listeners\r\n\t\t\tvar listeners = propertyListenersMap.get(object)\r\n\t\t\t// we need to do it before the other listeners, so we can update it before\r\n\t\t\t// we trigger a full clobbering of the object\r\n\t\t\tif (listeners) {\r\n\t\t\t\tlisteners = listeners.slice(0)\r\n\t\t\t\tfor (var i = 0, l = listeners.length; i < l; i++) {\r\n\t\t\t\t\tvar listener = listeners[i]\r\n\t\t\t\t\tif (listener !== parent) {\r\n\t\t\t\t\t\t// now go ahead and actually trigger the other listeners (but make sure we don't do the parent again)\r\n\t\t\t\t\t\tlistener.updated(event)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn newValue\r\n\t\t},\r\n\r\n\t\t_propertyChange: function(propertyName, object, type) {\r\n\t\t\tif (this.onPropertyChange) {\r\n\t\t\t\tthis.onPropertyChange(propertyName, object)\r\n\t\t\t}\r\n\t\t\tthis.updated(new PropertyChangeEvent(propertyName, new RefreshEvent(), this))\r\n\t\t},\r\n\t\teachKey: function(callback) {\r\n\t\t\tfor (var i in this._properties) {\r\n\t\t\t\tcallback(i)\r\n\t\t\t}\r\n\t\t\tfor (var i in this) {\r\n\t\t\t\tif (this.hasOwnProperty[i]) {\r\n\t\t\t\t\tvar value = this[i]\r\n\t\t\t\t\tif (value && value.parent == this && value.listeners) {\r\n\t\t\t\t\t\tcallback(i)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tapply: function(instance, args) {\r\n\t\t\treturn new Transform(args[0], this, args)\r\n\t\t},\r\n\t\tcall: function(instance) {\r\n\t\t\treturn this.apply(instance, Array.prototype.slice.call(arguments, 1))\r\n\t\t},\r\n\t\tforDependencies: function(callback) {\r\n\t\t\tif (this.returnedVariable) {\r\n\t\t\t\tcallback(this.returnedVariable)\r\n\t\t\t}\r\n\t\t\tif (this.hasNotifyingChild) {\r\n\t\t\t\tforPropertyNotifyingValues(this, this, callback)\r\n\t\t\t}\r\n\t\t\tif (this.parent) {\r\n\t\t\t\tcallback(this.parent)\r\n\t\t\t}\r\n\t\t},\r\n\t\tinit: function() {\r\n\t\t\tvar variable = this\r\n\t\t\tvar contextualizes, sources = [] // TODO: optimize this\r\n\t\t\tthis.forDependencies(function(dependency) {\r\n\t\t\t\tvar contextualized = dependency.notifies(variable)\r\n\t\t\t\tif (contextualized !== dependency) {\r\n\t\t\t\t\tcontextualizes = true\r\n\t\t\t\t}\r\n\t\t\t\tsources.push(contextualized)\r\n\t\t\t})\r\n\t\t\tif (contextualizes) {\r\n\t\t\t\tvar contextualized = new ContextualizedVariable()\r\n\t\t\t\t//context.instanceMap.set(this, contextualized)\r\n\t\t\t\tcontextualized.sources = sources\r\n\t\t\t\tcontextualized.init()\r\n\t\t\t\treturn contextualized\r\n\t\t\t}\r\n\r\n\t\t\tif (this.listeningToObject === null) {\r\n\t\t\t\t// we were previously listening to an object, but it needs to be restored\r\n\t\t\t\t// calling valueOf will cause the listening object to be restored\r\n\t\t\t\tthis.valueOf()\r\n\t\t\t}\r\n\t\t\treturn this\r\n\t\t},\r\n\t\tcleanup: function() {\r\n\t\t\tthis.listeners = false\r\n\t\t\tvar handles = this.handles\r\n\t\t\tif (handles) {\r\n\t\t\t\tfor (var i = 0; i < handles.length; i++) {\r\n\t\t\t\t\thandles[i].remove()\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.handles = null\r\n\t\t\tvar returnedVariable = this.returnedVariable\r\n\t\t\tvar variable = this\r\n\t\t\tthis.forDependencies(function(dependency) {\r\n\t\t\t\tdependency.stopNotifies(variable)\r\n\t\t\t})\r\n\t\t},\r\n\r\n\t\tversion: 0,\r\n\t\tversionWithChildren: 0,\r\n\r\n\t\tupdateVersion: function(version) {\r\n\t\t\tthis.version = nextVersion = Math.max(Date.now(), nextVersion + 1)\r\n\t\t},\r\n\r\n\t\tgetVersion: function() {\r\n\t\t\treturn Math.max(this.version,\r\n\t\t\t\tthis.returnedVariable && this.returnedVariable.getVersion ? this.returnedVariable.getFullVersion(context) : 0,\r\n\t\t\t\tthis.parent ? this.parent.getVersion(context) : 0)\r\n\t\t},\r\n\t\tgetFullVersion: function() {\r\n\t\t\treturn Math.max(this.versionWithChildren, this.getVersion())\r\n\t\t},\r\n\r\n\t\tgetSubject: function(selectVariable) {\r\n\t\t\treturn this.subject\r\n\t\t},\r\n\r\n\t\tgetUpdates: function(since) {\r\n\t\t\tvar updates = []\r\n\t\t\tvar nextUpdateMap = this.nextUpdateMap\r\n\t\t\tif (nextUpdateMap && since) {\r\n\t\t\t\twhile ((since = nextUpdateMap.get(since))) {\r\n\t\t\t\t\tif (since.type === 'refresh') {\r\n\t\t\t\t\t\t// if it was refresh, we can clear any prior entries\r\n\t\t\t\t\t\tupdates = []\r\n\t\t\t\t\t}\r\n\t\t\t\t\tupdates.push(since)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn updates\r\n\t\t},\r\n\r\n\t\tupdated: function(updateEvent, by, isDownstream) {\r\n\t\t\tif (!updateEvent) {\r\n\t\t\t\tupdateEvent = new RefreshEvent()\r\n\t\t\t\tupdateEvent.source = this\r\n\t\t\t}\r\n\t\t\tif (updateEvent.visited.has(this)){\r\n\t\t\t\t// if this event has already visited this variable, skip it\r\n\t\t\t\treturn updateEvent\r\n\t\t\t}\r\n\t\t\tupdateEvent.visited.add(this)\r\n\t\t\tif (this.__debug) {\r\n\t\t\t\t// debug is on\r\n\t\t\t\tVariable._logStackTrace(this)\r\n\t\t\t}\r\n\r\n\t\t\t/*var contextualInstance = context && context.getContextualized(this)\r\n\t\t\tif (contextualInstance) {\r\n\t\t\t\tcontextualInstance.updated(updateEvent, this)\r\n\t\t\t}\r\n\r\n\t\t\t// at some point we could do an update list so that we could incrementally update\r\n\t\t\t// lists in non-live situations\r\n\t\t\tif (this.lastUpdate) {\r\n\t\t\t\tvar nextUpdateMap = this.nextUpdateMap\r\n\t\t\t\tif (!nextUpdateMap) {\r\n\t\t\t\t\tnextUpdateMap = this.nextUpdateMap = new lang.WeakMap()\r\n\t\t\t\t}\r\n\t\t\t\tnextUpdateMap.set(this.lastUpdate, updateEvent)\r\n\t\t\t}\r\n\r\n\t\t\tthis.lastUpdate = updateEvent */\r\n\t\t\tif (updateEvent instanceof PropertyChangeEvent) {\r\n\t\t\t\tthis.versionWithChildren = Math.max(Date.now(), nextVersion + 1)\r\n\t\t\t} else if (!isDownstream) {\r\n\t\t\t\tthis.updateVersion()\r\n\t\t\t}\r\n\r\n\t\t\tvar listeners = this.listeners\r\n\t\t\tif (listeners) {\r\n\t\t\t\tvar variable = this\r\n\t\t\t\t// make a copy, in case they change\r\n\t\t\t\tlisteners = listeners.slice()\r\n\t\t\t\tfor (var i = 0, l = listeners.length; i < l; i++) {\r\n\t\t\t\t\tvar dependent = listeners[i]\r\n\t\t\t\t\tif ((updateEvent instanceof PropertyChangeEvent) &&\r\n\t\t\t\t\t\t\tdependent.parent) {\r\n\t\t\t\t\t\tif (dependent.key === updateEvent.key) {\r\n\t\t\t\t\t\t\tdependent.updated(updateEvent.childEvent, variable)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tdependent.updated(updateEvent, variable, true)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (updateEvent instanceof PropertyChangeEvent) {\r\n\t\t\t\tif (this.returnedVariable && this.fixed) {\r\n\t\t\t\t\tthis.returnedVariable.updated(updateEvent, this)\r\n\t\t\t\t}\r\n\t\t\t\tif (this.constructor.collection) {\r\n\t\t\t\t\tthis.constructor.collection.updated(updateEvent, this)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (this.parent) {\r\n\t\t\t\tthis.parent.updated(new PropertyChangeEvent(this.key, updateEvent, this.parent), this)\r\n\t\t\t}\r\n\t\t\tif (this.collection) {\r\n\t\t\t\tthis.collection.updated(updateEvent, this)\r\n\t\t\t}\r\n\t\t\treturn updateEvent\r\n\t\t},\r\n\r\n\t\tinvalidate: function() {\r\n\t\t\t// for back-compatibility for now\r\n\t\t\tthis.updated()\r\n\t\t},\r\n\r\n\t\tnotifies: function(target) {\r\n\t\t\t// TODO: Eventually we want this to be trigerred from context, but context gets shared with returned variables, so will need to handle that\r\n\t\t\tif (!target) {\r\n\t\t\t\tthrow new Error('No listener provided for notification')\r\n\t\t\t}\r\n\t\t\tvar listeners = this.listeners\r\n\t\t\tif (!listeners || !this.hasOwnProperty('listeners')) {\r\n\t\t\t\tvar variable = this.init()\r\n\t\t\t\tvariable.listeners = listeners = [target]\r\n\t\t\t\treturn variable\r\n\t\t\t} else if (listeners.indexOf(target) === -1) {\r\n\t\t\t\tlisteners.push(target)\r\n\t\t\t}\r\n\t\t\treturn this\r\n\t\t},\r\n\t\tsubscribe: function(listener) {\r\n\t\t\t// ES7 Observable (and baconjs) compatible API\r\n\t\t\tvar updated\r\n\t\t\tvar updateQueued\r\n\t\t\tvar variable = this\r\n\t\t\t// it is important to make sure you register for notifications before getting the value\r\n\t\t\tif (typeof listener === 'function') {\r\n\t\t\t\t// BaconJS compatible API\r\n\t\t\t\tvar variable = this\r\n\t\t\t\tvar event = {\r\n\t\t\t\t\tvalue: function() {\r\n\t\t\t\t\t\treturn new Context(null, true).executeWithin(function() {\r\n\t\t\t\t\t\t\treturn variable.valueOf(true)\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tupdated = function() {\r\n\t\t\t\t\tupdateQueued = false\r\n\t\t\t\t\tlistener(event)\r\n\t\t\t\t}\r\n\t\t\t}\telse if (listener.next) {\r\n\t\t\t\t// Assuming ES7 Observable API. It is actually a streaming API, this pretty much violates all principles of reactivity, but we will support it\r\n\t\t\t\tupdated = function() {\r\n\t\t\t\t\tupdateQueued = false\r\n\t\t\t\t\tvariable.then(function(value) {\r\n\t\t\t\t\t\tlistener.next(value)\r\n\t\t\t\t\t}, function(error) {\r\n\t\t\t\t\t\tlistener.error(value)\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tthrow new Error('Subscribing to an invalid listener, the listener must be a function, or have an update or next method')\r\n\t\t\t}\r\n\t\t\tvar updateReceiver = {\r\n\t\t\t\tupdated: function() {\r\n\t\t\t\t\tif (updateQueued) {\r\n\t\t\t\t\t\treturn\r\n\t\t\t\t\t}\r\n\t\t\t\t\tupdateQueued = true\r\n\t\t\t\t\tlang.nextTurn(updated)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tupdated()\r\n\t\t\tthis.notifies(updateReceiver)\r\n\t\t\treturn {\r\n\t\t\t\tunsubscribe: function() {\r\n\t\t\t\t\tvariable.stopNotifies(updateReceiver)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tstopNotifies: function(dependent) {\r\n\t\t\tvar listeners = this.listeners\r\n\t\t\tif (listeners) {\r\n\t\t\t\tvar index = listeners.indexOf(dependent)\r\n\t\t\t\tif (index > -1) {\r\n\t\t\t\t\tlisteners.splice(index, 1)\r\n\t\t\t\t\tif (listeners.length === 0) {\r\n\t\t\t\t\t\t// clear the listeners so it will be reinitialized if it has\r\n\t\t\t\t\t\t// listeners again\r\n\t\t\t\t\t\tthis.cleanup()\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tput: function(value, event) {\r\n\t\t\tvar variable = this\r\n\t\t\tif (this.parent) {\r\n\t\t\t\treturn this._changeValue(RequestChange, value, event)\r\n\t\t\t}\r\n\t\t\tvar oldValue = this.getValue ? this.getValue() : this.value\r\n\t\t\tif (oldValue === value && typeof value != 'object') {\r\n\t\t\t\treturn noChange\r\n\t\t\t}\r\n\t\t\tif (oldValue && oldValue.put &&\r\n\t\t\t\t\t// if it is set to fixed, we see we can put in the current variable\r\n\t\t\t\t\t(variable.fixed || !(value && value.put))) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\treturn oldValue.put(value)\r\n\t\t\t\t} catch (error) {\r\n\t\t\t\t\tif (!error.deniedPut) {\r\n\t\t\t\t\t\tthrow error\r\n\t\t\t\t\t}// else if the put was denied, continue on and set the value on this variable\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (value && value.then && !value.notifies) {\r\n\t\t\t\tvalue = assignPromise(this, value)\r\n\t\t\t} else {\r\n\t\t\t\tvariable.value = value\r\n\t\t\t}\r\n\t\t\tevent = event || new RefreshEvent()\r\n\t\t\tevent.oldValue = oldValue\r\n\t\t\tevent.target = variable\r\n\t\t\tvariable.updated(event, variable)\r\n\t\t\treturn value\r\n\t\t},\r\n\t\tget: function(key) {\r\n\t\t\tif (this[key] || (this._properties && this._properties[key])) {\r\n\t\t\t\treturn this.property(key).valueOf(true)\r\n\t\t\t}\r\n\t\t\tvar object = this.getValue()\r\n\t\t\tif (!object) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tif (typeof object.get === 'function') {\r\n\t\t\t\treturn object.get(key)\r\n\t\t\t}\r\n\t\t\tvar value = object[key]\r\n\t\t\tif (value && value.notifies) {\r\n\t\t\t\t// nested variable situation, get underlying value\r\n\t\t\t\treturn value.valueOf(true)\r\n\t\t\t}\r\n\t\t\treturn value\r\n\t\t},\r\n\t\tset: function(key, value, event) {\r\n\t\t\t// TODO: create an optimized route when the property doesn't exist yet\r\n\t\t\tthis.property(key)._changeValue(RequestSet, value, event)\r\n\t\t},\r\n\t\tundefine: function(key) {\r\n\t\t\tthis.set(key, undefined)\r\n\t\t},\r\n\t\tis: function(newValue, event) {\r\n\t\t\tif (this.parent) {\r\n\t\t\t\tvar parent = this.parent\r\n\t\t\t\tvar key = this.key\r\n\t\t\t\tvar object = (parent.getValue ? parent.getValue(true) : parent.value)\r\n\t\t\t\tvar parentEvent = new PropertyChangeEvent(key, event || new RefreshEvent(), parent)\r\n\t\t\t\tif (object) {\r\n\t\t\t\t\tobject[key] = newValue\r\n\t\t\t\t\tthis.updated(parentEvent, this)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tobject = (typeof key === 'number' ? [] : {})\r\n\t\t\t\t\tobject[key] = newValue\r\n\t\t\t\t\tparent.is(object, parentEvent)\r\n\t\t\t\t}\r\n\t\t\t\treturn this\r\n\t\t\t}\r\n\t\t\tthis.fixed = true\r\n\r\n\t\t\tthis.value = newValue\r\n\t\t\tthis.updated(new RefreshEvent(), this)\r\n\t\t\treturn this\r\n\t\t},\r\n\t\tproxy: function(proxiedVariable) {\r\n\t\t\treturn this.is(proxiedVariable)\r\n\t\t},\r\n\t\tnext: function(value) {\r\n\t\t\t// for ES7 observable compatibility\r\n\t\t\tthis.put(value)\r\n\t\t},\r\n\t\terror: function(error) {\r\n\t\t\t// for ES7 observable compatibility\r\n\t\t\tvar listeners = this.listeners\r\n\t\t\tif (listeners) {\r\n\t\t\t\t// make a copy, in case they change\r\n\t\t\t\tlisteners.forEach(function(dependent) {\r\n\t\t\t\t\t// skip notifying property listeners if we are headed up the parent chain\r\n\t\t\t\t\tdependent.error(error)\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t},\r\n\t\tcomplete: function(value) {\r\n\t\t\t// for ES7 observable compatibility\r\n\t\t\tthis.put(value)\r\n\t\t},\r\n\t\tsetValue: function(value) {\r\n\t\t\treturn this.value = value\r\n\t\t},\r\n\t\tonValue: function(listener) {\r\n\t\t\treturn this.subscribe(function(event) {\r\n\t\t\t\twhen(event.value(), function(value) {\r\n\t\t\t\t\tlistener(value)\r\n\t\t\t\t})\r\n\t\t\t})\r\n\t\t},\r\n\t\ttoJSON: function() {\r\n\t\t\treturn this.valueOf()\r\n\t\t},\r\n\t\ttoString: function() {\r\n\t\t\treturn String(this.valueOf())\r\n\t\t},\r\n\t\tforEach: function(callbackOrItemClass, callback) {\r\n\t\t\t// iterate through current value of variable\r\n\t\t\tif (callbackOrItemClass.notifies) {\r\n\t\t\t\treturn this.forEach(function(item) {\r\n\t\t\t\t\tvar itemVariable = callbackOrItemClass.from(item)\r\n\t\t\t\t\tcallback.call(this, itemVariable)\r\n\t\t\t\t}, context)\r\n\t\t\t}\r\n\t\t\tvar collectionOf = this.collectionOf\r\n\t\t\tif (collectionOf) {\r\n\t\t\t\tvar variable = this\r\n\t\t\t\treturn when(this.valueOf(true), function(value) {\r\n\t\t\t\t\tif (value && value.forEach) {\r\n\t\t\t\t\t\tvalue.forEach(function(item, index) {\r\n\t\t\t\t\t\t\tcallbackOrItemClass.call(variable, variable.property(index, collectionOf))\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\treturn when(this.valueOf(true), function(value) {\r\n\t\t\t\tif (value && value.forEach) {\r\n\t\t\t\t\tvalue.forEach(callbackOrItemClass)\r\n\t\t\t\t}else{\r\n\t\t\t\t\tfor (var i in value) {\r\n\t\t\t\t\t\tcallbackOrItemClass.call(value, value[i], i)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t},\r\n\r\n\t\tto: function (transformFunction, reverse) {\r\n\t\t\tif (typeof transformFunction !== 'function') {\r\n\t\t\t\tif (typeof transformFunction === 'object') {\r\n\t\t\t\t\tthis.to(transformFunction.get, transformFunction.set)\r\n\t\t\t\t}\r\n\t\t\t\tthrow new Error('No function provided to transform')\r\n\t\t\t}\r\n\t\t\tif (reverse) {\r\n\t\t\t\ttransformFunction.reverse = function(value, args) {\r\n\t\t\t\t\t// for direct to, we can just use the first argument\r\n\t\t\t\t\treverse.call(this, value, args[0])\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (transformFunction.prototype instanceof Variable) {\r\n\t\t\t\treturn new transformFunction(this)\r\n\t\t\t}\r\n\t\t\treturn new (this._Transform || Transform)(this, transformFunction)\r\n\t\t},\r\n\t\tmap: function (transformFunction) {\r\n\t\t\treturn this.to(function(value) {\r\n\t\t\t\tif (value instanceof Array) {\r\n\t\t\t\t\tthrow new Error('map without VArray')\r\n\t\t\t\t}\r\n\t\t\t\treturn transformFunction(value)\r\n\t\t\t})\r\n\t\t},\r\n\t\tas: function(Class) {\r\n\t\t\t// easiest way to cast to a variable class\r\n\t\t\tvar instance = new Class(this)\r\n\t\t\tinstance.fixed = true\r\n\t\t\treturn instance\r\n\t\t},\r\n\t\twhileResolving: function(valueUntilResolved, useLastValue) {\r\n\t\t\treturn valueUntilResolved || arguments.length > 0 ? new WhileResolving(this, valueUntilResolved, useLastValue) :\r\n\t\t\t\tnew WhileResolving(this, undefined, true) // for zero arguments we default to the last value\r\n\t\t},\r\n\t\tget schema() {\r\n\t\t\t// default schema is the constructor\r\n\t\t\tif (this.returnedVariable) {\r\n\t\t\t\treturn this.returnedVariable.schema\r\n\t\t\t}\r\n\t\t\tif (this.parent) {\r\n\t\t\t\tvar parentSchemaProperties = this.parent.schema.properties || this.parent.schema\r\n\t\t\t\treturn parentSchemaProperties && parentSchemaProperties[this.key]\r\n\t\t\t}\r\n\t\t\treturn this.constructor\r\n\t\t},\r\n\t\tset schema(schema) {\r\n\t\t\t// but allow it to be overriden\r\n\t\t\tObject.defineProperty(this, 'schema', {\r\n\t\t\t\tvalue: schema\r\n\t\t\t})\r\n\t\t},\r\n\t\tvalidate: function(target, schema) {\r\n\t\t\tif (this.returnedVariable) {\r\n\t\t\t\treturn this.returnedVariable.validate(target, schema)\r\n\t\t\t}\r\n\t\t\tif (this.parent) {\r\n\t\t\t\treturn this.parent.validate(target.valueOf(), schema)\r\n\t\t\t}\r\n\t\t\tif (schema) {\r\n\t\t\t\tif (schema.type && (schema.type !== typeof target)) {\r\n\t\t\t\t\treturn ['Target type of ' + typeof target + ' does not match schema type of ' + schema.type]\r\n\t\t\t\t}\r\n\t\t\t\tif (schema.required && (target == null || target == '' || (typeof target === 'number' && isNaN(target)))) {\r\n\t\t\t\t\treturn ['Value is required']\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tvar valid = []\r\n\t\t\tvalid.isValid = true\r\n\t\t\treturn valid\r\n\t\t},\r\n\r\n\t\tget validation() {\r\n\t\t\tvar validation = new Validating(this)\r\n\t\t\tObject.defineProperty(this, 'validation', {\r\n\t\t\t\tvalue: validation\r\n\t\t\t})\r\n\t\t\treturn validation\r\n\t\t},\r\n\t\tset validation(validation) {\r\n\t\t\t// but allow it to be overriden\r\n\t\t\tObject.defineProperty(this, 'validation', {\r\n\t\t\t\tvalue: validation\r\n\t\t\t})\r\n\t\t},\r\n\t\tset structured(structure) {\r\n\t\t\t// find any variable properties and attaches them as a property\r\n\t\t\tvar keys = Object.keys(this)\r\n\t\t\tvar properties = keys.length > 1 && this._properties || (this._properties = {})\r\n\t\t\tfor(var i = 0, l = keys.length; i < l; i++) {\r\n\t\t\t\tvar key = keys[i]\r\n\t\t\t\tvar value = this[key]\r\n\t\t\t\tif (value instanceof Variable) {\r\n\t\t\t\t\tvar existing = properties[key]\r\n\t\t\t\t\tif (existing) {\r\n\t\t\t\t\t\tif (existing !== value) {\r\n\t\t\t\t\t\t\t// an existing property exists, put in it\r\n\t\t\t\t\t\t\texisting.put(value)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (value.parent) {\r\n\t\t\t\t\t\t\tif (value.parent === this) {\r\n\t\t\t\t\t\t\t\tcontinue // just being assigned to another property\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// property already exists with different parent, make a proxy\r\n\t\t\t\t\t\t\t\tvar newValue = new Variable()\r\n\t\t\t\t\t\t\t\tnewValue.proxy(value)\r\n\t\t\t\t\t\t\t\tvalue = newValue\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvalue.key = key\r\n\t\t\t\t\t\tvalue.parent = this\r\n\t\t\t\t\t\tproperties[key] = value\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tgetId: function() {\r\n\t\t\treturn this.id || (this.id = Variable.nextId++)\r\n\t\t},\r\n\t\tobserveObject: function() {\r\n\t\t\tvar variable = this\r\n\t\t\treturn when(this.valueOf(), function(object) {\r\n\t\t\t\tvar listeners = propertyListenersMap.get(object)\r\n\t\t\t\tif (!listeners) {\r\n\t\t\t\t\tpropertyListenersMap.set(object, listeners = [])\r\n\t\t\t\t}\r\n\t\t\t\tif (listeners.observerCount) {\r\n\t\t\t\t\tlisteners.observerCount++\r\n\t\t\t\t}else{\r\n\t\t\t\t\tlisteners.observerCount = 1\r\n\t\t\t\t\tvar observer = listeners.observer = lang.observe(object, function(events) {\r\n\t\t\t\t\t\tfor (var i = 0, l = listeners.length; i < l; i++) {\r\n\t\t\t\t\t\t\tvar listener = listeners[i]\r\n\t\t\t\t\t\t\tfor (var j = 0, el = events.length; j < el; j++) {\r\n\t\t\t\t\t\t\t\tvar event = events[j]\r\n\t\t\t\t\t\t\t\tlistener._propertyChange(event.name, object)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t\tif (observer.addKey) {\r\n\t\t\t\t\t\tfor (var i = 0, l = listeners.length; i < l; i++) {\r\n\t\t\t\t\t\t\tvar listener = listeners[i]\r\n\t\t\t\t\t\t\tlistener.eachKey(function(key) {\r\n\t\t\t\t\t\t\t\tobserver.addKey(key)\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tregisterListener(object, variable)\r\n\t\t\t\treturn {\r\n\t\t\t\t\tremove: function() {\r\n\t\t\t\t\t\tderegisterListener(object, variable)\r\n\t\t\t\t\t\tif (!(--listeners.observerCount)) {\r\n\t\t\t\t\t\t\tlisteners.observer.remove()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t},\r\n\t\t\t\t\tdone: function() {\r\n\t\t\t\t\t\t// deliver changes\r\n\t\t\t\t\t\tlang.deliverChanges(observer)\r\n\t\t\t\t\t\tthis.remove()\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t},\r\n\t\tgetCollectionOf: function() {\r\n\t\t\treturn this.returnedVariable && this.returnedVariable.collectionOf || this.constructor.collectionOf\r\n\t\t},\r\n\t\t_sN: function(name) {\r\n\t\t\t// for compilers to set a name\r\n\t\t\tthis.name = name\r\n\t\t\treturn this\r\n\t\t},\r\n\t\tget _debug() {\r\n\t\t\tif (this.__debug === undefined) {\r\n\t\t\t\tthis.__debug = this.name || (Math.random() + '').slice(2)\r\n\t\t\t}\r\n\t\t\treturn this.__debug\r\n\t\t},\r\n\t\tset _debug(_debug) {\r\n\t\t\tthis.__debug = _debug\r\n\t\t},\r\n\t\tget _lastUpdated() {\r\n\t\t\treturn new Date(this.getVersion())\r\n\t\t}\r\n\t}\r\n\r\n\t// a variable inheritance change goes through its own prototype, so classes/constructor\r\n\t// can be used as variables as well\r\n\tfor (var key in VariablePrototype) {\r\n\t\tObject.defineProperty(Variable, key, Object.getOwnPropertyDescriptor(VariablePrototype, key))\r\n\t}\r\n\r\n\tVariable.as = function(Type) {\r\n\t\tvar NewType = this.with({})\r\n\t\tvar target = NewType.prototype\r\n\t\tvar prototype = Type.prototype\r\n\t\tdo {\r\n\t\t\tvar names = Object.getOwnPropertyNames(prototype)\r\n\t\t\tfor (var i = 0; i < names.length; i++) {\r\n\t\t\t\tvar name = names[i]\r\n\t\t\t\tif (!Object.getOwnPropertyDescriptor(target, name)) {\r\n\t\t\t\t\tObject.defineProperty(target, name, Object.getOwnPropertyDescriptor(prototype, name))\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tprototype = getPrototypeOf(prototype)\r\n\t\t} while (prototype && prototype !== Variable.prototype)\r\n\t\treturn NewType\r\n\t}\r\n\r\n\tVariable.with = function(properties, ExtendedVariable) {\r\n\t\t// TODO: handle arguments\r\n\t\tvar Base = this\r\n\t\tvar prototype\r\n\t\tif (Object.getOwnPropertyDescriptor(this, 'prototype').writable === false) {\r\n\t\t\t// extending native class\r\n\t\t\tExtendedVariable = lang.extendClass(this)\r\n\t\t\tprototype = ExtendedVariable.prototype\r\n\t\t} else {\r\n\t\t\t// extending function/constructor\r\n\t\t\tExtendedVariable = ExtendedVariable || function() {\r\n\t\t\t\tif (this instanceof ExtendedVariable) {\r\n\t\t\t\t\tBase.apply(this, arguments)\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn ExtendedVariable.with(properties)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tprototype = ExtendedVariable.prototype = Object.create(this.prototype)\r\n\t\t\tprototype.constructor = ExtendedVariable\r\n\t\t\tsetPrototypeOf(ExtendedVariable, this)\r\n\t\t}\r\n\t\treturn ExtendedVariable.assign(properties)\r\n\t}\r\n\tVariable.assign = function(properties) {\r\n\t\tvar prototype = this.prototype\r\n\t\tfor (var key in properties) {\r\n\t\t\tvar descriptor = Object.getOwnPropertyDescriptor(properties, key)\r\n\t\t\tvar value = descriptor.value\r\n\t\t\tif (typeof value === 'function' && key !== 'collectionOf') {\r\n\t\t\t\tif (value.notifies) {\r\n\t\t\t\t\t// variable class\r\n\t\t\t\t\tdescriptor = (function(key, Class) {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\tget: function() {\r\n\t\t\t\t\t\t\t\tvar property = (this._properties || (this._properties = {}))[key]\r\n\t\t\t\t\t\t\t\tif (!property) {\r\n\t\t\t\t\t\t\t\t\tthis._properties[key] = property = new Class()\r\n\t\t\t\t\t\t\t\t\tproperty.key = key\r\n\t\t\t\t\t\t\t\t\tproperty.parent = this\r\n\t\t\t\t\t\t\t\t\tif (property.listeners) {\r\n\t\t\t\t\t\t\t\t\t\t// if it already has listeners, need to reinit it with the parent\r\n\t\t\t\t\t\t\t\t\t\tproperty.init()\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\treturn property\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\tset: function(value) {\r\n\t\t\t\t\t\t\t\tthis[key]._changeValue(RequestSet, value)\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\tenumerable: true\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})(key, value)\r\n\t\t\t\t\tif (value === Variable) {\r\n\t\t\t\t\t\tvalue = Variable() // create own instance\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvalue.isPropertyClass = true\r\n\t\t\t\t} else if (isGenerator(value)) {\r\n\t\t\t\t\tdescriptor = getGeneratorDescriptor(value)\r\n\t\t\t\t} else if (value.defineAs) {\r\n\t\t\t\t\tdescriptor = value.defineAs(key)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvalue = generalizeMethod(value, key)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tObject.defineProperty(prototype, key, descriptor)\r\n\t\t\tif (value !== undefined) {\r\n\t\t\t\t// TODO: If there is a getter/setter here, use defineProperty\r\n\t\t\t\tthis[key] = value\r\n\t\t\t} else {\r\n\t\t\t\t// getter/setter\r\n\t\t\t\tObject.defineProperty(this, key, descriptor)\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (properties && properties.hasOwn) {\r\n\t\t\thasOwn.call(this, properties.hasOwn)\r\n\t\t}\r\n\t\treturn this\r\n\t}\r\n\r\n\tObject.defineProperty(Variable, 'defaultInstance', {\r\n\t\tget: function() {\r\n\t\t\treturn this.hasOwnProperty('_defaultInstance') ?\r\n\t\t\t\tthis._defaultInstance : (\r\n\t\t\t\t\tthis._defaultInstance = new this(),\r\n\t\t\t\t\tthis._defaultInstance.subject = defaultContext,\r\n\t\t\t\t\tthis._defaultInstance)\r\n\t\t}\r\n\t})\r\n\tVariable.hasOwn = function(Target, createInstance) {\r\n\t\tvar instanceMap = new lang.WeakMap()\r\n\t\tinstanceMap.createInstance = createInstance\r\n\t\tvar subjectMap = this.ownedClasses || (this.ownedClasses = new lang.WeakMap())\r\n\t\tsubjectMap.set(Target, instanceMap)\r\n\t}\r\n\r\n\r\n\tfunction arrayToModify(variable, callback) {\r\n\t\t// TODO: switch this to allow promises\r\n\t\treturn when(variable.cachedValue || variable.valueOf(true), function(array) {\r\n\t\t\tvar newArray = array ?\r\n\t\t\t\tvariable.isWritable ? array.slice(0) : array\r\n\t\t\t\t: []\r\n\t\t\tvar results = callback.call(variable, newArray)\r\n\t\t\treturn when(newArray === array ? // if we are just modifying the original array\r\n\t\t\t\t\tvariable.updated(results[1], variable) : // then just send out an updated event\r\n\t\t\t\t\tvariable.put(newArray, results[1]), function() { // otherwise put in the new array\r\n\t\t\t\tvariable.cachedVersion++ // update the cached version, so any version checking will know it has changed\r\n\t\t\t\treturn results[0]\r\n\t\t\t})\r\n\t\t})\r\n\t}\r\n\r\n\tfunction insertedAt(variable, added, startingIndex, arrayLength, event) {\r\n\t\tvar addedCount = added.length\r\n\t\t// adjust the key positions of any index properties after splice\r\n\t\tif (addedCount > 0) {\r\n\t\t\tevent = event || new ArrayEvent({\r\n\t\t\t\tmodifier: variable,\r\n\t\t\t\tactions: []\r\n\t\t\t})\r\n\t\t\tvar arrayPosition\r\n\t\t\tfor (var i = arrayLength - addedCount; i > startingIndex;) {\r\n\t\t\t\tvar arrayPosition = variable[--i]\r\n\t\t\t\tif (arrayPosition) {\r\n\t\t\t\t\tvariable[i] = undefined\r\n\t\t\t\t\tarrayPosition.key += addedCount\r\n\t\t\t\t\tvariable[arrayPosition.key] = arrayPosition\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// send out updates\r\n\t\t\tfor (var i = 0, l = added.length; i < l; i++) {\r\n\t\t\t\tevent.actions.push({\r\n\t\t\t\t\tvalue: added[i],\r\n\t\t\t\t\tindex: i + startingIndex,\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn event\r\n\t}\r\n\r\n\tfunction removedAt(variable, removed, startingIndex, removalCount, arrayLength) {\r\n\t\t// adjust the properties\r\n\t\tvar i = startingIndex + removalCount\r\n\t\tvar arrayPosition\r\n\t\tif (removalCount > 0) {\r\n\t\t\tvar event = new ArrayEvent({\r\n\t\t\t\tmodifier: variable,\r\n\t\t\t\tactions: []\r\n\t\t\t})\r\n\t\t\tfor (var i = startingIndex + removalCount; i < arrayLength + removalCount; i++) {\r\n\t\t\t\tvar arrayPosition = variable[i]\r\n\t\t\t\tif (arrayPosition) {\r\n\t\t\t\t\tvariable[i] = undefined\r\n\t\t\t\t\tarrayPosition.key -= removalCount\r\n\t\t\t\t\tvariable[arrayPosition.key] = arrayPosition\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// send out updates\r\n\t\t\tfor (var i = 0; i < removalCount; i++) {\r\n\t\t\t\tevent.actions.push({\r\n\t\t\t\t\tpreviousIndex: startingIndex,\r\n\t\t\t\t\toldValue: removed[i]\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tvariable.cachedVersion = variable.version // update the cached version so it doesn't need to be recomputed\r\n\t\t}\r\n\t\treturn event\r\n\t}\r\n\r\n\tif (typeof Symbol !== 'undefined') {\r\n\t\tVariable.prototype[Symbol.iterator] = function() {\r\n\t\t\tvar iterator = this.valueOf()[Symbol.iterator]()\r\n\t\t\tvar variable = this\r\n\t\t\tvar collectionOf = this.collectionOf\r\n\t\t\tif (collectionOf) {\r\n\t\t\t\tvar parent = this\r\n\t\t\t\tvar i = 0\r\n\t\t\t\treturn {\r\n\t\t\t\t\tnext: function() {\r\n\t\t\t\t\t\tvar result = iterator.next()\r\n\t\t\t\t\t\tif (!result.done) {\r\n\t\t\t\t\t\t\tresult.value = variable.property(i++, collectionOf)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn result\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn iterator\r\n\t\t}\r\n\t}\r\n\r\n\tvar VMap = Variable.VMap = lang.compose(Variable, function(value){\r\n\t\tif (typeof value !== 'undefined') {\r\n\t\t\tthis.value = value\r\n\t\t}\r\n\t}, {\r\n\t\tfixed: true,\r\n\t\tisWritable: false,\r\n\t\t// TODO: Move all the get and set functionality for maps out of Variable\r\n\t\tproperty: function(key, PropertyClass) {\r\n\t\t\tvar properties = this._properties || (this._properties = new Map())\r\n\t\t\tvar propertyVariable = properties.get(key)\r\n\t\t\tif (!propertyVariable) {\r\n\t\t\t\t// create the property variable\r\n\t\t\t\tpropertyVariable = new (PropertyClass || this.PropertyClass)()\r\n\t\t\t\tpropertyVariable.key = key\r\n\t\t\t\tpropertyVariable.parent = this\r\n\t\t\t\tif (propertyVariable.listeners) {\r\n\t\t\t\t\t// if it already has listeners, need to reinit it with the parent\r\n\t\t\t\t\tpropertyVariable.init()\r\n\t\t\t\t}\r\n\t\t\t\tproperties.set(key, propertyVariable)\r\n\t\t\t}\r\n\t\t\treturn propertyVariable\r\n\t\t}\r\n\t})\r\n\r\n\tvar Transform = Variable.Transform = lang.compose(Variable, function Transform(source, transform, sources) {\r\n\t\tif (source !== undefined || sources) {\r\n\t\t\tthis.source = source\r\n\t\t}\r\n\t\tif (transform) {\r\n\t\t\tthis.transform = transform\r\n\t\t\tif (sources) {\r\n\t\t\t\tfor (var i = 1, l = sources.length; i < l; i++) {\r\n\t\t\t\t\tthis['source' + i] = sources[i]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}, {\r\n\t\tgetValue: function() {\r\n\t\t\t// first check to see if we have the variable already computed\r\n\t\t\tif (this.readyState == 'invalidated') {\r\n\t\t\t\tthis.readyState = nextVersion.toString()\r\n\t\t\t} else if (isFinite(this.readyState)) {\r\n\t\t\t\t// will un-invalidate this later (contextualizedVariable.readyState = 'up-to-date')\r\n\t\t\t} else if ((this.listeners && this.readyState === 'up-to-date' || this.staysUpdated) && this.cachedVersion > -1) {\r\n\t\t\t\t// it is live, so we can shortcut and just return the cached value\r\n\t\t\t\tif (context) {\r\n\t\t\t\t\tcontext.setVersion(this.cachedVersion)\r\n\t\t\t\t\tif (context.ifModifiedSince >= this.cachedVersion && !this.returnedVariable) {\r\n\t\t\t\t\t\treturn NOT_MODIFIED\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn this.promise || this.cachedValue\r\n\t\t\t}\r\n\t\t\t/*if (!this.hasOwnProperty('source1') && context) {\r\n\t\t\t\t// TODO: Not sure if this is a helpful optimization or not\r\n\t\t\t\t// if we have a single source, we can use ifModifiedSince\r\n\t\t\t\tif (!contextualizedVariable && this.context && this.context.matches(context)) {\r\n\t\t\t\t\t\tcontextualizedVariable = this\r\n\t\t\t\t\t}\r\n\t\t\t}*/\r\n\t\t\tvar readyState = this.readyState\r\n\t\t\tvar parentContext = context\r\n\t\t\tvar transformContext = context = context ? context.newContext() : new Context()\r\n\t\t\tvar args = []\r\n\t\t\tvar isAsyncInputs\r\n\t\t\ttry {\r\n\t\t\t\tif (this.version) {\r\n\t\t\t\t\t// get the version in there\r\n\t\t\t\t\ttransformContext.setVersion(this.version)\r\n\t\t\t\t}\r\n\t\t\t\tif (this && this.cachedVersion >= this.version && this.cachedVersion > -1 && !this.hasOwnProperty('source1')) {\r\n\t\t\t\t\ttransformContext.ifModifiedSince = this.cachedVersion\r\n\t\t\t\t}\r\n\t\t\t\t// TODO: var hasCustomTransformFunction = this.transform && this.transform.value === ObjectValueOf\r\n\t\t \t\tvar transform = this.transform && this.transform.valueOf()\r\n\r\n\t\t\t\tvar argument, argumentName, lastPromiseResult, resolved = []\r\n\t\t\t\tvar afterPromiseResolved\r\n\t\t\t\tvar remaining = 1\r\n\t\t\t\tvar variable = this\r\n\t\t\t\tvar whenArgumentResolved = function(result) {\r\n\t\t\t\t\tresolved[this.__index || 0] = result\r\n\t\t\t\t\tremaining--\r\n\t\t\t\t\tif(remaining === 0) {\r\n\t\t\t\t\t\treturn whenAllResolved()\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\treturn this.__previousPromiseResult\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tfor (var i = 0; (argument = this[argumentName = i > 0 ? 'source' + i : 'source']) || argumentName in this; i++) {\r\n\t\t\t\t\tif (argument) {\r\n\t\t\t\t\t\tvar result = argument.valueOf(true)\r\n\t\t\t\t\t\tif (result && result.then) {\r\n\t\t\t\t\t\t\tremaining++\r\n\t\t\t\t\t\t\tif (i === 0) {\r\n\t\t\t\t\t\t\t\tlastPromiseResult = result.then(whenArgumentResolved)\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tlastPromiseResult = result.then(whenArgumentResolved.bind({\r\n\t\t\t\t\t\t\t\t\t__index: i,\r\n\t\t\t\t\t\t\t\t\t__previousPromiseResult: lastPromiseResult\r\n\t\t\t\t\t\t\t\t}))\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tresolved[i] = result\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tresolved[i] = argument\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (--remaining === 0) {\r\n\t\t\t\t\treturn whenAllResolved()\r\n\t\t\t\t\t// everything resolved, fast path\r\n\t\t\t\t}\r\n\t\t\t\tisAsyncInputs = true\r\n\t\t\t\tfunction whenAllResolved() {\r\n\t \t\t\t\tif (transformContext.ifModifiedSince !== undefined) {\r\n\t \t\t\t\t\ttransformContext.ifModifiedSince = undefined\r\n\t \t\t\t\t}\r\n\t\t\t\t\tvar version = transformContext.version\r\n\t\t\t\t\tif (variable.cachedVersion >= version || resolved[0] == NOT_MODIFIED) { // note that cached version can get \"ahead\" of `version` of all dependencies, in cases where the transform ends up executing an valueOf() that advances the resolution context version number. \r\n\t\t\t\t\t\t// get it out of the cache\r\n\t\t\t\t\t\tif (parentContext) {\r\n\t\t\t\t\t\t\tparentContext.setVersion(version)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (parentContext && parentContext.ifModifiedSince >= version &&\r\n\t\t\t\t\t\t\t\tparentContext.ifModifiedSince >= variable.cachedVersion &&\r\n\t\t\t\t\t\t\t\t!variable.returnedVariable) {\r\n\t\t\t\t\t\t\treturn NOT_MODIFIED\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn variable.promise || promiseSafeResult(variable.cachedValue)\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvar result = transform ? transform.apply(variable, resolved) : resolved[0]\r\n\t\t\t\t\tvar isPromise = result && result.then && !result.notifies\r\n\t\t\t\t\tversion = transformContext.version\r\n\r\n\t\t\t\t\tif (isPromise) {\r\n\t\t\t\t\t\tvar promise = variable.promise = result\r\n\t\t\t\t\t\tvariable.cachedVersion = version\r\n\t\t\t\t\t\tresult = result.then(function(resolved) {\r\n\t\t\t\t\t\t\tif (promise === variable.promise) { // make sure we are still the latest promise\r\n\t\t\t\t\t\t\t\tvariable.promise = null\r\n\t\t\t\t\t\t\t\tonResolve(resolved, transformContext.version)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn resolved\r\n\t\t\t\t\t\t}, function(error) {\r\n\t\t\t\t\t\t\tif (promise === variable.promise) { // make sure we are still the latest promise\r\n\t\t\t\t\t\t\t\t// clear out the cache on an error\r\n\t\t\t\t\t\t\t\tvariable.promise = null\r\n\t\t\t\t\t\t\t\tvariable.lastError = error\r\n\t\t\t\t\t\t\t\tonResolve(null, -1)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tthrow error // rethrow so it isn't silenced\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tonResolve(result, version)\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn promiseSafeResult(result)\r\n\r\n\t\t\t\t\tfunction promiseSafeResult(result) {\r\n\t\t\t\t\t\tif (isAsyncInputs && result && result.notifies) {\r\n\t\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\t\t__variable: result\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn result\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfunction onResolve(result, version) {\r\n\t\t\t\t\t\tif (variable.readyState === readyState) {\r\n\t\t\t\t\t\t\tif (parentContext) {\r\n\t\t\t\t\t\t\t\tparentContext.setVersion(version)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tvariable.readyState = (variable.listeners || variable.staysUpdated || parentContext && parentContext.notifies) ? 'up-to-date' : '' // mark it as up-to-date now\r\n\t\t\t\t\t\t\tvariable.cachedVersion = version\r\n\t\t\t\t\t\t\tvariable.cachedValue = result\r\n\t\t\t\t\t\t}/* else {\r\n\t\t\t\t\t\t\tconsole.log('ready state different than when the variable trasnform started ', variable, variable.readyState, readyState)\r\n\t\t\t\t\t\t}*/\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn lastPromiseResult\r\n\t\t\t} finally {\r\n\t\t\t\tif (parentContext) {\r\n\t\t\t\t\tparentContext.setVersion(transformContext.version)\r\n\t\t\t\t}\r\n\t \t\t\tcontext = parentContext\r\n\t \t\t}\r\n\t \t},\r\n\r\n\t\tforDependencies: function(callback) {\r\n\t\t\t// depend on the args\r\n\t\t\tVariable.prototype.forDependencies.call(this, callback)\r\n\t\t\tvar argument, argumentName\r\n\t\t\tfor (var i = 0; (argument = this[argumentName = i > 0 ? 'source' + i : 'source']) || argumentName in this; i++) {\r\n\t\t\t\tif (argument && argument.notifies) {\r\n\t\t\t\t\tcallback(argument)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tupdated: function(updateEvent, by, isDownstream) {\r\n\t\t\tthis.readyState = 'invalidated'\r\n\t\t\tif (this.promise) {\r\n\t\t\t\tthis.promise = null\r\n\t\t\t}\r\n\t\t\tif (by !== this.returnedVariable && updateEvent && updateEvent.type !== 'refresh') {\r\n\t\t\t\t// search for the output in the sources\r\n\t\t\t\tvar argument, argumentName\r\n\t\t\t\tfor (var i = 0; (argument = this[argumentName = i > 0 ? 'source' + i : 'source']) || argumentName in this; i++) {\r\n\t\t\t\t\tif (argument === by) {\r\n\t\t\t\t\t\t// if one of the args was updated, we need to do a full refresh (we can't compute differential events without knowledge of how the mapping function works)\r\n\t\t\t\t\t\tupdateEvent = new RefreshEvent()\r\n\t\t\t\t\t\tcontinue\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn Variable.prototype.updated.call(this, updateEvent, by, isDownstream)\r\n\t\t},\r\n\r\n\t\tcleanup: function() {\r\n\t\t\tif (this.readyState === 'up-to-date' && !this.staysUpdated) {\r\n\t\t\t\tthis.readyState = '' // once there are no listeners, we can't guarantee we are up-to-date\r\n\t\t\t}\r\n\t\t\tVariable.prototype.cleanup.call(this)\r\n\t\t},\r\n\r\n\t\tgetUpdates: function(since) {\r\n\t\t\t// this always issues updates, nothing incremental can flow through it\r\n\t\t\tif (!since || since.version < getVersion()) {\r\n\t\t\t\treturn [new RefreshEvent()]\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tgetArguments: function() {\r\n\t\t\tvar args = []\r\n\t\t\tvar argument, argumentName\r\n\t\t\tfor (var i = 0; (argument = this[argumentName = i > 0 ? 'source' + i : 'source']) || argumentName in this; i++) {\r\n\t\t\t\targs.push(argument)\r\n\t\t\t}\r\n\t\t\treturn args\r\n\t\t},\r\n\t\tput: function(value, event) {\r\n\t\t\tvar call = this\r\n\t\t\treturn when(this.valueOf(true), function(originalValue) {\r\n\t\t\t\tif (originalValue === value && typeof value != 'object') {\r\n\t\t\t\t\treturn noChange\r\n\t\t\t\t}\r\n\t\t\t\tvar transform = call.transform.valueOf()\r\n\t\t\t\tif (transform.reverse) {\r\n\t\t\t\t\t(transform.reverse).call(call, value, call.getArguments())\r\n\t\t\t\t\tcall.updated(event)\r\n\t\t\t\t} else if (originalValue && originalValue.put) {\r\n\t\t\t\t\treturn originalValue.put(value, event)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar error = new Error('Can not put value into a one-way transform, that lacks a reversal')\r\n\t\t\t\t\terror.deniedPut = true\r\n\t\t\t\t\tthrow error\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t},\r\n\t\tsetReverse: function(reverse) {\r\n\t\t\tthis.transform.valueOf().reverse = reverse\r\n\t\t\treturn this\r\n\t\t}\r\n\t})\r\n\tObject.defineProperty(Transform.prototype, 'isWritable', {\r\n\t\tget: function() {\r\n\t\t\treturn this.transform && !!this.transform.reverse\r\n\t\t}\r\n\t})\r\n\r\n\tvar RESOLUTION_UPDATE = {}\r\n\t\tWhileResolving = lang.compose(Transform, function WhileResolving(variable, defaultValue, useLastValue) {\r\n\t\tthis.source = variable\r\n\t\tif (defaultValue !== undefined) {\r\n\t\t\tthis.default = defaultValue\r\n\t\t}\r\n\t\tif (useLastValue) {\r\n\t\t\tthis.useLastValue = true\r\n\t\t}\r\n\t}, {\r\n\t\tfixed: true,\r\n\t\tgetValue: function() {\r\n\t\t\tvar result = Transform.prototype.getValue.call(this)\r\n\t\t\tif (result && result.then) {\r\n\t\t\t\tvar version = this.version\r\n\t\t\t\tvar variable = this\r\n\t\t\t\tresult.then(function(value) {\r\n\t\t\t\t\tif (version === variable.version) {\r\n\t\t\t\t\t\tVariable.prototype.updated.call(variable)\r\n\t\t\t\t\t\tvariable.cachedVersion = variable.version\r\n\t\t\t\t\t}\r\n\t\t\t\t}, function (error) {\r\n\t\t\t\t\tconsole.error('Variable resolution failed', error)\r\n\t\t\t\t})\r\n\t\t\t\treturn this.useLastValue && 'cachedValue' in this ? this.cachedValue : this.default\r\n\t\t\t}\r\n\t\t\treturn result\r\n\t\t},\r\n\t\tput: function(value, event) {\r\n\t\t\treturn this.source.put(value, event)\r\n\t\t}\r\n\t})\r\n\r\n\tvar ContextualTransform = lang.compose(Transform, function ContextualTransform() {\r\n\t\tTransform.apply(this, arguments)\r\n\t}, {\r\n\t\tgetValue: function() {\r\n\t\t\t// first check to see if we have the variable already computed\r\n\t\t\tvar contextualizedVariable = context ? context.getContextualized(this) : this\r\n\t\t\tif (contextualizedVariable && contextualizedVariable !== this) {\r\n\t\t\t\treturn contextualizedVariable.getValue()\r\n\t\t\t}\r\n\t\t\treturn Transform.prototype.getValue.call(this)\r\n\t\t},\r\n\t\t_needsContextualization: true\r\n\t})\r\n\r\n\tvar Item = lang.compose(Variable, function Item(value, content) {\r\n\t\tthis.value = value\r\n\t\tthis.collection = content\r\n\t}, {})\r\n\r\n\tvar ContextualizedVariable = lang.compose(Variable, function ContextualizedVariable(generic, subject) {\r\n\t\tthis.generic = generic\r\n\t\tthis.subject = subject\r\n\t}, {\r\n\t\tvalueOf: function() {\r\n\t\t\t// TODO: Lookup Context type for all of these using registry or something\r\n\t\t\tvar subject = this.subject\r\n\t\t\tvar context = subject.getContextualized ? subject : new Context(subject)\r\n\t\t\tvar generic = this.generic\r\n\t\t\treturn context.executeWithin(function() {\r\n\t\t\t\treturn generic.valueOf()\r\n\t\t\t})\r\n\t\t},\r\n\r\n\t\tforDependencies: function(callback) {\r\n\t\t\tthis.sources && this.sources.forEach(callback)\r\n\t\t},\r\n\r\n\t\tgetVersion: function() {\r\n\t\t\tvar version = Variable.prototype.getVersion.call(this)\r\n\t\t\tvar sources = this.sources || 0\r\n\t\t\tfor (var i = 0, l = sources.length; i < l; i++) {\r\n\t\t\t\tvar source = sources[i]\r\n\t\t\t\tif (source.getFullVersion) {\r\n\t\t\t\t\tversion = Math.max(version, source.getFullVersion())\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn version\r\n\t\t},\r\n\r\n\t\tput: function(value, event) {\r\n\t\t\tvar subject = this.subject\r\n\t\t\treturn this.generic.put(value, event)\r\n\t\t}\r\n\t})\r\n\r\n\tvar VArray = Variable.VArray = lang.compose(Variable, function VArray(value) {\r\n\t\treturn makeSubVar(this, value, VArray)\r\n\t}, {\r\n\t\t_isStrictArray: true,\r\n\t\t/* TODO: at some point, we might add support for length, but need to make it be dependent/notified by array changes\r\n\t\tget length() {\r\n\t\t\tif (typeof this !== 'function') {\r\n\t\t\t\tObject.defineProperty(this, 'length', {\r\n\t\t\t\t\tconfigurable: true\r\n\t\t\t\t})\r\n\t\t\t\treturn this.property('length')\r\n\t\t\t}\r\n\t\t},\r\n\t\tset length(length) {\r\n\t\t\t// allow overriding\r\n\t\t\tObject.defineProperty(this, 'length', {\r\n\t\t\t\tvalue: length\r\n\t\t\t})\r\n\t\t},*/\r\n\t\tproperty: function(key, PropertyClass) {\r\n\t\t\treturn Variable.prototype.property.call(this, key, PropertyClass || typeof key === 'number' && this.collectionOf)\r\n\t\t},\r\n\t\tsplice: function(startingIndex, removalCount) {\r\n\t\t\tvar args = arguments\r\n\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\tif (startingIndex < 0) {\r\n\t\t\t\t\tstartingIndex = array.length + startingIndex\r\n\t\t\t\t}\r\n\t\t\t\tvar results = array.splice.apply(array, args)\r\n\t\t\t\tvar event = removedAt(this, results, startingIndex, removalCount, array.length)\r\n\t\t\t\tevent = insertedAt(this, [].slice.call(args, 2), startingIndex, array.length, event)\r\n\t\t\t\treturn [results, event]\r\n\t\t\t})\r\n\t\t},\r\n\t\tpush: function() {\r\n\t\t\tvar args = arguments\r\n\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\tvar results = array.push.apply(array, args)\r\n\t\t\t\tvar event = insertedAt(this, args, array.length - args.length, array.length)\r\n\t\t\t\treturn [results, event]\r\n\t\t\t})\r\n\t\t},\r\n\t\tunshift: function() {\r\n\t\t\tvar args = arguments\r\n\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\tvar results = array.unshift.apply(array, args)\r\n\t\t\t\tvar event = insertedAt(this, args, 0, array.length)\r\n\t\t\t\treturn [results, event]\r\n\t\t\t})\r\n\t\t},\r\n\t\tpop: function() {\r\n\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\tvar results = array.pop()\r\n\t\t\t\tvar event = removedAt(this, [results], array.length, 1)\r\n\t\t\t\treturn [results, event]\r\n\t\t\t})\r\n\t\t},\r\n\t\tshift: function() {\r\n\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\tvar results = array.shift()\r\n\t\t\t\tvar event = removedAt(this, [results], 0, 1, array.length)\r\n\t\t\t\treturn [results, event]\r\n\t\t\t})\r\n\t\t}\r\n\t})\r\n\tVArray.of = function(collectionOf) {\r\n\t\tvar ArrayClass = VArray({collectionOf: collectionOf})\r\n\t\tif (this !== VArray) {\r\n\t\t\t// new operator\r\n\t\t\treturn new ArrayClass()\r\n\t\t}\r\n\t\treturn ArrayClass\r\n\t}\r\n\r\n\tfunction toArray(array) {\r\n\t\tif (!array) {\r\n\t\t\treturn []\r\n\t\t}\r\n\t\tif (array.length > -1) {\r\n\t\t\treturn array\r\n\t\t}\r\n\t\tvar newArray = []\r\n\t\tif (array.forEach) {\r\n\t\t\tarray.forEach(function(item) {\r\n\t\t\t\tnewArray.push(item)\r\n\t\t\t})\r\n\t\t}\r\n\t\treturn newArray\r\n\t}\r\n\r\n\tvar getValue\r\n\tvar GeneratorVariable = lang.compose(Transform, function ReactiveGenerator(generator){\r\n\t\tthis.generator = generator\r\n\t}, {\r\n\t\ttransform: {\r\n\t\t\tvalueOf: function() {\r\n\t\t\t\tvar generatorContext = context\r\n\t\t\t\tvar resuming\r\n\t\t\t\treturn next\r\n\t\t\t\tfunction next() {\r\n\t\t\t\t\tvar nextValue\r\n\t\t\t\t\tvar i\r\n\t\t\t\t\tvar generatorIterator\r\n\t\t\t\t\tvar isThrowing\r\n\t\t\t\t\tif (resuming) {\r\n\t\t\t\t\t\t// resuming from a promise\r\n\t\t\t\t\t\tgeneratorIterator = resuming.iterator\r\n\t\t\t\t\t\ti = resuming.i\r\n\t\t\t\t\t\tnextValue = resuming.value\r\n\t\t\t\t\t\tif (nextValue && nextValue.then) {\r\n\t\t\t\t\t\t\tthrow new Error('Generator resumed with promise or variable', nextValue)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tisThrowing = resuming.isThrowing\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (generatorContext) {\r\n\t\t\t\t\t\t\t// must restart the context, if the input values had previously been checked and hashed against this context, must restart them.\r\n\t\t\t\t\t\t\tgeneratorContext.restart()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ti = 0\r\n\t\t\t\t\t\tgeneratorIterator = this.generator()\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tdo {\r\n\t\t\t\t\t\tvar stepReturn = generatorIterator[isThrowing ? 'throw' : 'next'](nextValue)\r\n\t\t\t\t\t\tif (stepReturn.done) {\r\n\t\t\t\t\t\t\tvar oldSources = this.sources || []\r\n\t\t\t\t\t\t\tvar newLength = i\r\n\t\t\t\t\t\t\tvar newSources = []\r\n\t\t\t\t\t\t\twhile(this[argumentName = i > 0 ? 'source' + i : 'source']) {\r\n\t\t\t\t\t\t\t\t// clear out old properties\r\n\t\t\t\t\t\t\t\tthis[argumentName] = undefined\r\n\t\t\t\t\t\t\t\ti++\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tfor (i = 0; i < newLength; i++) {\r\n\t\t\t\t\t\t\t\t// create new array\r\n\t\t\t\t\t\t\t\tvar argumentName = i > 0 ? 'source' + i : 'source'\r\n\t\t\t\t\t\t\t\tif (this[argumentName] && this[argumentName].notifies) {\r\n\t\t\t\t\t\t\t\t\tnewSources.push(this[argumentName])\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tfor (i = 0; i < oldSources.length; i++) {\r\n\t\t\t\t\t\t\t\tif (newSources.indexOf(oldSources[i]) == -1) {\r\n\t\t\t\t\t\t\t\t\toldSources[i].stopNotifies(this)\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tthis.sources = newSources\r\n\t\t\t\t\t\t\treturn stepReturn.value\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tnextValue = stepReturn.value\r\n\t\t\t\t\t\t// compare with the arguments from the last\r\n\t\t\t\t\t\t// execution to see if they are the same\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tvar argumentName = i > 0 ? 'source' + i : 'source'\r\n\t\t\t\t\t\t\tif (this[argumentName] !== nextValue || this[argumentName] === undefined) {\r\n\t\t\t\t\t\t\t\t// subscribe if it is a variable\r\n\t\t\t\t\t\t\t\tif (nextValue && nextValue.notifies) {\r\n\t\t\t\t\t\t\t\t\tif (this.listeners) {\r\n\t\t\t\t\t\t\t\t\t\tnextValue.notifies(this)\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tthis[argumentName] = nextValue\r\n\t\t\t\t\t\t\t\t} else if (typeof nextValue === 'function' && isGenerator(nextValue)) {\r\n\t\t\t\t\t\t\t\t\tresuming = {\r\n\t\t\t\t\t\t\t\t\t\ti: i,\r\n\t\t\t\t\t\t\t\t\t\titerator: nextValue()\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tnext.call(this)\r\n\t\t\t\t\t\t\t\t\ti = resuming.i\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tthis[argumentName] = null\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\ti++\r\n\t\t\t\t\t\t\tif (nextValue && nextValue.then) {\r\n\t\t\t\t\t\t\t\t// if it is a promise or variable, we will wait on it\r\n\t\t\t\t\t\t\t\tvar variable = this\r\n\t\t\t\t\t\t\t\tresuming = {\r\n\t\t\t\t\t\t\t\t\ti: i,\r\n\t\t\t\t\t\t\t\t\titerator: generatorIterator\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tvar isSync = null\r\n\t\t\t\t\t\t\t\t// and return the promise so that the next caller can wait on this\r\n\t\t\t\t\t\t\t\tvar promise = nextValue.then(function(value) {\r\n\t\t\t\t\t\t\t\t\tif (isSync !== false) {\r\n\t\t\t\t\t\t\t\t\t\tisSync = true\r\n\t\t\t\t\t\t\t\t\t\tnextValue = value\r\n\t\t\t\t\t\t\t\t\t\treturn\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tresuming.value = value\r\n\t\t\t\t\t\t\t\t\tif (generatorContext) {\r\n\t\t\t\t\t\t\t\t\t\treturn generatorContext.executeWithin(next.bind(variable))\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\treturn next.call(variable)\r\n\t\t\t\t\t\t\t\t}, function(error) {\r\n\t\t\t\t\t\t\t\t\tresuming.value = error\r\n\t\t\t\t\t\t\t\t\tresuming.isThrowing = true\r\n\t\t\t\t\t\t\t\t\tif (generatorContext) {\r\n\t\t\t\t\t\t\t\t\t\treturn generatorContext.executeWithin(next.bind(variable))\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\treturn next.call(variable)\r\n\t\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\t\tif (!isSync) {\r\n\t\t\t\t\t\t\t\t\tisSync = false\r\n\t\t\t\t\t\t\t\t\treturn promise\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tisThrowing = false\r\n\t\t\t\t\t\t} catch (error) {\r\n\t\t\t\t\t\t\tisThrowing = true\r\n\t\t\t\t\t\t\tnextValue = error\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} while(true)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t})\r\n\r\n\tvar Validating = lang.compose(Transform, function(source) {\r\n\t\tthis.source = source\r\n\t}, {\r\n\t\ttransform: function(target) {\r\n\t\t\tvar target = this.source\r\n\t\t\treturn target && target.validate(target, target.schema)\r\n\t\t}\r\n\t})\r\n\r\n\tfunction makeSubVar(instance, value, Type) {\r\n\t\tif (instance instanceof Variable) {\r\n\t\t\tVariable.call(instance, value)\r\n\t\t} else {\r\n\t\t\treturn Type.with(value)\r\n\t\t}\r\n\t}\r\n\r\n\tfunction objectUpdated(object) {\r\n\t\t// simply notifies any subscribers to an object, that it has changed\r\n\t\tvar listeners = propertyListenersMap.get(object)\r\n\t\tif (listeners) {\r\n\t\t\tfor (var i = 0, l = listeners.length; i < l; i++) {\r\n\t\t\t\tlisteners[i]._propertyChange(null, object)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tvar argsToArray = {\r\n\t\tapply: function(instance, args) {\r\n\t\t\treturn args\r\n\t\t}\r\n\t}\r\n\r\n\tfunction all(array, transform) {\r\n\t\t// This is intended to mirror Promise.all. It actually takes\r\n\t\t// an iterable, but for now we are just looking for array-like\r\n\t\tif (array instanceof Array) {\r\n\t\t\tif (array.length > 1000) {\r\n\t\t\t\t //throw new Error('too big')\r\n\t\t\t}\r\n\t\t\tif (array.length > 0 || typeof transform === 'function') {\r\n\t\t\t\t// TODO: Return VArray Transform\r\n\t\t\t\treturn new Transform(array[0], typeof transform === 'function' ? transform : argsToArray, array)\r\n\t\t\t} else {\r\n\t\t\t\treturn new VArray([])\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (arguments.length > 1) {\r\n\t\t\t// support multiple arguments as an array\r\n\t\t\treturn new Transform(arguments[0], argsToArray, arguments).as(VArray)\r\n\t\t}\r\n\t\tif (typeof array === 'object') {\r\n\t\t\t// allow an object as a hash to be mapped\r\n\t\t\tvar keyMapping = []\r\n\t\t\tvar valueArray = []\r\n\t\t\tfor (var key in array) {\r\n\t\t\t\tkeyMapping.push(key)\r\n\t\t\t\tvalueArray.push(array[key])\r\n\t\t\t}\r\n\t\t\treturn new Variable(function(results) {\r\n\t\t\t\tvar resultObject = {}\r\n\t\t\t\tfor (var i = 0; i < results.length; i++) {\r\n\t\t\t\t\tresultObject[keyMapping[i]] = results[i]\r\n\t\t\t\t}\r\n\t\t\t\treturn resultObject\r\n\t\t\t}).apply(null, valueArray)\r\n\t\t}\r\n\t\tthrow new TypeError('Variable.all requires an array')\r\n\t}\r\n\r\n\tfunction hasOwn(Target, createForInstance) {\r\n\r\n\t\tvar ownedClasses = this.ownedClasses || (this.ownedClasses = new lang.WeakMap())\r\n\t\t// TODO: assign to super classes\r\n\t\tvar Class = this\r\n\t\townedClasses.set(Target, createForInstance || function() { return new Target() })\r\n\t\treturn this\r\n\t}\r\n\tfunction generalizeClass() {\r\n\t\tvar prototype = this.prototype\r\n\t\tvar prototypeNames = Object.getOwnPropertyNames(prototype)\r\n\t\tfor(var i = 0, l = prototypeNames.length; i < l; i++) {\r\n\t\t\tvar name = prototypeNames[i]\r\n\t\t\tObject.defineProperty(this, name, getGeneralizedDescriptor(Object.getOwnPropertyDescriptor(prototype, name), name, this))\r\n\t\t}\r\n\t}\r\n\tfunction getGeneralizedDescriptor(descriptor, name, Class) {\r\n\t\tif (typeof descriptor.value === 'function') {\r\n\t\t\treturn {\r\n\t\t\t\tvalue: generalizeMethod(Class, name)\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\treturn descriptor\r\n\t\t}\r\n\t}\r\n\tfunction generalizeMethod(Class, name) {\r\n\t\t// I think we can just rely on `this`, but we could use the argument:\r\n\t\t// function(possibleEvent) {\r\n\t\t// \tvar target = possibleEvent && possibleEvent.target\r\n\t\tvar method = Class[name] = function() {\r\n\t\t\tvar instance = Class.for(this)\r\n\t\t\treturn instance[name].apply(instance, arguments)\r\n\t\t}\r\n\t\tmethod.for = function(context) {\r\n\t\t\tvar instance = Class.for(context)\r\n\t\t\treturn function() {\r\n\t\t\t\treturn instance[name].apply(instance, arguments)\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn method\r\n\t}\r\n\r\n\tvar defaultContext = {\r\n\t\tname: 'Default context',\r\n\t\tdescription: 'This object is the default context for classes, corresponding to a singleton instance of that class',\r\n\t\tconstructor: {\r\n\t\t\tgetForClass: function(subject, Class) {\r\n\t\t\t\treturn Class.defaultInstance\r\n\t\t\t}\r\n\t\t},\r\n\t\tcontains: function() {\r\n\t\t\treturn true // contains everything\r\n\t\t}\r\n\t}\r\n\tfunction instanceForContext(Class, context) {\r\n\t\tif (!context) {\r\n\t\t\treturn Class.defaultInstance\r\n\t\t}\r\n\t\tvar instance = context.specify(Class)\r\n\t\tif (!context.instanceMap) {\r\n\t\t\tcontext.instanceMap = new Map()\r\n\t\t}\r\n\t\tcontext.instanceMap.set(Class, instance)\r\n\t\treturn instance\r\n//\t\tvar instance = context.subject.constructor.getForClass && context.subject.constructor.getForClass(context.subject, Class) || Class.defaultInstance\r\n//\t\tcontext.distinctSubject = mergeSubject(context.distinctSubject, instance.subject)\r\n//\t\treturn instance\r\n\t}\r\n\tVariable.valueOf = function(allowPromise) {\r\n\t\t// contextualized valueOf\r\n\t\treturn instanceForContext(this, context).valueOf(allowPromise)\r\n\t}\r\n\tVariable.then = function(callback, errback) {\r\n\t\t// contextualized valueOf\r\n\t\treturn instanceForContext(this, context).then(callback, errback)\r\n\t}\r\n\tVariable.getValue = function() {\r\n\t\t// contextualized getValue\r\n\t\treturn instanceForContext(this, context)\r\n\t}\r\n\tVariable.put = function(value) {\r\n\t\t// contextualized setValue\r\n\t\treturn instanceForContext(this, context).put(value)\r\n\t}\r\n\tVariable.for = function(subject) {\r\n\t\tif (subject != null) {\r\n\t\t\tif (subject.target && !subject.constructor.getForClass) {\r\n\t\t\t\t// makes HTML events work\r\n\t\t\t\tsubject = subject.target\r\n\t\t\t}\r\n\t\t\tvar instance\r\n\t\t\tinstance = new Context(subject).specify(this)\r\n\t\t\tif (instance && !instance.subject) {\r\n\t\t\t\tinstance.subject = subject\r\n\t\t\t}\r\n\t\t\t// TODO: Do we have a global context that we set on defaultInstance?\r\n\t\t\treturn instance || this.defaultInstance\r\n\t\t} else {\r\n\t\t\treturn this.defaultInstance\r\n\t\t}\r\n\t}\r\n\tVariable.from = function(value) {\r\n\t\tif (value && typeof value === 'object') {\r\n\t\t\t// a plain object, we use our own map to retrieve the instance (or create one)\r\n\t\t\tvar instanceMap = this.instanceMap || (this.instanceMap = new lang.WeakMap())\r\n\t\t\tvar instance = instanceMap.get(value)\r\n\t\t\tif (!instance) {\r\n\t\t\t\tinstanceMap.set(value, instance = new this(value))\r\n\t\t\t}\r\n\t\t\treturn instance\r\n\t\t} else {\r\n\t\t\t// a primitive, just unconditionally create a new variable for it\r\n\t\t\treturn new this(value)\r\n\t\t}\r\n\t}\r\n\tVariable.notifies = function(target) {\r\n\t\tvar instance = instanceForContext(this, context)\r\n\t\tinstance.notifies(target)\r\n\t\treturn instance\r\n\t}\r\n\tVariable.stopNotifies = function(target) {\r\n\t\tthis.defaultInstance.stopNotifies(target)\r\n\t}\r\n\tVariable.getCollectionOf = function () {\r\n\t\treturn this.collectionOf\r\n\t}\r\n\tVariable.updated = function(updateEvent, by) {\r\n\t\treturn instanceForContext(this, context).updated(updateEvent, by)\r\n\t}\r\n\tVariable._Transform = ContextualTransform\r\n\tvar proxyHandler = {\r\n\t\tget: function(target, name) {\r\n\t\t\tvar value = target[name]\r\n\t\t\treturn value === undefined ? target.property(name) : value\r\n\t\t},\r\n\t\tset: function(target, name, value) {\r\n\t\t\tvar oldValue = target[name]\r\n\t\t\tif (oldValue && oldValue.put) {\r\n\t\t\t\t// own property available to put into\r\n\t\t\t\toldValue.put(value)\r\n\t\t\t} else {\r\n\t\t\t\ttarget.set(name, value)\r\n\t\t\t}\r\n\t\t\treturn true\r\n\t\t},\r\n\t\thas: function(target, name) {\r\n\t\t\treturn (name in target) || (name in target.valueOf())\r\n\t\t},\r\n\t\tdeleteProperty: function(target, name) {\r\n\t\t\treturn proxyHandler.set(target, name, undefined)\r\n\t\t},\r\n\t\townKeys: function(target) {\r\n\t\t\treturn Object.getOwnPropertyNames(target.valueOf())\r\n\t\t}\r\n\t}\r\n\tVariable.proxy = function(source) {\r\n\t\t// should we memoize?\r\n\t\treturn new Proxy(source instanceof this ? source : this.from(source), proxyHandler)\r\n\t}\r\n\tObject.defineProperty(Variable, 'collectionOf', {\r\n\t\tget: function() {\r\n\t\t\treturn this._collectionOf\r\n\t\t},\r\n\t\tset: function(ItemClass) {\r\n\t\t\tif (this._collectionOf != ItemClass) {\r\n\t\t\t\tthis._collectionOf = ItemClass\r\n\t\t\t\tItemClass.collection = this\r\n\t\t\t}\r\n\t\t}\r\n\t})\r\n\tObject.defineProperty(Variable, 'collection', {\r\n\t\tget: function() {\r\n\t\t\treturn this._collection\r\n\t\t},\r\n\t\tset: function(Collection) {\r\n\t\t\tif (this._collection != Collection) {\r\n\t\t\t\tthis._collection = Collection\r\n\t\t\t\tCollection.collectionOf = this\r\n\t\t\t}\r\n\t\t}\r\n\t})\r\n\tVariable.nextVersion = Date.now()\r\n\tVariable.generalize = generalizeClass\r\n\tVariable.call = Function.prototype.call // restore these\r\n\tVariable.apply = Function.prototype.apply\r\n\r\n\tfunction VFunction() {\r\n\t}\r\n\t(VFunction.returns = function(Type){\r\n\t\tfunction VFunction() {}\r\n\t\tVFunction.defineAs = function(method)\t{\r\n\t\t\treturn {\r\n\t\t\t\tvalue: function() {\r\n\t\t\t\t\tvar args = arguments\r\n\t\t\t\t\t// TODO: make these args part of the call so variables can be resolved\r\n\t\t\t\t\t// TODO: may actually want to do getValue().invoke()\r\n\t\t\t\t\treturn new Type(new Transform(this, function(value) {\r\n\t\t\t\t\t\t\treturn value == null ? undefined : value[method].apply(value, args)\r\n\t\t\t\t\t}))\r\n\t\t\t\t},\r\n\t\t\t\twritable: true,\r\n\t\t\t\tconfigurable: true\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn VFunction\r\n\t})\r\n\r\n\tfunction VMethod() {\r\n\t}\r\n\tVMethod.defineAs = function(method) {\r\n\t\treturn {\r\n\t\t\tvalue: function() {\r\n\t\t\t\tvar args = arguments\r\n\t\t\t\t// TODO: make these args part of the call so variables can be resolved\r\n\t\t\t\t// TODO: may actually want to do getValue().invoke()\r\n\t\t\t\tvar variable = this\r\n\t\t\t\treturn when(this.valueOf(), function(value) {\r\n\t\t\t\t\tvar returnValue = value[method].apply(value, args)\r\n\t\t\t\t\treturn when(variable.put(value), function() {\r\n\t\t\t\t\t\treturn returnValue\r\n\t\t\t\t\t})\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\twritable: true,\r\n\t\t\tconfigurable: true\t\t\t\r\n\t\t}\t\t\r\n\t}\r\n\r\n\tfunction VString(value) {\r\n\t\treturn makeSubVar(this, (typeof value === 'object' || value == null) ? value : String(value), VString)\r\n\t}\r\n\r\n\tfunction VNumber(value) {\r\n\t\treturn makeSubVar(this, typeof value === 'object' ? value : Number(value), VNumber)\r\n\t}\r\n\t\r\n\tVString = Variable.with({\r\n\t\tcharAt: VFunction.returns(VString),\r\n\t\tcodeCharAt: VFunction.returns(VNumber),\r\n\t\tindexOf: VFunction.returns(VNumber),\r\n\t\tlastIndexOf: VFunction.returns(VNumber),\r\n\t\tmatch: VFunction.returns(VArray),\r\n\t\treplace: VFunction.returns(VString),\r\n\t\tsubstr: VFunction.returns(VString),\r\n\t\tslice: VFunction.returns(VString),\r\n\t\ttoUpperCase: VFunction.returns(VString),\r\n\t\ttoLowerCase: VFunction.returns(VString),\r\n\t\tlength: VNumber\r\n\t}, VString)\r\n\r\n\tVNumber = Variable.with({\r\n\t\ttoFixed: VFunction.returns(VString),\r\n\t\ttoExponential: VFunction.returns(VString),\r\n\t\ttoPrecision: VFunction.returns(VString),\r\n\t\ttoLocaleString: VFunction.returns(VString)\r\n\t}, VNumber)\r\n\r\n\tfunction VBoolean(value) {\r\n\t\treturn makeSubVar(this, typeof value === 'object' ? value : Boolean(value), VBoolean)\r\n\t}\r\n\tVBoolean = Variable.with({}, VBoolean)\r\n\r\n\tfunction VSet(value) {\r\n\t\treturn makeSubVar(this, value instanceof Array ? new lang.Set(value) : value, VSet)\r\n\t}\r\n\tVSet = Variable.with({\r\n\t\thas: VFunction.returns(VBoolean),\r\n\t\tadd: VMethod,\r\n\t\tclear: VMethod,\r\n\t\tdelete: VMethod\r\n\t}, VSet)\r\n\tObject.defineProperty(VSet.prototype, 'array', {\r\n\t\tget: function() {\r\n\t\t\treturn this._array || (this._array = this.to(toArray).as(VArray))\r\n\t\t}\r\n\t})\r\n\r\n\tfunction VDate(value) {\r\n\t\treturn makeSubVar(this, typeof value === 'object' ? value : new Date(value), VDate)\r\n\t}\r\n\tVDate = Variable.with({\r\n\t\ttoDateString: VFunction.returns(VString),\r\n\t\ttoTimeString: VFunction.returns(VString),\r\n\t\ttoGMTString: VFunction.returns(VString),\r\n\t\ttoUTCString: VFunction.returns(VString),\r\n\t\tgetTime: VFunction.returns(VNumber),\r\n\t\tsetTime: VMethod\r\n\t}, VDate)\r\n\r\n\tvar VPromise = lang.compose(Variable, function VPromise(value) {\r\n\t\treturn makeSubVar(this, value, VPromise)\r\n\t}, {\r\n\t\tvalueOf: function() {\r\n\t\t\treturn this.then()\r\n\t\t},\r\n\t})\r\n\tvar exports = {\r\n\t\t__esModule: true,\r\n\t\tVariable: Variable,\r\n\t\tVArray: VArray,\r\n\t\tdefault: Variable,\r\n\t\tVString: VString,\r\n\t\tVNumber: VNumber,\r\n\t\tVBoolean: VBoolean,\r\n\t\tVPromise: VPromise,\r\n\t\tVDate: VDate,\r\n\t\tVSet: VSet,\r\n\t\tVMap: VMap,\r\n\t\tGeneratorVariable: GeneratorVariable,\r\n\t\tTransform: Transform,\r\n\t\tdeny: deny,\r\n\t\tnoChange: noChange,\r\n\t\tContext: Context,\r\n\t\tItem: Item,\r\n\t\tNotifyingContext: NotifyingContext,\r\n\t\tall: all,\r\n\t\treact: react,\r\n\t\tobjectUpdated: objectUpdated,\r\n\t\tNOT_MODIFIED: NOT_MODIFIED\r\n\t}\r\n\tObject.defineProperty(exports, 'currentContext', {\r\n\t\tget: function() {\r\n\t\t\treturn context\r\n\t\t}\r\n\t})\r\n\r\n\tvar IterativeMethod = lang.compose(Transform, function(source, method, args) {\r\n\t\tthis.source = source\r\n\t\t// source.interestWithin = true\r\n\t\tthis.method = method\r\n\t\tthis.arguments = args\r\n\t}, {\r\n\t\ttransform: function(array) {\r\n\t\t\tvar method = this.method\r\n\t\t\tvar isStrictArray = this.source && this.source._isStrictArray\r\n\t\t\tif (array && array.forEach) {\r\n\t\t\t\t// already an array\r\n\t\t\t\t//array = this._mappedItems(array)\r\n\t\t\t} else if (isStrictArray) {\r\n\t\t\t\tarray = []\r\n\t\t\t} else {\r\n\t\t\t\t// if not an array convert to an array\r\n\t\t\t\tarray = [array]\r\n\t\t\t}\r\n\t\t\tif (typeof method === 'string') {\r\n\t\t\t\t// apply method\r\n\t\t\t\treturn array[method].apply(array, this.arguments)\r\n\t\t\t} else {\r\n\t\t\t\treturn method(array, this.arguments)\r\n\t\t\t}\r\n\t\t},\r\n\t\t_mappedItems: function(array) {\r\n\t\t\tvar source = this.source\r\n\t\t\tvar collectionOf = source && source.collectionOf\r\n\t\t\treturn collectionOf ? array.map(function(item, i) {\r\n\t\t\t\tvar wrapped = collectionOf.from(item)\r\n\t\t\t\twrapped.collection = source\r\n\t\t\t\treturn wrapped\r\n\t\t\t}) : array\r\n\t\t},\r\n\r\n\t\tgetCollectionOf: function(){\r\n\t\t\treturn this.source.getCollectionOf()\r\n\t\t},\r\n\t\t_isStrictArray: true\r\n\t})\r\n\r\n\tfunction defineArrayMethod(method, constructor, properties, returns) {\r\n\t\tvar IterativeResults = lang.compose(returns ? returns.as(IterativeMethod) : IterativeMethod, constructor, properties)\r\n\t\tIterativeResults.prototype.method || (IterativeResults.prototype.method = method)\r\n\t\tObject.defineProperty(IterativeResults.prototype, 'isIterable', {value: true});\r\n\t\tVArray[method] = VArray.prototype[method] = function() {\r\n\t\t\tvar results = new IterativeResults(this)\r\n\t\t\tresults.source = this\r\n\t\t\tresults.arguments = arguments\r\n\t\t\treturn results\r\n\t\t}\r\n\t}\r\n\r\n\tdefineArrayMethod('filter', function Filtered() {}, {\r\n\t\tupdated: function(event, by, isDownstream) {\r\n\t\t\tif (!event || event.modifier === this || (event.modifier && event.modifier.constructor === this)) {\r\n\t\t\t\treturn Transform.prototype.updated.call(this, event, by)\r\n\t\t\t}\r\n\t\t\tvar contextualizedVariable = context && context.getContextualized(this) || this\r\n\t\t\tif (event.type === 'array-update') {\r\n\t\t\t\tfor (var i = 0, l = event.actions.length; i < l; i++) {\r\n\t\t\t\t\tvar action = event.actions[i]\r\n\t\t\t\t\tif (action.oldValue) {\r\n\t\t\t\t\t\tvar index = contextualizedVariable.cachedValue.indexOf(event.oldValue)\r\n\t\t\t\t\t\tif (index > -1) {\r\n\t\t\t\t\t\t\tcontextualizedVariable.splice(index, 1)\r\n\t\t\t\t\t\t}\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (action.value) {\r\n\t\t\t\t\t\tif ([event.value].filter(this.arguments[0]).length > 0) {\r\n\t\t\t\t\t\t\tcontextualizedVariable.push(event.value)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else if (event.type === 'update') {\r\n\t\t\t\tvar object = event.parent.valueOf()\r\n\t\t\t\tvar index = contextualizedVariable.cachedValue.indexOf(object)\r\n\t\t\t\tvar matches = [object].filter(this.arguments[0]).length > 0\r\n\t\t\t\tif (index > -1) {\r\n\t\t\t\t\tif (matches) {\r\n\t\t\t\t\t\treturn new PropertyChangeEvent(index, event, contextualizedVariable.cachedValue,\r\n\t\t\t\t\t\t\t// might need to do something with this\r\n\t\t\t\t\t\t\tobject)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tcontextualizedVariable.splice(index, 1)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\telse {\r\n\t\t\t\t\tif (matches) {\r\n\t\t\t\t\t\tcontextualizedVariable.push(object)\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// else nothing mactches\r\n\t\t\t\t}\r\n\t\t\t\treturn\r\n\t\t\t} else {\r\n\t\t\t\treturn Transform.prototype.updated.call(this, event, by, isDownstream)\r\n\t\t\t}\r\n\t\t}\r\n\t}, VArray)\r\n\tdefineArrayMethod('map', function Mapped(source) {\r\n\t\tthis._isStrictArray = source._isStrictArray\r\n\t}, {\r\n\t\ttransform: function(array) {\r\n\t\t\tvar isStrictArray = this.source && this.source._isStrictArray\r\n\t\t\tvar mapFunction = this.arguments[0]\r\n\t\t\tif (array && array.map) {\r\n\t\t\t\tvar source = this.source\r\n\t\t\t\tvar collectionOf = source && source.collectionOf\r\n\t\t\t\treturn array.map(collectionOf ? function(item, i) {\r\n\t\t\t\t\treturn mapFunction(source.property(i), i)\r\n\t\t\t\t} : mapFunction)\r\n\t\t\t} else if (!isStrictArray) {\r\n\t\t\t\tif (method === 'map'){\r\n\t\t\t\t\t// fast path, and special behavior for map\r\n\t\t\t\t\treturn mapFunction(array)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn IterativeMethod.prototype.transform.call(this, array)\r\n\t\t},\r\n\t\tupdated: function(event, by, isDownstream) {\r\n\t\t\tif (!event || event.modifier === this || (event.modifier && event.modifier.constructor === this)) {\r\n\t\t\t\treturn Variable.prototype.updated.call(this, event, by)\r\n\t\t\t}\r\n\t\t\tvar contextualizedVariable = context && context.getContextualized(this) || this\r\n\t\t\tif (event.type === 'array-update') {\r\n\t\t\t\tfor (var i = 0, l = event.actions.length; i < l; i++) {\r\n\t\t\t\t\tvar action = event.actions[i]\r\n\t\t\t\t\tif (action.previousIndex > -1) {\r\n\t\t\t\t\t\tcontextualizedVariable.splice(action.previousIndex, 1)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (action.value) {\r\n\t\t\t\t\t\tvar array = contextualizedVariable.cachedValue\r\n\t\t\t\t\t\tcontextualizedVariable.push(this.arguments[0].call(this.arguments[1], this.source.property(array && array.length)))\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n/*\t\t\tif (event.type === 'delete') {\r\n\t\t\t\tcontextualizedVariable.splice(event.previousIndex, 1)\r\n\t\t\t} else if (event.type === 'add') {\r\n\t\t\t\tvar array = contextualizedVariable.cachedValue\r\n\t\t\t\tcontextualizedVariable.push(this.arguments[0].call(this.arguments[1], this.source.property(array && array.length)))*/\r\n\t\t\t} else if (event.type === 'update') {\r\n\t\t\t\tif (this.getCollectionOf()) {\r\n\t\t\t\t\treturn // if it has typed items, we don't need to propagate update events, since they will be handled by the variable item.\r\n\t\t\t\t}\r\n\t\t\t\tvar object = event.parent.valueOf()\r\n\t\t\t\tvar array = contextualizedVariable.cachedValue\r\n\t\t\t\tvar index = event.key\r\n\t\t\t\tvar value = event.value\r\n\t\t\t\tif (index > -1) {\r\n\t\t\t\t\t// update was to an index property of this array variable\r\n\t\t\t\t\tvalue = object[index]\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// update was inside an object inside of our array\r\n\t\t\t\t\tindex = array && array.map && array.indexOf(object)\r\n\t\t\t\t}\r\n\t\t\t\tif (index > -1) {\r\n\t\t\t\t\tcontextualizedVariable.splice(index, 1, this.arguments[0].call(this.arguments[1], this.source.property(index)))\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn Transform.prototype.updated.call(this, event, by, isDownstream)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\treturn Transform.prototype.updated.call(this, event, by, isDownstream)\r\n\t\t\t}\r\n\t\t}\r\n\t}, VArray)\r\n\tdefineArrayMethod('reduce', function Reduced() {})\r\n\tdefineArrayMethod('reduceRight', function Reduced() {})\r\n\tdefineArrayMethod('some', function Aggregated() {}, {}, VBoolean)\r\n\tdefineArrayMethod('every', function Aggregated() {}, {}, VBoolean)\r\n\tdefineArrayMethod('slice', function Aggregated() {}, {}, VArray)\r\n\tdefineArrayMethod('keyBy', function UniqueIndex(source, args) {}, {\r\n\t\tproperty: VMap.prototype.property,\r\n\t\tmethod: function(array, args) {\r\n\t\t\tvar index = new Map()\r\n\t\t\tvar keyGenerator = args[0]\r\n\t\t\tvar valueGenerator = args[1]\r\n\t\t\tvar hasKeyFunction = typeof keyGenerator === 'function'\r\n\t\t\tvar hasValueFunction = typeof valueGenerator === 'function'\r\n\t\t\tvar hasKey = !!keyGenerator\r\n\t\t\tfor (var i = 0, l = array.length; i < l; i++) {\r\n\t\t\t\tvar element = array[i]\r\n\t\t\t\tindex.set(\r\n\t\t\t\t\thasKeyFunction ? keyGenerator(element, emit) :\r\n\t\t\t\t\t\thasKey ? element[keyGenerator] : element,\r\n\t\t\t\t\thasValueFunction ? valueGenerator(element) : element)\r\n\t\t\t}\r\n\t\t\tfunction emit(key, value) {\r\n\t\t\t\tindex.set(key, value)\r\n\t\t\t}\r\n\t\t\treturn index\r\n\t\t}\r\n\t})\r\n\r\n\tdefineArrayMethod('groupBy', function UniqueIndex(source, args) {}, {\r\n\t\tproperty: VMap.prototype.property,\r\n\t\tmethod: function(array, args) {\r\n\t\t\tvar index = new Map()\r\n\t\t\tvar keyGenerator = args[0]\r\n\t\t\tvar valueGenerator = args[1]\r\n\t\t\tvar hasKeyFunction = typeof keyGenerator === 'function'\r\n\t\t\tvar hasValueFunction = typeof valueGenerator === 'function'\r\n\t\t\tvar hasKey = !!keyGenerator\r\n\t\t\tfor (var i = 0, l = array.length; i < l; i++) {\r\n\t\t\t\tvar element = array[i]\r\n\t\t\t\tvar key = hasKeyFunction ? keyGenerator(element) :\r\n\t\t\t\t\t\thasKey ? element[keyGenerator] : element\r\n\t\t\t\tvar group = index.get(key)\r\n\t\t\t\tif (!group) {\r\n\t\t\t\t\tindex.set(key, group = [])\r\n\t\t\t\t}\r\n\t\t\t\tgroup.push(hasValueFunction ? valueGenerator(element) : element)\r\n\t\t\t}\r\n\t\t\tfunction emit(key, value) {\r\n\t\t\t\tvar group = index.get(key)\r\n\t\t\t\tif (!group) {\r\n\t\t\t\t\tindex.set(key, group = [])\r\n\t\t\t\t}\r\n\t\t\t\tgroup.push(value)\r\n\t\t\t}\r\n\t\t\treturn index\r\n\t\t}\r\n\t})\r\n\r\n\tvar getGeneratorDescriptor = Variable.getGeneratorDescriptor = function(value) {\r\n\t\tvar variables\r\n\t\treturn {\r\n\t\t\tget: function() {\r\n\t\t\t\tif (!variables) {\r\n\t\t\t\t\t variables = new lang.WeakMap()\r\n\t\t\t\t}\r\n\t\t\t\tvar variable = variables.get(this)\r\n\t\t\t\tif (!variable) {\r\n\t\t\t\t\tvariables.set(this, variable = new GeneratorVariable(value.bind(this)))\r\n\t\t\t\t}\r\n\t\t\t\treturn variable\r\n\t\t\t},\r\n\t\t\tenumerable: true\r\n\t\t}\r\n\t}\r\n\r\n\tfunction react(generator, options) {\r\n\t\tif (typeof generator !== 'function') {\r\n\t\t\tthrow new Error('react() must be called with a generator.')\r\n\t\t}\r\n\t\tif (options && options.reverse) {\r\n\t\t\tgenerator.reverse = options.reverse\r\n\t\t}\r\n\t\treturn new GeneratorVariable(generator)\r\n\t}\r\n\r\n\tVariable.all = all\r\n\tVariable.Context = Context\r\n\r\n\treturn exports\r\n}))\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./Variable.js\n ** module id = 4\n ** module chunks = 0\n **/","(function (root, factory) { if (typeof define === 'function' && define.amd) {\r\n\tdefine(['./util/lang', './operators', './Variable'], factory) } else if (typeof module === 'object' && module.exports) {\t\t\t\t\r\n\tmodule.exports = factory(require('./util/lang'), require('./operators'), require('./Variable')) // Node\r\n}}(this, function (lang, operators, VariableExports) {\r\n\r\n\tvar Transform = VariableExports.Transform\r\n\tvar Variable = VariableExports.Variable\r\n\tvar VArray = VariableExports.VArray\r\n\tvar isGenerator = lang.isGenerator\r\n\tvar ObjectTransform = lang.compose(Transform, function ObjectTransform(source, transform, sources) {\r\n\t\tthis.sources = sources\r\n\t\tTransform.apply(this, arguments)\r\n\t}, {\r\n\t\t_getAsObject: function() {\r\n\t\t\treturn this.transform.apply(this, preserveObjects(this.sources))\r\n\t\t}\r\n\t})\r\n\tfunction preserveObjects(sources) {\r\n\t\tfor (var i = 0, l = sources.length; i < l; i++) {\r\n\t\t\tvar source = sources[i]\r\n\t\t\tif (source && source._getAsObject) {\r\n\t\t\t\tsources[i] = source._getAsObject()\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn sources\r\n\t}\r\n\r\n\tvar reactive = {\r\n\t\tfrom: function(value, options) {\r\n\t\t\tif (value && value.property) {\r\n\t\t\t\treturn value\r\n\t\t\t}\r\n\t\t\tif (typeof value === 'function' && isGenerator(value)) {\r\n\t\t\t\treturn VariableExports.react(value, options)\r\n\t\t\t}\r\n\t\t\treturn Variable.from(value)\r\n\t\t},\r\n\t\tgetp: function(object, property) {\r\n\t\t\tif (object) {\r\n\t\t\t\t// TODO: Use a static set of public methods/properties that can be accessed\r\n\t\t\t\tif (object.property) {\r\n\t\t\t\t\t// it is a variable already, but check to see if we are using a method/property directly on the variable\r\n\t\t\t\t\tvar directPropertyValue = object[property]\r\n\t\t\t\t\treturn directPropertyValue !== undefined ? directPropertyValue : object.property(property)\r\n\t\t\t\t}\r\n\t\t\t\treturn object[property]\r\n\t\t\t}\r\n\t\t\t// not even truthy, return undefined\r\n\t\t},\r\n\t\tget: function(target, key, Type) { // for babel decorators\r\n\t\t\tvar property = (target._properties || (target._properties = {}))[key]\r\n\t\t\tif (!property) {\r\n\t\t\t\ttarget._properties[key] = property = new (getType(Type))()\r\n\t\t\t\tif (target.getValue) {\r\n\t\t\t\t\tproperty.key = key\r\n\t\t\t\t\tproperty.parent = target\r\n\t\t\t\t\tif (property.listeners) {\r\n\t\t\t\t\t\t// if it already has listeners, need to reinit it with the parent\r\n\t\t\t\t\t\tproperty.init()\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn property\r\n\t\t},\r\n\t\tset: function(target, key, value) {\r\n\t\t\tvar property = target[key]\r\n\t\t\tproperty.parent ? property._changeValue(3, value) : property.put(value)\r\n\t\t},\r\n\t\tprop: function(Type) {\r\n\t\t\treturn function(prototype, key) {\r\n\t\t\t\tdefineProperty(prototype, key, Type)\r\n\t\t\t}\r\n\t\t},\r\n\t\tcond: function(test, consequent, alternate) {\r\n\t\t\treturn operators.if(test, operators.choose(consequent, alternate))\r\n\t\t},\r\n\t\tfcall: function(target, args) {\r\n\t\t\tif (target.property && typeof target === 'function') {\r\n\t\t\t\treturn target.apply(null, preserveObjects(args))\r\n\t\t\t}\r\n\t\t\treturn new Transform(args[0], target, args)\r\n\t\t},\r\n\t\tmcall: function(target, key, args) {\r\n\t\t\tvar method = target[key]\r\n\t\t\tif (typeof method === 'function' && method.property || key === 'bind') {\r\n\t\t\t\t// for now we check to see if looks like it could handle a variable, or is a bind call\r\n\t\t\t\treturn method.apply(target, preserveObjects(args))\r\n\t\t\t}\r\n\t\t\treturn new Transform(args[0], target[key].bind(target), args)\r\n\t\t},\r\n\t\tncall: function(target, args) {\r\n\t\t\tif (target.property && typeof target === 'function') {\r\n\t\t\t\treturn new (target.bind.apply(target, [null].concat(preserveObjects(args))))()\r\n\t\t\t}\r\n\t\t\treturn new Transform(args[0], function() {\r\n\t\t\t\treturn new (target.bind.apply(target, [null].concat(arguments)))()\r\n\t\t\t}, args)\r\n\t\t},\r\n\r\n\t\tobj: function(sources) {\r\n\t\t\treturn sources\r\n\t\t\t//return new ObjectTransform(sources[0], transform, sources)\r\n\t\t},\r\n\r\n\t\tval: function(value) {\r\n\t\t\treturn value && value.valueOf()\r\n\t\t},\r\n\t\tcls: function(definitions) {\r\n\t\t\treactive = this // TODO: clean this up\r\n\t\t\treturn function(Class) {\r\n\t\t\t\tvar prototype = Class.prototype\r\n\t\t\t\tif (!(prototype instanceof Variable)) {\r\n\t\t\t\t\tif (Object.getPrototypeOf(prototype) == Object.prototype) {\r\n\t\t\t\t\t\tObject.setPrototypeOf(Class, Variable)\r\n\t\t\t\t\t\tObject.setPrototypeOf(prototype, Variable.prototype)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tconsole.warn('Unable to make class a reactive variable')\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tfor (var key in definitions) {\r\n\t\t\t\t\tdefineProperty(prototype, key, definitions[key])\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tlang.copy(reactive, operators)\r\n\r\n\tvar typeMappings = new Map()\r\n\ttypeMappings.set('string', VariableExports.VString)\r\n\ttypeMappings.set('number', VariableExports.VNumber)\r\n\ttypeMappings.set('boolean', VariableExports.VBoolean)\r\n\ttypeMappings.set(Array, VArray)\r\n\ttypeMappings.set(Map, VariableExports.VMap)\r\n\ttypeMappings.set(Set, VariableExports.VSet)\r\n\tfunction getType(Type) {\r\n\t\tif (typeMappings.has(Type)) {\r\n\t\t\treturn typeMappings.get(Type)\r\n\t\t} else if (typeof Type === 'object') {\r\n\t\t\tif (Type instanceof Array) {\r\n\t\t\t\treturn VArray.of(getType(Type[0]))\r\n\t\t\t}\r\n\t\t\tvar typedObject = {}\r\n\t\t\tfor (var key in Type) {\r\n\t\t\t\ttypedObject[key] = getType(Type[key])\r\n\t\t\t}\r\n\t\t\treturn Variable.with(typedObject)\r\n\t\t}\r\n\t\treturn Type\r\n\t}\r\n\r\n\tfunction defineProperty(target, key, Type) {\r\n\t\tif (!Type) {\r\n\t\t\tconsole.warn('Invalid type specified for', target && target.constructor.name, 'property', key, '(ensure you are using a concrete type, not an interface)')\r\n\t\t} else if (!Type.notifies) {\r\n\t\t\tType = getType(Type) || Variable\r\n\t\t}\r\n\t\tObject.defineProperty(target, key, {\r\n\t\t\tget: function() {\r\n\t\t\t\treturn reactive.get(this, key, Type)\r\n\t\t\t},\r\n\t\t\tset: function(value) {\r\n\t\t\t\treactive.set(this, key, value)\r\n\t\t\t},\r\n\t\t\tenumerable: true\r\n\t\t})\r\n\t}\r\n\r\n\treturn reactive\r\n}))\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./reactive.js\n ** module id = 5\n ** module chunks = 0\n **/","(function (root, factory) { if (typeof define === 'function' && define.amd) {\r\n\tdefine(['./Variable'], factory) } else if (typeof module === 'object' && module.exports) {        \r\n  module.exports = factory(require('./Variable')) // Node\r\n}}(this, function (VariableExports) {\r\n\r\n\tvar VBoolean = VariableExports.VBoolean\r\n\tvar VNumber = VariableExports.VNumber\r\n\tvar operatingFunctions = {};\r\n\tvar operators = {};\r\n\tfunction getOperatingFunction(expression){\r\n\t\t// jshint evil: true\r\n\t\treturn operatingFunctions[expression] ||\r\n\t\t\t(operatingFunctions[expression] =\r\n\t\t\t\tnew Function('a', 'b', 'return ' + expression));\r\n\t}\r\n\tfunction operator(operator, type, name, precedence, forward, reverseA, reverseB){\r\n\t\t// defines the standard operators\r\n\t\tvar reverse = function(output, inputs){\r\n\t\t\tvar a = inputs[0],\r\n\t\t\t\tb = inputs[1]\r\n\t\t\tvar firstError\r\n\t\t\tif(a && a.put){\r\n\t\t\t\ttry {\r\n\t\t\t\t\treturn a.put(reverseA(output, b && b.valueOf()))\r\n\t\t\t\t} catch(error) {\r\n\t\t\t\t\tif (error.deniedPut) {\r\n\t\t\t\t\t\tfirstError = error\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthrow error\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(b && b.put){\r\n\t\t\t\tb.put(reverseB(output, a && a.valueOf()))\r\n\t\t\t} else {\r\n\t\t\t\tthrow (firstError && firstError.message ? firstError : new Error('Can not assign change value to constant operators'))\r\n\t\t\t}\r\n\t\t};\r\n\t\t// define a function that can lazily ensure the operating function\r\n\t\t// is available\r\n\t\tvar operatorHandler = {\r\n\t\t\tapply: function(instance, args){\r\n\t\t\t\tforward = getOperatingFunction(forward);\r\n\t\t\t\treverseA = reverseA && getOperatingFunction(reverseA);\r\n\t\t\t\treverseB = reverseB && getOperatingFunction(reverseB);\r\n\t\t\t\tforward.reverse = reverse;\r\n\t\t\t\toperators[operator] = operatorHandler = new VariableExports.Variable(forward);\r\n\r\n\t\t\t\taddFlags(operatorHandler);\r\n\t\t\t\targs = Array.prototype.slice.call(args);\r\n\t\t\t\treturn operatorHandler.apply(instance, args);\r\n\t\t\t}\r\n\t\t};\r\n\t\tfunction addFlags(operatorHandler){\r\n\t\t\toperatorHandler.precedence = precedence;\r\n\t\t\toperatorHandler.infix = reverseB !== false;\r\n\t\t}\r\n\t\taddFlags(operatorHandler);\r\n\t\toperators[operator] = operatorHandler;\r\n\t\toperators[name] = function() {\r\n\t\t\tvar result = operatorHandler.apply(null, arguments)\r\n\t\t\treturn type ? result.as(type) : result\r\n\t\t}\r\n\t}\r\n\t// using order precedence from:\r\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence\r\n\toperator('+', VNumber, 'add', 6, 'a+b', 'a-b', 'a-b');\r\n\toperator('-', VNumber, 'subtract', 6, 'a-b', 'a+b', 'b-a');\r\n\toperator('*', VNumber, 'multiply', 5, 'a*b', 'a/b', 'a/b');\r\n\toperator('/', VNumber, 'divide', 5, 'a/b', 'a*b', 'b/a');\r\n//\toperator('^', 7, 'a^b', 'a^(-b)', 'Math.log(a)/Math.log(b)');\r\n\toperator('?', null, 'if', 16, 'b[a?0:1]', 'a===b[0]||(a===b[1]?false:(function(){throw new Error()})())', '[a,b]');\r\n\toperator(':', null, 'choose', 15, '[a,b]', 'a[0]?a[1]:(function(){throw new Error()})()', 'a[1]');\r\n\toperator('!', VBoolean, 'not', 4, '!a', '!a', false);\r\n\toperator('%', VNumber, 'remainder', 5, 'a%b');\r\n\toperator('>', VBoolean, 'greater', 8, 'a>b');\r\n\toperator('>=', VBoolean, 'greaterOrEqual', 8, 'a>=b');\r\n\toperator('<', VBoolean, 'less', 8, 'a<b');\r\n\toperator('<=', VBoolean, 'lessOrEqual', 8, 'a<=b');\r\n\toperator('===', VBoolean, 'strictEqual', 9, 'a===b');\r\n\toperator('==', VBoolean, 'equal', 9, 'a==b');\r\n\toperator('&', VBoolean, 'and', 8, 'a&&b');\r\n\toperator('|', VBoolean, 'or', 8, 'a||b');\r\n\toperator('round', 'round', 8, 'Math.round(a*Math.pow(10,b||1))/Math.pow(10,b||1)', 'a', 'a');\r\n\treturn operators;\r\n}))\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./operators.js\n ** module id = 6\n ** module chunks = 0\n **/","(function (root, factory) { if (typeof define === 'function' && define.amd) {\r\n\tdefine(['./util/lang', './Variable'], factory) } else if (typeof module === 'object' && module.exports) {        \r\n  module.exports = factory(require('./util/lang'), require('./Variable')) // Node\r\n}}(this, function (lang, VariableExports) {\r\n\tvar Variable = VariableExports.Variable\r\n\t\r\n\tfunction deepCopy(source, target, derivativeMap) {\r\n\t\tif (source && typeof source == 'object') {\r\n\t\t\tif (source instanceof Array) {\r\n\t\t\t\ttarget = [] // always create a new array for array targets\r\n\t\t\t\tfor(var i = 0, l = source.length; i < l; i++) {\r\n\t\t\t\t\ttarget[i] = deepCopy(source[i], null, derivativeMap)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (!target || typeof target !== 'object') {\r\n\t\t\t\t\ttarget = derivativeMap && derivativeMap.get(source)\r\n\t\t\t\t\tif (!target) {\r\n\t\t\t\t\t\ttarget = {}\r\n\t\t\t\t\t\tderivativeMap && derivativeMap.set(source, target)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tfor (var i in source) {\r\n\t\t\t\t\ttarget[i] = deepCopy(source[i], target[i], derivativeMap)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn target\r\n\t\t}\r\n\t\treturn source\r\n\t}\r\n\r\n\tvar Copy = lang.compose(Variable, function(copiedFrom) {\r\n\t\t// this is the variable that we derive from\r\n\t\tthis.copiedFrom = copiedFrom\r\n\t\tthis.derivativeMap = new lang.WeakMap(null, 'derivative')\r\n\t\tthis.isDirty = new Variable(false)\r\n\t}, {\r\n\t\tgetValue: function(sync, forModification, forChild) {\r\n\t\t\tif(this.state) {\r\n\t\t\t\tthis.state = null\r\n\t\t\t}\r\n\t\t\tvar value = this.copiedFrom.valueOf()\r\n\t\t\tif(value && typeof value == 'object') {\r\n\t\t\t\tvar derivative = this.derivativeMap.get(value)\r\n\t\t\t\tif (derivative == null) {\r\n\t\t\t\t\tthis.derivativeMap.set(value, derivative = deepCopy(value, undefined, this.derivativeMap))\r\n\t\t\t\t\tthis.setValue(derivative)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(this.value === undefined) {\r\n\t\t\t\treturn value\r\n\t\t\t}\r\n\t\t\treturn Variable.prototype.getValue.call(this, sync, forModification, forChild)\r\n\t\t},\r\n\t\tgetCopyOf: function(value) {\r\n\t\t\tvar derivative = this.derivativeMap.get(value)\r\n\t\t\tif (derivative == null) {\r\n\t\t\t\tthis.derivativeMap.set(value, derivative = deepCopy(value, undefined, this.derivativeMap))\r\n\t\t\t}\r\n\t\t\treturn derivative\r\n\t\t},\r\n\t\tsave: function() {\r\n\t\t\t// copy back to the original object\r\n\t\t\tvar original = this.copiedFrom.valueOf()\r\n\t\t\tvar newCopiedFrom = deepCopy(this.valueOf(), original)\r\n\t\t\tif (this.copiedFrom.put) { // copiedFrom doesn't have to be a variable, it can be a plain object\r\n\t\t\t\t// assign it now\r\n\t\t\t\tthis.copiedFrom.put(newCopiedFrom)\r\n\t\t\t}\r\n\t\t\tthis.isDirty.put(false)\r\n\t\t\tthis.onSave && this.onSave()\r\n\t\t},\r\n\t\trevert: function() {\r\n\t\t\tvar original = this.copiedFrom.valueOf()\r\n\t\t\tthis.derivativeMap = new lang.WeakMap(null, 'derivative') // clear out the mapping, so we can start fresh\r\n\t\t\tthis.put(deepCopy(original, undefined, this.derivativeMap))\r\n\t\t\tthis.isDirty.put(false)\r\n\t\t},\r\n\t\tupdated: function() {\r\n\t\t\tthis.isDirty.put(true)\r\n\t\t\treturn Variable.prototype.updated.apply(this, arguments)\r\n\t\t}\r\n\t})\r\n\treturn Copy\r\n}))\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./Copy.js\n ** module id = 7\n ** module chunks = 0\n **/"],"sourceRoot":""}