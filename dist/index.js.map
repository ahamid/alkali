{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///index.js","webpack:///webpack/bootstrap e8361cc7919b48750685","webpack:///./index.js","webpack:///./Element.js","webpack:///./Variable.js","webpack:///./util/lang.js","webpack:///./Renderer.js","webpack:///./react.js","webpack:///./operators.js","webpack:///./Copy.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","Element","Variable","react","Renderer","operators","Copy","main","Object","create","all","spawn","func","valueOf","assign","apply","undefined","lang","isGenerator","constructor","displayName","name","Context","subject","booleanStyle","options","element","value","key","style","defaultStyle","directStyle","layoutChildren","parent","children","container","prepend","fragment","length","doc","createDocumentFragment","i","l","childNode","child","currentParent","appendChild","isContentNode","contentNode","Array","notifies","variableAsText","nodeType","Error","createTextNode","insertBefore","firstChild","content","text","error","stack","textNode","enterRenderer","TextRenderer","variable","bidirectionalHandler","InputPropertyRenderer","inputs","tagName","bindChanges","prototype","renderSelectValueUpdate","renderUpdate","noop","applyAttribute","AttributeRenderer","setAttribute","applySubProperties","renderer","SubPropertyRenderer","compose","PropertyRenderer","arguments","subKey","subValue","applyProperties","properties","styleDefinition","styleDefinitions","propertyHandlers","StyleRenderer","slice","addEventListener","buildContent","each","ItemClass","itemAs","Item","hasOwn","itemVariable","_item","collection","ListRenderer","forEach","item","childElement","buildInputContent","conversion","nextTurn","inputEvents","event","result","put","deny","type","parseFloat","inputType","inputProperty","date","datetime","time","applyToClass","applyOnCreate","_applyOnCreate","classHandlers","TypeError","getApplySet","Class","hasOwnProperty","getForClass","parentApplySet","getPrototypeOf","keys","getOwnPropertyNames","defineProperty","toLowerCase","renderDescriptor","renderMethod","map","WeakMap","get","has","set","makeElementConstructor","selector","withProperties","forTarget","property","propertyForElement","superConstructor","selectorMatch","match","SELECTOR_REGEX","operator","className","remaining","createElement","presumptiveParentMap","setPrototypeOf","ElementApplyOnCreate","argument","createdCallback","created","append","registerTag","registerElement","getConstructor","tags","setTag","generate","elements","elementName","ElementClass","generateInputs","HTMLInputElement","target","From","Target","createInstance","ownedClasses","parentNode","ownedInstances","instance","ThisElementVariable","_Variable","observeObject","updaters","push","cleanup","stop","needsRestart","restart","elementAttached","attached","elementDetached","detached","firstVisit","node","state","__alkaliAttached__","action","docBody","contains","knownElementProperties","newValue","definition","ClassNameRenderer","ElementRenderer","currentClassName","changingClassName","removed","replace","document","tag","INPUT","TEXTAREA","display","visibility","color","opacity","zoom","minZoom","maxZoom","fontWeight","position","textDecoration","base","proto","__proto__","classes","flag","class","for","role","render","GeneratorVariable","bind","valueAsNumber","valueAsDate","checked","dataset","attributes","elment","styleObjectHandler","nextClassId","uniqueSelectors","radios","querySelectorAll","radio","dispatchEvent","Event","HTMLElement","within","aliases","Anchor","Paragraph","Textarea","DList","UList","OList","ListItem","Text","TextInput","TableRow","TableCell","TableHeaderCell","TableHeader","TableBody","alias","to","refresh","moveLiveElementsEnabled","extend","ExtendedElement","descriptor","getOwnPropertyDescriptor","MutationObserver","body","lifeStates","nodes","observer","mutations","il","mutation","j","jl","nodeIteration","k","kl","baseNode","currentNode","nextNode","nextSibling","observe","childList","subtree","mergeSubject","context","nextContext","getMaterializedContextualInstance","distinctSubject","contextMap","defaultContext","when","callback","then","whenAll","promiseInvolved","registerListener","listener","listeners","propertyListenersMap","listenerId","autoObserveObjects","listeningToObject","deregisterListener","index","splice","RefreshEvent","visited","Set","PropertyChangeEvent","childEvent","AddEvent","args","DeleteEvent","arrayToModify","_willModify","cachedValue","array","updateVersion","results","cachedVersion","version","insertedAt","added","startingIndex","arrayLength","addedCount","_properties","arrayPosition","updated","modifier","removedAt","removalCount","previousIndex","oldValue","iterateMethod","method","IterativeMethod","addFlag","functionValue","objectUpdated","object","_propertyChange","Composite","keyMapping","valueArray","resultObject","createForInstance","generalizeClass","prototypeNames","getGeneralizedDescriptor","generalizeMethod","instanceForContext","defaultInstance","noChange","RequestChange","nextId","freeze","propertyName","contextFromCache","VariablePrototype","gotValue","getValue","previousNotifyingValue","notifyingValue","ownObject","dependents","stopNotifies","isMap","Map","propertyVariable","Property","instanceMap","ContextualizedVariable","distinctFor","contextualizedVariable","onPropertyChange","eachKey","Call","forDependencies","init","dependency","handles","remove","computedVariable","getVersion","Math","max","getSubject","selectVariable","getUpdates","since","updates","nextUpdateMap","updateEvent","by","add","contextualInstance","lastUpdate","dependent","e","console","fixed","invalidate","unsubscribe","subscribe","updateQueued","next","handle","initialValue","setValue","undefine","proxy","proxiedVariable","thisVariable","complete","onValue","callbackOrItemClass","callbackOrContext","collectionVariable","transformFunction","reverse","forward","schema","validate","valid","isValid","validation","Validating","getId","observerCount","events","el","addKey","done","deliverChanges","unshift","pop","shift","Symbol","iterator","VMap","Caching","withComputedValue","computedValue","watchedContext","newVersion","gotValueAndListen","_changeValue","parentUpdated","parentSchemaProperties","arg","resolved","functionVariable","invoke","argsVersion","execute","originalValue","observeArguments","handlesContext","handlesPromises","input","setReverse","Source","source","propagatedEvent","filterUpdated","indexOf","matches","filter","mapUpdated","generator","resuming","lastValue","generatorIterator","isThrowing","stepReturn","nextVariable","VArray","description","generalize","Function","ExtendedVariable","Base","_defaultInstance","feature","hasFeatures","diff","previous","current","queued","toJSONHidden","queuedListeners","requestAnimationFrame","promise","Promise","keyFlag","currentValue","targetAncestor","previousSet","previousGet","enumerable","timerStarted","setInterval","watchedObjects","watchedCopies","copy","unobserve","Hidden","toJSON","processAnimationFrame","toRender","setTimeout","resolve","reject","resolution","finished","errorResolution","isResolved","queue","errback","newError","values","mapProperty","intermediary","errorHandler","onResolve","onError","onEach","readyInputs","lastPromiseResult","previousPromiseResult","div","alkaliRenderers","update","updateRendering","shouldRender","alwaysUpdate","updateOnStart","ContentRenderer","onElementRemoval","renderers","invalidatedElements","invalidated","contextMatches","invalidateElement","invalidatedParts","queueTask","processQueue","updateElement","always","renderersOnShow","addElement","omitValueOf","started","renderLoading","isNaN","eventualValue","innerHTML","replaceChild","childNodes","nodeValue","eachItem","nextChild","thisElement","childElements","builtList","removeChild","onShowElement","shownElement","getElementsByClassName","includingTop","onlyChildren","getElementsByTagName","from","prop","cond","test","consequent","alternate","choose","fcall","mcall","getOperatingFunction","expression","operatingFunctions","precedence","reverseA","reverseB","addFlags","operatorHandler","infix","output","a","b","deepCopy","derivativeMap","copiedFrom","isDirty","derivative","thisValue","getCopyOf","save","original","newCopiedFrom","onSave","revert"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"alkali\"] = factory();\n\telse\n\t\troot[\"alkali\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"alkali\"] = factory();\n\telse\n\t\troot[\"alkali\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/// <reference path=\"./typing.d.ts\" />\r\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1), __webpack_require__(2), __webpack_require__(5), __webpack_require__(4), __webpack_require__(6), __webpack_require__(7)], __WEBPACK_AMD_DEFINE_RESULT__ = function(Element, Variable, react, Renderer, operators, Copy) {\r\n\t\tvar main = Object.create(Element)\r\n\t\tmain.Copy = Copy\r\n\t\tmain.Element = Element\r\n\t\tmain.Variable = Variable\r\n\t\tmain.all = Variable.all\r\n\t\tmain.react = react\r\n\t\tmain.spawn = function(func) {\r\n\t\t\treturn react(func).valueOf()\r\n\t\t}\r\n\t\tmain.Renderer = Renderer\r\n\t\tObject.assign(main, Renderer)\r\n\t\tObject.assign(main, operators)\r\n\t\treturn main\r\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(4), __webpack_require__(3)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Variable, Renderer, lang) {\r\n\t\tvar knownElementProperties = {};\r\n\t\t['textContent', 'innerHTML', 'title', 'href', 'value', 'valueAsNumber', 'role', 'render'].forEach(function(property) {\r\n\t\t\tknownElementProperties[property] = true\r\n\t\t})\r\n\t\r\n\t\tvar SELECTOR_REGEX = /(\\.|#)([-\\w]+)(.+)?/\r\n\t\tfunction isGenerator(func) {\r\n\t\t\tif (typeof func === 'function') {\r\n\t\t\t\tvar constructor = func.constructor\r\n\t\t\t\treturn (constructor.displayName || constructor.name) === 'GeneratorFunction'\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction Context(subject){\r\n\t\t\tthis.subject = subject\r\n\t\t}\r\n\t\r\n\t\tvar PropertyRenderer = Renderer.PropertyRenderer\r\n\t\tvar InputPropertyRenderer = Renderer.InputPropertyRenderer\r\n\t\tvar AttributeRenderer = Renderer.AttributeRenderer\r\n\t\tvar StyleRenderer = lang.compose(Renderer.StyleRenderer, function StyleRenderer() {\r\n\t\t\tRenderer.StyleRenderer.apply(this, arguments)\r\n\t\t}, {\r\n\t\t\trenderUpdate: function(newValue, element) {\r\n\t\t\t\tvar definition = styleDefinitions[this.name]\r\n\t\t\t\tif (definition) {\r\n\t\t\t\t\tdefinition(element, newValue, this.name)\r\n\t\t\t\t} else {\r\n\t\t\t\t\telement.style[this.name] = newValue\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\tvar ClassNameRenderer = lang.compose(Renderer.ElementRenderer, function ClassNameRenderer(options) {\r\n\t\t\tthis.className = options.className\r\n\t\t\tRenderer.apply(this, arguments)\r\n\t\t}, {\r\n\t\t\trenderUpdate: function(newValue, element) {\r\n\t\t\t\tvar currentClassName = element.className\r\n\t\t\t\tvar changingClassName = this.className\r\n\t\t\t\t// remove the className (needed for addition or removal)\r\n\t\t\t\t// see http://jsperf.com/remove-class-name-algorithm/2 for some tests on this\r\n\t\t\t\tvar removed = currentClassName && (' ' + currentClassName + ' ').replace(' ' + changingClassName + ' ', ' ')\r\n\t\t\t\tif (newValue) {\r\n\t\t\t\t\t// addition, add the className\r\n\t\t\t\t\tchangingClassName = currentClassName ? (removed + changingClassName).slice(1) : changingClassName;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// we already have removed the class, just need to trim\r\n\t\t\t\t\tchangingClassName = removed.slice(1, removed.length - 1)\r\n\t\t\t\t}\r\n\t\t\t\t// only assign if it changed, this can save a lot of time\r\n\t\t\t\tif (changingClassName != currentClassName) {\r\n\t\t\t\t\telement.className = changingClassName\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\t// TODO: check for renderContent with text updater\r\n\t\tvar TextRenderer = Renderer.TextRenderer\r\n\t\tvar ListRenderer = Renderer.ListRenderer\r\n\t\t\r\n\t\tvar toAddToElementPrototypes = []\r\n\t\tvar createdBaseElements = []\r\n\t\tvar doc = typeof document !== 'undefined' ? document : {\r\n\t\t\tcreateElement: function(tag) {\r\n\t\t\t\treturn {}\r\n\t\t\t},\r\n\t\t\taddEventListener: function() {\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tvar testStyle = doc.createElement('div').style\r\n\t\tvar childTagForParent = {\r\n\t\t\tTABLE: ['tr','td'],\r\n\t\t\tTBODY: ['tr','td'],\r\n\t\t\tTR: 'td',\r\n\t\t\tUL: 'li',\r\n\t\t\tOL: 'li',\r\n\t\t\tSELECT: 'option'\r\n\t\t}\r\n\t\tvar inputs = {\r\n\t\t\tINPUT: 1,\r\n\t\t\tTEXTAREA: 1\r\n\t\t\t// SELECT: 1, we exclude this, so the default \"content\" of the element can be the options\r\n\t\t}\r\n\t\r\n\t\tfunction booleanStyle(options) {\r\n\t\t\treturn function(element, value, key) {\r\n\t\t\t\tif (typeof value === 'boolean') {\r\n\t\t\t\t\t// has a boolean conversion\r\n\t\t\t\t\tvalue = options[value ? 0 : 1]\r\n\t\t\t\t}\r\n\t\t\t\telement.style[key] = value\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction defaultStyle(element, value, key) {\r\n\t\t\tif (typeof value === 'number') {\r\n\t\t\t\tvalue = value + 'px'\r\n\t\t\t}\r\n\t\t\telement.style[key] = value\r\n\t\t}\r\n\t\tfunction directStyle(element, value, key) {\r\n\t\t\telement.style[key] = value\r\n\t\t}\r\n\t\r\n\t\tvar styleDefinitions = {\r\n\t\t\tdisplay: booleanStyle(['initial', 'none']),\r\n\t\t\tvisibility: booleanStyle(['visible', 'hidden']),\r\n\t\t\tcolor: directStyle,\r\n\t\t\topacity: directStyle,\r\n\t\t\tzoom: directStyle,\r\n\t\t\tminZoom: directStyle,\r\n\t\t\tmaxZoom: directStyle,\r\n\t\t\tfontWeight: directStyle,\r\n\t\t\tposition: booleanStyle(['absolute', '']),\r\n\t\t\ttextDecoration: booleanStyle(['underline', '']),\r\n\t\t\tfontWeight: booleanStyle(['bold', 'normal'])\r\n\t\t}\r\n\t\t;[\"alignContent\",\"alignItems\",\"alignSelf\",\"animation\",\"animationDelay\",\"animationDirection\",\"animationDuration\",\"animationFillMode\",\"animationIterationCount\",\"animationName\",\"animationPlayState\",\"animationTimingFunction\",\"backfaceVisibility\",\"background\",\"backgroundAttachment\",\"backgroundBlendMode\",\"backgroundClip\",\"backgroundColor\",\"backgroundImage\",\"backgroundOrigin\",\"backgroundPosition\",\"backgroundPositionX\",\"backgroundPositionY\",\"backgroundRepeat\",\"backgroundRepeatX\",\"backgroundRepeatY\",\"backgroundSize\",\"baselineShift\",\"border\",\"borderBottom\",\"borderBottomColor\",\"borderBottomLeftRadius\",\"borderBottomRightRadius\",\"borderBottomStyle\",\"borderBottomWidth\",\"borderCollapse\",\"borderColor\",\"borderImage\",\"borderImageOutset\",\"borderImageRepeat\",\"borderImageSlice\",\"borderImageSource\",\"borderImageWidth\",\"borderLeft\",\"borderLeftColor\",\"borderLeftStyle\",\"borderLeftWidth\",\"borderRadius\",\"borderRight\",\"borderRightColor\",\"borderRightStyle\",\"borderRightWidth\",\"borderSpacing\",\"borderStyle\",\"borderTop\",\"borderTopColor\",\"borderTopLeftRadius\",\"borderTopRightRadius\",\"borderTopStyle\",\"borderTopWidth\",\"borderWidth\",\"bottom\",\"boxShadow\",\"boxSizing\",\"bufferedRendering\",\"captionSide\",\"clear\",\"clip\",\"clipPath\",\"clipRule\",\"color\",\"colorInterpolation\",\"colorInterpolationFilters\",\"colorRendering\",\"counterIncrement\",\"counterReset\",\"cursor\",\"direction\",\"display\",\"emptyCells\",\"fill\",\"fillOpacity\",\"fillRule\",\"filter\",\"flex\",\"flexBasis\",\"flexDirection\",\"flexFlow\",\"flexGrow\",\"flexShrink\",\"flexWrap\",\"float\",\"floodColor\",\"floodOpacity\",\"font\",\"fontFamily\",\"fontFeatureSettings\",\"fontKerning\",\"fontSize\",\"fontStretch\",\"fontStyle\",\"fontVariant\",\"fontVariantLigatures\",\"fontWeight\",\"height\",\"imageRendering\",\"isolation\",\"justifyContent\",\"left\",\"letterSpacing\",\"lightingColor\",\"lineHeight\",\"listStyle\",\"listStyleImage\",\"listStylePosition\",\"listStyleType\",\"margin\",\"marginBottom\",\"marginLeft\",\"marginRight\",\"marginTop\",\"marker\",\"markerEnd\",\"markerMid\",\"markerStart\",\"mask\",\"maskType\",\"maxHeight\",\"maxWidth\",\"maxZoom\",\"minHeight\",\"minWidth\",\"minZoom\",\"mixBlendMode\",\"motion\",\"motionOffset\",\"motionPath\",\"motionRotation\",\"objectFit\",\"objectPosition\",\"opacity\",\"order\",\"orientation\",\"orphans\",\"outline\",\"outlineColor\",\"outlineOffset\",\"outlineStyle\",\"outlineWidth\",\"overflow\",\"overflowWrap\",\"overflowX\",\"overflowY\",\"padding\",\"paddingBottom\",\"paddingLeft\",\"paddingRight\",\"paddingTop\",\"page\",\"pageBreakAfter\",\"pageBreakBefore\",\"pageBreakInside\",\"paintOrder\",\"perspective\",\"perspectiveOrigin\",\"pointerEvents\",\"position\",\"quotes\",\"resize\",\"right\",\"shapeImageThreshold\",\"shapeMargin\",\"shapeOutside\",\"shapeRendering\",\"size\",\"speak\",\"src\",\"stopColor\",\"stopOpacity\",\"stroke\",\"strokeDasharray\",\"strokeDashoffset\",\"strokeLinecap\",\"strokeLinejoin\",\"strokeMiterlimit\",\"strokeOpacity\",\"strokeWidth\",\"tabSize\",\"tableLayout\",\"textAlign\",\"textAlignLast\",\"textAnchor\",\"textCombineUpright\",\"textDecoration\",\"textIndent\",\"textOrientation\",\"textOverflow\",\"textRendering\",\"textShadow\",\"textTransform\",\"top\",\"touchAction\",\"transform\",\"transformOrigin\",\"transformStyle\",\"transition\",\"transitionDelay\",\"transitionDuration\",\"transitionProperty\",\"transitionTimingFunction\",\"unicodeBidi\",\"unicodeRange\",\"userZoom\",\"vectorEffect\",\"verticalAlign\",\"visibility\",\"whiteSpace\",\"widows\",\"width\",\"willChange\",\"wordBreak\",\"wordSpacing\",\"wordWrap\",\"writingMode\",\"zIndex\",\"zoom\"].forEach(function(property) {\r\n\t\t\tstyleDefinitions[property] = styleDefinitions[property] || defaultStyle\r\n\t\t})\r\n\t\tvar styleSheet\r\n\t\tvar presumptiveParentMap = new WeakMap()\r\n\t\r\n\t\tvar setPrototypeOf = Object.setPrototypeOf || (function(base, proto) { base.__proto__ = proto})\r\n\t\tvar getPrototypeOf = Object.getPrototypeOf || (function(base) { return base.__proto__ })\r\n\t\tfunction createCssRule(selector) {\r\n\t\t\tif (!styleSheet) {\r\n\t\t\t\tvar styleSheetElement = doc.createElement(\"style\")\r\n\t\t\t\tstyleSheetElement.setAttribute(\"type\", \"text/css\")\r\n\t//\t\t\tstyleSheet.appendChild(doc.createTextNode(css))\r\n\t\t\t\tdoc.head.insertBefore(styleSheetElement, doc.head.firstChild)\r\n\t\t\t\tstyleSheet = styleSheetElement.sheet\r\n\t\t\t}\r\n\t\t\tvar cssRules = styleSheet.cssRules || styleSheet.rules\r\n\t\t\treturn cssRules[styleSheet.addRule(selector, ' ', cssRules.length)]\r\n\t\t}\r\n\t\tvar invalidatedElements = new WeakMap(null, 'invalidated')\r\n\t\tvar queued\r\n\t\r\n\t\tvar toRender = []\r\n\t\tfunction flatten(target, part) {\r\n\t\t\tvar base = target.base\r\n\t\t\tif (base) {\r\n\t\t\t\tvar basePart = base[part]\r\n\t\t\t\tif (basePart) {\r\n\t\t\t\t\ttarget[part] || target[part]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction layoutChildren(parent, children, container, prepend) {\r\n\t\t\tvar fragment = (children.length > 3 || prepend) ? doc.createDocumentFragment() : parent\r\n\t\t\tfor(var i = 0, l = children.length; i < l; i++) {\r\n\t\t\t\tvar child = children[i]\r\n\t\t\t\tvar childNode\r\n\t\t\t\tif (child && child.create) {\r\n\t\t\t\t\t// an element constructor\r\n\t\t\t\t\tcurrentParent = parent\r\n\t\t\t\t\tchildNode = child.create()\r\n\t\t\t\t\tfragment.appendChild(childNode)\r\n\t\t\t\t\tif (child.isContentNode) {\r\n\t\t\t\t\t\tcontainer.contentNode = childNode\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (typeof child == 'function') {\r\n\t\t\t\t\t// TODO: reenable this\r\n\t//\t\t\t\tif (child.for) {\r\n\t\t\t\t\t\t// a variable constructor that can be contextualized\r\n\t\t//\t\t\t\tfragment.appendChild(variableAsText(parent, child))\r\n\t\t\t//\t\t} else {\r\n\t\t\t\t\t\t// an element constructor\r\n\t\t\t\t\t\tchildNode = new child()\r\n\t\t\t\t\t\tfragment.appendChild(childNode)\r\n\t\t\t\t//\t}\r\n\t\t\t\t} else if (typeof child == 'object') {\r\n\t\t\t\t\tif (child instanceof Array) {\r\n\t\t\t\t\t\t// array of sub-children\r\n\t\t\t\t\t\tcontainer = container || parent\r\n\t\t\t\t\t\tchildNode = childNode || parent\r\n\t\t\t\t\t\tlayoutChildren(childNode.contentNode || childNode, child, container)\r\n\t\t\t\t\t} else if (child.notifies) {\r\n\t\t\t\t\t\t// a variable\r\n\t\t\t\t\t\tfragment.appendChild(childNode = variableAsText(parent, child))\r\n\t\t\t\t\t} else if (child.nodeType) {\r\n\t\t\t\t\t\t// an element itself\r\n\t\t\t\t\t\tfragment.appendChild(childNode = child)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// TODO: apply properties to last child, but with binding to the parent (for events)\r\n\t\t\t\t\t\tthrow new Error('Unknown child type ' + child)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// a primitive value\r\n\t\t\t\t\tchildNode = doc.createTextNode(child)\r\n\t\t\t\t\tfragment.appendChild(childNode)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (fragment != parent) {\r\n\t\t\t\tif (prepend) {\r\n\t\t\t\t\tparent.insertBefore(fragment, parent.firstChild)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tparent.appendChild(fragment)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn childNode\r\n\t\t}\r\n\t\tfunction variableAsText(parent, content) {\r\n\t\t\tif (content == null) {\r\n\t\t\t\treturn doc.createTextNode('')\r\n\t\t\t}\r\n\t\t\tvar text\r\n\t\t\ttry {\r\n\t\t\t\ttext = content.valueOf(new Context(parent))\r\n\t\t\t} catch (error) {\r\n\t\t\t\ttext = error.stack\r\n\t\t\t}\r\n\t\t\tvar textNode = doc.createTextNode(text)\r\n\t\t\tif (content.notifies) {\r\n\t\t\t\tenterRenderer(TextRenderer, {\r\n\t\t\t\t\telement: parent,\r\n\t\t\t\t\ttextNode: textNode,\r\n\t\t\t\t\tvariable: content\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\treturn textNode\r\n\t\t}\r\n\t\r\n\t\tfunction bidirectionalHandler(element, value, key) {\r\n\t\t\tif (value && value.notifies) {\r\n\t\t\t\tenterRenderer(InputPropertyRenderer, {\r\n\t\t\t\t\tname: key,\r\n\t\t\t\t\tvariable: value,\r\n\t\t\t\t\telement: element\r\n\t\t\t\t})\r\n\t\t\t\tif (inputs[element.tagName] || element.tagName === 'SELECT') {\r\n\t\t\t\t\tbindChanges(element, value, key)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (element.tagName === 'SELECT' && key === 'value') {\r\n\t\t\t\t\t// use the deferred <select> value assignment\r\n\t\t\t\t\tInputPropertyRenderer.prototype.renderSelectValueUpdate(value, element)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tInputPropertyRenderer.prototype.renderUpdate(value, element)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction noop() {}\r\n\t\tvar propertyHandlers = {\r\n\t\t\tcontent: noop, // content and children have special handling in create\r\n\t\t\tchildren: noop,\r\n\t\t\ttagName: noop,\r\n\t\t\teach: noop, // just used by content, doesn't need to be recorded on the element\r\n\t\t\tclasses: function(element, classes) {\r\n\t\t\t\tif (!(classes.length > -1)) {\r\n\t\t\t\t\t// index the classes, if necessary\r\n\t\t\t\t\tvar i = 0\r\n\t\t\t\t\tfor (var key in classes) {\r\n\t\t\t\t\t\tif (!classes[i]) {\r\n\t\t\t\t\t\t\tclasses[i] = key\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ti++\r\n\t\t\t\t\t}\r\n\t\t\t\t\tclasses.length = i\r\n\t\t\t\t}\r\n\t\t\t\tfor (var i = 0, l = classes.length; i < l; i++) {\r\n\t\t\t\t\t// find each class name\r\n\t\t\t\t\tvar className = classes[i]\r\n\t\t\t\t\tvar flag = classes[className]\r\n\t\t\t\t\tif (flag && flag.notifies) {\r\n\t\t\t\t\t\t// if it is a variable, we react to it\r\n\t\t\t\t\t\tenterRenderer(ClassNameRenderer, {\r\n\t\t\t\t\t\t\telement: element,\r\n\t\t\t\t\t\t\tclassName: className,\r\n\t\t\t\t\t\t\tvariable: flag\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t} else if (flag || flag === undefined) {\r\n\t\t\t\t\t\telement.className += ' ' + className\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tclass: applyAttribute,\r\n\t\t\tfor: applyAttribute,\r\n\t\t\trole: applyAttribute,\r\n\t\t\trender: function(element, value, key, properties) {\r\n\t\t\t\t// TODO: This doesn't need to be a property updater\r\n\t\t\t\t// we should also verify it is a generator\r\n\t\t\t\t// and maybe, at some point, find an optimization to eliminate the bind()\r\n\t\t\t\tenterRenderer(PropertyRenderer, {\r\n\t\t\t\t\tname: key,\r\n\t\t\t\t\tvariable: new Variable.GeneratorVariable(value.bind(element, properties)),\r\n\t\t\t\t\telement: element\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tvalue: bidirectionalHandler,\r\n\t\t\tvalueAsNumber: bidirectionalHandler,\r\n\t\t\tvalueAsDate: bidirectionalHandler,\r\n\t\t\tchecked: bidirectionalHandler,\r\n\t\t\tdataset: applySubProperties(function(newValue, element, key) {\r\n\t\t\t\telement.dataset[key || this.name] = newValue\r\n\t\t\t}),\r\n\t\t\tattributes: applySubProperties(function(newValue, element, key) {\r\n\t\t\t\telement.setAttribute(key || this.name, newValue)\r\n\t\t\t}),\r\n\t\t\tstyle: function(element, value, key) {\r\n\t\t\t\tif (typeof value === 'string') {\r\n\t\t\t\t\telement.setAttribute('style', value)\r\n\t\t\t\t} else if (value && value.notifies) {\r\n\t\t\t\t\tenterRenderer(AttributeRenderer, {\r\n\t\t\t\t\t\tname: 'style',\r\n\t\t\t\t\t\tvariable: value,\r\n\t\t\t\t\t\telment: element\r\n\t\t\t\t\t})\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstyleObjectHandler(element, value, key)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction applyAttribute(element, value, key) {\r\n\t\t\tif (value && value.notifies) {\r\n\t\t\t\tenterRenderer(AttributeRenderer, {\r\n\t\t\t\t\tname: key,\r\n\t\t\t\t\tvariable: value,\r\n\t\t\t\t\telement: element\r\n\t\t\t\t})\r\n\t\t\t} else {\r\n\t\t\t\telement.setAttribute(key, value)\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tvar styleObjectHandler = applySubProperties(function(newValue, element, key) {\r\n\t\t\telement.style[key || this.name] = newValue\r\n\t\t})\r\n\t\r\n\t\tfunction applySubProperties(renderer) {\r\n\t\t\tvar SubPropertyRenderer = lang.compose(PropertyRenderer, function SubPropertyRenderer(options) {\r\n\t\t\t\tPropertyRenderer.apply(this, arguments)\r\n\t\t\t}, {\r\n\t\t\t\trenderUpdate: renderer\r\n\t\t\t})\t\r\n\t\t\treturn function(element, value, key) {\r\n\t\t\t\tvar target = element[key]\r\n\t\t\t\tfor (var subKey in value) {\r\n\t\t\t\t\tvar subValue = value[subKey]\r\n\t\t\t\t\tif (subValue && subValue.notifies) {\r\n\t\t\t\t\t\tenterRenderer(SubPropertyRenderer, {\r\n\t\t\t\t\t\t\tname: subKey,\r\n\t\t\t\t\t\t\tvariable: subValue,\r\n\t\t\t\t\t\t\telement: element\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\trenderer(subValue, element, subKey)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction applyProperties(element, properties) {\r\n\t\t\tfor (var key in properties) {\r\n\t\t\t\tvar value = properties[key]\r\n\t\t\t\tvar styleDefinition = styleDefinitions[key]\r\n\t\t\t\tif (propertyHandlers[key]) {\r\n\t\t\t\t\tpropertyHandlers[key](element, value, key, properties)\r\n\t\t\t\t} else if ((styleDefinition = styleDefinitions[key]) && element[key] === undefined) {\r\n\t\t\t\t\tif (value && value.notifies) {\r\n\t\t\t\t\t\tenterRenderer(StyleRenderer, {\r\n\t\t\t\t\t\t\tname: key,\r\n\t\t\t\t\t\t\tvariable: value,\r\n\t\t\t\t\t\t\telement: element\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tstyleDefinition(element, value, key)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (value && value.notifies) {\r\n\t\t\t\t\tenterRenderer(PropertyRenderer, {\r\n\t\t\t\t\t\tname: key,\r\n\t\t\t\t\t\tvariable: value,\r\n\t\t\t\t\t\telement: element\r\n\t\t\t\t\t})\r\n\t\t\t\t} else if (typeof value === 'function' && key.slice(0, 2) === 'on') {\r\n\t\t\t\t\telement.addEventListener(key.slice(2), value)\r\n\t\t\t\t} else {\r\n\t\t\t\t\telement[key] = value\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction applySelector(element, selector) {\r\n\t\t\tselector.replace(/(\\.|#)?(\\w+)/g, function(t, operator, name) {\r\n\t\t\t\tif (operator == '.') {\r\n\t\t\t\t\telement._class = (element._class ? element._class + ' ' : '') + name\r\n\t\t\t\t} else if (operator == '#') {\r\n\t\t\t\t\telement._id = name\r\n\t\t\t\t} else {\r\n\t\t\t\t\telement._tag = name\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t}\r\n\t\r\n\t\tnextClassId = 1\r\n\t\tuniqueSelectors = {}\r\n\t\tfunction getUniqueSelector(element) {\r\n\t\t\tvar selector = element.hasOwnProperty('_uniqueSelector') ? element._uniqueSelector :\r\n\t\t\t\t(element._tag + (element._class ? '.' + element._class.replace(/\\s+/g, '.') : '') +\r\n\t\t\t\t(element._id ? '#' + element._id : ''))\r\n\t\t\tif (!selector.match(/[#\\.-]/)) {\r\n\t\t\t\tif (uniqueSelectors[selector]) {\r\n\t\t\t\t\telement._class = '.x-' + nextClassId++\r\n\t\t\t\t\tselector = getUniqueSelector(element)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tuniqueSelectors[selector] = selector\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn selector\r\n\t\t}\r\n\t\r\n\t\tfunction buildContent(element, content, key, properties) {\r\n\t\t\tvar each = element.each || properties.each\r\n\t\t\tif (each && content) {\r\n\t\t\t\t// render as list\r\n\t\t\t\tif (each.create) {\r\n\t\t\t\t\tvar ItemClass = element.itemAs || Item\r\n\t\t\t\t\thasOwn(each, ItemClass, function (element) {\r\n\t\t\t\t\t\tvar itemVariable = ItemClass.for(element._item)\r\n\t\t\t\t\t\titemVariable.collection = content\r\n\t\t\t\t\t\treturn itemVariable\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t\tif (content.notifies) {\r\n\t\t\t\t\tenterRenderer(ListRenderer, {\r\n\t\t\t\t\t\teach: each,\r\n\t\t\t\t\t\tvariable: content,\r\n\t\t\t\t\t\telement: element\r\n\t\t\t\t\t})\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar fragment = doc.createDocumentFragment()\r\n\t\t\t\t\tcontent.forEach(function(item) {\r\n\t\t\t\t\t\tif (each.create) {\r\n\t\t\t\t\t\t\tchildElement = each.create({parent: element, _item: item}) // TODO: make a faster object here potentially\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tchildElement = each(item, element)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfragment.appendChild(childElement)\r\n\t\t\t\t\t})\r\n\t\t\t\t\telement.appendChild(fragment)\r\n\t\t\t\t}\r\n\t\t\t} else if (inputs[element.tagName]) {\r\n\t\t\t\t// render into input\r\n\t\t\t\tbuildInputContent(element, content)\r\n\t\t\t} else if (content instanceof Array) {\r\n\t\t\t\t// treat array as children (potentially of the content node)\r\n\t\t\t\telement = element.contentNode || element\r\n\t\t\t\tlayoutChildren(element, content, element)\r\n\t\t\t} else {\r\n\t\t\t\t// render as string\r\n\t\t\t\telement.appendChild(variableAsText(element, content))\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction bindChanges(element, variable, key, conversion) {\r\n\t\t\tlang.nextTurn(function() { // wait for next turn in case inputChanges isn't set yet\r\n\t\t\t\tvar inputEvents = element.inputEvents || ['change', 'alkali-change']\r\n\t\t\t\tfor (var i = 0, l = inputEvents.length; i < l; i++) {\r\n\t\t\t\t\telement.addEventListener(inputEvents[i], function (event) {\r\n\t\t\t\t\t\tvar value = element[key]\r\n\t\t\t\t\t\tvar result = variable.put(conversion ? conversion(value, element) : value, new Context(element))\r\n\t\t\t\t\t\tif (result === Variable.deny) {\r\n\t\t\t\t\t\t\tthrow new Error('Variable change denied')\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t}\r\n\t\r\n\t\tdoc.addEventListener('click', function(event) {\r\n\t\t\tvar target = event.target\r\n\t\t\tif (target.type === 'radio') {\r\n\t\t\t\tvar radios = doc.querySelectorAll('input[type=radio]')\r\n\t\t\t\tfor (var i = 0, l = radios.length; i < l; i++) {\r\n\t\t\t\t\tvar radio = radios[i]\r\n\t\t\t\t\tif (radio.name === target.name && radio !== target) {\r\n\t\t\t\t\t\tradio.dispatchEvent(new Event('alkali-change', {}))\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\tfunction conversion(value, element) {\r\n\t\t\tif (element.type == 'number') {\r\n\t\t\t\treturn parseFloat(value)\r\n\t\t\t}\r\n\t\t\treturn value\r\n\t\t}\r\n\t\r\n\t\tfunction buildInputContent(element, content) {\r\n\t\t\tvar inputType = element.type\r\n\t\t\tvar inputProperty = inputType in {date: 1, datetime: 1, time: 1} ?\r\n\t\t\t\t\t'valueAsDate' : (inputType === 'checkbox' || inputType === 'radio') ?\r\n\t\t\t\t\t\t'checked' : 'value'\r\n\t\r\n\t\t\tif (content && content.notifies) {\r\n\t\t\t\t// a variable, respond to changes\r\n\t\t\t\tenterRenderer(InputPropertyRenderer, {\r\n\t\t\t\t\tvariable: content,\r\n\t\t\t\t\tname: inputProperty,\r\n\t\t\t\t\telement: element\r\n\t\t\t\t})\r\n\t\t\t\t// and bind the other way as well, updating the variable in response to input changes\r\n\t\t\t\tbindChanges(element, content, inputProperty, conversion)\r\n\t\t\t} else {\r\n\t\t\t\t// primitive\r\n\t\t\t\telement[inputProperty] = content\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar classHandlers = {\r\n\t\t\thasOwn: function(Element, value) {\r\n\t\t\t\thasOwn(Element, value)\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction applyToClass(value, Element) {\r\n\t\t\tvar applyOnCreate = Element._applyOnCreate\r\n\t\t\tvar prototype = Element.prototype\r\n\t\t\tif (value && typeof value === 'object') {\r\n\t\t\t\tif (value instanceof Array || value.notifies) {\r\n\t\t\t\t\tapplyOnCreate.content = value\r\n\t\t\t\t} else {\r\n\t\t\t\t\tfor (var key in value) {\r\n\t\t\t\t\t// TODO: eventually we want to be able to set these as rules statically per element\r\n\t\t\t\t\t/*if (styleDefinitions[key]) {\r\n\t\t\t\t\t\tvar styles = Element.styles || (Element.styles = [])\r\n\t\t\t\t\t\tstyles.push(key)\r\n\t\t\t\t\t\tstyles[key] = descriptor.value\r\n\t\t\t\t\t} else {*/\r\n\t\t\t\t\t\tif (classHandlers[key]) {\r\n\t\t\t\t\t\t\thasOwn(Element, value[key])\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// TODO: do deep merging of styles and classes, but not variables\r\n\t\t\t\t\t\t\tapplyOnCreate[key] = value[key]\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else if (typeof value === 'function' && !value.for) {\r\n\t\t\t\tthrow new TypeError('Function as argument not supported')\r\n\t\t\t} else {\r\n\t\t\t\tapplyOnCreate.content = value\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction getApplySet(Class) {\r\n\t\t\tif (Class.hasOwnProperty('_applyOnCreate')) {\r\n\t\t\t\treturn Class._applyOnCreate\r\n\t\t\t}\r\n\t\t\t// this means we didn't extend and evaluate the prototype yet\r\n\t\t\tif (Class.getForClass) {\r\n\t\t\t\t// we are extending an alkali constructor\r\n\t\t\t\t// if this class is inheriting from an alkali constructor, work our way up the chain\r\n\t\t\t\tapplyOnCreate = Class._applyOnCreate = {}\r\n\t\t\t\tvar parentApplySet = getApplySet(getPrototypeOf(Class))\r\n\t\t\t\tfor (var key in parentApplySet) {\r\n\t\t\t\t\tapplyOnCreate[key] = parentApplySet[key]\r\n\t\t\t\t}\r\n\t\t\t\t// we need to check the prototype for event handlers\r\n\t\t\t\tvar prototype = Class.prototype\r\n\t\t\t\tvar keys = Object.getOwnPropertyNames(prototype)\r\n\t\t\t\tfor (var i = 0, l = keys.length; i < l; i++) {\r\n\t\t\t\t\tvar key = keys[i]\r\n\t\t\t\t\tif (key.slice(0, 2) === 'on' || (key === 'render' && isGenerator(prototype[key]))) {\r\n\t\t\t\t\t\tapplyOnCreate[key] = prototype[key]\r\n\t\t\t\t\t} else if (key.slice(0, 6) === 'render') {\r\n\t\t\t\t\t\tObject.defineProperty(prototype, key[6].toLowerCase() + key.slice(7), renderDescriptor(key))\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn applyOnCreate\r\n\t\t\t}\r\n\t\t\treturn null\r\n\t\t}\r\n\t\r\n\t\tfunction renderDescriptor(renderMethod) {\r\n\t\t\tvar map = new WeakMap()\r\n\t\t\treturn {\r\n\t\t\t\tget: function() {\r\n\t\t\t\t\treturn map.has(this) ? map.get(this) : null\r\n\t\t\t\t},\r\n\t\t\t\tset: function(value) {\r\n\t\t\t\t\tmap.set(this, value)\r\n\t\t\t\t\tthis[renderMethod](value)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction makeElementConstructor() {\r\n\t\t\tfunction Element(selector, properties) {\r\n\t\t\t\tif (this instanceof Element){\r\n\t\t\t\t\t// create DOM element\r\n\t\t\t\t\t// Need to detect if we have registered the element and `this` is actually already the correct instance\r\n\t\t\t\t\treturn create.apply(Element.prototype === getPrototypeOf(this) ? Element :// this means it is from this constructor\r\n\t\t\t\t\t\tthis.constructor, // this means it was constructed from a subclass\r\n\t\t\t\t\t\targuments)\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// extend to create new class\r\n\t\t\t\t\treturn withProperties.apply(Element, arguments)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tElement.create = create\r\n\t\t\tElement.with = withProperties\r\n\t\t\tElement.for = forTarget\r\n\t\t\tElement.property = propertyForElement\r\n\t\t\tElement.getForClass = getForClass\r\n\t\t\treturn Element\r\n\t\t}\r\n\t\r\n\t\tfunction withProperties(selector, properties) {\r\n\t\t\tvar Element = makeElementConstructor()\r\n\t\t\tElement.superConstructor = this\r\n\t\t\tElement.tagName = this.tagName\r\n\t\t\tif (this.children) {\r\n\t\t\t\t// just copy this property\r\n\t\t\t\tElement.children = this.children\r\n\t\t\t}\r\n\t\t\tvar prototype = Element.prototype = this.prototype\r\n\t\r\n\t\t\tvar hasOwnApplySet\r\n\t\t\tvar applyOnCreate = Element._applyOnCreate = {}\r\n\t\t\tvar parentApplySet = getApplySet(this)\r\n\t\t\t// copy parent properties\r\n\t\t\tfor (var key in parentApplySet) {\r\n\t\t\t\tapplyOnCreate[key] = parentApplySet[key]\r\n\t\t\t}\r\n\t\r\n\t\t\tvar i = 0 // for arguments\r\n\t\t\tif (typeof selector === 'string') {\r\n\t\t\t\tvar selectorMatch = selector.match(SELECTOR_REGEX)\r\n\t\t\t\tif (selectorMatch) {\r\n\t\t\t\t\tdo {\r\n\t\t\t\t\t\tvar operator = selectorMatch[1]\r\n\t\t\t\t\t\tvar name = selectorMatch[2]\r\n\t\t\t\t\t\tif (operator == '.') {\r\n\t\t\t\t\t\t\tif (applyOnCreate.className) {\r\n\t\t\t\t\t\t\t\tapplyOnCreate.className += ' ' + name\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tapplyOnCreate.className = name\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tapplyOnCreate.id = name\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar remaining = selectorMatch[3]\r\n\t\t\t\t\t\tselectorMatch = remaining && remaining.match(SELECTOR_REGEX)\r\n\t\t\t\t\t} while (selectorMatch)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tapplyOnCreate.content = selector\r\n\t\t\t\t}\r\n\t\t\t\ti++ // skip the first argument\r\n\t\t\t}\r\n\t\r\n\t\t\tfor (var l = arguments.length; i < l; i++) {\r\n\t\t\t\tapplyToClass(arguments[i], Element)\r\n\t\t\t}\r\n\t\t\treturn Element\r\n\t\t}\r\n\t\tvar currentParent\r\n\t\tfunction create(selector, properties) {\r\n\t\t\t// TODO: make this a symbol\r\n\t\t\tvar applyOnCreate = getApplySet(this)\r\n\t\t\tif (currentParent) {\r\n\t\t\t\tvar parent = currentParent\r\n\t\t\t\tcurrentParent = null\r\n\t\t\t}\r\n\t/*\t\tif (this._initialized != this) {\r\n\t\t\t\tthis._initialized = this\r\n\t\t\t\tthis.initialize && this.initialize()\r\n\t\t\t\tvar styles = this.styles\r\n\t\t\t\tif (styles) {\r\n\t\t\t\t\tvar rule = createCssRule(getUniqueSelector(this))\r\n\t\t\t\t\tfor (var i = 0, l = styles.length; i < l; i++) {\r\n\t\t\t\t\t\tvar key = styles[i]\r\n\t\t\t\t\t\tvar value = styles[key]\r\n\t\t\t\t\t\t// TODO: if it is a contextualized variable, do this on the element\r\n\t\t\t\t\t\tvar styleDefinition = styleDefinitions[key]\r\n\t\t\t\t\t\tif (styleDefinition) {\r\n\t\t\t\t\t\t\tstyleDefinition(rule, value, key)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (!this.hasOwnProperty('_applyOnCreate')) {\r\n\t\t\t\t\tapplyOnCreate = getApplySet(this)\r\n\t\t\t\t}\r\n\t\t\t}*/\r\n\t\t\tvar element = doc.createElement(this.tagName)\r\n\t\t\tif (selector && selector.parent) {\r\n\t\t\t\tparent = selector.parent\r\n\t\t\t}\r\n\t\t\tif (parent) {\r\n\t\t\t\tpresumptiveParentMap.set(element, parent)\r\n\t\t\t}\r\n\t\t\tif (!(element instanceof this)) {\r\n\t\t\t\t// ideally we want to avoid this call, as it is expensive, but for classes that\r\n\t\t\t\t// don't register a tag name, we have to make sure the prototype chain is correct\r\n\t\t\t\tsetPrototypeOf(element, this.prototype)\r\n\t\t\t}\r\n\t\t\tif (element.constructor != this) {\r\n\t\t\t\telement.constructor = this // need to do this for hasOwn contextualization to work\r\n\t\t\t}\r\n\t\t\tif (arguments.length > 0) {\r\n\t\t\t\t// copy applyOnCreate when we have arguments\r\n\t\t\t\tvar ElementApplyOnCreate = applyOnCreate\r\n\t\t\t\tapplyOnCreate = {}\r\n\t\t\t\tfor (var key in ElementApplyOnCreate) {\r\n\t\t\t\t\tapplyOnCreate[key] = ElementApplyOnCreate[key]\r\n\t\t\t\t}\r\n\t\t\t\tvar i = 0\r\n\t\t\t\tif (typeof selector == 'string') {\r\n\t\t\t\t\ti++\r\n\t\t\t\t\tvar selectorMatch = selector.match(SELECTOR_REGEX)\r\n\t\t\t\t\tif (selectorMatch) {\r\n\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\tvar operator = selectorMatch[1]\r\n\t\t\t\t\t\t\tvar name = selectorMatch[2]\r\n\t\t\t\t\t\t\tif (operator == '.') {\r\n\t\t\t\t\t\t\t\tif (applyOnCreate.className) {\r\n\t\t\t\t\t\t\t\t\tapplyOnCreate.className += ' ' + name\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tif (element.className) {\r\n\t\t\t\t\t\t\t\t\t    element.className += ' ' + name\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t    element.className = name\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tif (applyOnCreate.id) {\r\n\t\t\t\t\t\t\t\t\tapplyOnCreate.id = name\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t// just skip right to the element\r\n\t\t\t\t\t\t\t\t\telement.id = name\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tvar remaining = selectorMatch[3]\r\n\t\t\t\t\t\t\tselectorMatch = remaining && remaining.match(SELECTOR_REGEX)\r\n\t\t\t\t\t\t} while (selectorMatch)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tapplyOnCreate.content = selector\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (selector && selector._item) {\r\n\t\t\t\t\t// this is kind of hack, to get the Item available before the properties, eventually we may want to\r\n\t\t\t\t\t// order static properties before variable binding applications, but for now.\r\n\t\t\t\t\telement._item = selector._item\r\n\t\t\t\t}\r\n\t\t\t\tfor (var l = arguments.length; i < l; i++) {\r\n\t\t\t\t\tvar argument = arguments[i]\r\n\t\t\t\t\tif (argument && typeof argument === 'object') {\r\n\t\t\t\t\t\tif (argument instanceof Array || argument.notifies) {\r\n\t\t\t\t\t\t\tapplyOnCreate.content = argument\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tfor (var key in argument) {\r\n\t\t\t\t\t\t\t\t// TODO: do deep merging of styles and classes, but not variables\r\n\t\t\t\t\t\t\t\tapplyOnCreate[key] = argument[key]\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (typeof argument === 'function' && argument.for) {\r\n\t\t\t\t\t\tapplyOnCreate.content = argument.for(element)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tapplyOnCreate.content = argument\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// TODO: inline this\r\n\t\t\tapplyProperties(element, applyOnCreate)\r\n\t\t\tif (this.children) {\r\n\t\t\t\tlayoutChildren(element, this.children, element)\r\n\t\t\t}\r\n\t\t\t// always do this last, so it can be properly inserted inside the children\r\n\t\t\tif (applyOnCreate.content) {\r\n\t\t\t\tbuildContent(element, applyOnCreate.content, 'content', applyOnCreate)\r\n\t\t\t}\r\n\t\t\telement.createdCallback && element.createdCallback()\r\n\t\t\telement.created && element.created(applyOnCreate)\r\n\t\t\treturn element\r\n\t\t}\r\n\t\r\n\t\tvar slice = [].slice\r\n\t\tfunction append(parent){\r\n\t\t\treturn this.nodeType ?\r\n\t\t\t\tlayoutChildren(this, arguments, this) : // called as a method\r\n\t\t\t\tlayoutChildren(parent, slice.call(arguments, 1), parent) // called as a function\r\n\t\t}\r\n\t\r\n\t\tfunction prepend(parent){\r\n\t\t\treturn this.nodeType ?\r\n\t\t\t\tlayoutChildren(this, arguments, this, true) : // called as a method\r\n\t\t\t\tlayoutChildren(parent, slice.call(arguments, 1), parent, true) // called as a function\r\n\t\t}\r\n\t\r\n\t\tfunction registerTag(tagName) {\r\n\t\t\tthis.tagName = tagName\r\n\t\t\tif (doc.registerElement && this.prototype.constructor === this) {\r\n\t\t\t\tdoc.registerElement(tagName, this)\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tvar Element = withProperties.call(typeof HTMLElement !== 'undefined' ? HTMLElement : function() {})\r\n\t\r\n\t\tElement.registerTag = registerTag\r\n\t\tElement.applyProperties = applyProperties\r\n\t\r\n\t\tElement.within = function(element){\r\n\t\t\t// find closest child\r\n\t\t}\r\n\t\r\n\t\tgenerate([\r\n\t\t\t'Video',\r\n\t\t\t'Source',\r\n\t\t\t'Media',\r\n\t\t\t'Audio',\r\n\t\t\t'UL',\r\n\t\t\t'Track',\r\n\t\t\t'Title',\r\n\t\t\t'TextArea',\r\n\t\t\t'Template',\r\n\t\t\t'TBody',\r\n\t\t\t'THead',\r\n\t\t\t'TFoot',\r\n\t\t\t'TR',\r\n\t\t\t'Table',\r\n\t\t\t'Col',\r\n\t\t\t'ColGroup',\r\n\t\t\t'TH',\r\n\t\t\t'TD',\r\n\t\t\t'Caption',\r\n\t\t\t'Style',\r\n\t\t\t'Span',\r\n\t\t\t'Shadow',\r\n\t\t\t'Select',\r\n\t\t\t'Script',\r\n\t\t\t'Quote',\r\n\t\t\t'Progress',\r\n\t\t\t'Pre',\r\n\t\t\t'Picture',\r\n\t\t\t'Param',\r\n\t\t\t'P',\r\n\t\t\t'Output',\r\n\t\t\t'Option',\r\n\t\t\t'Optgroup',\r\n\t\t\t'Object',\r\n\t\t\t'OL',\r\n\t\t\t'Ins',\r\n\t\t\t'Del',\r\n\t\t\t'Meter',\r\n\t\t\t'Meta',\r\n\t\t\t'Menu',\r\n\t\t\t'Map',\r\n\t\t\t'Link',\r\n\t\t\t'Legend',\r\n\t\t\t'Label',\r\n\t\t\t'LI',\r\n\t\t\t'KeyGen',\r\n\t\t\t'Input',\r\n\t\t\t'Image',\r\n\t\t\t'IFrame',\r\n\t\t\t'H1',\r\n\t\t\t'H2',\r\n\t\t\t'H3',\r\n\t\t\t'H4',\r\n\t\t\t'H5',\r\n\t\t\t'H6',\r\n\t\t\t'Hr',\r\n\t\t\t'FrameSet',\r\n\t\t\t'Frame',\r\n\t\t\t'Form',\r\n\t\t\t'Font',\r\n\t\t\t'Embed',\r\n\t\t\t'Article',\r\n\t\t\t'Aside',\r\n\t\t\t'Footer',\r\n\t\t\t'Figure',\r\n\t\t\t'FigCaption',\r\n\t\t\t'Header',\r\n\t\t\t'Main',\r\n\t\t\t'Mark',\r\n\t\t\t'MenuItem',\r\n\t\t\t'Nav',\r\n\t\t\t'Section',\r\n\t\t\t'Summary',\r\n\t\t\t'WBr',\r\n\t\t\t'Div',\r\n\t\t\t'Dialog',\r\n\t\t\t'Details',\r\n\t\t\t'DataList',\r\n\t\t\t'DL',\r\n\t\t\t'Canvas',\r\n\t\t\t'Button',\r\n\t\t\t'Base',\r\n\t\t\t'Br',\r\n\t\t\t'Area',\r\n\t\t\t'A'\r\n\t\t])\r\n\t\tgenerateInputs([\r\n\t\t\t'Checkbox',\r\n\t\t\t'Password',\r\n\t\t\t'Submit',\r\n\t\t\t'Radio',\r\n\t\t\t'Color',\r\n\t\t\t'Date',\r\n\t\t\t'DateTime',\r\n\t\t\t'Email',\r\n\t\t\t'Month',\r\n\t\t\t'Number',\r\n\t\t\t'Range',\r\n\t\t\t'Search',\r\n\t\t\t'Tel',\r\n\t\t\t'Time',\r\n\t\t\t'Url',\r\n\t\t\t'Week'])\r\n\t\r\n\t\tvar tags = {}\r\n\t\tfunction getConstructor(tagName) {\r\n\t\t\ttagName = tagName.toLowerCase()\r\n\t\t\treturn tags[tagName] ||\r\n\t\t\t\t(tags[tagName] =\r\n\t\t\t\t\tsetTag(withProperties.call(doc.createElement(tagName).constructor), tagName))\r\n\t\t}\r\n\t\r\n\t\tfunction setTag(Element, tagName) {\r\n\t\t\tElement.tagName = tagName\r\n\t\t\treturn Element\r\n\t\t}\r\n\t\tfunction generate(elements) {\r\n\t\t\telements.forEach(function(elementName) {\r\n\t\t\t\tvar ElementClass\r\n\t\t\t\tObject.defineProperty(Element, elementName, {\r\n\t\t\t\t\tget: function() {\r\n\t\t\t\t\t\treturn ElementClass || (ElementClass = getConstructor(elementName))\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t})\r\n\t\t}\r\n\t\tfunction generateInputs(elements) {\r\n\t\t\telements.forEach(function(inputType) {\r\n\t\t\t\tvar ElementClass\r\n\t\t\t\tObject.defineProperty(Element, inputType, {\r\n\t\t\t\t\tget: function() {\r\n\t\t\t\t\t\t// TODO: make all inputs extend from input generated from generate\r\n\t\t\t\t\t\treturn ElementClass || (ElementClass = setTag(withProperties.call(HTMLInputElement, {\r\n\t\t\t\t\t\t\ttype: inputType.toLowerCase()\r\n\t\t\t\t\t\t}), 'input'))\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t\t// alias all the inputs with an Input suffix\r\n\t\t\t\tObject.defineProperty(Element, inputType + 'Input', {\r\n\t\t\t\t\tget: function() {\r\n\t\t\t\t\t\treturn this[inputType]\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t})\r\n\t\t}\r\n\t\r\n\t\tvar aliases = {\r\n\t\t\tAnchor: 'A',\r\n\t\t\tParagraph: 'P',\r\n\t\t\tTextarea: 'TextArea',\r\n\t\t\tDList: 'DL',\r\n\t\t\tUList: 'UL',\r\n\t\t\tOList: 'OL',\r\n\t\t\tListItem: 'LI',\r\n\t\t\tText: 'Input',\r\n\t\t\tTextInput: 'Input',\r\n\t\t\tTableRow: 'TR',\r\n\t\t\tTableCell: 'TD',\r\n\t\t\tTableHeaderCell: 'TH',\r\n\t\t\tTableHeader: 'THead',\r\n\t\t\tTableBody: 'TBody'\r\n\t\t}\r\n\t\tfor (var alias in aliases) {\r\n\t\t\t(function(alias, to) {\r\n\t\t\t\tObject.defineProperty(Element, alias, {\r\n\t\t\t\t\tget: function() {\r\n\t\t\t\t\t\treturn this[to]\r\n\t\t\t\t\t}\r\n\t\t\t\t})\t\t\t\r\n\t\t\t})(alias, aliases[alias])\r\n\t\t}\r\n\t\r\n\t\tElement.append = append\r\n\t\tElement.prepend = prepend\r\n\t\tElement.refresh = Renderer.refresh\r\n\t\tvar options = Element.options = {\r\n\t\t\tmoveLiveElementsEnabled: true,\r\n\t\t}\r\n\t\tElement.content = function(element){\r\n\t\t\t// container marker\r\n\t\t\treturn {\r\n\t\t\t\tisContentNode: true,\r\n\t\t\t\tcreate: element.create.bind(element)\r\n\t\t\t}\r\n\t\t}\r\n\t\t// TODO: unify this in lang\r\n\t\tElement.extend = function(Class, properties) {\r\n\t\t\tfunction ExtendedElement() {\r\n\t\t\t\treturn Class.apply(this, arguments)\r\n\t\t\t}\r\n\t\t\tsetPrototypeOf(ExtendedElement, Class)\r\n\t\t\tvar prototype = ExtendedElement.prototype = Object.create(Class.prototype)\r\n\t\t\tprototype.constructor = ExtendedElement\r\n\t\t\tObject.getOwnPropertyNames(properties).forEach(function(key) {\r\n\t\t\t\tvar descriptor = Object.getOwnPropertyDescriptor(properties, key)\r\n\t\t\t\tif (classHandlers[key]) {\r\n\t\t\t\t\tclassHandlers[key](ExtendedElement, descriptor.value)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tObject.defineProperty(prototype, key, descriptor)\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\treturn ExtendedElement\r\n\t\t}\r\n\t\r\n\t\tfunction forTarget(target) {\r\n\t\t\treturn target.constructor.getForClass(target, this)\r\n\t\t}\r\n\t\r\n\t\tfunction hasOwn(From, Target, createInstance) {\r\n\t\t\tif (typeof Target === 'object' && Target.Class) {\r\n\t\t\t\treturn hasOwn(From, Target.Class, Target.createInstance)\r\n\t\t\t}\r\n\t\t\tif (Target instanceof Array) {\r\n\t\t\t\treturn Target.forEach(function(Target) {\r\n\t\t\t\t\thasOwn(From, Target)\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tvar ownedClasses = From.ownedClasses || (From.ownedClasses = new WeakMap())\r\n\t\t\t// TODO: assign to super classes\r\n\t\t\townedClasses.set(Target, createInstance || function() {\r\n\t\t\t\treturn new Target()\r\n\t\t\t})\r\n\t\t\treturn From\r\n\t\t}\r\n\t\r\n\t\tvar globalInstances = {}\r\n\t\tfunction getForClass(element, Target) {\r\n\t\t\tvar createInstance\r\n\t\t\twhile (element && !(createInstance = element.constructor.ownedClasses && element.constructor.ownedClasses.get(Target))) {\r\n\t\t\t\telement = element.parentNode || presumptiveParentMap.get(element)\r\n\t\t\t}\r\n\t\t\tif (createInstance) {\r\n\t\t\t\tvar ownedInstances = element.ownedInstances || (element.ownedInstances = new WeakMap())\r\n\t\t\t\tvar instance = ownedInstances.get(Target)\r\n\t\t\t\tif (instance === undefined) {\r\n\t\t\t\t\townedInstances.set(Target, instance = createInstance(element))\r\n\t\t\t\t\tinstance.subject = element\r\n\t\t\t\t}\r\n\t\t\t\treturn instance\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction propertyForElement(key) {\r\n\t\t\t// we just need to establish one Variable class for each element, so we cache it\r\n\t\t\tThisElementVariable = this._Variable\r\n\t\t\tif (!ThisElementVariable) {\r\n\t\t\t\t// need our own branded variable class for this element class\r\n\t\t\t\tThisElementVariable = this._Variable = Variable()\r\n\t\r\n\t\t\t\thasOwn(this, ThisElementVariable, function(element) {\r\n\t\t\t\t\t// when we create the instance, immediately observe it\r\n\t\t\t\t\t// TODO: we might want to do this in init instead\r\n\t\t\t\t\tvar instance = new ThisElementVariable(element)\r\n\t\t\t\t\tinstance.observeObject()\r\n\t\t\t\t\treturn instance\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\t// now actually get the property class\r\n\t\t\treturn ThisElementVariable.property(key)\r\n\t\t}\r\n\t\r\n\t\tvar Item = Element.Item = Variable.Item\r\n\t\r\n\t\tfunction enterRenderer(Renderer, options/*, target*/) {\r\n\t\t\t// this will be used for optimized class-level variables\r\n\t\t\t/*if (target.started) { // TODO: Might want to pass in started as a parameter\r\n\t\t\t\t// this means that the updater has already been created, so we just need to add this instance\r\n\t\t\t\tRenderer.prototype.renderUpdate.call(options, element)\r\n\t\t\t} else {*/\r\n\t\t\tvar target = options.element\r\n\t\t\tvar updaters = target.updaters || (target.updaters = [])\r\n\t\t\tupdaters.push(new Renderer(options))\r\n\t\t\t//}\r\n\t\t}\r\n\t\r\n\t\tfunction cleanup(target) {\r\n\t\t\tvar updaters = target.updaters\r\n\t\t\tif (updaters) {\r\n\t\t\t\tfor (var i = 0, l = updaters.length; i < l; i++) {\r\n\t\t\t\t\tupdaters[i].stop()\r\n\t\t\t\t}\r\n\t\t\t\ttarget.needsRestart = true\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction restart(target) {\r\n\t\t\tvar updaters = target.updaters\r\n\t\t\tif (updaters) {\r\n\t\t\t\tfor (var i = 0, l = updaters.length; i < l; i++) {\r\n\t//\t\t\t\tupdaters[i].start()\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t// setup the mutation observer so we can be notified of attachments and removals\r\n\t\tfunction elementAttached(element) {\r\n\t\t\tvar Class = element.constructor\r\n\t\t\tif (Class.create) {\r\n\t/*\t\t\tif (Class.attachedInstances) {\r\n\t\t\t\t\tClass.attachedInstances.push(element)\r\n\t\t\t\t\tif (Class.attachedInstances.length === 1 && Class.needsRestart) {\r\n\t\t\t\t\t\trestart(Class)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tClass.attachedInstances = [element]\r\n\t\t\t\t}*/\r\n\t\t\t\tif (element.attached) {\r\n\t\t\t\t\telement.attached()\r\n\t\t\t\t}\r\n\t\t\t\tif (element.needsRestart) {\r\n\t\t\t\t\trestart(element)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction elementDetached(element) {\r\n\t\t\t/*var attachedInstances = element.constructor.attachedInstances\r\n\t\t\tif (attachedInstances) {\r\n\t\t\t\tvar index = attachedInstances.indexOf(element)\r\n\t\t\t\tif (index > -1) {\r\n\t\t\t\t\tattachedInstances.splice(index, 1)\r\n\t\t\t\t\tif (attachedInstances.length === 0) {\r\n\t\t\t\t\t\tcleanup(Class)\r\n\t\t\t\t\t}\r\n\t\t\t\t}*/\r\n\t\t\t\tif (element.detached) {\r\n\t\t\t\t\telement.detached()\r\n\t\t\t\t}\r\n\t\t\t\tcleanup(element)\r\n\t\t\t//}\r\n\t\t}\r\n\t\tif (typeof MutationObserver === 'function') {\r\n\t\t\tvar docBody = doc.body\r\n\t\t\tvar lifeStates = [{\r\n\t\t\t\tname: 'detached',\r\n\t\t\t\tnodes: 'removedNodes',\r\n\t\t\t\taction: elementDetached\r\n\t\t\t}, {\r\n\t\t\t\tname: 'attached',\r\n\t\t\t\tnodes: 'addedNodes',\r\n\t\t\t\taction: elementAttached\r\n\t\t\t}]\r\n\t\t\tfunction firstVisit(node, state) {\r\n\t\t\t\tif (state.name === 'attached') {\r\n\t\t\t\t\tif (node.__alkaliAttached__) {\r\n\t\t\t\t\t\treturn false\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tnode.__alkaliAttached__ = true\r\n\t\t\t\t\t\tstate.action(node)\r\n\t\t\t\t\t\treturn true\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (node.__alkaliAttached__) {\r\n\t\t\t\t\tif (docBody.contains(node)) {\r\n\t\t\t\t\t\t// detached event, but it is actually still attached (will get attached in a later mutation record)\r\n\t\t\t\t\t\t// so don't get through the detached/attached lifecycle\r\n\t\t\t\t\t\treturn false\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnode.__alkaliAttached__ = false\r\n\t\t\t\t\tstate.action(node)\r\n\t\t\t\t}\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\t\t\tvar observer = new MutationObserver(function(mutations) {\r\n\t\t\t\tfor (var i = 0, il = mutations.length; i < il; i++) {\r\n\t\t\t\t\tvar mutation = mutations[i]\r\n\t\t\t\t\t// invoke action on element if we haven't already\r\n\t\t\t\t\tactionIteration:\r\n\t\t\t\t\tfor (var j = 0, jl = lifeStates.length; j < jl; j++) { // two steps, removed nodes and added nodes\r\n\t\t\t\t\t\tvar state = lifeStates[j]\r\n\t\t\t\t\t\tvar nodes = mutation[state.nodes]\r\n\t\t\t\t\t\t// iterate over node list\r\n\t\t\t\t\t\tnodeIteration:\r\n\t\t\t\t\t\tfor (var k = 0, kl = nodes.length; k < kl; k++) {\r\n\t\t\t\t\t\t\tvar baseNode = nodes[k]\r\n\t\t\t\t\t\t\tif (firstVisit(baseNode, state)) {\r\n\t\t\t\t\t\t\t\t// start traversal with child, if it exists\r\n\t\t\t\t\t\t\t\tvar currentNode = baseNode.firstChild\r\n\t\t\t\t\t\t\t\tif (currentNode) {\r\n\t\t\t\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\t\t\t\tvar nextNode\r\n\t\t\t\t\t\t\t\t\t\tif (currentNode.nodeType === 1 && firstVisit(currentNode, state)) {\r\n\t\t\t\t\t\t\t\t\t\t\t// depth-first search\r\n\t\t\t\t\t\t\t\t\t\t\tnextNode = currentNode.firstChild\r\n\t\t\t\t\t\t\t\t\t\t\tif (!nextNode) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tnextNode = currentNode.nextSibling\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\tnextNode = currentNode.nextSibling\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tif (!nextNode) {\r\n\t\t\t\t\t\t\t\t\t\t\t// come back out to parents\r\n\t\t\t\t\t\t\t\t\t\t\t// TODO: try keeping a stack to make this faster\r\n\t\t\t\t\t\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentNode = currentNode.parentNode\r\n\t\t\t\t\t\t\t\t\t\t\t\tif (currentNode === baseNode) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tcontinue nodeIteration\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t} while (!(nextNode = currentNode.nextSibling))\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tcurrentNode = nextNode\r\n\t\t\t\t\t\t\t\t\t} while (true)\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// if (options.moveLiveElementsEnabled) {\r\n\t\t\t\t\t\t\t// TODO: any options that we can really do here?\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\tobserver.observe(docBody, {\r\n\t\t\t\tchildList: true,\r\n\t\t\t\tsubtree: true\r\n\t\t\t})\r\n\t\t}\r\n\t\r\n\t\treturn Element\r\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\r\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(3)], __WEBPACK_AMD_DEFINE_RESULT__ = function (lang) {\r\n\t\tvar deny = {}\r\n\t\tvar noChange = {}\r\n\t\tvar WeakMap = lang.WeakMap\r\n\t\tvar setPrototypeOf = Object.setPrototypeOf || (function(base, proto) { base.__proto__ = proto})\r\n\t\tvar getPrototypeOf = Object.getPrototypeOf || (function(base) { return base.__proto__ })\r\n\t\t// update types\r\n\t\tvar ToParent = 2\r\n\t\tvar RequestChange = 3\r\n\t\t\r\n\t\tvar ToChild = Object.freeze({\r\n\t\t\ttype: 'refresh'\r\n\t\t})\r\n\t\tvar nextId = 1\r\n\t\tvar propertyListenersMap = new WeakMap(null, 'propertyListenersMap')\r\n\t\r\n\t\tvar CacheEntry = lang.compose(WeakMap, function() {\r\n\t\t},{\r\n\t\t\t_propertyChange: function(propertyName) {\r\n\t\t\t\tthis.variable._propertyChange(propertyName, contextFromCache(this))\r\n\t\t\t}\r\n\t\t})\r\n\t\tvar listenerId = 1\r\n\t\r\n\t\tfunction mergeSubject(context) {\r\n\t\t\tfor (var i = 1, l = arguments.length; i < l; i++) {\r\n\t\t\t\tvar nextContext = arguments[i]\r\n\t\t\t\tif (nextContext !== context && (!context || nextContext && context.contains && context.contains(nextContext))) {\r\n\t\t\t\t\tcontext = nextContext\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn context\r\n\t\t}\r\n\t\r\n\t\tfunction getMaterializedContextualInstance(variable, context) {\r\n\t\t\tvar subject = context && (context.distinctSubject || context.subject)\r\n\t\t\tif (typeof variable === 'function') {\r\n\t\t\t\treturn variable.for(subject)\r\n\t\t\t}\r\n\t\t\tvar contextMap = variable.contextMap\r\n\t\t\tif (context && contextMap) {\r\n\t\t\t\twhile(subject && !contextMap.has(subject)) {\r\n\t\t\t\t\tsubject = subject.parentNode\r\n\t\t\t\t}\r\n\t\t\t\tif (!subject) {\r\n\t\t\t\t\tsubject = defaultContext\r\n\t\t\t\t}\r\n\t\t\t\treturn contextMap.get(subject)\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction when(value, callback) {\r\n\t\t\tif (value && value.then) {\r\n\t\t\t\treturn value.then(callback)\r\n\t\t\t}\r\n\t\t\treturn callback(value)\r\n\t\t}\r\n\t\r\n\t\tfunction Context(subject){\r\n\t\t\tthis.subject = subject\r\n\t\t}\r\n\t\tfunction whenAll(inputs, callback){\r\n\t\t\tvar promiseInvolved\r\n\t\t\tvar needsContext\r\n\t\t\tfor (var i = 0, l = inputs.length; i < l; i++) {\r\n\t\t\t\tif (inputs[i] && inputs[i].then) {\r\n\t\t\t\t\tpromiseInvolved = true\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (promiseInvolved) {\r\n\t\t\t\treturn lang.whenAll(inputs, callback)\r\n\t\t\t}\r\n\t\t\treturn callback(inputs)\r\n\t\t}\r\n\t\r\n\t\tfunction registerListener(value, listener) {\r\n\t\t\tvar listeners = propertyListenersMap.get(value)\r\n\t\t\tvar id = listener.listenerId || (listener.listenerId = ('-' + listenerId++))\r\n\t\t\tif (listeners) {\r\n\t\t\t\tif (listeners[id] === undefined) {\r\n\t\t\t\t\tlisteners[id] = listeners.push(listener) - 1\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\tpropertyListenersMap.set(value, listeners = [listener])\r\n\t\t\t\tlisteners[id] = 0\r\n\t\t\t\tif (Variable.autoObserveObjects) {\r\n\t\t\t\t\tobserve(value)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tlistener.listeningToObject = value\r\n\t\t}\r\n\t\tfunction deregisterListener(listener) {\r\n\t\t\tif (listener.listeningToObject) {\r\n\t\t\t\tvar value = listener.listeningToObject\r\n\t\t\t\tlistener.listeningToObject = null\r\n\t\t\t\tvar listeners = propertyListenersMap.get(value)\r\n\t\t\t\tif (listeners) {\r\n\t\t\t\t\tvar index = listeners[listener.listenerId]\r\n\t\t\t\t\tif (index > -1) {\r\n\t\t\t\t\t\tlisteners.splice(index, 1)\r\n\t\t\t\t\t\tdelete listeners[listener.listenerId]\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction RefreshEvent() {\r\n\t\t\tthis.visited = new Set()\r\n\t\t}\r\n\t\tRefreshEvent.prototype.type = 'refresh'\r\n\t\r\n\t\tfunction PropertyChangeEvent(key, childEvent, parent) {\r\n\t\t\tthis.key = key\r\n\t\t\tthis.childEvent = childEvent\r\n\t\t\tthis.parent = parent\r\n\t\t\tthis.visited = childEvent.visited\r\n\t\t}\r\n\t\tPropertyChangeEvent.prototype.type = 'update'\r\n\t\r\n\t\tfunction AddEvent(args) {\r\n\t\t\tthis.visited = new Set()\r\n\t\t\tfor (var key in args) {\r\n\t\t\t\tthis[key] = args[key]\r\n\t\t\t}\r\n\t\t}\r\n\t\tAddEvent.prototype.type = 'add'\r\n\t\tfunction DeleteEvent(args) {\r\n\t\t\tthis.visited = new Set()\r\n\t\t\tfor (var key in args) {\r\n\t\t\t\tthis[key] = args[key]\r\n\t\t\t}\r\n\t\t}\r\n\t\tDeleteEvent.prototype.type = 'delete'\r\n\t\r\n\t\r\n\t\tfunction Variable(value) {\r\n\t\t\tif (this instanceof Variable) {\r\n\t\t\t\t// new call, may eventually use new.target\r\n\t\t\t\tthis.value = typeof value === 'undefined' ? this.default : value\r\n\t\t\t} else {\r\n\t\t\t\treturn Variable.extend(value)\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar VariablePrototype = Variable.prototype = {\r\n\t\t\tconstructor: Variable,\r\n\t\t\tvalueOf: function(context) {\r\n\t\t\t\tif (this.subject) {\r\n\t\t\t\t\tvar variable = this\r\n\t\t\t\t\tcontext = new Context(this.subject)\r\n\t\t\t\t}\r\n\t\t\t\treturn this.gotValue(this.getValue(context), context)\r\n\t\t\t},\r\n\t\t\tgetValue: function() {\r\n\t\t\t\treturn this.value\r\n\t\t\t},\r\n\t\t\tgotValue: function(value, context) {\r\n\t\t\t\tvar previousNotifyingValue = this.notifyingValue\r\n\t\t\t\tvar variable = this\r\n\t\t\t\tif (value && value.then) {\r\n\t\t\t\t\treturn when(value, function(value) {\r\n\t\t\t\t\t\treturn Variable.prototype.gotValue.call(variable, value, context)\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t\tif (previousNotifyingValue) {\r\n\t\t\t\t\tif (value === previousNotifyingValue) {\r\n\t\t\t\t\t\t// nothing changed, immediately return valueOf (or ownObject if we have it)\r\n\t\t\t\t\t\treturn variable.ownObject || value.valueOf(context)\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// if there was a another value that we were dependent on before, stop listening to it\r\n\t\t\t\t\t// TODO: we may want to consider doing cleanup after the next rendering turn\r\n\t\t\t\t\tif (variable.dependents) {\r\n\t\t\t\t\t\tpreviousNotifyingValue.stopNotifies(variable)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvariable.notifyingValue = null\r\n\t\t\t\t}\r\n\t\t\t\tif (value && value.notifies) {\r\n\t\t\t\t\tif (variable.dependents) {\r\n\t\t\t\t\t\t\t// the value is another variable, start receiving notifications\r\n\t\t\t\t\t\tvalue.notifies(variable)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvariable.notifyingValue = value\r\n\t\t\t\t\tvalue = value.valueOf(context)\r\n\t\t\t\t\tif (variable.ownObject) {\r\n\t\t\t\t\t\tif (getPrototypeOf(variable.ownObject) !== value) {\r\n\t\t\t\t\t\t\tsetPrototypeOf(variable.ownObject, value)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvalue = variable.ownObject\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (value === undefined) {\r\n\t\t\t\t\tvalue = variable.default\r\n\t\t\t\t}\r\n\t\t\t\treturn value\r\n\t\t\t},\r\n\t\t\tisMap: function() {\r\n\t\t\t\treturn this.value instanceof Map\r\n\t\t\t},\r\n\t\t\tproperty: function(key) {\r\n\t\t\t\tvar isMap = this.isMap()\r\n\t\t\t\tvar properties = this._properties || (this._properties = isMap ? new Map() : {})\r\n\t\t\t\tvar propertyVariable = isMap ? properties.get(key) : properties[key]\r\n\t\t\t\tif (!propertyVariable) {\r\n\t\t\t\t\t// create the property variable\r\n\t\t\t\t\tpropertyVariable = new Property(this, key)\r\n\t\t\t\t\tif (isMap) {\r\n\t\t\t\t\t\tproperties.set(key, propertyVariable)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tproperties[key] = propertyVariable\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn propertyVariable\r\n\t\t\t},\r\n\t\t\tfor: function(subject) {\r\n\t\t\t\tif (subject && subject.target && !subject.constructor.getForClass) {\r\n\t\t\t\t\t// makes HTML events work\r\n\t\t\t\t\tsubject = subject.target\r\n\t\t\t\t}\r\n\t\t\t\tif (typeof this === 'function') {\r\n\t\t\t\t\t// this is a class, the subject should hopefully have an entry\r\n\t\t\t\t\tif (subject !== undefined) {\r\n\t\t\t\t\t\tvar instance\r\n\t\t\t\t\t\tif (subject.constructor.getForClass) {\r\n\t\t\t\t\t\t\t// if the subject has it is own means of retrieving an instance\r\n\t\t\t\t\t\t\tinstance = subject.constructor.getForClass(subject, this)\r\n\t\t\t\t\t\t\tif (instance && !instance.subject) {\r\n\t\t\t\t\t\t\t\tinstance.subject = subject\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tif (subject && typeof subject === 'object') {\r\n\t\t\t\t\t\t\t\t// a plain object, we use our own map to retrieve the instance (or create one)\r\n\t\t\t\t\t\t\t\tvar instanceMap = this.instanceMap || (this.instanceMap = new WeakMap())\r\n\t\t\t\t\t\t\t\tinstance = instanceMap.get(subject)\r\n\t\t\t\t\t\t\t\tif (!instance) {\r\n\t\t\t\t\t\t\t\t\tinstanceMap.set(subject, instance = new this(subject))\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// a primitive, just unconditionally create a new variable for it\r\n\t\t\t\t\t\t\t\tinstance = new this(subject)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// TODO: Do we have a global context that we set on defaultInstance?\r\n\t\t\t\t\t\treturn instance || this.defaultInstance\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn this.defaultInstance\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn new ContextualizedVariable(this, subject || defaultContext)\r\n\t\t\t},\r\n\t\t\tdistinctFor: function(subject) {\r\n\t\t\t\tif (typeof this === 'function') {\r\n\t\t\t\t\treturn this.for(subject)\r\n\t\t\t\t}\r\n\t\t\t\tvar map = this.contextMap || (this.contextMap = new WeakMap())\r\n\t\t\t\tif (map.has(subject)) {\r\n\t\t\t\t\treturn map.get(subject)\r\n\t\t\t\t}\r\n\t\t\t\tvar contextualizedVariable\r\n\t\t\t\tmap.set(subject, contextualizedVariable = new ContextualizedVariable(this, subject))\r\n\t\t\t\treturn contextualizedVariable\r\n\t\t\t},\r\n\t\t\t_propertyChange: function(propertyName, object, context, type) {\r\n\t\t\t\tif (this.onPropertyChange) {\r\n\t\t\t\t\tthis.onPropertyChange(propertyName, object, context)\r\n\t\t\t\t}\r\n\t\t\t\tthis.updated(new PropertyChangeEvent(propertyName, new RefreshEvent(), this), null, context)\r\n\t\t\t},\r\n\t\t\teachKey: function(callback) {\r\n\t\t\t\tfor (var i in this._properties) {\r\n\t\t\t\t\tcallback(i)\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tapply: function(instance, args) {\r\n\t\t\t\treturn new Call(this, args)\r\n\t\t\t},\r\n\t\t\tcall: function(instance) {\r\n\t\t\t\treturn this.apply(instance, Array.prototype.slice.call(arguments, 1))\r\n\t\t\t},\r\n\t\t\tforDependencies: function(callback) {\r\n\t\t\t\tif (this.notifyingValue) {\r\n\t\t\t\t\tcallback(this.notifyingValue)\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tinit: function() {\r\n\t\t\t\tif (this.subject) {\r\n\t\t\t\t\tthis.constructor.notifies(this)\r\n\t\t\t\t}\r\n\t\t\t\tvar variable = this\r\n\t\t\t\tthis.forDependencies(function(dependency) {\r\n\t\t\t\t\tdependency.notifies(variable)\r\n\t\t\t\t})\r\n\t\t\t\tif (this.listeningToObject === null) {\r\n\t\t\t\t\t// we were previously listening to an object, but it needs to be restored\r\n\t\t\t\t\t// calling valueOf will cause the listening object to be restored\r\n\t\t\t\t\tthis.valueOf()\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tcleanup: function() {\r\n\t\t\t\tvar handles = this.handles\r\n\t\t\t\tif (handles) {\r\n\t\t\t\t\tfor (var i = 0; i < handles.length; i++) {\r\n\t\t\t\t\t\thandles[i].remove()\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tthis.handles = null\r\n\t\t\t\tvar notifyingValue = this.notifyingValue\r\n\t\t\t\tif (notifyingValue) {\r\n\t\t\t\t\t// TODO: move this into the caching class\r\n\t\t\t\t\tthis.computedVariable = null\r\n\t\t\t\t}\r\n\t\t\t\tvar variable = this\r\n\t\t\t\tthis.forDependencies(function(dependency) {\r\n\t\t\t\t\tdependency.stopNotifies(variable)\r\n\t\t\t\t})\r\n\t\t\t\tif (this.context) {\r\n\t\t\t\t\tthis.constructor.stopNotifies(this)\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\r\n\t\t\tupdateVersion: function(version) {\r\n\t\t\t\tthis.version = nextId++\r\n\t\t\t},\r\n\t\r\n\t\t\tgetVersion: function(context) {\r\n\t\t\t\treturn Math.max(this.version || 0, this.notifyingValue && this.notifyingValue.getVersion ? this.notifyingValue.getVersion(context) : 0)\r\n\t\t\t},\r\n\t\r\n\t\t\tgetSubject: function(selectVariable) {\r\n\t\t\t\treturn this.subject\r\n\t\t\t},\r\n\t\r\n\t\t\tgetUpdates: function(since) {\r\n\t\t\t\tvar updates = []\r\n\t\t\t\tvar nextUpdateMap = this.nextUpdateMap\r\n\t\t\t\tif (nextUpdateMap && since) {\r\n\t\t\t\t\twhile ((since = nextUpdateMap.get(since))) {\r\n\t\t\t\t\t\tif (since.type === 'refresh') {\r\n\t\t\t\t\t\t\t// if it was refresh, we can clear any prior entries\r\n\t\t\t\t\t\t\tupdates = []\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tupdates.push(since)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn updates\r\n\t\t\t},\r\n\t\r\n\t\t\tupdated: function(updateEvent, by, context) {\r\n\t\t\t\tif (!updateEvent) {\r\n\t\t\t\t\tupdateEvent = new RefreshEvent()\r\n\t\t\t\t}\r\n\t\t\t\tif (updateEvent.visited.has(this)){\r\n\t\t\t\t\t// if this event has already visited this variable, skip it\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t\tupdateEvent.visited.add(this)\r\n\t\t\t\tif (this.subject) {\r\n\t\t\t\t\tif (by === this.constructor) {\r\n\t\t\t\t\t\t// if we receive an update from the constructor, filter it\r\n\t\t\t\t\t\tif (!(!context || (context.distinctSubject || context.subject) === this.subject || (context.subject.contains && this.subject.nodeType && context.subject.contains(this.subject)))) {\r\n\t\t\t\t\t\t\treturn\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// if we receive an outside update, send it to the constructor\r\n\t\t\t\t\t\treturn this.constructor.updated(updateEvent, this, new Context(this.subject))\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tvar contextualInstance = getMaterializedContextualInstance(this, context)\r\n\t\t\t\tif (contextualInstance) {\r\n\t\t\t\t\tcontextualInstance.updated(updateEvent, this, context)\r\n\t\t\t\t}\r\n\t\t\t\tif (this.lastUpdate) {\r\n\t\t\t\t\tvar nextUpdateMap = this.nextUpdateMap\r\n\t\t\t\t\tif (!nextUpdateMap) {\r\n\t\t\t\t\t\tnextUpdateMap = this.nextUpdateMap = new WeakMap()\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnextUpdateMap.set(this.lastUpdate, updateEvent)\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.lastUpdate = updateEvent\r\n\t\t\t\tthis.updateVersion()\r\n\t\t\t\tvar value = this.value\r\n\t\r\n\t\t\t\tvar dependents = this.dependents\r\n\t\t\t\tif (dependents) {\r\n\t\t\t\t\t// make a copy, in case they change\r\n\t\t\t\t\tdependents = dependents.slice(0)\r\n\t\t\t\t\tfor (var i = 0, l = dependents.length; i < l; i++) {\r\n\t\t\t\t\t\ttry{\r\n\t\t\t\t\t\t\tvar dependent = dependents[i]\r\n\t\t\t\t\t\t\tif ((updateEvent instanceof PropertyChangeEvent) &&\r\n\t\t\t\t\t\t\t\t\t(dependent instanceof Property)) {\r\n\t\t\t\t\t\t\t\tif (dependent.key === updateEvent.key) {\r\n\t\t\t\t\t\t\t\t\tdependent.updated(updateEvent.childEvent, this, context)\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tdependent.updated(updateEvent, this, context)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}catch(e) {\r\n\t\t\t\t\t\t\tconsole.error(e, e.stack, 'updating a variable')\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (updateEvent instanceof PropertyChangeEvent) {\r\n\t\t\t\t\tif (this.notifyingValue && this.fixed) {\r\n\t\t\t\t\t\tthis.notifyingValue.updated(updateEvent, this, context)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (this.collection) {\r\n\t\t\t\t\t\tthis.collection.updated(updateEvent, this, context)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn updateEvent\r\n\t\t\t},\r\n\t\r\n\t\t\tinvalidate: function() {\r\n\t\t\t\t// for back-compatibility for now\r\n\t\t\t\tthis.updated()\r\n\t\t\t},\r\n\t\r\n\t\t\tnotifies: function(target) {\r\n\t\t\t\tvar dependents = this.dependents\r\n\t\t\t\tif (!dependents || !this.hasOwnProperty('dependents')) {\r\n\t\t\t\t\tthis.dependents = dependents = []\r\n\t\t\t\t\tthis.init()\r\n\t\t\t\t}\r\n\t\t\t\tdependents.push(target)\r\n\t\t\t\tvar variable = this\r\n\t\t\t\treturn {\r\n\t\t\t\t\tunsubscribe: function() {\r\n\t\t\t\t\t\tvariable.stopNotifies(target)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tsubscribe: function(listener) {\r\n\t\t\t\t// ES7 Observable (and baconjs) compatible API\r\n\t\t\t\tvar updated\r\n\t\t\t\tvar updateQueued\r\n\t\t\t\tvar variable = this\r\n\t\t\t\t// it is important to make sure you register for notifications before getting the value\r\n\t\t\t\tif (typeof listener === 'function') {\r\n\t\t\t\t\t// BaconJS compatible API\r\n\t\t\t\t\tvar variable = this\r\n\t\t\t\t\tvar event = {\r\n\t\t\t\t\t\tvalue: function() {\r\n\t\t\t\t\t\t\treturn variable.valueOf()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tupdated = function() {\r\n\t\t\t\t\t\tupdateQueued = false\r\n\t\t\t\t\t\tlistener(event)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\telse if (listener.next) {\r\n\t\t\t\t\t// Assuming ES7 Observable API. It is actually a streaming API, this pretty much violates all principles of reactivity, but we will support it\r\n\t\t\t\t\tupdated = function() {\r\n\t\t\t\t\t\tupdateQueued = false\r\n\t\t\t\t\t\tlistener.next(variable.valueOf())\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow new Error('Subscribing to an invalid listener, the listener must be a function, or have an update or next method')\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar handle = this.notifies({\r\n\t\t\t\t\tupdated: function() {\r\n\t\t\t\t\t\tif (updateQueued) {\r\n\t\t\t\t\t\t\treturn\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tupdateQueued = true\r\n\t\t\t\t\t\tlang.nextTurn(updated)\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t\tvar initialValue = this.valueOf()\r\n\t\t\t\tif (initialValue !== undefined) {\r\n\t\t\t\t\tupdated()\r\n\t\t\t\t}\r\n\t\t\t\treturn handle\r\n\t\t\t},\r\n\t\t\tstopNotifies: function(dependent) {\r\n\t\t\t\tvar dependents = this.dependents\r\n\t\t\t\tif (dependents) {\r\n\t\t\t\t\tfor (var i = 0; i < dependents.length; i++) {\r\n\t\t\t\t\t\tif (dependents[i] === dependent) {\r\n\t\t\t\t\t\t\tdependents.splice(i--, 1)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (dependents.length === 0) {\r\n\t\t\t\t\t\t// clear the dependents so it will be reinitialized if it has\r\n\t\t\t\t\t\t// dependents again\r\n\t\t\t\t\t\tthis.dependents = dependents = false\r\n\t\t\t\t\t\tthis.cleanup()\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tput: function(value, context) {\r\n\t\t\t\tvar variable = this\r\n\t\t\t\tif (this.ownObject) {\r\n\t\t\t\t\tthis.ownObject = false\r\n\t\t\t\t}\t\t\t\r\n\t\t\t\treturn when(this.getValue(context), function(oldValue) {\r\n\t\t\t\t\tif (oldValue === value) {\r\n\t\t\t\t\t\treturn noChange\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (variable.fixed &&\r\n\t\t\t\t\t\t\t// if it is set to fixed, we see we can put in the current variable\r\n\t\t\t\t\t\t\toldValue && oldValue.put) {\r\n\t\t\t\t\t\treturn oldValue.put(value)\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn when(variable.setValue(value, context), function(value) {\r\n\t\t\t\t\t\tvariable.updated(new RefreshEvent(), variable, context)\r\n\t\t\t\t\t})\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tget: function(key) {\r\n\t\t\t\treturn when(this.valueOf(), function(object) {\r\n\t\t\t\t\tvar value = object && (typeof object.get === 'function' ? object.get(key) : object[key])\r\n\t\t\t\t\tif (value && value.notifies) {\r\n\t\t\t\t\t\t// nested variable situation, get underlying value\r\n\t\t\t\t\t\treturn value.valueOf()\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn value\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tset: function(key, value) {\r\n\t\t\t\t// TODO: create an optimized route when the property doesn't exist yet\r\n\t\t\t\tthis.property(key).put(value)\r\n\t\t\t},\r\n\t\t\tundefine: function(key, context) {\r\n\t\t\t\tthis.set(key, undefined, context)\r\n\t\t\t},\r\n\t\t\tproxy: function(proxiedVariable) {\r\n\t\t\t\tvar thisVariable = this\r\n\t\t\t\tthis.fixed = true\r\n\t\t\t\treturn when(this.setValue(proxiedVariable), function(value) {\r\n\t\t\t\t\tthisVariable.updated(new RefreshEvent(), thisVariable)\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tnext: function(value) {\r\n\t\t\t\t// for ES7 observable compatibility\r\n\t\t\t\tthis.put(value)\r\n\t\t\t},\r\n\t\t\terror: function(error) {\r\n\t\t\t\t// for ES7 observable compatibility\r\n\t\t\t\tvar dependents = this.dependents\r\n\t\t\t\tif (dependents) {\r\n\t\t\t\t\t// make a copy, in case they change\r\n\t\t\t\t\tdependents = dependents.slice(0)\r\n\t\t\t\t\tfor (var i = 0, l = dependents.length; i < l; i++) {\r\n\t\t\t\t\t\ttry{\r\n\t\t\t\t\t\t\tvar dependent = dependents[i]\r\n\t\t\t\t\t\t\t// skip notifying property dependents if we are headed up the parent chain\r\n\t\t\t\t\t\t\tdependent.error(error)\r\n\t\t\t\t\t\t}catch(e) {\r\n\t\t\t\t\t\t\tconsole.error(e, 'sending an error')\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tcomplete: function(value) {\r\n\t\t\t\t// for ES7 observable compatibility\r\n\t\t\t\tthis.put(value)\r\n\t\t\t},\r\n\t\t\tsetValue: function(value) {\r\n\t\t\t\tthis.value = value\r\n\t\t\t},\r\n\t\t\tonValue: function(listener) {\r\n\t\t\t\treturn this.subscribe(function(event) {\r\n\t\t\t\t\tlang.when(event.value(), function(value) {\r\n\t\t\t\t\t\tlistener(value)\r\n\t\t\t\t\t})\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tforEach: function(callbackOrItemClass, callbackOrContext, context) {\r\n\t\t\t\t// iterate through current value of variable\r\n\t\t\t\tif (callbackOrItemClass.notifies) {\r\n\t\t\t\t\tvar collectionVariable = this\r\n\t\t\t\t\tthis.forEach(function(item) {\r\n\t\t\t\t\t\tvar itemVariable = callbackOrItemClass.for(item)\r\n\t\t\t\t\t\titemVariable.collection = collectionVariable\r\n\t\t\t\t\t\tcallbackOrContext.call(this, itemVariable)\r\n\t\t\t\t\t}, context)\r\n\t\t\t\t}\r\n\t\t\t\treturn when(this.valueOf(callbackOrContext), function(value) {\r\n\t\t\t\t\tif (value && value.forEach) {\r\n\t\t\t\t\t\tvalue.forEach(callbackOrItemClass)\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tfor (var i in value) {\r\n\t\t\t\t\t\t\tcallbackOrItemClass.call(value, value[i], i)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\r\n\t\t\tto: function (transformFunction, reverse) {\r\n\t\t\t\tif (typeof transformFunction !== 'function') {\r\n\t\t\t\t\tif (typeof transformFunction === 'object') {\r\n\t\t\t\t\t\tthis.to(transformFunction.forward, transformFunction.reverse)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthrow new Error('No function provided to transform')\r\n\t\t\t\t}\r\n\t\t\t\tif (reverse) {\r\n\t\t\t\t\ttransformFunction.reverse = function(value, args, context) {\r\n\t\t\t\t\t\t// for direct to, we can just use the first argument\r\n\t\t\t\t\t\treverse.call(this, args[0], context)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn new Call(transformFunction, [this])\r\n\t\t\t},\r\n\t\t\tget schema() {\r\n\t\t\t\t// default schema is the constructor\r\n\t\t\t\treturn this.notifyingValue ? this.notifyingValue.schema : this.constructor\r\n\t\t\t},\r\n\t\t\tset schema(schema) {\r\n\t\t\t\t// but allow it to be overriden\r\n\t\t\t\tObject.defineProperty(this, 'schema', {\r\n\t\t\t\t\tvalue: schema\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tvalidate: function(target, schema) {\r\n\t\t\t\tif (this.notifyingValue) {\r\n\t\t\t\t\treturn this.notifyingValue.validate(target, schema)\r\n\t\t\t\t}\r\n\t\t\t\tif (schema.type && (schema.type !== typeof target)) {\r\n\t\t\t\t\treturn ['Target type of ' + typeof target + ' does not match schema type of ' + schema.type]\r\n\t\t\t\t}\r\n\t\t\t\tvar valid = []\r\n\t\t\t\tvalid.isValid = true\r\n\t\t\t\treturn valid\r\n\t\t\t},\r\n\t\r\n\t\t\tget validation() {\r\n\t\t\t\tvar validation = new Validating(this)\r\n\t\t\t\tObject.defineProperty(this, 'validation', {\r\n\t\t\t\t\tvalue: validation\r\n\t\t\t\t})\r\n\t\t\t\treturn validation\r\n\t\t\t},\r\n\t\t\tset validation(validation) {\r\n\t\t\t\t// but allow it to be overriden\r\n\t\t\t\tObject.defineProperty(this, 'validation', {\r\n\t\t\t\t\tvalue: validation\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tgetId: function() {\r\n\t\t\t\treturn this.id || (this.id = nextId++)\r\n\t\t\t},\r\n\t\t\tobserveObject: function() {\r\n\t\t\t\tvar variable = this\r\n\t\t\t\treturn when(this.valueOf(), function(object) {\r\n\t\t\t\t\tvar listeners = propertyListenersMap.get(object)\r\n\t\t\t\t\tif (!listeners) {\r\n\t\t\t\t\t\tpropertyListenersMap.set(object, listeners = [])\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (listeners.observerCount) {\r\n\t\t\t\t\t\tlisteners.observerCount++\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tlisteners.observerCount = 1\r\n\t\t\t\t\t\tvar observer = listeners.observer = lang.observe(object, function(events) {\r\n\t\t\t\t\t\t\tfor (var i = 0, l = listeners.length; i < l; i++) {\r\n\t\t\t\t\t\t\t\tvar listener = listeners[i]\r\n\t\t\t\t\t\t\t\tfor (var j = 0, el = events.length; j < el; j++) {\r\n\t\t\t\t\t\t\t\t\tvar event = events[j]\r\n\t\t\t\t\t\t\t\t\tlistener._propertyChange(event.name, object)\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t\tif (observer.addKey) {\r\n\t\t\t\t\t\t\tfor (var i = 0, l = listeners.length; i < l; i++) {\r\n\t\t\t\t\t\t\t\tvar listener = listeners[i]\r\n\t\t\t\t\t\t\t\tlistener.eachKey(function(key) {\r\n\t\t\t\t\t\t\t\t\tobserver.addKey(key)\r\n\t\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tregisterListener(object, variable)\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tremove: function() {\r\n\t\t\t\t\t\t\tderegisterListener(object, variable)\r\n\t\t\t\t\t\t\tif (!(--listeners.observerCount)) {\r\n\t\t\t\t\t\t\t\tlisteners.observer.remove()\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tdone: function() {\r\n\t\t\t\t\t\t\t// deliver changes\r\n\t\t\t\t\t\t\tlang.deliverChanges(observer)\r\n\t\t\t\t\t\t\tthis.remove()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\t_willModify: function(context) {\r\n\t\t\t\t// an intent to modify, so we need to make sure we have our own copy\r\n\t\t\t\t// of an object when necessary\r\n\t\t\t\tif (this.fixed) {\r\n\t\t\t\t\tif (this.value && this.value._willModify) {\r\n\t\t\t\t\t\treturn this.value._willModify(context)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (!this.ownObject && this.value && this.value.notifies) {\r\n\t\t\t\t\tvar variable = this\r\n\t\t\t\t\treturn when(this.valueOf(context), function(value) {\r\n\t\t\t\t\t\tif (value && typeof value === 'object') {\r\n\t\t\t\t\t\t\tif (value instanceof Array) {\r\n\t\t\t\t\t\t\t\tvariable.ownObject = value.slice(0)\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tvariable.ownObject = Object.create(value)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tsplice: function(startingIndex, removalCount) {\r\n\t\t\t\tvar args = arguments\r\n\t\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\t\tvar results = array.splice.apply(array, args)\r\n\t\t\t\t\tremovedAt(this, results, startingIndex, removalCount, array.length)\r\n\t\t\t\t\tinsertedAt(this, [].slice.call(args, 2), startingIndex, array.length)\r\n\t\t\t\t\treturn results\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tpush: function() {\r\n\t\t\t\tvar args = arguments\r\n\t\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\t\tvar results = array.push.apply(array, args)\r\n\t\t\t\t\tinsertedAt(this, args, array.length - args.length, array.length)\r\n\t\t\t\t\treturn results\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tunshift: function() {\r\n\t\t\t\tvar args = arguments\r\n\t\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\t\tvar results = array.unshift.apply(array, args)\r\n\t\t\t\t\tinsertedAt(this, args, 0, array.length)\r\n\t\t\t\t\treturn results\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tpop: function() {\r\n\t\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\t\tvar results = array.pop()\r\n\t\t\t\t\tremovedAt(this, [results], array.length, 1)\r\n\t\t\t\t\treturn results\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tshift: function() {\r\n\t\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\t\tvar results = array.shift()\r\n\t\t\t\t\tremovedAt(this, [results], 0, 1, array.length)\r\n\t\t\t\t\treturn results\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction arrayToModify(variable, callback) {\r\n\t\t\tvariable._willModify()\r\n\t\t\t// TODO: switch this to allow promises\r\n\t\t\twhen(variable.cachedValue || variable.valueOf(), function(array) {\r\n\t\t\t\tif (!array) {\r\n\t\t\t\t\tvariable.put(array = [])\r\n\t\t\t\t}\r\n\t\t\t\tvariable.updateVersion()\r\n\t\t\t\tvar results = callback.call(variable, array)\r\n\t\t\t\tvariable.cachedVersion = variable.version // update the cached version so it doesn't need to be recomputed\r\n\t\t\t\treturn results\r\n\t\t\t})\r\n\t\t}\r\n\t\r\n\t\tfunction insertedAt(variable, added, startingIndex, arrayLength) {\r\n\t\t\tvar addedCount = added.length\r\n\t\t\t// adjust the key positions of any index properties after splice\r\n\t\t\tif (addedCount > 0) {\r\n\t\t\t\tif (variable._properties) {\r\n\t\t\t\t\tvar arrayPosition\r\n\t\t\t\t\tfor (var i = arrayLength - addedCount; i > startingIndex;) {\r\n\t\t\t\t\t\tvar arrayPosition = variable._properties[--i]\r\n\t\t\t\t\t\tif (arrayPosition) {\r\n\t\t\t\t\t\t\tvariable._properties[i] = undefined\r\n\t\t\t\t\t\t\tarrayPosition.key += addedCount\r\n\t\t\t\t\t\t\tvariable._properties[arrayPosition.key] = arrayPosition\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// send out updates\r\n\t\t\t\tfor (var i = 0, l = added.length; i < l; i++) {\r\n\t\t\t\t\tvariable.updated(new AddEvent({\r\n\t\t\t\t\t\tvalue: added[i],\r\n\t\t\t\t\t\tindex: i + startingIndex,\r\n\t\t\t\t\t\tmodifier: variable\r\n\t\t\t\t\t}), variable)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction removedAt(variable, removed, startingIndex, removalCount, arrayLength) {\r\n\t\t\t// adjust the properties\r\n\t\t\tvar i = startingIndex + removalCount\r\n\t\t\tvar arrayPosition\r\n\t\t\tif (removalCount > 0) {\r\n\t\t\t\tif (variable._properties) {\r\n\t\t\t\t\tfor (var i = startingIndex + removalCount; i < arrayLength + removalCount; i++) {\r\n\t\t\t\t\t\tvar arrayPosition = variable._properties[i]\r\n\t\t\t\t\t\tif (arrayPosition) {\r\n\t\t\t\t\t\t\tvariable._properties[i] = undefined\r\n\t\t\t\t\t\t\tarrayPosition.key -= removalCount\r\n\t\t\t\t\t\t\tvariable._properties[arrayPosition.key] = arrayPosition\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// send out updates\r\n\t\t\t\tfor (var i = 0; i < removalCount; i++) {\r\n\t\t\t\t\tvariable.updated(new DeleteEvent({\r\n\t\t\t\t\t\tpreviousIndex: startingIndex,\r\n\t\t\t\t\t\toldValue: removed[i],\r\n\t\t\t\t\t\tmodifier: variable\r\n\t\t\t\t\t}), variable)\r\n\t\t\t\t}\r\n\t\t\t\tvariable.cachedVersion = variable.version // update the cached version so it doesn't need to be recomputed\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tif (typeof Symbol !== 'undefined') {\r\n\t\t\tVariable.prototype[Symbol.iterator] = function() {\r\n\t\t\t\treturn this.valueOf()[Symbol.iterator]()\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tVariable.VMap = lang.compose(Variable, function(value){\r\n\t\t\tthis.value = typeof value === 'undefined' ? this.default : value\r\n\t\t}, {\r\n\t\t\t// TODO: Move all the get and set functionality for maps out of Variable\r\n\t\t\tproperty: function(key) {\r\n\t\t\t\tvar properties = this._properties || (this._properties = new Map())\r\n\t\t\t\tvar propertyVariable = properties.get(key)\r\n\t\t\t\tif (!propertyVariable) {\r\n\t\t\t\t\t// create the property variable\r\n\t\t\t\t\tpropertyVariable = new Property(this, key)\r\n\t\t\t\t\tproperties.set(key, propertyVariable)\r\n\t\t\t\t}\r\n\t\t\t\treturn propertyVariable\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\tvar cacheNotFound = {}\r\n\t\tvar Caching = Variable.Caching = lang.compose(Variable, function(getValue, setValue) {\r\n\t\t\tif (getValue) {\r\n\t\t\t\tthis.getValue = getValue\r\n\t\t\t}\r\n\t\t\tif (setValue) {\r\n\t\t\t\tthis.setValue = setValue\r\n\t\t\t}\r\n\t\t}, {\r\n\t\t\tvalueOf: function(context) {\r\n\t\t\t\t// first check to see if we have the variable already computed\r\n\t\t\t\tif (this.cachedVersion === this.getVersion()) {\r\n\t\t\t\t\tif (this.contextMap) {\r\n\t\t\t\t\t\tvar contextualizedVariable = getMaterializedContextualInstance(this, context)\r\n\t\t\t\t\t\tif (contextualizedVariable) {\r\n\t\t\t\t\t\t\treturn contextualizedVariable.cachedValue\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn this.cachedValue\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tvar variable = this\r\n\t\r\n\t\t\t\tfunction withComputedValue(computedValue) {\r\n\t\t\t\t\tif (computedValue && computedValue.notifies && variable.dependents) {\r\n\t\t\t\t\t\tvariable.computedVariable = computedValue\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcomputedValue = variable.gotValue(computedValue, watchedContext)\r\n\t\t\t\t\tvar contextualizedVariable\r\n\t\t\t\t\tif (watchedContext && watchedContext.distinctSubject) {\r\n\t\t\t\t\t\t(variable.contextMap || (variable.contextMap = new WeakMap()))\r\n\t\t\t\t\t\t\t.set(watchedContext.distinctSubject,\r\n\t\t\t\t\t\t\t\tcontextualizedVariable = new ContextualizedVariable(variable, watchedContext.distinctSubject))\r\n\t\t\t\t\t\tcontext.distinctSubject = mergeSubject(context.distinctSubject, watchedContext.distinctSubject)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tcontextualizedVariable = variable\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcontextualizedVariable.cachedVersion = newVersion\r\n\t\t\t\t\tcontextualizedVariable.cachedValue = computedValue\r\n\t\t\t\t\treturn computedValue\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar watchedContext\r\n\t\t\t\tif (context) {\r\n\t\t\t\t\twatchedContext = new Context(context.subject)\r\n\t\t\t\t}\r\n\t\t\t\tvar newVersion = this.getVersion()\r\n\t\t\t\tvar computedValue = this.getValue(watchedContext)\r\n\t\t\t\tif (computedValue && computedValue.then) {\r\n\t\t\t\t\treturn computedValue.then(withComputedValue)\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn withComputedValue(computedValue)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\tfunction GetCache() {\r\n\t\t}\r\n\t\r\n\t\tvar Property = lang.compose(Variable, function Property(parent, key) {\r\n\t\t\tthis.parent = parent\r\n\t\t\tthis.key = key\r\n\t\t},\r\n\t\t{\r\n\t\t\tforDependencies: function(callback) {\r\n\t\t\t\tVariable.prototype.forDependencies.call(this, callback)\r\n\t\t\t\tcallback(this.parent)\r\n\t\t\t},\r\n\t\t\tvalueOf: function(context) {\r\n\t\t\t\tvar key = this.key\r\n\t\t\t\tvar property = this\r\n\t\t\t\tvar object = this.parent.valueOf(context)\r\n\t\t\t\tfunction gotValueAndListen(object) {\r\n\t\t\t\t\tif (property.dependents) {\r\n\t\t\t\t\t\tvar listeners = propertyListenersMap.get(object)\r\n\t\t\t\t\t\tif (listeners && listeners.observer && listeners.observer.addKey) {\r\n\t\t\t\t\t\t\tlisteners.observer.addKey(key)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar value = property.gotValue(object == null ? undefined : typeof object.get === 'function' ? object.get(key) : object[key])\r\n\t\t\t\t\treturn value\r\n\t\t\t\t}\r\n\t\t\t\tif (object && object.then) {\r\n\t\t\t\t\treturn when(object, gotValueAndListen)\r\n\t\t\t\t}\r\n\t\t\t\treturn gotValueAndListen(object)\r\n\t\t\t},\r\n\t\t\tput: function(value, context) {\r\n\t\t\t\treturn this._changeValue(context, RequestChange, value)\r\n\t\t\t},\r\n\t\t\tparentUpdated: function(updateEvent, context) {\r\n\t\t\t\treturn Variable.prototype.updated.call(this, updateEvent, this.parent, context)\r\n\t\t\t},\r\n\t\t\tupdated: function(updateEvent, by, context) {\r\n\t\t\t\tif (updateEvent = Variable.prototype.updated.call(this, updateEvent, by, context)) {\r\n\t\t\t\t\tthis.parent.updated(new PropertyChangeEvent(this.key, updateEvent, this.parent), this, context)\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\t_changeValue: function(context, type, newValue) {\r\n\t\t\t\tvar key = this.key\r\n\t\t\t\tvar parent = this.parent\r\n\t\t\t\tvar variable = this\r\n\t\t\t\tparent._willModify(context)\r\n\t\t\t\treturn when(parent.valueOf(context), function(object) {\r\n\t\t\t\t\tif (object == null) {\r\n\t\t\t\t\t\t// nothing there yet, create an object to hold the new property\r\n\t\t\t\t\t\tvar response = parent.put(object = typeof key == 'number' ? [] : {}, context)\r\n\t\t\t\t\t}else if (typeof object != 'object') {\r\n\t\t\t\t\t\t// if the parent is not an object, we can't set anything (that will be retained)\r\n\t\t\t\t\t\treturn deny\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (type == RequestChange) {\r\n\t\t\t\t\t\tvar oldValue = typeof object.get === 'function' ? object.get(key) : object[key]\r\n\t\t\t\t\t\tif (oldValue === newValue) {\r\n\t\t\t\t\t\t\t// no actual change to make\r\n\t\t\t\t\t\t\treturn noChange\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (typeof object.set === 'function') {\r\n\t\t\t\t\t\t\tobject.set(key, newValue)\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tobject[key] = newValue\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvariable.updated(null, variable, context)\r\n\t\r\n\t\t\t\t\t// now notify any object listeners\r\n\t\t\t\t\tvar listeners = propertyListenersMap.get(object)\r\n\t\t\t\t\t// we need to do it before the other listeners, so we can update it before\r\n\t\t\t\t\t// we trigger a full clobbering of the object\r\n\t\t\t\t\tif (listeners) {\r\n\t\t\t\t\t\tlisteners = listeners.slice(0)\r\n\t\t\t\t\t\tfor (var i = 0, l = listeners.length; i < l; i++) {\r\n\t\t\t\t\t\t\tvar listener = listeners[i]\r\n\t\t\t\t\t\t\tif (listener !== parent) {\r\n\t\t\t\t\t\t\t\t// now go ahead and actually trigger the other listeners (but make sure we don't do the parent again)\r\n\t\t\t\t\t\t\t\tlistener._propertyChange(key, object, context, type)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\t_willModify: function() {\r\n\t\t\t\tthis.parent._willModify()\r\n\t\t\t\treturn Variable.prototype._willModify.call(this)\r\n\t\t\t},\r\n\t\t\tvalidate: function(target, schema) {\r\n\t\t\t\treturn this.parent.validate(target.valueOf(), schema)\r\n\t\t\t}\r\n\t\t})\r\n\t\tObject.defineProperty(Property.prototype, 'schema', {\r\n\t\t\tget: function() {\r\n\t\t\t\tvar parentSchemaProperties = this.parent.schema.properties\r\n\t\t\t\treturn parentSchemaProperties && parentSchemaProperties[this.key]\r\n\t\t\t},\r\n\t\t\tset: function(schema) {\r\n\t\t\t\t// have to repeat the override\r\n\t\t\t\tObject.defineProperty(this, 'schema', {\r\n\t\t\t\t\tvalue: schema\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t})\r\n\t\tVariable.Property = Property\r\n\t\r\n\t\tvar Item = Variable.Item = lang.compose(Variable, function Item(value, content) {\r\n\t\t\tthis.value = value\r\n\t\t\tthis.collection = content\r\n\t\t}, {})\r\n\t\r\n\t\tvar Composite = Variable.Composite = lang.compose(Caching, function Composite(args) {\r\n\t\t\tthis.args = args\r\n\t\t}, {\r\n\t\t\tforDependencies: function(callback) {\r\n\t\t\t\t// depend on the args\r\n\t\t\t\tCaching.prototype.forDependencies.call(this, callback)\r\n\t\t\t\tvar args = this.args\r\n\t\t\t\tfor (var i = 0, l = args.length; i < l; i++) {\r\n\t\t\t\t\tvar arg = args[i]\r\n\t\t\t\t\tif (arg && arg.notifies) {\r\n\t\t\t\t\t\tcallback(arg)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\r\n\t\t\tupdated: function(updateEvent, by, context) {\r\n\t\t\t\tvar args = this.args\r\n\t\t\t\tif (by !== this.notifyingValue && updateEvent && updateEvent.type !== 'refresh') {\r\n\t\t\t\t\t// using a painful search instead of indexOf, because args may be an arguments object\r\n\t\t\t\t\tfor (var i = 0, l = args.length; i < l; i++) {\r\n\t\t\t\t\t\tvar arg = args[i]\r\n\t\t\t\t\t\tif (arg === by) {\r\n\t\t\t\t\t\t\t// if one of the args was updated, we need to do a full refresh (we can't compute differential events without knowledge of how the mapping function works)\r\n\t\t\t\t\t\t\tupdateEvent = new RefreshEvent()\r\n\t\t\t\t\t\t\tcontinue\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn Caching.prototype.updated.call(this, updateEvent, by, context)\r\n\t\t\t},\r\n\t\r\n\t\t\tgetUpdates: function(since) {\r\n\t\t\t\t// this always issues updates, nothing incremental can flow through it\r\n\t\t\t\tif (!since || since.version < getVersion()) {\r\n\t\t\t\t\treturn [new RefreshEvent()]\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\r\n\t\t\tgetVersion: function(context) {\r\n\t\t\t\tvar args = this.args\r\n\t\t\t\tvar version = Variable.prototype.getVersion.call(this, context)\r\n\t\t\t\tfor (var i = 0, l = args.length; i < l; i++) {\r\n\t\t\t\t\tvar arg = args[i]\r\n\t\t\t\t\tif (arg && arg.getVersion) {\r\n\t\t\t\t\t\tversion = Math.max(version, arg.getVersion(context))\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn version\r\n\t\t\t},\r\n\t\r\n\t\t\tgetValue: function(context) {\r\n\t\t\t\tvar results = []\r\n\t\t\t\tvar args = this.args\r\n\t\t\t\tfor (var i = 0, l = args.length; i < l; i++) {\r\n\t\t\t\t\tvar arg = args[i]\r\n\t\t\t\t\tresults[i] = arg && arg.valueOf(context)\r\n\t\t\t\t}\r\n\t\t\t\treturn whenAll(results, function(resolved) {\r\n\t\t\t\t\treturn resolved\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\t// a call variable is the result of a call\r\n\t\tvar Call = lang.compose(Composite, function Call(functionVariable, args) {\r\n\t\t\tthis.functionVariable = functionVariable\r\n\t\t\tthis.args = args\r\n\t\t}, {\r\n\t\t\tfixed: true,\r\n\t\t\tforDependencies: function(callback) {\r\n\t\t\t\t// depend on the args\r\n\t\t\t\tComposite.prototype.forDependencies.call(this, callback)\r\n\t\t\t\tif (this.functionVariable.notifies) {\r\n\t\t\t\t\tcallback(this.functionVariable)\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\r\n\t\t\tgetValue: function(context) {\r\n\t\t\t\tvar functionValue = this.functionVariable.valueOf(context)\r\n\t\t\t\tif (functionValue.then) {\r\n\t\t\t\t\tvar call = this\r\n\t\t\t\t\treturn functionValue.then(function(functionValue) {\r\n\t\t\t\t\t\treturn call.invoke(functionValue, call.args, context)\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t\treturn this.invoke(functionValue, this.args, context)\r\n\t\t\t},\r\n\t\r\n\t\t\tgetVersion: function(context) {\r\n\t\t\t\t// TODO: shortcut if we are live and since equals this.lastUpdate\r\n\t\t\t\tvar argsVersion = Composite.prototype.getVersion.call(this, context)\r\n\t\t\t\tif (this.functionVariable.getVersion) {\r\n\t\t\t\t\treturn Math.max(argsVersion, this.functionVariable.getVersion(context))\r\n\t\t\t\t}\r\n\t\t\t\treturn argsVersion\r\n\t\t\t},\r\n\t\r\n\t\t\texecute: function(context) {\r\n\t\t\t\tvar call = this\r\n\t\t\t\treturn when(this.functionVariable.valueOf(context), function(functionValue) {\r\n\t\t\t\t\treturn call.invoke(functionValue, call.args, context, true)\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\r\n\t\t\tput: function(value, context) {\r\n\t\t\t\tvar call = this\r\n\t\t\t\treturn when(this.valueOf(context), function(originalValue) {\r\n\t\t\t\t\tif (originalValue === value) {\r\n\t\t\t\t\t\treturn noChange\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn when(call.functionVariable.valueOf(context), function(functionValue) {\r\n\t\t\t\t\t\treturn call.invoke(function() {\r\n\t\t\t\t\t\t\tif (functionValue.reverse) {\r\n\t\t\t\t\t\t\t\tfunctionValue.reverse.call(call, value, call.args, context)\r\n\t\t\t\t\t\t\t\treturn Variable.prototype.put.call(call, value, context)\r\n\t\t\t\t\t\t\t} else if (originalValue && originalValue.put) {\r\n\t\t\t\t\t\t\t\treturn originalValue.put(value)\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\treturn deny\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}, call.args, context)\r\n\t\t\t\t\t});\t\t\t\t\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tinvoke: function(functionValue, args, context, observeArguments) {\r\n\t\t\t\tvar instance = this.functionVariable.parent\r\n\t\t\t\tif (functionValue.handlesContext) {\r\n\t\t\t\t\treturn functionValue.apply(instance, args, context)\r\n\t\t\t\t}else{\r\n\t\t\t\t\tvar results = []\r\n\t\t\t\t\tfor (var i = 0, l = args.length; i < l; i++) {\r\n\t\t\t\t\t\tvar arg = args[i]\r\n\t\t\t\t\t\tresults[i] = arg && arg.valueOf(context)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tinstance = instance && instance.valueOf(context)\r\n\t\t\t\t\tif (functionValue.handlesPromises) {\r\n\t\t\t\t\t\treturn functionValue.apply(instance, results, context)\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\t// include the instance in whenAll\r\n\t\t\t\t\t\tresults.push(instance)\r\n\t\t\t\t\t\t// wait for the values to be received\r\n\t\t\t\t\t\treturn whenAll(results, function(inputs) {\r\n\t\t\t\t\t\t\tif (observeArguments) {\r\n\t\t\t\t\t\t\t\tvar handles = []\r\n\t\t\t\t\t\t\t\tfor (var i = 0, l = inputs.length; i < l; i++) {\r\n\t\t\t\t\t\t\t\t\tvar input = inputs[i]\r\n\t\t\t\t\t\t\t\t\tif (input && typeof input === 'object') {\r\n\t\t\t\t\t\t\t\t\t\thandles.push(observe(input))\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tvar instance = inputs.pop()\r\n\t\t\t\t\t\t\t\ttry{\r\n\t\t\t\t\t\t\t\t\tvar result = functionValue.apply(instance, inputs, context)\r\n\t\t\t\t\t\t\t\t}finally{\r\n\t\t\t\t\t\t\t\t\twhen(result, function() {\r\n\t\t\t\t\t\t\t\t\t\tfor (var i = 0; i < l; i++) {\r\n\t\t\t\t\t\t\t\t\t\t\thandles[i].done()\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\treturn result\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tvar instance = inputs.pop()\r\n\t\t\t\t\t\t\treturn functionValue.apply(instance, inputs, context)\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tsetReverse: function(reverse) {\r\n\t\t\t\tthis.functionVariable.valueOf().reverse = reverse\r\n\t\t\t\treturn this\r\n\t\t\t}\r\n\t\t})\r\n\t\tVariable.Call = Call\r\n\t\r\n\t\tvar ContextualizedVariable = lang.compose(Variable, function ContextualizedVariable(Source, subject) {\r\n\t\t\tthis.constructor = Source\r\n\t\t\tthis.subject = subject\r\n\t\t}, {\r\n\t\t\tvalueOf: function() {\r\n\t\t\t\treturn this.constructor.valueOf(new Context(this.subject))\r\n\t\t\t},\r\n\t\r\n\t\t\tput: function(value) {\r\n\t\t\t\treturn this.constructor.put(value, new Context(this.subject))\r\n\t\t\t},\r\n\t\t\tparentUpdated: function(event, context) {\r\n\t\t\t\t// if we receive an outside update, send it to the constructor\r\n\t\t\t\tthis.constructor.updated(event, this.parent, this.context)\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\r\n\t\tfunction iterateMethod(method) {\r\n\t\t\tVariable.prototype[method] = function() {\r\n\t\t\t\treturn new IterativeMethod(this, method, arguments)\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\titerateMethod('filter')\r\n\t\titerateMethod('map')\r\n\t\titerateMethod('reduce')\r\n\t\titerateMethod('reduceRight')\r\n\t\titerateMethod('some')\r\n\t\titerateMethod('every')\r\n\t\titerateMethod('slice')\r\n\t\t\r\n\t\tvar IterativeMethod = lang.compose(Composite, function(source, method, args) {\r\n\t\t\tthis.source = source\r\n\t\t\t// source.interestWithin = true\r\n\t\t\tthis.method = method\r\n\t\t\tthis.args = args\r\n\t\t}, {\r\n\t\t\tgetValue: function(context) {\r\n\t\t\t\tvar method = this.method\r\n\t\t\t\tvar args = this.args\r\n\t\t\t\tvar variable = this\r\n\t\t\t\treturn when(this.source.valueOf(context), function(array) {\r\n\t\t\t\t\tif (array && array.forEach) {\r\n\t\t\t\t\t\tif (variable.dependents) {\r\n\t\t\t\t\t\t\tvar contextualizedVariable\r\n\t\t\t\t\t\t\tif (context) {\r\n\t\t\t\t\t\t\t\tvar contextMap = variable.contextMap || (variable.contextMap = new WeakMap())\r\n\t\t\t\t\t\t\t\tif (contextMap.has(context.distinctSubject)) {\r\n\t\t\t\t\t\t\t\t\tcontextualizedVariable = contextMap.get(context.distinctSubject)\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tcontextMap.set(context.distinctSubject, contextualizedVariable = new ContextualizedVariable(variable, context.distinctSubject))\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tcontextualizedVariable = variable\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (method === 'map'){\r\n\t\t\t\t\t\t\t// fast path, and special behavior for map\r\n\t\t\t\t\t\t\treturn args[0](array)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// if not an array convert to an array\r\n\t\t\t\t\t\tarray = [array]\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// apply method\r\n\t\t\t\t\treturn array[method].apply(array, args)\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tupdated: function(event, by, context) {\r\n\t\t\t\tif (!event || event.modifier === this || (event.modifier && event.modifier.constructor === this)) {\r\n\t\t\t\t\treturn Composite.prototype.updated.call(this, event, by, context)\r\n\t\t\t\t}\r\n\t\t\t\tvar propagatedEvent = event.type === 'refresh' ? event : // always propagate refreshes\r\n\t\t\t\t\tthis[this.method + 'Updated'] ? this[this.method + 'Updated'](event, context) : // if we have an updated handler, use it\r\n\t\t\t\t\tnew RefreshEvent() // else recompute the array method\r\n\t\t\t\t// TODO: make sure we normalize the event structure\r\n\t\t\t\tif (propagatedEvent) {\r\n\t\t\t\t\tComposite.prototype.updated.call(this, propagatedEvent, by, context)\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tfilterUpdated: function(event, context) {\r\n\t\t\t\tvar contextualizedVariable = getMaterializedContextualInstance(this, context) || this\r\n\t\t\t\tif (event.type === 'delete') {\r\n\t\t\t\t\tvar index = contextualizedVariable.cachedValue.indexOf(event.oldValue)\r\n\t\t\t\t\tif (index > -1) {\r\n\t\t\t\t\t\tcontextualizedVariable.splice(index, 1)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (event.type === 'add') {\r\n\t\t\t\t\tif ([event.value].filter(this.args[0]).length > 0) {\r\n\t\t\t\t\t\tcontextualizedVariable.push(event.value)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (event.type === 'update') {\r\n\t\t\t\t\tvar object = event.parent.valueOf(context)\r\n\t\t\t\t\tvar index = contextualizedVariable.cachedValue.indexOf(object)\r\n\t\t\t\t\tvar matches = [object].filter(this.args[0]).length > 0\r\n\t\t\t\t\tif (index > -1) {\r\n\t\t\t\t\t\tif (matches) {\r\n\t\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\t\ttype: 'updated',\r\n\t\t\t\t\t\t\t\tobject: object,\r\n\t\t\t\t\t\t\t\tindex: index\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tcontextualizedVariable.splice(index, 1)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\telse {\r\n\t\t\t\t\t\tif (matches) {\r\n\t\t\t\t\t\t\tcontextualizedVariable.push(object)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// else nothing mactches\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn event\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tmapUpdated: function(event, context) {\r\n\t\t\t\tvar contextualizedVariable = getMaterializedContextualInstance(this, context) || this\r\n\t\t\t\tif (event.type === 'delete') {\r\n\t\t\t\t\tcontextualizedVariable.splice(event.previousIndex, 1)\r\n\t\t\t\t} else if (event.type === 'add') {\r\n\t\t\t\t\tcontextualizedVariable.push(this.args[0].call(this.args[1], event.value))\r\n\t\t\t\t} else if (event.type === 'update') {\r\n\t\t\t\t\tvar object = event.parent.valueOf(context)\r\n\t\t\t\t\tvar array = contextualizedVariable.cachedValue\r\n\t\t\t\t\tif (array && array.map) {\r\n\t\t\t\t\t\tvar index = array.indexOf(object)\r\n\t\t\t\t\t\tvar matches = [object].filter(this.args[0]).length > 0\r\n\t\t\t\t\t\tcontextualizedVariable.splice(index, 1, this.args[0].call(this.args[1], event.value))\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn event\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn event\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\t// TODO: Create specialized updated handlers for faster recomputation of other array derivatives\r\n\t\t\tforDependencies: function(callback) {\r\n\t\t\t\t// depend on the args\r\n\t\t\t\tComposite.prototype.forDependencies.call(this, callback)\r\n\t\t\t\tcallback(this.source)\r\n\t\t\t},\r\n\t\t\tgetVersion: function(context) {\r\n\t\t\t\treturn Math.max(Composite.prototype.getVersion.call(this, context), this.source.getVersion(context))\r\n\t\t\t}\t\t\r\n\t\t})\r\n\t\r\n\t\r\n\t\tvar getValue\r\n\t\tvar GeneratorVariable = Variable.GeneratorVariable = lang.compose(Variable.Composite, function ReactiveGenerator(generator){\r\n\t\t\tthis.generator = generator\r\n\t\t\tthis.args = []\r\n\t\t}, {\r\n\t\t\tgetValue: getValue = function(context, resuming) {\r\n\t\t\t\tvar lastValue\r\n\t\t\t\tvar i\r\n\t\t\t\tvar generatorIterator\r\n\t\t\t\tvar isThrowing\r\n\t\t\t\tif (resuming) {\r\n\t\t\t\t\t// resuming from a promise\r\n\t\t\t\t\tgeneratorIterator = resuming.iterator\r\n\t\t\t\t\ti = resuming.i\r\n\t\t\t\t\tlastValue = resuming.value\r\n\t\t\t\t\tisThrowing = resuming.isThrowing\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// a fresh start\r\n\t\t\t\t\ti = 0\r\n\t\t\t\t\tgeneratorIterator = this.generator()\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tvar args = this.args\r\n\t\t\t\tdo {\r\n\t\t\t\t\tvar stepReturn = generatorIterator[isThrowing ? 'throw' : 'next'](lastValue)\r\n\t\t\t\t\tif (stepReturn.done) {\r\n\t\t\t\t\t\treturn stepReturn.value\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar nextVariable = stepReturn.value\r\n\t\t\t\t\t// compare with the arguments from the last\r\n\t\t\t\t\t// execution to see if they are the same\r\n\t\t\t\t\tif (args[i] !== nextVariable) {\r\n\t\t\t\t\t\tif (args[i]) {\r\n\t\t\t\t\t\t\targs[i].stopNotifies(this)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// subscribe if it is a variable\r\n\t\t\t\t\t\tif (nextVariable && nextVariable.notifies) {\r\n\t\t\t\t\t\t\tnextVariable.notifies(this)\r\n\t\t\t\t\t\t\tthis.args[i] = nextVariable\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthis.args[i] = null\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\ti++\r\n\t\t\t\t\tlastValue = nextVariable && nextVariable.valueOf(context)\r\n\t\t\t\t\tif (lastValue && lastValue.then) {\r\n\t\t\t\t\t\t// if it is a promise, we will wait on it\r\n\t\t\t\t\t\tvar variable = this\r\n\t\t\t\t\t\t// and return the promise so that the getValue caller can wait on this\r\n\t\t\t\t\t\treturn lastValue.then(function(value) {\r\n\t\t\t\t\t\t\treturn getValue.call(variable, context, {\r\n\t\t\t\t\t\t\t\ti: i,\r\n\t\t\t\t\t\t\t\titerator: generatorIterator,\r\n\t\t\t\t\t\t\t\tvalue: value\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t}, function(error) {\r\n\t\t\t\t\t\t\treturn getValue.call(variable, context, {\r\n\t\t\t\t\t\t\t\ti: i,\r\n\t\t\t\t\t\t\t\titerator: generatorIterator,\r\n\t\t\t\t\t\t\t\tvalue: error,\r\n\t\t\t\t\t\t\t\tisThrowing: true\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}\r\n\t\t\t\t} while(true)\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\tvar Validating = lang.compose(Caching, function(target) {\r\n\t\t\tthis.target = target\r\n\t\t}, {\r\n\t\t\tforDependencies: function(callback) {\r\n\t\t\t\tCaching.prototype.forDependencies.call(this, callback)\r\n\t\t\t\tcallback(this.target)\r\n\t\t\t},\r\n\t\t\tgetVersion: function(context) {\r\n\t\t\t\treturn Math.max(Variable.prototype.getVersion.call(this, context), this.target.getVersion(context))\r\n\t\t\t},\r\n\t\t\tgetValue: function(context) {\r\n\t\t\t\tvar target = this.target\r\n\t\t\t\treturn target.validate(target, target.schema)\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\tfunction validate(target) {\r\n\t\t\tvar schemaForObject = schema(target)\r\n\t\t\treturn new Validating(target, schemaForObject)\r\n\t\t}\r\n\t\tVariable.VArray = Variable\r\n\t\tVariable.deny = deny\r\n\t\tVariable.noChange = noChange\r\n\t\tfunction addFlag(name) {\r\n\t\t\tVariable[name] = function(functionValue) {\r\n\t\t\t\tfunctionValue[name] = true\r\n\t\t\t}\r\n\t\t}\r\n\t\taddFlag(Variable, 'handlesContext')\r\n\t\taddFlag(Variable, 'handlesPromises')\r\n\t\r\n\t\tfunction objectUpdated(object) {\r\n\t\t\t// simply notifies any subscribers to an object, that it has changed\r\n\t\t\tvar listeners = propertyListenersMap.get(object)\r\n\t\t\tif (listeners) {\r\n\t\t\t\tfor (var i = 0, l = listeners.length; i < l; i++) {\r\n\t\t\t\t\tlisteners[i]._propertyChange(null, object)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction all(array) {\r\n\t\t\t// This is intended to mirror Promise.all. It actually takes\r\n\t\t\t// an iterable, but for now we are just looking for array-like\r\n\t\t\tif (array.length > -1) {\r\n\t\t\t\treturn new Composite(array)\r\n\t\t\t}\r\n\t\t\tif (arguments.length > 1) {\r\n\t\t\t\t// support multiple arguments as an array\r\n\t\t\t\treturn new Composite(arguments)\r\n\t\t\t}\r\n\t\t\tif (typeof array === 'object') {\r\n\t\t\t\t// allow an object as a hash to be mapped\r\n\t\t\t\tvar keyMapping = []\r\n\t\t\t\tvar valueArray = []\r\n\t\t\t\tfor (var key in array) {\r\n\t\t\t\t\tkeyMapping.push(key)\r\n\t\t\t\t\tvalueArray.push(array[key])\r\n\t\t\t\t}\r\n\t\t\t\treturn new Variable(function(results) {\r\n\t\t\t\t\tvar resultObject = {}\r\n\t\t\t\t\tfor (var i = 0; i < results.length; i++) {\r\n\t\t\t\t\t\tresultObject[keyMapping[i]] = results[i]\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn resultObject\r\n\t\t\t\t}).apply(null, valueArray)\r\n\t\t\t}\r\n\t\t\tthrow new TypeError('Variable.all requires an array')\r\n\t\t}\r\n\t\r\n\t\tfunction hasOwn(Target, createForInstance) {\r\n\t\t\tvar ownedClasses = this.ownedClasses || (this.ownedClasses = new WeakMap())\r\n\t\t\t// TODO: assign to super classes\r\n\t\t\tvar Class = this\r\n\t\t\townedClasses.set(Target, createForInstance || function() { return new Target() })\r\n\t\t\treturn this\r\n\t\t}\r\n\t\tfunction getForClass(subject, Target) {\r\n\t\t\tvar createInstance = subject.constructor.ownedClasses && subject.constructor.ownedClasses.get(Target)\r\n\t\t\tif (createInstance) {\r\n\t\t\t\tvar ownedInstances = subject.ownedInstances || (subject.ownedInstances = new WeakMap())\r\n\t\t\t\tvar instance = ownedInstances.get(Target)\r\n\t\t\t\tif (!instance) {\r\n\t\t\t\t\townedInstances.set(Target, instance = createInstance(subject))\r\n\t\t\t\t\tinstance.subject = subject\r\n\t\t\t\t}\r\n\t\t\t\treturn instance\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction generalizeClass() {\r\n\t\t\tvar prototype = this.prototype\r\n\t\t\tvar prototypeNames = Object.getOwnPropertyNames(prototype)\r\n\t\t\tfor(var i = 0, l = prototypeNames.length; i < l; i++) {\r\n\t\t\t\tvar name = prototypeNames[i]\r\n\t\t\t\tObject.defineProperty(this, name, getGeneralizedDescriptor(Object.getOwnPropertyDescriptor(prototype, name), name, this))\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction getGeneralizedDescriptor(descriptor, name, Class) {\r\n\t\t\tif (typeof descriptor.value === 'function') {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tvalue: generalizeMethod(Class, name)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\treturn descriptor\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction generalizeMethod(Class, name) {\r\n\t\t\t// I think we can just rely on `this`, but we could use the argument:\r\n\t\t\t// function(possibleEvent) {\r\n\t\t\t// \tvar target = possibleEvent && possibleEvent.target\r\n\t\t\tvar method = Class[name] = function() {\r\n\t\t\t\tvar instance = Class.for(this)\r\n\t\t\t\treturn instance[name].apply(instance, arguments)\r\n\t\t\t}\r\n\t\t\tmethod.for = function(context) {\r\n\t\t\t\tvar instance = Class.for(context)\r\n\t\t\t\treturn function() {\r\n\t\t\t\t\treturn instance[name].apply(instance, arguments)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn method\r\n\t\t}\r\n\t\r\n\t\tvar defaultContext = {\r\n\t\t\tname: 'Default context',\r\n\t\t\tdescription: 'This object is the default context for classes, corresponding to a singleton instance of that class',\r\n\t\t\tconstructor: {\r\n\t\t\t\tgetForClass: function(subject, Class) {\r\n\t\t\t\t\treturn Class.defaultInstance\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tcontains: function() {\r\n\t\t\t\treturn true // contains everything\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction instanceForContext(Class, context) {\r\n\t\t\tif (!context) {\r\n\t\t\t\tthrow new TypeError('Accessing a generalized class without context to resolve to an instance, call for(context) (where context is an element or related variable instance) on your variable first')\r\n\t\t\t}\r\n\t\t\tvar instance = context.subject.constructor.getForClass && context.subject.constructor.getForClass(context.subject, Class) || Class.defaultInstance\r\n\t\t\tcontext.distinctSubject = mergeSubject(context.distinctSubject, instance.subject)\r\n\t\t\treturn instance\r\n\t\t}\r\n\t\t// a variable inheritance change goes through its own prototype, so classes/constructor\r\n\t\t// can be used as variables as well\r\n\t\tfor (var key in VariablePrototype) {\r\n\t\t\tObject.defineProperty(Variable, key, Object.getOwnPropertyDescriptor(VariablePrototype, key))\r\n\t\t}\r\n\t\tVariable.valueOf = function(context) {\r\n\t\t\t// contextualized getValue\r\n\t\t\treturn instanceForContext(this, context).valueOf()\r\n\t\t}\r\n\t\tVariable.setValue = function(value, context) {\r\n\t\t\t// contextualized setValue\r\n\t\t\treturn instanceForContext(this, context).put(value)\r\n\t\t}\r\n\t\tVariable.getForClass = getForClass\r\n\t\tVariable.generalize = generalizeClass\r\n\t\tVariable.call = Function.prototype.call // restore these\r\n\t\tVariable.apply = Function.prototype.apply\r\n\t\tVariable.extend = function(properties) {\r\n\t\t\t// TODO: handle arguments\r\n\t\t\tvar Base = this\r\n\t\t\tfunction ExtendedVariable() {\r\n\t\t\t\tif (this instanceof ExtendedVariable) {\r\n\t\t\t\t\treturn Base.apply(this, arguments)\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn ExtendedVariable.extend(properties)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tvar prototype = ExtendedVariable.prototype = Object.create(this.prototype)\r\n\t\t\tExtendedVariable.prototype.constructor = ExtendedVariable\r\n\t\t\tsetPrototypeOf(ExtendedVariable, this)\r\n\t\t\tfor (var key in properties) {\r\n\t\t\t\tvar descriptor = Object.getOwnPropertyDescriptor(properties, key)\r\n\t\t\t\tObject.defineProperty(prototype, key, descriptor)\r\n\t\t\t\tObject.defineProperty(ExtendedVariable, key, getGeneralizedDescriptor(descriptor, key, ExtendedVariable))\r\n\t\t\t}\r\n\t\t\tif (properties && properties.hasOwn) {\r\n\t\t\t\thasOwn.call(ExtendedVariable, properties.hasOwn)\r\n\t\t\t}\r\n\t\t\treturn ExtendedVariable\r\n\t\t}\r\n\t\tObject.defineProperty(Variable, 'defaultInstance', {\r\n\t\t\tget: function() {\r\n\t\t\t\treturn this.hasOwnProperty('_defaultInstance') ?\r\n\t\t\t\t\tthis._defaultInstance : (\r\n\t\t\t\t\t\tthis._defaultInstance = new this(),\r\n\t\t\t\t\t\tthis._defaultInstance.subject = defaultContext,\r\n\t\t\t\t\t\tthis._defaultInstance)\r\n\t\t\t}\r\n\t\t})\r\n\t\tVariable.hasOwn = hasOwn\r\n\t\tVariable.all = all\r\n\t\tVariable.objectUpdated = objectUpdated\r\n\t\tVariable.observe = function() {\r\n\t\t\tthrow new Error('Use variable.observeObject() instead')\r\n\t\t}\r\n\t\r\n\t\treturn Variable\r\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\r\n\t\tvar getPrototypeOf = Object.getPrototypeOf || (function(base) { return base.__proto__ })\r\n\t\tvar setPrototypeOf = Object.setPrototypeOf || (function(base, proto) { base.__proto__ = proto})\r\n\t\tvar hasFeatures = {\r\n\t\t\trequestAnimationFrame: typeof requestAnimationFrame != 'undefined',\r\n\t\t\tdefineProperty: Object.defineProperty && (function() {\r\n\t\t\t\ttry{\r\n\t\t\t\t\tObject.defineProperty({}, 't', {})\r\n\t\t\t\t\treturn true\r\n\t\t\t\t}catch(e) {\r\n\t\t\t\t}\r\n\t\t\t})(),\r\n\t\t\tpromise: typeof Promise !== 'undefined',\r\n\t\t\tMutationObserver: typeof MutationObserver !== 'undefined',\r\n\t\t\t'WeakMap': typeof WeakMap === 'function'\r\n\t\t}\r\n\t\tfunction has(feature) {\r\n\t\t\treturn hasFeatures[feature]\r\n\t\t}\r\n\t\t// This is an polyfill for Object.observe with just enough functionality\r\n\t\t// for what Variables need\r\n\t\t// An observe function, with polyfile\r\n\t\tvar observe =\r\n\t\t\thas('defineProperty') ? \r\n\t\t\tfunction observe(target, listener) {\r\n\t\t\t\t/*for(var i in target) {\r\n\t\t\t\t\taddKey(i)\r\n\t\t\t\t}*/\r\n\t\t\t\tlistener.addKey = addKey\r\n\t\t\t\tlistener.remove = function() {\r\n\t\t\t\t\tlistener = null\r\n\t\t\t\t}\r\n\t\t\t\treturn listener\r\n\t\t\t\tfunction addKey(key) {\r\n\t\t\t\t\tvar keyFlag = 'key' + key\r\n\t\t\t\t\tif(this[keyFlag]) {\r\n\t\t\t\t\t\treturn\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tthis[keyFlag] = true\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar currentValue = target[key]\r\n\t\t\t\t\tvar targetAncestor = target\r\n\t\t\t\t\tvar descriptor\r\n\t\t\t\t\tdo {\r\n\t\t\t\t\t\tdescriptor = Object.getOwnPropertyDescriptor(targetAncestor, key)\r\n\t\t\t\t\t} while(!descriptor && (targetAncestor = getPrototypeOf(targetAncestor)))\r\n\t\r\n\t\t\t\t\tif(descriptor && descriptor.set) {\r\n\t\t\t\t\t\tvar previousSet = descriptor.set\r\n\t\t\t\t\t\tvar previousGet = descriptor.get\r\n\t\t\t\t\t\tObject.defineProperty(target, key, {\r\n\t\t\t\t\t\t\tget: function() {\r\n\t\t\t\t\t\t\t\treturn (currentValue = previousGet.call(this))\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\tset: function(value) {\r\n\t\t\t\t\t\t\t\tpreviousSet.call(this, value)\r\n\t\t\t\t\t\t\t\tif(currentValue !== value) {\r\n\t\t\t\t\t\t\t\t\tcurrentValue = value\r\n\t\t\t\t\t\t\t\t\tif(listener) {\r\n\t\t\t\t\t\t\t\t\t\tlistener([{target: this, name: key}])\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\tenumerable: descriptor.enumerable\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tObject.defineProperty(target, key, {\r\n\t\t\t\t\t\t\tget: function() {\r\n\t\t\t\t\t\t\t\treturn currentValue\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\tset: function(value) {\r\n\t\t\t\t\t\t\t\tif(currentValue !== value) {\r\n\t\t\t\t\t\t\t\t\tcurrentValue = value\r\n\t\t\t\t\t\t\t\t\tif(listener) {\r\n\t\t\t\t\t\t\t\t\t\tlistener([{target: this, name: key}])\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\tenumerable: !descriptor || descriptor.enumerable\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} :\r\n\t\t\t// and finally a polling-based solution, for the really old browsers\r\n\t\t\tfunction(target, listener) {\r\n\t\t\t\tif(!timerStarted) {\r\n\t\t\t\t\ttimerStarted = true\r\n\t\t\t\t\tsetInterval(function() {\r\n\t\t\t\t\t\tfor(var i = 0, l = watchedObjects.length; i < l; i++) {\r\n\t\t\t\t\t\t\tdiff(watchedCopies[i], watchedObjects[i], listeners[i])\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}, 20)\r\n\t\t\t\t}\r\n\t\t\t\tvar copy = {}\r\n\t\t\t\tfor(var i in target) {\r\n\t\t\t\t\tif(target.hasOwnProperty(i)) {\r\n\t\t\t\t\t\tcopy[i] = target[i]\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\twatchedObjects.push(target)\r\n\t\t\t\twatchedCopies.push(copy)\r\n\t\t\t\tlisteners.push(listener)\r\n\t\t\t}\r\n\t\tvar queuedListeners\r\n\t\tfunction queue(listener, object, name) {\r\n\t\t\tif(queuedListeners) {\r\n\t\t\t\tif(queuedListeners.indexOf(listener) === -1) {\r\n\t\t\t\t\tqueuedListeners.push(listener)\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\tqueuedListeners = [listener]\r\n\t\t\t\tlang.nextTurn(function() {\r\n\t\t\t\t\tqueuedListeners.forEach(function(listener) {\r\n\t\t\t\t\t\tvar events = []\r\n\t\t\t\t\t\tlistener.properties.forEach(function(property) {\r\n\t\t\t\t\t\t\tevents.push({target: listener.object, name: property})\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t\tlistener(events)\r\n\t\t\t\t\t\tlistener.object = null\r\n\t\t\t\t\t\tlistener.properties = null\r\n\t\t\t\t\t})\r\n\t\t\t\t\tqueuedListeners = null\r\n\t\t\t\t}, 0)\r\n\t\t\t}\r\n\t\t\tlistener.object = object\r\n\t\t\tvar properties = listener.properties || (listener.properties = [])\r\n\t\t\tif(properties.indexOf(name) === -1) {\r\n\t\t\t\tproperties.push(name)\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar unobserve = has('observe') ? Object.unobserve :\r\n\t\t\tfunction(target, listener) {\r\n\t\t\t\tif(listener.remove) {\r\n\t\t\t\t\tlistener.remove()\r\n\t\t\t\t}\r\n\t\t\t\tfor(var i = 0, l = watchedObjects.length; i < l; i++) {\r\n\t\t\t\t\tif(watchedObjects[i] === target && listeners[i] === listener) {\r\n\t\t\t\t\t\twatchedObjects.splice(i, 1)\r\n\t\t\t\t\t\twatchedCopies.splice(i, 1)\r\n\t\t\t\t\t\tlisteners.splice(i, 1)\r\n\t\t\t\t\t\treturn\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\tvar watchedObjects = []\r\n\t\tvar watchedCopies = []\r\n\t\tvar listeners = []\r\n\t\tvar timerStarted = false\r\n\t\tfunction diff(previous, current, callback) {\r\n\t\t\t// TODO: keep an array of properties for each watch for faster iteration\r\n\t\t\tvar queued\r\n\t\t\tfor(var i in previous) {\r\n\t\t\t\tif(previous.hasOwnProperty(i) && previous[i] !== current[i]) {\r\n\t\t\t\t\t// a property has changed\r\n\t\t\t\t\tprevious[i] = current[i]\r\n\t\t\t\t\t(queued || (queued = [])).push({name: i})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor(var i in current) {\r\n\t\t\t\tif(current.hasOwnProperty(i) && !previous.hasOwnProperty(i)) {\r\n\t\t\t\t\t// a property has been added\r\n\t\t\t\t\tprevious[i] = current[i]\r\n\t\t\t\t\t(queued || (queued = [])).push({name: i})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(queued) {\r\n\t\t\t\tcallback(queued)\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tvar id = 1\r\n\t\t// a function that returns a function, to stop JSON serialization of an\r\n\t\t// object\r\n\t\tfunction toJSONHidden() {\r\n\t\t\treturn toJSONHidden\r\n\t\t}\r\n\t\t// An object that will be hidden from JSON serialization\r\n\t\tvar Hidden = function () {\r\n\t\t}\r\n\t\tHidden.prototype.toJSON = toJSONHidden\r\n\t\r\n\t\tvar lang = {\r\n\t\t\trequestAnimationFrame: has('requestAnimationFrame') ? requestAnimationFrame :\r\n\t\t\t\t(function() {\r\n\t\t\t\t\tvar toRender = []\r\n\t\t\t\t\tvar queued = false\r\n\t\t\t\t\tfunction processAnimationFrame() {\r\n\t\t\t\t\t\tfor (var i = 0; i < toRender.length; i++) {\r\n\t\t\t\t\t\t\ttoRender[i]()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttoRender = []\r\n\t\t\t\t\t\tqueued = false\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfunction requestAnimationFrame(renderer) {\r\n\t\t\t\t\t \tif (!queued) {\r\n\t\t\t\t\t\t\tsetTimeout(processAnimationFrame)\r\n\t\t\t\t\t\t\tqueued = true\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttoRender.push(renderer)\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn requestAnimationFrame\r\n\t\t\t\t})(),\r\n\t\t\tPromise: has('promise') ? Promise : (function() {\r\n\t\t\t\tfunction Promise(execute) {\r\n\t\t\t\t\tvar isResolved, resolution, errorResolution\r\n\t\t\t\t\tvar queue = 0\r\n\t\t\t\t\tfunction resolve(value) {\r\n\t\t\t\t\t\t// resolve function\r\n\t\t\t\t\t\tif(value && value.then) {\r\n\t\t\t\t\t\t\t// received a promise, wait for it\r\n\t\t\t\t\t\t\tvalue.then(resolve, reject)\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\tresolution = value\r\n\t\t\t\t\t\t\tfinished()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfunction reject(error) {\r\n\t\t\t\t\t\t// reject function\r\n\t\t\t\t\t\terrorResolution = error\r\n\t\t\t\t\t\tfinished()\r\n\t\t\t\t\t}\r\n\t\t\t\t\texecute(resolve, reject)\r\n\t\t\t\t\tfunction finished() {\r\n\t\t\t\t\t\tisResolved = true\r\n\t\t\t\t\t\tfor(var i = 0, l = queue.length; i < l; i++) {\r\n\t\t\t\t\t\t\tqueue[i]()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// clean out the memory\r\n\t\t\t\t\t\tqueue = 0\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tthen: function(callback, errback) {\r\n\t\t\t\t\t\t\treturn new Promise(function(resolve, reject) {\r\n\t\t\t\t\t\t\t\tfunction handle() {\r\n\t\t\t\t\t\t\t\t\t// promise fulfilled, call the appropriate callback\r\n\t\t\t\t\t\t\t\t\ttry{\r\n\t\t\t\t\t\t\t\t\t\tif(errorResolution && !errback) {\r\n\t\t\t\t\t\t\t\t\t\t\t// errors without a handler flow through\r\n\t\t\t\t\t\t\t\t\t\t\treject(errorResolution)\r\n\t\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t\t// resolve to the callback's result\r\n\t\t\t\t\t\t\t\t\t\t\tresolve(errorResolution ?\r\n\t\t\t\t\t\t\t\t\t\t\t\terrback(errorResolution) :\r\n\t\t\t\t\t\t\t\t\t\t\t\tcallback ?\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tcallback(resolution) : resolution)\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}catch(newError) {\r\n\t\t\t\t\t\t\t\t\t\t// caught an error, reject the returned promise\r\n\t\t\t\t\t\t\t\t\t\treject(newError)\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif(isResolved) {\r\n\t\t\t\t\t\t\t\t\t// already resolved, immediately handle\r\n\t\t\t\t\t\t\t\t\thandle()\r\n\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t(queue || (queue = [])).push(handle)\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn Promise\r\n\t\t\t}()),\r\n\t\r\n\t\t\tWeakMap: has('WeakMap') ? WeakMap :\r\n\t\t \tfunction (values, name) {\r\n\t\t \t\tvar mapProperty = '__' + (name || '') + id++\r\n\t\t \t\treturn has('defineProperty') ?\r\n\t\t \t\t{\r\n\t\t \t\t\tget: function (key) {\r\n\t\t \t\t\t\treturn key[mapProperty]\r\n\t\t \t\t\t},\r\n\t\t \t\t\tset: function (key, value) {\r\n\t\t \t\t\t\tObject.defineProperty(key, mapProperty, {\r\n\t\t \t\t\t\t\tvalue: value,\r\n\t\t \t\t\t\t\tenumerable: false\r\n\t\t \t\t\t\t})\r\n\t\t \t\t\t}\r\n\t\t \t\t} :\r\n\t\t \t\t{\r\n\t\t \t\t\tget: function (key) {\r\n\t\t \t\t\t\tvar intermediary = key[mapProperty]\r\n\t\t \t\t\t\treturn intermediary && intermediary.value\r\n\t\t \t\t\t},\r\n\t\t \t\t\tset: function (key, value) {\r\n\t\t \t\t\t\t// we use an intermediary that is hidden from JSON serialization, at least\r\n\t\t \t\t\t\tvar intermediary = key[mapProperty] || (key[mapProperty] = new Hidden())\r\n\t\t \t\t\t\tintermediary.value = value\r\n\t\t \t\t\t}\r\n\t\t \t\t}\r\n\t\t \t},\r\n\t\r\n\t\t\tobserve: observe,\r\n\t\t\tunobserve: unobserve,\r\n\t\t\twhen: function(value, callback, errorHandler) {\r\n\t\t\t\treturn value && value.then ?\r\n\t\t\t\t\t(value.then(callback, errorHandler) || value) : callback(value)\r\n\t\t\t},\r\n\t\t\twhenAll: function(inputs, callback) {\r\n\t\t\t\tvar promiseInvolved\r\n\t\t\t\tfor(var i = 0, l = inputs.length; i < l; i++) {\r\n\t\t\t\t\tif(inputs[i] && inputs[i].then) {\r\n\t\t\t\t\t\tpromiseInvolved = true\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif(promiseInvolved) {\r\n\t\t\t\t\t// we have asynch inputs, do lazy loading\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tthen: function(onResolve, onError) {\r\n\t\t\t\t\t\t\tvar remaining = 1\r\n\t\t\t\t\t\t\tvar result\r\n\t\t\t\t\t\t\tvar readyInputs = []\r\n\t\t\t\t\t\t\tvar lastPromiseResult\r\n\t\t\t\t\t\t\tfor(var i = 0; i < inputs.length; i++) {\r\n\t\t\t\t\t\t\t\tvar input = inputs[i]\r\n\t\t\t\t\t\t\t\tremaining++\r\n\t\t\t\t\t\t\t\tif(input && input.then) {\r\n\t\t\t\t\t\t\t\t\t(function(i, previousPromiseResult) {\r\n\t\t\t\t\t\t\t\t\t\tlastPromiseResult = input.then(function(value) {\r\n\t\t\t\t\t\t\t\t\t\t\treadyInputs[i] = value\r\n\t\t\t\t\t\t\t\t\t\t\tonEach()\r\n\t\t\t\t\t\t\t\t\t\t\tif(!remaining) {\r\n\t\t\t\t\t\t\t\t\t\t\t\treturn result\r\n\t\t\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t\t\treturn previousPromiseResult\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}, onError)\r\n\t\t\t\t\t\t\t\t\t})(i, lastPromiseResult)\r\n\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\treadyInputs[i] = input\r\n\t\t\t\t\t\t\t\t\tonEach()\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tonEach()\r\n\t\t\t\t\t\t\tfunction onEach() {\r\n\t\t\t\t\t\t\t\tremaining--\r\n\t\t\t\t\t\t\t\tif(!remaining) {\r\n\t\t\t\t\t\t\t\t\tresult = onResolve(callback(readyInputs))\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn lastPromiseResult\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tinputs: inputs\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// just sync inputs\r\n\t\t\t\treturn callback(inputs)\r\n\t\r\n\t\t\t},\r\n\t\t\tcompose: function(Base, constructor, properties) {\r\n\t\t\t\tvar prototype = constructor.prototype = Object.create(Base.prototype)\r\n\t\t\t\tsetPrototypeOf(constructor, Base)\r\n\t\t\t\tfor(var i in properties) {\r\n\t\t\t\t\tprototype[i] = properties[i]\r\n\t\t\t\t}\r\n\t\t\t\tprototype.constructor = constructor\r\n\t\t\t\treturn constructor\r\n\t\t\t},\r\n\t\t\tnextTurn: has('MutationObserver') ?\r\n\t\t\t\tfunction (callback) {\r\n\t\t\t\t\t// promises don't resolve consistently on the next micro turn (Edge doesn't do it right),\r\n\t\t\t\t\t// so use mutation observer\r\n\t\t\t\t\t// TODO: make a faster mode that doesn't recreate each time\r\n\t\t\t\t\tvar div = document.createElement('div')\r\n\t\t\t\t\tvar observer = new MutationObserver(callback)\r\n\t\t\t\t\tobserver.observe(div, {\r\n\t\t\t\t\t\tattributes: true\r\n\t\t\t\t\t})\r\n\t\t\t\t\tdiv.setAttribute('a', id++)\r\n\t\t\t\t} :\r\n\t\t\t\tfunction (callback) {\r\n\t\t\t\t\t// TODO: we can do better for other, older browsers\r\n\t\t\t\t\tsetTimeout(callback, 0)\r\n\t\t\t\t},\r\n\t\t\tcopy: Object.assign || function(target, source) {\r\n\t\t\t\tfor(var i in source) {\r\n\t\t\t\t\ttarget[i] = source[i]\r\n\t\t\t\t}\r\n\t\t\t\treturn target\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn lang\r\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(3)], __WEBPACK_AMD_DEFINE_RESULT__ = function (lang, Variable) {\r\n\t\tvar doc = typeof document !== 'undefined' && document\r\n\t\tvar invalidatedElements\r\n\t\tvar queued\r\n\t\tvar toRender = []\r\n\t\tvar nextId = 1\r\n\t\tvar requestAnimationFrame = lang.requestAnimationFrame\r\n\t\r\n\t\tfunction Context(subject){\r\n\t\t\tthis.subject = subject\r\n\t\t}\r\n\t\r\n\t\tfunction Renderer(options) {\r\n\t\t\tvar variable = options.variable\r\n\t\r\n\t\t\tthis.variable = variable\r\n\t\t\tthis.elements = []\r\n\t\t\tif (options) {\r\n\t\t\t\tif (options.selector) {\r\n\t\t\t\t\tthis.selector = options.selector\r\n\t\t\t\t}\r\n\t\t\t\tif (options.elements) {\r\n\t\t\t\t\tthis.elements = options.elements\r\n\t\t\t\t\tthis.element = this.elements[0]\r\n\t\t\t\t}\r\n\t\t\t\tif (options.element) {\r\n\t\t\t\t\tthis.element = options.element\r\n\t\t\t\t\tthis.elements.push(options.element)\r\n\t\t\t\t}\r\n\t\t\t\tfor(var i = 0, l = this.elements.length; i < l; i++) {\r\n\t\t\t\t\t(this.elements[i].alkaliRenderers || (this.elements[i].alkaliRenderers = [])).push(this)\r\n\t\t\t\t}\r\n\t\t\t\tif (options.update) {\r\n\t\t\t\t\tthis.updateRendering = options.update\r\n\t\t\t\t}\r\n\t\t\t\tif (options.shouldRender) {\r\n\t\t\t\t\tthis.shouldRender = options.shouldRender\r\n\t\t\t\t}\r\n\t\t\t\tif (options.renderUpdate) {\r\n\t\t\t\t\tthis.renderUpdate = options.renderUpdate\r\n\t\t\t\t}\r\n\t\t\t\tif (options.alwaysUpdate) {\r\n\t\t\t\t\tthis.alwaysUpdate = options.alwaysUpdate\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (variable.updated) {\r\n\t\t\t\t// if it has update, we don't need to instantiate a closure\r\n\t\t\t\tvariable.notifies(this)\r\n\t\t\t} else {\r\n\t\t\t\t// baconjs-esqe API\r\n\t\t\t\tvar renderer = this\r\n\t\t\t\tvariable.subscribe(function (event) {\r\n\t\t\t\t\t// replace the variable with an object\r\n\t\t\t\t\t// that returns the value from the event\r\n\t\t\t\t\trenderer.variable = {\r\n\t\t\t\t\t\tvalueOf: function () {\r\n\t\t\t\t\t\t\treturn event.value()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\trenderer.updated()\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tif(options && options.updateOnStart !== false){\r\n\t\t\t\tthis.updateRendering(true)\r\n\t\t\t}\r\n\t\t}\r\n\t\tRenderer.prototype = {\r\n\t\t\tconstructor: Renderer,\r\n\t\t\tupdateRendering: function () {\r\n\t\t\t\tthrow new Error ('updateRendering must be implemented by sub class of Renderer')\r\n\t\t\t},\r\n\t\t\tupdated: function (updateEvent, by, context) {\r\n\t\t\t\tif (!this.invalidated) {\r\n\t\t\t\t\tif (!context || this.contextMatches(context)) {\r\n\t\t\t\t\t\t// do this only once, until we render again\r\n\t\t\t\t\t\tthis.invalidated = true\r\n\t\t\t\t\t\tvar renderer = this\r\n\t\t\t\t\t\trequestAnimationFrame(function(){\r\n\t\t\t\t\t\t\tinvalidatedElements = null\r\n\t\t\t\t\t\t\trenderer.updateRendering(renderer.alwaysUpdate)\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tcontextMatches: function(context) {\r\n\t\t\t\treturn true\r\n\t\t\t\treturn context == this.elements ||\r\n\t\t\t\t\t// if context is any element in this.elements - perhaps return only the specific matching elements?\r\n\t\t\t\t\t(this.elements.indexOf(context) != -1) ||\r\n\t\t\t\t  // (context is an array and any/all elements are contained in this.elements) ||\r\n\t\t\t\t\t// context contains() any of this.elements\r\n\t\t\t\t\t(function(elements) {\r\n\t\t\t\t\t\tfor(var i = 0, l = elements.length; i < l; i++) {\r\n\t\t\t\t\t\t\tif (context.contains(elements[i])) return true\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn false\r\n\t\t\t\t\t})(this.elements)\r\n\t\t\t},\r\n\t\t\tinvalidateElement: function(element) {\r\n\t\t\t\tif(!invalidatedElements){\r\n\t\t\t\t\tinvalidatedElements = new WeakMap(null, 'invalidated')\r\n\t\t\t\t\t// TODO: if this is not a real weak map, we don't want to GC it, or it will leak\r\n\t\t\t\t}\r\n\t\t\t\tvar invalidatedParts = invalidatedElements.get(element)\r\n\t\t\t\tinvalidatedElements.set(element, invalidatedParts = {})\r\n\t\t\t\tif (!invalidatedParts[id]) {\r\n\t\t\t\t\tinvalidatedParts[id] = true\r\n\t\t\t\t}\r\n\t\t\t\tif (!queued) {\r\n\t\t\t\t\tlang.queueTask(processQueue)\r\n\t\t\t\t\tqueued = true\r\n\t\t\t\t}\r\n\t\t\t\tvar renderer = this\r\n\t\t\t\ttoRender.push(function(){\r\n\t\t\t\t\trenderer.invalidated = false\r\n\t\t\t\t\trenderer.updateElement(element)\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tgetId: function(){\r\n\t\t\t\treturn this.id || (this.id = nextId++)\r\n\t\t\t},\r\n\t\t\tstop: function() {\r\n\t\t\t\tthis.variable.stopNotifies(this)\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction ElementRenderer(options) {\r\n\t\t\tRenderer.call(this, options)\r\n\t\t}\r\n\t\tElementRenderer.prototype = Object.create(Renderer.prototype)\r\n\t\tElementRenderer.prototype.shouldRender = function (element) {\r\n\t\t\treturn document.body.contains(element)\r\n\t\t}\r\n\t\tElementRenderer.prototype.getSubject = function () {\r\n\t\t\treturn this.element || this.elements[0]\r\n\t\t}\r\n\t\tElementRenderer.prototype.updateRendering = function (always, element) {\r\n\t\t\tvar elements = this.elements || (element && [element]) || []\r\n\t\t\tif(!elements.length){\r\n\t\t\t\tif(this.selector){\r\n\t\t\t\t\telements = document.querySelectorAll(this.selector)\r\n\t\t\t\t}else{\r\n\t\t\t\t\tthrow new Error('No element or selector was provided to the Renderer')\r\n\t\t\t\t}\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tfor(var i = 0, l = elements.length; i < l; i++){\r\n\t\t\t\tif(always || this.shouldRender(elements[i])){\r\n\t\t\t\t\t// it is connected\r\n\t\t\t\t\tthis.updateElement(elements[i])\r\n\t\t\t\t}else{\r\n\t\t\t\t\tvar id = this.getId()\r\n\t\t\t\t\tvar renderers = elements[i].renderersOnShow\r\n\t\t\t\t\tif(!renderers){\r\n\t\t\t\t\t\trenderers = elements[i].renderersOnShow = []\r\n\t\t\t\t\t\telements[i].className += ' needs-rerendering'\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!renderers[id]) {\r\n\t\t\t\t\t\trenderers[id] = this\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tElementRenderer.prototype.addElement = function (element) {\r\n\t\t\tif (this.selector) {\r\n\t\t\t\telement.renderersOnShow = [this]\r\n\t\t\t} else {\r\n\t\t\t\tthis.elements.push(element)\r\n\t\t\t}\r\n\t\t\t// and immediately do an update\r\n\t\t\tthis.updateElement(element)\r\n\t\t}\r\n\t\tElementRenderer.prototype.updateElement = function(element) {\r\n\t\t\tthis.invalidated = false\r\n\t\t\ttry {\r\n\t\t\t\t// TODO: might make something cheaper than for(element) for setting context?\r\n\t\t\t\tvar value = !this.omitValueOf && this.variable.valueOf(new Context(element))\r\n\t\t\t} catch (error) {\r\n\t\t\t\telement.appendChild(document.createTextNode(error))\r\n\t\t\t}\r\n\t\t\tif(value !== undefined || this.started){\r\n\t\t\t\tthis.started = true\r\n\t\t\t\tif(value && value.then){\r\n\t\t\t\t\tif(this.renderLoading){\r\n\t\t\t\t\t\tthis.renderLoading(value, element)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar renderer = this\r\n\t\t\t\t\tvalue.then(function (value) {\r\n\t\t\t\t\t\trenderer.renderUpdate(value, element)\r\n\t\t\t\t\t})\r\n\t\t\t\t}else{\r\n\t\t\t\t\tthis.renderUpdate(value, element)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tElementRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\t\tthrow new Error('renderUpdate(newValue) must be implemented')\r\n\t\t}\r\n\t\tRenderer.Renderer = Renderer\r\n\t\tRenderer.ElementRenderer = ElementRenderer\r\n\t\r\n\t\tfunction AttributeRenderer(options) {\r\n\t\t\tif(options.name){\r\n\t\t\t\tthis.name = options.name\r\n\t\t\t}\r\n\t\t\tElementRenderer.apply(this, arguments)\r\n\t\t}\r\n\t\tAttributeRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\t\tAttributeRenderer.prototype.type = 'AttributeRenderer'\r\n\t\tAttributeRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\t\telement.setAttribute(this.name, newValue)\r\n\t\t}\r\n\t\tRenderer.AttributeRenderer = AttributeRenderer\r\n\t\r\n\t\tfunction PropertyRenderer(options) {\r\n\t\t\tif (options.name) {\r\n\t\t\t\tthis.name = options.name\r\n\t\t\t}\r\n\t\t\tElementRenderer.apply(this, arguments)\r\n\t\t}\r\n\t\tPropertyRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\t\tPropertyRenderer.prototype.type = 'PropertyRenderer'\r\n\t\tPropertyRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\t\telement[this.name] = newValue\r\n\t\t}\r\n\t\tRenderer.PropertyRenderer = PropertyRenderer\r\n\t\r\n\t\tfunction InputPropertyRenderer(options) {\r\n\t\t\tif (options.element && options.element.tagName === 'SELECT' && options.name === 'value') {\r\n\t\t\t\t// use the deferred value assignment for <select>\r\n\t\t\t\tthis.renderUpdate = this.renderSelectValueUpdate\r\n\t\t\t}\r\n\t\t\tPropertyRenderer.apply(this, arguments)\r\n\t\t}\r\n\t\tInputPropertyRenderer.prototype = Object.create(PropertyRenderer.prototype)\r\n\t\tInputPropertyRenderer.prototype.type = 'InputPropertyRenderer'\r\n\t\tInputPropertyRenderer.prototype.renderUpdate = function(newValue, element) {\r\n\t\t\tif (element.type === 'number') {\r\n\t\t\t\tif (isNaN(newValue)) {\r\n\t\t\t\t\tnewValue = ''\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telement[this.name] = newValue\r\n\t\t}\r\n\t\tInputPropertyRenderer.prototype.renderSelectValueUpdate = function (newValue, element) {\r\n\t\t\telement.value = newValue\r\n\t\t\tif (element.value != newValue && !element.value) {\r\n\t\t\t\t// if we didn't successfully set the value of a <select>, we may need to wait until the children are constructed\r\n\t\t\t\telement.eventualValue = newValue\r\n\t\t\t\tlang.nextTurn(function() {\r\n\t\t\t\t\tif (element.eventualValue) {\r\n\t\t\t\t\t\telement.value = element.eventualValue\r\n\t\t\t\t\t\telement.eventualValue = undefined\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t} else {\r\n\t\t\t\telement.eventualValue = undefined\r\n\t\t\t}\r\n\t\t}\r\n\t\tRenderer.InputPropertyRenderer = InputPropertyRenderer\r\n\t\r\n\t\tfunction StyleRenderer(options) {\r\n\t\t\tif(options.name){\r\n\t\t\t\tthis.name = options.name\r\n\t\t\t}\r\n\t\t\tElementRenderer.apply(this, arguments)\r\n\t\t}\r\n\t\tStyleRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\t\tStyleRenderer.prototype.type = 'StyleRenderer'\r\n\t\tStyleRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\t\telement.style[this.name] = newValue\r\n\t\t}\r\n\t\tRenderer.StyleRenderer = StyleRenderer\r\n\t\r\n\t\tfunction ContentRenderer(options) {\r\n\t\t\tElementRenderer.apply(this, arguments)\r\n\t\t}\r\n\t\tContentRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\t\tContentRenderer.prototype.type = 'ContentRenderer'\r\n\t\tContentRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\t\telement.innerHTML = ''\r\n\t\t\tif (newValue === undefined){\r\n\t\t\t\tnewValue = ''\r\n\t\t\t}\r\n\t\t\telement.appendChild(document.createTextNode(newValue))\r\n\t\t}\r\n\t\tRenderer.ContentRenderer = ContentRenderer\r\n\t\r\n\t\tfunction TextRenderer(options) {\r\n\t\t\tthis.position = options.position\r\n\t\t\tthis.textNode = options.textNode\r\n\t\t\tElementRenderer.apply(this, arguments)\r\n\t\t}\r\n\t\tTextRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\t\tTextRenderer.prototype.type = 'TextRenderer'\r\n\t\tTextRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\t\tif (newValue == null){\r\n\t\t\t\tnewValue = ''\r\n\t\t\t} else if (newValue.nodeType) {\r\n\t\t\t\tif (this.textNode && this.textNode.parentNode == element) {\r\n\t\t\t\t\t// text node is attached, we can replace it with the node\r\n\t\t\t\t\telement.replaceChild(newValue, this.textNode)\r\n\t\t\t\t} else {\r\n\t\t\t\t\telement.appendChild(newValue)\r\n\t\t\t\t}\r\n\t\t\t\tthis.textNode = newValue\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\t(this.textNode || element.childNodes[this.position]).nodeValue = newValue\r\n\t\t}\r\n\t\tRenderer.TextRenderer = TextRenderer\r\n\t\r\n\t\tfunction ListRenderer(options) {\r\n\t\t\tif (options.each) {\r\n\t\t\t\tthis.each = options.each\r\n\t\t\t}\r\n\t\t\tElementRenderer.apply(this, arguments)\r\n\t\t}\r\n\t\tListRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\t\tListRenderer.prototype.updated = function (updateEvent, context) {\r\n\t\t\t(this.updates || (this.updates = [])).push(updateEvent)\r\n\t\t\tElementRenderer.prototype.updated.call(this, updateEvent, context)\r\n\t\t}\r\n\t\tListRenderer.prototype.type = 'ListRenderer'\r\n\t\tListRenderer.prototype.omitValueOf = true\r\n\t\tListRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\t\tvar container\r\n\t\t\tvar each = this.each\r\n\t\t\tvar thisElement = this.elements[0]\r\n\t\t\tvar renderer = this\r\n\t\t\tif (!this.builtList) {\r\n\t\t\t\tthis.builtList = true\r\n\t\t\t\tcontainer = document.createDocumentFragment()\r\n\t\t\t\tvar childElements = this.childElements = []\r\n\t\t\t\tthis.variable.for(thisElement).forEach(function(item) {\r\n\t\t\t\t\teachItem(item)\r\n\t\t\t\t})\r\n\t\t\t\tthis.element.appendChild(container)\r\n\t\t\t} else {\r\n\t\t\t\tvar childElements = this.childElements\r\n\t\t\t\tvar updates = this.updates\r\n\t\t\t\tcontainer = this.element\r\n\t\t\t\tupdates.forEach(function(update) {\r\n\t\t\t\t\tif (update.type === 'refresh') {\r\n\t\t\t\t\t\trenderer.builtList = false\r\n\t\t\t\t\t\tfor (var i = 0, l = childElements.length; i < l; i++) {\r\n\t\t\t\t\t\t\tthisElement.removeChild(childElements[i])\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\trenderer.renderUpdate()\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (update.previousIndex > -1) {\r\n\t\t\t\t\t\t\tthisElement.removeChild(childElements[update.previousIndex])\r\n\t\t\t\t\t\t\tchildElements.splice(update.previousIndex, 1)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (update.index > -1) {\r\n\t\t\t\t\t\t\tvar nextChild = childElements[update.index] || null\r\n\t\t\t\t\t\t\teachItem(update.value, update.index, nextChild)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t\tthis.updates = [] // clear the updates\r\n\t\t\t}\r\n\t\t\tfunction eachItem(item, index, nextChild) {\r\n\t\t\t\tvar childElement\r\n\t\t\t\tif (each.create) {\r\n\t\t\t\t\tchildElement = each.create({parent: thisElement, _item: item}) // TODO: make a faster object here potentially\r\n\t\t\t\t} else {\r\n\t\t\t\t\tchildElement = each(item, thisElement)\r\n\t\t\t\t}\r\n\t\t\t\tif (nextChild) {\r\n\t\t\t\t\tcontainer.insertBefore(childElement, nextChild)\r\n\t\t\t\t\tchildElements.splice(index, 0, childElement)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcontainer.appendChild(childElement)\r\n\t\t\t\t\tchildElements.push(childElement)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tRenderer.ListRenderer = ListRenderer\r\n\t\r\n\t\tRenderer.onShowElement = function(shownElement){\r\n\t\t\trequestAnimationFrame(function(){\r\n\t\t\t\tinvalidatedElements = null\r\n\t\t\t\tvar elements = [].slice.call(shownElement.getElementsByClassName('needs-rerendering'))\r\n\t\t\t\tif (shownElement.className.indexOf('needs-rerendering') > 0){\r\n\t\t\t\t\tvar includingTop = [shownElement]\r\n\t\t\t\t\tincludingTop.push.apply(includingTop, elements)\r\n\t\t\t\t\telements = includingTop\r\n\t\t\t\t}\r\n\t\t\t\tfor (var i = 0, l = elements.length; i < l; i++){\r\n\t\t\t\t\tvar element = elements[i]\r\n\t\t\t\t\tvar renderers = element.renderersOnShow\r\n\t\t\t\t\tif(renderers){\r\n\t\t\t\t\t\telement.renderersOnShow = null\r\n\t\t\t\t\t\t// remove needs-rerendering class\r\n\t\t\t\t\t\telement.className = element.className.replace(/\\s?needs\\-rerendering\\s?/g, '')\r\n\t\t\t\t\t\tfor (var id in renderers) {\r\n\t\t\t\t\t\t\tvar renderer = renderers[id]\r\n\t\t\t\t\t\t\trenderer.updateElement(element)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t}\r\n\t\r\n\t\tfunction onElementRemoval(element){\r\n\t\t\t// cleanup element renderers\r\n\t\t\tif(element.alkaliRenderers){\r\n\t\t\t\tvar renderers = element.alkaliRenderers\r\n\t\t\t\tfor(var i = 0; i < renderers.length; i++){\r\n\t\t\t\t\tvar renderer = renderers[i]\r\n\t\t\t\t\trenderer.variable.stopNotifies(renderer)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tRenderer.onElementRemoval = function(element, onlyChildren){\r\n\t\t\tif(!onlyChildren){\r\n\t\t\t\tonElementRemoval(element)\r\n\t\t\t}\r\n\t\t\tvar children = element.getElementsByTagName('*')\r\n\t\t\tfor(var i = 0, l = children.length; i < l; i++){\r\n\t\t\t\tvar child = children[i]\r\n\t\t\t\tif(child.alkaliRenderers){\r\n\t\t\t\t\tonElementRemoval(child)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn Renderer\r\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(3), __webpack_require__(2), __webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = function (lang, Variable, operators) {\r\n\t\r\n\t\tfunction react(generator, options) {\r\n\t    if (typeof generator !== 'function') {\r\n\t      throw new Error('react() must be called with a generator. You need to use the babel-plugin-transform-alkali plugin if you want to use reactive expressions')\r\n\t    }\r\n\t\t\tif (options && options.reverse) {\r\n\t\t\t\tgenerator.reverse = options.reverse\r\n\t\t\t}\r\n\t\t\treturn new Variable.GeneratorVariable(generator)\r\n\t\t}\r\n\t  Object.assign(react, operators)\r\n\t  react.from = function(value) {\r\n\t    if (value && value.notifies) {\r\n\t      return value\r\n\t    }\r\n\t    return new Variable(value)\r\n\t  }\r\n\t  react.prop = function(object, property) {\r\n\t    if (object) {\r\n\t      var value = object[property]\r\n\t      if (value !== undefined || !object.property) {\r\n\t        return value\r\n\t      } else {\r\n\t        return object.property(property)\r\n\t      }\r\n\t    }\r\n\t    return object\r\n\t  }\r\n\t  react.cond = function(test, consequent, alternate) {\r\n\t    return operators.if(test, operators.choose(consequent, alternate))\r\n\t  }\r\n\t  react.fcall = function(target, args) {\r\n\t    return new Variable.Call(target, args)\r\n\t  }\r\n\t  react.mcall = function(target, key, args) {\r\n\t    return new Variable.Call(target[key].bind(target), args)\r\n\t  }\r\n\t\treturn react\r\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Variable) {\r\n\t\tvar deny = Variable.deny;\r\n\t\tvar operatingFunctions = {};\r\n\t\tvar operators = {};\r\n\t\tfunction getOperatingFunction(expression){\r\n\t\t\t// jshint evil: true\r\n\t\t\treturn operatingFunctions[expression] ||\r\n\t\t\t\t(operatingFunctions[expression] =\r\n\t\t\t\t\tnew Function('a', 'b', 'deny', 'return ' + expression));\r\n\t\t}\r\n\t\tfunction operator(operator, name, precedence, forward, reverseA, reverseB){\r\n\t\t\t// defines the standard operators\r\n\t\t\tvar reverse = function(output, inputs){\r\n\t\t\t\tvar a = inputs[0],\r\n\t\t\t\t\tb = inputs[1];\r\n\t\t\t\tif(a && a.put){\r\n\t\t\t\t\tvar result = reverseA(output, b && b.valueOf());\r\n\t\t\t\t\tif(result !== deny){\r\n\t\t\t\t\t\ta.put(result);\r\n\t\t\t\t\t}\r\n\t\t\t\t}else if(b && b.put){\r\n\t\t\t\t\tb.put(reverseB(output, a && a.valueOf()));\r\n\t\t\t\t}else{\r\n\t\t\t\t\treturn deny;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\t// define a function that can lazily ensure the operating function\r\n\t\t\t// is available\r\n\t\t\tvar operatorHandler = {\r\n\t\t\t\tapply: function(instance, args){\r\n\t\t\t\t\tforward = getOperatingFunction(forward);\r\n\t\t\t\t\treverseA = reverseA && getOperatingFunction(reverseA);\r\n\t\t\t\t\treverseB = reverseB && getOperatingFunction(reverseB);\r\n\t\t\t\t\tforward.reverse = reverse;\r\n\t\t\t\t\toperators[operator] = operatorHandler = new Variable(forward);\r\n\t\r\n\t\t\t\t\taddFlags(operatorHandler);\r\n\t\t\t\t\targs = Array.prototype.slice.call(args);\r\n\t\t\t\t\targs.push(deny)\r\n\t\t\t\t\treturn operatorHandler.apply(instance, args);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\tfunction addFlags(operatorHandler){\r\n\t\t\t\toperatorHandler.precedence = precedence;\r\n\t\t\t\toperatorHandler.infix = reverseB !== false;\r\n\t\t\t}\r\n\t\t\taddFlags(operatorHandler);\r\n\t\t\toperators[operator] = operatorHandler;\r\n\t\t\toperators[name] = function() {\r\n\t\t\t\treturn operatorHandler.apply(null, arguments)\r\n\t\t\t}\r\n\t\t}\r\n\t\t// using order precedence from:\r\n\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence\r\n\t\toperator('+', 'add', 6, 'a+b', 'a-b', 'a-b');\r\n\t\toperator('-', 'subtract', 6, 'a-b', 'a+b', 'b-a');\r\n\t\toperator('*', 'multiply', 5, 'a*b', 'a/b', 'a/b');\r\n\t\toperator('/', 'divide', 5, 'a/b', 'a*b', 'b/a');\r\n\t//\toperator('^', 7, 'a^b', 'a^(-b)', 'Math.log(a)/Math.log(b)');\r\n\t\toperator('?', 'if', 16, 'b[a?0:1]', 'a===b[0]||(a===b[1]?false:deny)', '[a,b]');\r\n\t\toperator(':', 'choose', 15, '[a,b]', 'a[0]?a[1]:deny', 'a[1]');\r\n\t\toperator('!', 'not', 4, '!a', '!a', false);\r\n\t\toperator('%', 'remainder', 5, 'a%b');\r\n\t\toperator('>', 'greater', 8, 'a>b');\r\n\t\toperator('>=', 'greaterOrEqual', 8, 'a>=b');\r\n\t\toperator('<', 'less', 8, 'a<b');\r\n\t\toperator('<=', 'lessOrEqual', 8, 'a<=b');\r\n\t\toperator('==', 'equal', 9, 'a===b');\r\n\t\toperator('&', 'and', 8, 'a&&b');\r\n\t\toperator('|', 'or', 8, 'a||b');\r\n\t\toperator('round', 'round', 8, 'Math.round(a*Math.pow(10,b||1))/Math.pow(10,b||1)', 'a', 'a');\r\n\t\treturn operators;\r\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(3), __webpack_require__(2)], __WEBPACK_AMD_DEFINE_RESULT__ = function (lang, Variable) {\r\n\t\r\n\t\tfunction deepCopy(source, target, derivativeMap) {\r\n\t\t\tif (source && typeof source == 'object') {\r\n\t\t\t\tif (source instanceof Array) {\r\n\t\t\t\t\ttarget = [] // always create a new array for array targets\r\n\t\t\t\t\tfor(var i = 0, l = source.length; i < l; i++) {\r\n\t\t\t\t\t\ttarget[i] = deepCopy(source[i], null, derivativeMap)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (!target || typeof target !== 'object') {\r\n\t\t\t\t\t\ttarget = derivativeMap && derivativeMap.get(source)\r\n\t\t\t\t\t\tif (!target) {\r\n\t\t\t\t\t\t\ttarget = {}\r\n\t\t\t\t\t\t\tderivativeMap && derivativeMap.set(source, target)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfor (var i in source) {\r\n\t\t\t\t\t\ttarget[i] = deepCopy(source[i], target[i], derivativeMap)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn target\r\n\t\t\t}\r\n\t\t\treturn source\r\n\t\t}\r\n\t\r\n\t\tvar Copy = lang.compose(Variable, function(copiedFrom) {\r\n\t\t\t// this is the variable that we derive from\r\n\t\t\tthis.copiedFrom = copiedFrom\r\n\t\t\tthis.derivativeMap = new lang.WeakMap(null, 'derivative')\r\n\t\t\tthis.isDirty = new Variable(false)\r\n\t\t}, {\r\n\t\t\tvalueOf: function(context) {\r\n\t\t\t\tif(this.state) {\r\n\t\t\t\t\tthis.state = null\r\n\t\t\t\t}\r\n\t\t\t\tvar value = this.copiedFrom.valueOf(context)\r\n\t\t\t\tif(value && typeof value == 'object') {\r\n\t\t\t\t\tvar derivative = this.derivativeMap.get(value)\r\n\t\t\t\t\tif (derivative == null) {\r\n\t\t\t\t\t\tthis.derivativeMap.set(value, derivative = deepCopy(value, undefined, this.derivativeMap))\r\n\t\t\t\t\t\tthis.setValue(derivative, context)\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn derivative\r\n\t\t\t\t}\r\n\t\t\t\tvar thisValue = this.getValue(context)\r\n\t\t\t\tif(thisValue === undefined) {\r\n\t\t\t\t\treturn value\r\n\t\t\t\t}\r\n\t\t\t\treturn thisValue\r\n\t\t\t},\r\n\t\t\tgetCopyOf: function(value) {\r\n\t\t\t\tvar derivative = this.derivativeMap.get(value)\r\n\t\t\t\tif (derivative == null) {\r\n\t\t\t\t\tthis.derivativeMap.set(value, derivative = deepCopy(value, undefined, this.derivativeMap))\r\n\t\t\t\t}\r\n\t\t\t\treturn derivative\r\n\t\t\t},\r\n\t\t\tsave: function() {\r\n\t\t\t\t// copy back to the original object\r\n\t\t\t\tvar original = this.copiedFrom.valueOf()\r\n\t\t\t\tvar newCopiedFrom = deepCopy(this.valueOf(), original)\r\n\t\t\t\tif (original !== newCopiedFrom) {\r\n\t\t\t\t\t// if we have replaced it with a new object/value, put it\r\n\t\t\t\t\tthis.copiedFrom.put && this.copiedFrom.put(newCopiedFrom)\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// else we have modified an existing object, but we still need to notify\r\n\t\t\t\t\tif (this.copiedFrom.notifies && this.copiedFrom.updated) { // copiedFrom doesn't have to be a variable, it can be a plain object\r\n\t\t\t\t\t\tthis.copiedFrom.updated()\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tthis.isDirty.put(false)\r\n\t\t\t\tthis.onSave && this.onSave()\r\n\t\t\t},\r\n\t\t\trevert: function() {\r\n\t\t\t\tvar original = this.copiedFrom.valueOf()\r\n\t\t\t\tthis.put(deepCopy(original, this.derivativeMap.get(original), this.derivativeMap))\r\n\t\t\t\tthis.isDirty.put(false)\r\n\t\t\t},\r\n\t\t\tupdated: function() {\r\n\t\t\t\tthis.isDirty.put(true)\r\n\t\t\t\treturn Variable.prototype.updated.apply(this, arguments)\r\n\t\t\t}\r\n\t\t})\r\n\t\treturn Copy\r\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** index.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap e8361cc7919b48750685\n **/","/// <reference path=\"./typing.d.ts\" />\r\ndefine(['./Element', './Variable', './react', './Renderer', './operators', './Copy'], function(Element, Variable, react, Renderer, operators, Copy) {\r\n\tvar main = Object.create(Element)\r\n\tmain.Copy = Copy\r\n\tmain.Element = Element\r\n\tmain.Variable = Variable\r\n\tmain.all = Variable.all\r\n\tmain.react = react\r\n\tmain.spawn = function(func) {\r\n\t\treturn react(func).valueOf()\r\n\t}\r\n\tmain.Renderer = Renderer\r\n\tObject.assign(main, Renderer)\r\n\tObject.assign(main, operators)\r\n\treturn main\r\n})\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./index.js\n ** module id = 0\n ** module chunks = 0\n **/","define(['./Variable', './Renderer', './util/lang'], function (Variable, Renderer, lang) {\r\n\tvar knownElementProperties = {};\r\n\t['textContent', 'innerHTML', 'title', 'href', 'value', 'valueAsNumber', 'role', 'render'].forEach(function(property) {\r\n\t\tknownElementProperties[property] = true\r\n\t})\r\n\r\n\tvar SELECTOR_REGEX = /(\\.|#)([-\\w]+)(.+)?/\r\n\tfunction isGenerator(func) {\r\n\t\tif (typeof func === 'function') {\r\n\t\t\tvar constructor = func.constructor\r\n\t\t\treturn (constructor.displayName || constructor.name) === 'GeneratorFunction'\r\n\t\t}\r\n\t}\r\n\tfunction Context(subject){\r\n\t\tthis.subject = subject\r\n\t}\r\n\r\n\tvar PropertyRenderer = Renderer.PropertyRenderer\r\n\tvar InputPropertyRenderer = Renderer.InputPropertyRenderer\r\n\tvar AttributeRenderer = Renderer.AttributeRenderer\r\n\tvar StyleRenderer = lang.compose(Renderer.StyleRenderer, function StyleRenderer() {\r\n\t\tRenderer.StyleRenderer.apply(this, arguments)\r\n\t}, {\r\n\t\trenderUpdate: function(newValue, element) {\r\n\t\t\tvar definition = styleDefinitions[this.name]\r\n\t\t\tif (definition) {\r\n\t\t\t\tdefinition(element, newValue, this.name)\r\n\t\t\t} else {\r\n\t\t\t\telement.style[this.name] = newValue\r\n\t\t\t}\r\n\t\t}\r\n\t})\r\n\r\n\tvar ClassNameRenderer = lang.compose(Renderer.ElementRenderer, function ClassNameRenderer(options) {\r\n\t\tthis.className = options.className\r\n\t\tRenderer.apply(this, arguments)\r\n\t}, {\r\n\t\trenderUpdate: function(newValue, element) {\r\n\t\t\tvar currentClassName = element.className\r\n\t\t\tvar changingClassName = this.className\r\n\t\t\t// remove the className (needed for addition or removal)\r\n\t\t\t// see http://jsperf.com/remove-class-name-algorithm/2 for some tests on this\r\n\t\t\tvar removed = currentClassName && (' ' + currentClassName + ' ').replace(' ' + changingClassName + ' ', ' ')\r\n\t\t\tif (newValue) {\r\n\t\t\t\t// addition, add the className\r\n\t\t\t\tchangingClassName = currentClassName ? (removed + changingClassName).slice(1) : changingClassName;\r\n\t\t\t} else {\r\n\t\t\t\t// we already have removed the class, just need to trim\r\n\t\t\t\tchangingClassName = removed.slice(1, removed.length - 1)\r\n\t\t\t}\r\n\t\t\t// only assign if it changed, this can save a lot of time\r\n\t\t\tif (changingClassName != currentClassName) {\r\n\t\t\t\telement.className = changingClassName\r\n\t\t\t}\r\n\t\t}\r\n\t})\r\n\r\n\t// TODO: check for renderContent with text updater\r\n\tvar TextRenderer = Renderer.TextRenderer\r\n\tvar ListRenderer = Renderer.ListRenderer\r\n\t\r\n\tvar toAddToElementPrototypes = []\r\n\tvar createdBaseElements = []\r\n\tvar doc = typeof document !== 'undefined' ? document : {\r\n\t\tcreateElement: function(tag) {\r\n\t\t\treturn {}\r\n\t\t},\r\n\t\taddEventListener: function() {\r\n\t\t}\r\n\t}\r\n\r\n\tvar testStyle = doc.createElement('div').style\r\n\tvar childTagForParent = {\r\n\t\tTABLE: ['tr','td'],\r\n\t\tTBODY: ['tr','td'],\r\n\t\tTR: 'td',\r\n\t\tUL: 'li',\r\n\t\tOL: 'li',\r\n\t\tSELECT: 'option'\r\n\t}\r\n\tvar inputs = {\r\n\t\tINPUT: 1,\r\n\t\tTEXTAREA: 1\r\n\t\t// SELECT: 1, we exclude this, so the default \"content\" of the element can be the options\r\n\t}\r\n\r\n\tfunction booleanStyle(options) {\r\n\t\treturn function(element, value, key) {\r\n\t\t\tif (typeof value === 'boolean') {\r\n\t\t\t\t// has a boolean conversion\r\n\t\t\t\tvalue = options[value ? 0 : 1]\r\n\t\t\t}\r\n\t\t\telement.style[key] = value\r\n\t\t}\r\n\t}\r\n\r\n\tfunction defaultStyle(element, value, key) {\r\n\t\tif (typeof value === 'number') {\r\n\t\t\tvalue = value + 'px'\r\n\t\t}\r\n\t\telement.style[key] = value\r\n\t}\r\n\tfunction directStyle(element, value, key) {\r\n\t\telement.style[key] = value\r\n\t}\r\n\r\n\tvar styleDefinitions = {\r\n\t\tdisplay: booleanStyle(['initial', 'none']),\r\n\t\tvisibility: booleanStyle(['visible', 'hidden']),\r\n\t\tcolor: directStyle,\r\n\t\topacity: directStyle,\r\n\t\tzoom: directStyle,\r\n\t\tminZoom: directStyle,\r\n\t\tmaxZoom: directStyle,\r\n\t\tfontWeight: directStyle,\r\n\t\tposition: booleanStyle(['absolute', '']),\r\n\t\ttextDecoration: booleanStyle(['underline', '']),\r\n\t\tfontWeight: booleanStyle(['bold', 'normal'])\r\n\t}\r\n\t;[\"alignContent\",\"alignItems\",\"alignSelf\",\"animation\",\"animationDelay\",\"animationDirection\",\"animationDuration\",\"animationFillMode\",\"animationIterationCount\",\"animationName\",\"animationPlayState\",\"animationTimingFunction\",\"backfaceVisibility\",\"background\",\"backgroundAttachment\",\"backgroundBlendMode\",\"backgroundClip\",\"backgroundColor\",\"backgroundImage\",\"backgroundOrigin\",\"backgroundPosition\",\"backgroundPositionX\",\"backgroundPositionY\",\"backgroundRepeat\",\"backgroundRepeatX\",\"backgroundRepeatY\",\"backgroundSize\",\"baselineShift\",\"border\",\"borderBottom\",\"borderBottomColor\",\"borderBottomLeftRadius\",\"borderBottomRightRadius\",\"borderBottomStyle\",\"borderBottomWidth\",\"borderCollapse\",\"borderColor\",\"borderImage\",\"borderImageOutset\",\"borderImageRepeat\",\"borderImageSlice\",\"borderImageSource\",\"borderImageWidth\",\"borderLeft\",\"borderLeftColor\",\"borderLeftStyle\",\"borderLeftWidth\",\"borderRadius\",\"borderRight\",\"borderRightColor\",\"borderRightStyle\",\"borderRightWidth\",\"borderSpacing\",\"borderStyle\",\"borderTop\",\"borderTopColor\",\"borderTopLeftRadius\",\"borderTopRightRadius\",\"borderTopStyle\",\"borderTopWidth\",\"borderWidth\",\"bottom\",\"boxShadow\",\"boxSizing\",\"bufferedRendering\",\"captionSide\",\"clear\",\"clip\",\"clipPath\",\"clipRule\",\"color\",\"colorInterpolation\",\"colorInterpolationFilters\",\"colorRendering\",\"counterIncrement\",\"counterReset\",\"cursor\",\"direction\",\"display\",\"emptyCells\",\"fill\",\"fillOpacity\",\"fillRule\",\"filter\",\"flex\",\"flexBasis\",\"flexDirection\",\"flexFlow\",\"flexGrow\",\"flexShrink\",\"flexWrap\",\"float\",\"floodColor\",\"floodOpacity\",\"font\",\"fontFamily\",\"fontFeatureSettings\",\"fontKerning\",\"fontSize\",\"fontStretch\",\"fontStyle\",\"fontVariant\",\"fontVariantLigatures\",\"fontWeight\",\"height\",\"imageRendering\",\"isolation\",\"justifyContent\",\"left\",\"letterSpacing\",\"lightingColor\",\"lineHeight\",\"listStyle\",\"listStyleImage\",\"listStylePosition\",\"listStyleType\",\"margin\",\"marginBottom\",\"marginLeft\",\"marginRight\",\"marginTop\",\"marker\",\"markerEnd\",\"markerMid\",\"markerStart\",\"mask\",\"maskType\",\"maxHeight\",\"maxWidth\",\"maxZoom\",\"minHeight\",\"minWidth\",\"minZoom\",\"mixBlendMode\",\"motion\",\"motionOffset\",\"motionPath\",\"motionRotation\",\"objectFit\",\"objectPosition\",\"opacity\",\"order\",\"orientation\",\"orphans\",\"outline\",\"outlineColor\",\"outlineOffset\",\"outlineStyle\",\"outlineWidth\",\"overflow\",\"overflowWrap\",\"overflowX\",\"overflowY\",\"padding\",\"paddingBottom\",\"paddingLeft\",\"paddingRight\",\"paddingTop\",\"page\",\"pageBreakAfter\",\"pageBreakBefore\",\"pageBreakInside\",\"paintOrder\",\"perspective\",\"perspectiveOrigin\",\"pointerEvents\",\"position\",\"quotes\",\"resize\",\"right\",\"shapeImageThreshold\",\"shapeMargin\",\"shapeOutside\",\"shapeRendering\",\"size\",\"speak\",\"src\",\"stopColor\",\"stopOpacity\",\"stroke\",\"strokeDasharray\",\"strokeDashoffset\",\"strokeLinecap\",\"strokeLinejoin\",\"strokeMiterlimit\",\"strokeOpacity\",\"strokeWidth\",\"tabSize\",\"tableLayout\",\"textAlign\",\"textAlignLast\",\"textAnchor\",\"textCombineUpright\",\"textDecoration\",\"textIndent\",\"textOrientation\",\"textOverflow\",\"textRendering\",\"textShadow\",\"textTransform\",\"top\",\"touchAction\",\"transform\",\"transformOrigin\",\"transformStyle\",\"transition\",\"transitionDelay\",\"transitionDuration\",\"transitionProperty\",\"transitionTimingFunction\",\"unicodeBidi\",\"unicodeRange\",\"userZoom\",\"vectorEffect\",\"verticalAlign\",\"visibility\",\"whiteSpace\",\"widows\",\"width\",\"willChange\",\"wordBreak\",\"wordSpacing\",\"wordWrap\",\"writingMode\",\"zIndex\",\"zoom\"].forEach(function(property) {\r\n\t\tstyleDefinitions[property] = styleDefinitions[property] || defaultStyle\r\n\t})\r\n\tvar styleSheet\r\n\tvar presumptiveParentMap = new WeakMap()\r\n\r\n\tvar setPrototypeOf = Object.setPrototypeOf || (function(base, proto) { base.__proto__ = proto})\r\n\tvar getPrototypeOf = Object.getPrototypeOf || (function(base) { return base.__proto__ })\r\n\tfunction createCssRule(selector) {\r\n\t\tif (!styleSheet) {\r\n\t\t\tvar styleSheetElement = doc.createElement(\"style\")\r\n\t\t\tstyleSheetElement.setAttribute(\"type\", \"text/css\")\r\n//\t\t\tstyleSheet.appendChild(doc.createTextNode(css))\r\n\t\t\tdoc.head.insertBefore(styleSheetElement, doc.head.firstChild)\r\n\t\t\tstyleSheet = styleSheetElement.sheet\r\n\t\t}\r\n\t\tvar cssRules = styleSheet.cssRules || styleSheet.rules\r\n\t\treturn cssRules[styleSheet.addRule(selector, ' ', cssRules.length)]\r\n\t}\r\n\tvar invalidatedElements = new WeakMap(null, 'invalidated')\r\n\tvar queued\r\n\r\n\tvar toRender = []\r\n\tfunction flatten(target, part) {\r\n\t\tvar base = target.base\r\n\t\tif (base) {\r\n\t\t\tvar basePart = base[part]\r\n\t\t\tif (basePart) {\r\n\t\t\t\ttarget[part] || target[part]\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction layoutChildren(parent, children, container, prepend) {\r\n\t\tvar fragment = (children.length > 3 || prepend) ? doc.createDocumentFragment() : parent\r\n\t\tfor(var i = 0, l = children.length; i < l; i++) {\r\n\t\t\tvar child = children[i]\r\n\t\t\tvar childNode\r\n\t\t\tif (child && child.create) {\r\n\t\t\t\t// an element constructor\r\n\t\t\t\tcurrentParent = parent\r\n\t\t\t\tchildNode = child.create()\r\n\t\t\t\tfragment.appendChild(childNode)\r\n\t\t\t\tif (child.isContentNode) {\r\n\t\t\t\t\tcontainer.contentNode = childNode\r\n\t\t\t\t}\r\n\t\t\t} else if (typeof child == 'function') {\r\n\t\t\t\t// TODO: reenable this\r\n//\t\t\t\tif (child.for) {\r\n\t\t\t\t\t// a variable constructor that can be contextualized\r\n\t//\t\t\t\tfragment.appendChild(variableAsText(parent, child))\r\n\t\t//\t\t} else {\r\n\t\t\t\t\t// an element constructor\r\n\t\t\t\t\tchildNode = new child()\r\n\t\t\t\t\tfragment.appendChild(childNode)\r\n\t\t\t//\t}\r\n\t\t\t} else if (typeof child == 'object') {\r\n\t\t\t\tif (child instanceof Array) {\r\n\t\t\t\t\t// array of sub-children\r\n\t\t\t\t\tcontainer = container || parent\r\n\t\t\t\t\tchildNode = childNode || parent\r\n\t\t\t\t\tlayoutChildren(childNode.contentNode || childNode, child, container)\r\n\t\t\t\t} else if (child.notifies) {\r\n\t\t\t\t\t// a variable\r\n\t\t\t\t\tfragment.appendChild(childNode = variableAsText(parent, child))\r\n\t\t\t\t} else if (child.nodeType) {\r\n\t\t\t\t\t// an element itself\r\n\t\t\t\t\tfragment.appendChild(childNode = child)\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// TODO: apply properties to last child, but with binding to the parent (for events)\r\n\t\t\t\t\tthrow new Error('Unknown child type ' + child)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t// a primitive value\r\n\t\t\t\tchildNode = doc.createTextNode(child)\r\n\t\t\t\tfragment.appendChild(childNode)\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (fragment != parent) {\r\n\t\t\tif (prepend) {\r\n\t\t\t\tparent.insertBefore(fragment, parent.firstChild)\r\n\t\t\t} else {\r\n\t\t\t\tparent.appendChild(fragment)\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn childNode\r\n\t}\r\n\tfunction variableAsText(parent, content) {\r\n\t\tif (content == null) {\r\n\t\t\treturn doc.createTextNode('')\r\n\t\t}\r\n\t\tvar text\r\n\t\ttry {\r\n\t\t\ttext = content.valueOf(new Context(parent))\r\n\t\t} catch (error) {\r\n\t\t\ttext = error.stack\r\n\t\t}\r\n\t\tvar textNode = doc.createTextNode(text)\r\n\t\tif (content.notifies) {\r\n\t\t\tenterRenderer(TextRenderer, {\r\n\t\t\t\telement: parent,\r\n\t\t\t\ttextNode: textNode,\r\n\t\t\t\tvariable: content\r\n\t\t\t})\r\n\t\t}\r\n\t\treturn textNode\r\n\t}\r\n\r\n\tfunction bidirectionalHandler(element, value, key) {\r\n\t\tif (value && value.notifies) {\r\n\t\t\tenterRenderer(InputPropertyRenderer, {\r\n\t\t\t\tname: key,\r\n\t\t\t\tvariable: value,\r\n\t\t\t\telement: element\r\n\t\t\t})\r\n\t\t\tif (inputs[element.tagName] || element.tagName === 'SELECT') {\r\n\t\t\t\tbindChanges(element, value, key)\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (element.tagName === 'SELECT' && key === 'value') {\r\n\t\t\t\t// use the deferred <select> value assignment\r\n\t\t\t\tInputPropertyRenderer.prototype.renderSelectValueUpdate(value, element)\r\n\t\t\t} else {\r\n\t\t\t\tInputPropertyRenderer.prototype.renderUpdate(value, element)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction noop() {}\r\n\tvar propertyHandlers = {\r\n\t\tcontent: noop, // content and children have special handling in create\r\n\t\tchildren: noop,\r\n\t\ttagName: noop,\r\n\t\teach: noop, // just used by content, doesn't need to be recorded on the element\r\n\t\tclasses: function(element, classes) {\r\n\t\t\tif (!(classes.length > -1)) {\r\n\t\t\t\t// index the classes, if necessary\r\n\t\t\t\tvar i = 0\r\n\t\t\t\tfor (var key in classes) {\r\n\t\t\t\t\tif (!classes[i]) {\r\n\t\t\t\t\t\tclasses[i] = key\r\n\t\t\t\t\t}\r\n\t\t\t\t\ti++\r\n\t\t\t\t}\r\n\t\t\t\tclasses.length = i\r\n\t\t\t}\r\n\t\t\tfor (var i = 0, l = classes.length; i < l; i++) {\r\n\t\t\t\t// find each class name\r\n\t\t\t\tvar className = classes[i]\r\n\t\t\t\tvar flag = classes[className]\r\n\t\t\t\tif (flag && flag.notifies) {\r\n\t\t\t\t\t// if it is a variable, we react to it\r\n\t\t\t\t\tenterRenderer(ClassNameRenderer, {\r\n\t\t\t\t\t\telement: element,\r\n\t\t\t\t\t\tclassName: className,\r\n\t\t\t\t\t\tvariable: flag\r\n\t\t\t\t\t})\r\n\t\t\t\t} else if (flag || flag === undefined) {\r\n\t\t\t\t\telement.className += ' ' + className\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tclass: applyAttribute,\r\n\t\tfor: applyAttribute,\r\n\t\trole: applyAttribute,\r\n\t\trender: function(element, value, key, properties) {\r\n\t\t\t// TODO: This doesn't need to be a property updater\r\n\t\t\t// we should also verify it is a generator\r\n\t\t\t// and maybe, at some point, find an optimization to eliminate the bind()\r\n\t\t\tenterRenderer(PropertyRenderer, {\r\n\t\t\t\tname: key,\r\n\t\t\t\tvariable: new Variable.GeneratorVariable(value.bind(element, properties)),\r\n\t\t\t\telement: element\r\n\t\t\t})\r\n\t\t},\r\n\t\tvalue: bidirectionalHandler,\r\n\t\tvalueAsNumber: bidirectionalHandler,\r\n\t\tvalueAsDate: bidirectionalHandler,\r\n\t\tchecked: bidirectionalHandler,\r\n\t\tdataset: applySubProperties(function(newValue, element, key) {\r\n\t\t\telement.dataset[key || this.name] = newValue\r\n\t\t}),\r\n\t\tattributes: applySubProperties(function(newValue, element, key) {\r\n\t\t\telement.setAttribute(key || this.name, newValue)\r\n\t\t}),\r\n\t\tstyle: function(element, value, key) {\r\n\t\t\tif (typeof value === 'string') {\r\n\t\t\t\telement.setAttribute('style', value)\r\n\t\t\t} else if (value && value.notifies) {\r\n\t\t\t\tenterRenderer(AttributeRenderer, {\r\n\t\t\t\t\tname: 'style',\r\n\t\t\t\t\tvariable: value,\r\n\t\t\t\t\telment: element\r\n\t\t\t\t})\r\n\t\t\t} else {\r\n\t\t\t\tstyleObjectHandler(element, value, key)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfunction applyAttribute(element, value, key) {\r\n\t\tif (value && value.notifies) {\r\n\t\t\tenterRenderer(AttributeRenderer, {\r\n\t\t\t\tname: key,\r\n\t\t\t\tvariable: value,\r\n\t\t\t\telement: element\r\n\t\t\t})\r\n\t\t} else {\r\n\t\t\telement.setAttribute(key, value)\r\n\t\t}\r\n\t}\r\n\r\n\tvar styleObjectHandler = applySubProperties(function(newValue, element, key) {\r\n\t\telement.style[key || this.name] = newValue\r\n\t})\r\n\r\n\tfunction applySubProperties(renderer) {\r\n\t\tvar SubPropertyRenderer = lang.compose(PropertyRenderer, function SubPropertyRenderer(options) {\r\n\t\t\tPropertyRenderer.apply(this, arguments)\r\n\t\t}, {\r\n\t\t\trenderUpdate: renderer\r\n\t\t})\t\r\n\t\treturn function(element, value, key) {\r\n\t\t\tvar target = element[key]\r\n\t\t\tfor (var subKey in value) {\r\n\t\t\t\tvar subValue = value[subKey]\r\n\t\t\t\tif (subValue && subValue.notifies) {\r\n\t\t\t\t\tenterRenderer(SubPropertyRenderer, {\r\n\t\t\t\t\t\tname: subKey,\r\n\t\t\t\t\t\tvariable: subValue,\r\n\t\t\t\t\t\telement: element\r\n\t\t\t\t\t})\r\n\t\t\t\t} else {\r\n\t\t\t\t\trenderer(subValue, element, subKey)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction applyProperties(element, properties) {\r\n\t\tfor (var key in properties) {\r\n\t\t\tvar value = properties[key]\r\n\t\t\tvar styleDefinition = styleDefinitions[key]\r\n\t\t\tif (propertyHandlers[key]) {\r\n\t\t\t\tpropertyHandlers[key](element, value, key, properties)\r\n\t\t\t} else if ((styleDefinition = styleDefinitions[key]) && element[key] === undefined) {\r\n\t\t\t\tif (value && value.notifies) {\r\n\t\t\t\t\tenterRenderer(StyleRenderer, {\r\n\t\t\t\t\t\tname: key,\r\n\t\t\t\t\t\tvariable: value,\r\n\t\t\t\t\t\telement: element\r\n\t\t\t\t\t})\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstyleDefinition(element, value, key)\r\n\t\t\t\t}\r\n\t\t\t} else if (value && value.notifies) {\r\n\t\t\t\tenterRenderer(PropertyRenderer, {\r\n\t\t\t\t\tname: key,\r\n\t\t\t\t\tvariable: value,\r\n\t\t\t\t\telement: element\r\n\t\t\t\t})\r\n\t\t\t} else if (typeof value === 'function' && key.slice(0, 2) === 'on') {\r\n\t\t\t\telement.addEventListener(key.slice(2), value)\r\n\t\t\t} else {\r\n\t\t\t\telement[key] = value\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction applySelector(element, selector) {\r\n\t\tselector.replace(/(\\.|#)?(\\w+)/g, function(t, operator, name) {\r\n\t\t\tif (operator == '.') {\r\n\t\t\t\telement._class = (element._class ? element._class + ' ' : '') + name\r\n\t\t\t} else if (operator == '#') {\r\n\t\t\t\telement._id = name\r\n\t\t\t} else {\r\n\t\t\t\telement._tag = name\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n\r\n\tnextClassId = 1\r\n\tuniqueSelectors = {}\r\n\tfunction getUniqueSelector(element) {\r\n\t\tvar selector = element.hasOwnProperty('_uniqueSelector') ? element._uniqueSelector :\r\n\t\t\t(element._tag + (element._class ? '.' + element._class.replace(/\\s+/g, '.') : '') +\r\n\t\t\t(element._id ? '#' + element._id : ''))\r\n\t\tif (!selector.match(/[#\\.-]/)) {\r\n\t\t\tif (uniqueSelectors[selector]) {\r\n\t\t\t\telement._class = '.x-' + nextClassId++\r\n\t\t\t\tselector = getUniqueSelector(element)\r\n\t\t\t} else {\r\n\t\t\t\tuniqueSelectors[selector] = selector\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn selector\r\n\t}\r\n\r\n\tfunction buildContent(element, content, key, properties) {\r\n\t\tvar each = element.each || properties.each\r\n\t\tif (each && content) {\r\n\t\t\t// render as list\r\n\t\t\tif (each.create) {\r\n\t\t\t\tvar ItemClass = element.itemAs || Item\r\n\t\t\t\thasOwn(each, ItemClass, function (element) {\r\n\t\t\t\t\tvar itemVariable = ItemClass.for(element._item)\r\n\t\t\t\t\titemVariable.collection = content\r\n\t\t\t\t\treturn itemVariable\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tif (content.notifies) {\r\n\t\t\t\tenterRenderer(ListRenderer, {\r\n\t\t\t\t\teach: each,\r\n\t\t\t\t\tvariable: content,\r\n\t\t\t\t\telement: element\r\n\t\t\t\t})\r\n\t\t\t} else {\r\n\t\t\t\tvar fragment = doc.createDocumentFragment()\r\n\t\t\t\tcontent.forEach(function(item) {\r\n\t\t\t\t\tif (each.create) {\r\n\t\t\t\t\t\tchildElement = each.create({parent: element, _item: item}) // TODO: make a faster object here potentially\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tchildElement = each(item, element)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfragment.appendChild(childElement)\r\n\t\t\t\t})\r\n\t\t\t\telement.appendChild(fragment)\r\n\t\t\t}\r\n\t\t} else if (inputs[element.tagName]) {\r\n\t\t\t// render into input\r\n\t\t\tbuildInputContent(element, content)\r\n\t\t} else if (content instanceof Array) {\r\n\t\t\t// treat array as children (potentially of the content node)\r\n\t\t\telement = element.contentNode || element\r\n\t\t\tlayoutChildren(element, content, element)\r\n\t\t} else {\r\n\t\t\t// render as string\r\n\t\t\telement.appendChild(variableAsText(element, content))\r\n\t\t}\r\n\t}\r\n\r\n\tfunction bindChanges(element, variable, key, conversion) {\r\n\t\tlang.nextTurn(function() { // wait for next turn in case inputChanges isn't set yet\r\n\t\t\tvar inputEvents = element.inputEvents || ['change', 'alkali-change']\r\n\t\t\tfor (var i = 0, l = inputEvents.length; i < l; i++) {\r\n\t\t\t\telement.addEventListener(inputEvents[i], function (event) {\r\n\t\t\t\t\tvar value = element[key]\r\n\t\t\t\t\tvar result = variable.put(conversion ? conversion(value, element) : value, new Context(element))\r\n\t\t\t\t\tif (result === Variable.deny) {\r\n\t\t\t\t\t\tthrow new Error('Variable change denied')\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n\r\n\tdoc.addEventListener('click', function(event) {\r\n\t\tvar target = event.target\r\n\t\tif (target.type === 'radio') {\r\n\t\t\tvar radios = doc.querySelectorAll('input[type=radio]')\r\n\t\t\tfor (var i = 0, l = radios.length; i < l; i++) {\r\n\t\t\t\tvar radio = radios[i]\r\n\t\t\t\tif (radio.name === target.name && radio !== target) {\r\n\t\t\t\t\tradio.dispatchEvent(new Event('alkali-change', {}))\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t})\r\n\r\n\tfunction conversion(value, element) {\r\n\t\tif (element.type == 'number') {\r\n\t\t\treturn parseFloat(value)\r\n\t\t}\r\n\t\treturn value\r\n\t}\r\n\r\n\tfunction buildInputContent(element, content) {\r\n\t\tvar inputType = element.type\r\n\t\tvar inputProperty = inputType in {date: 1, datetime: 1, time: 1} ?\r\n\t\t\t\t'valueAsDate' : (inputType === 'checkbox' || inputType === 'radio') ?\r\n\t\t\t\t\t'checked' : 'value'\r\n\r\n\t\tif (content && content.notifies) {\r\n\t\t\t// a variable, respond to changes\r\n\t\t\tenterRenderer(InputPropertyRenderer, {\r\n\t\t\t\tvariable: content,\r\n\t\t\t\tname: inputProperty,\r\n\t\t\t\telement: element\r\n\t\t\t})\r\n\t\t\t// and bind the other way as well, updating the variable in response to input changes\r\n\t\t\tbindChanges(element, content, inputProperty, conversion)\r\n\t\t} else {\r\n\t\t\t// primitive\r\n\t\t\telement[inputProperty] = content\r\n\t\t}\r\n\t}\r\n\tvar classHandlers = {\r\n\t\thasOwn: function(Element, value) {\r\n\t\t\thasOwn(Element, value)\r\n\t\t}\r\n\t}\r\n\r\n\tfunction applyToClass(value, Element) {\r\n\t\tvar applyOnCreate = Element._applyOnCreate\r\n\t\tvar prototype = Element.prototype\r\n\t\tif (value && typeof value === 'object') {\r\n\t\t\tif (value instanceof Array || value.notifies) {\r\n\t\t\t\tapplyOnCreate.content = value\r\n\t\t\t} else {\r\n\t\t\t\tfor (var key in value) {\r\n\t\t\t\t// TODO: eventually we want to be able to set these as rules statically per element\r\n\t\t\t\t/*if (styleDefinitions[key]) {\r\n\t\t\t\t\tvar styles = Element.styles || (Element.styles = [])\r\n\t\t\t\t\tstyles.push(key)\r\n\t\t\t\t\tstyles[key] = descriptor.value\r\n\t\t\t\t} else {*/\r\n\t\t\t\t\tif (classHandlers[key]) {\r\n\t\t\t\t\t\thasOwn(Element, value[key])\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// TODO: do deep merging of styles and classes, but not variables\r\n\t\t\t\t\t\tapplyOnCreate[key] = value[key]\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (typeof value === 'function' && !value.for) {\r\n\t\t\tthrow new TypeError('Function as argument not supported')\r\n\t\t} else {\r\n\t\t\tapplyOnCreate.content = value\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getApplySet(Class) {\r\n\t\tif (Class.hasOwnProperty('_applyOnCreate')) {\r\n\t\t\treturn Class._applyOnCreate\r\n\t\t}\r\n\t\t// this means we didn't extend and evaluate the prototype yet\r\n\t\tif (Class.getForClass) {\r\n\t\t\t// we are extending an alkali constructor\r\n\t\t\t// if this class is inheriting from an alkali constructor, work our way up the chain\r\n\t\t\tapplyOnCreate = Class._applyOnCreate = {}\r\n\t\t\tvar parentApplySet = getApplySet(getPrototypeOf(Class))\r\n\t\t\tfor (var key in parentApplySet) {\r\n\t\t\t\tapplyOnCreate[key] = parentApplySet[key]\r\n\t\t\t}\r\n\t\t\t// we need to check the prototype for event handlers\r\n\t\t\tvar prototype = Class.prototype\r\n\t\t\tvar keys = Object.getOwnPropertyNames(prototype)\r\n\t\t\tfor (var i = 0, l = keys.length; i < l; i++) {\r\n\t\t\t\tvar key = keys[i]\r\n\t\t\t\tif (key.slice(0, 2) === 'on' || (key === 'render' && isGenerator(prototype[key]))) {\r\n\t\t\t\t\tapplyOnCreate[key] = prototype[key]\r\n\t\t\t\t} else if (key.slice(0, 6) === 'render') {\r\n\t\t\t\t\tObject.defineProperty(prototype, key[6].toLowerCase() + key.slice(7), renderDescriptor(key))\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn applyOnCreate\r\n\t\t}\r\n\t\treturn null\r\n\t}\r\n\r\n\tfunction renderDescriptor(renderMethod) {\r\n\t\tvar map = new WeakMap()\r\n\t\treturn {\r\n\t\t\tget: function() {\r\n\t\t\t\treturn map.has(this) ? map.get(this) : null\r\n\t\t\t},\r\n\t\t\tset: function(value) {\r\n\t\t\t\tmap.set(this, value)\r\n\t\t\t\tthis[renderMethod](value)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction makeElementConstructor() {\r\n\t\tfunction Element(selector, properties) {\r\n\t\t\tif (this instanceof Element){\r\n\t\t\t\t// create DOM element\r\n\t\t\t\t// Need to detect if we have registered the element and `this` is actually already the correct instance\r\n\t\t\t\treturn create.apply(Element.prototype === getPrototypeOf(this) ? Element :// this means it is from this constructor\r\n\t\t\t\t\tthis.constructor, // this means it was constructed from a subclass\r\n\t\t\t\t\targuments)\r\n\t\t\t} else {\r\n\t\t\t\t// extend to create new class\r\n\t\t\t\treturn withProperties.apply(Element, arguments)\r\n\t\t\t}\r\n\t\t}\r\n\t\tElement.create = create\r\n\t\tElement.with = withProperties\r\n\t\tElement.for = forTarget\r\n\t\tElement.property = propertyForElement\r\n\t\tElement.getForClass = getForClass\r\n\t\treturn Element\r\n\t}\r\n\r\n\tfunction withProperties(selector, properties) {\r\n\t\tvar Element = makeElementConstructor()\r\n\t\tElement.superConstructor = this\r\n\t\tElement.tagName = this.tagName\r\n\t\tif (this.children) {\r\n\t\t\t// just copy this property\r\n\t\t\tElement.children = this.children\r\n\t\t}\r\n\t\tvar prototype = Element.prototype = this.prototype\r\n\r\n\t\tvar hasOwnApplySet\r\n\t\tvar applyOnCreate = Element._applyOnCreate = {}\r\n\t\tvar parentApplySet = getApplySet(this)\r\n\t\t// copy parent properties\r\n\t\tfor (var key in parentApplySet) {\r\n\t\t\tapplyOnCreate[key] = parentApplySet[key]\r\n\t\t}\r\n\r\n\t\tvar i = 0 // for arguments\r\n\t\tif (typeof selector === 'string') {\r\n\t\t\tvar selectorMatch = selector.match(SELECTOR_REGEX)\r\n\t\t\tif (selectorMatch) {\r\n\t\t\t\tdo {\r\n\t\t\t\t\tvar operator = selectorMatch[1]\r\n\t\t\t\t\tvar name = selectorMatch[2]\r\n\t\t\t\t\tif (operator == '.') {\r\n\t\t\t\t\t\tif (applyOnCreate.className) {\r\n\t\t\t\t\t\t\tapplyOnCreate.className += ' ' + name\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tapplyOnCreate.className = name\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tapplyOnCreate.id = name\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar remaining = selectorMatch[3]\r\n\t\t\t\t\tselectorMatch = remaining && remaining.match(SELECTOR_REGEX)\r\n\t\t\t\t} while (selectorMatch)\r\n\t\t\t} else {\r\n\t\t\t\tapplyOnCreate.content = selector\r\n\t\t\t}\r\n\t\t\ti++ // skip the first argument\r\n\t\t}\r\n\r\n\t\tfor (var l = arguments.length; i < l; i++) {\r\n\t\t\tapplyToClass(arguments[i], Element)\r\n\t\t}\r\n\t\treturn Element\r\n\t}\r\n\tvar currentParent\r\n\tfunction create(selector, properties) {\r\n\t\t// TODO: make this a symbol\r\n\t\tvar applyOnCreate = getApplySet(this)\r\n\t\tif (currentParent) {\r\n\t\t\tvar parent = currentParent\r\n\t\t\tcurrentParent = null\r\n\t\t}\r\n/*\t\tif (this._initialized != this) {\r\n\t\t\tthis._initialized = this\r\n\t\t\tthis.initialize && this.initialize()\r\n\t\t\tvar styles = this.styles\r\n\t\t\tif (styles) {\r\n\t\t\t\tvar rule = createCssRule(getUniqueSelector(this))\r\n\t\t\t\tfor (var i = 0, l = styles.length; i < l; i++) {\r\n\t\t\t\t\tvar key = styles[i]\r\n\t\t\t\t\tvar value = styles[key]\r\n\t\t\t\t\t// TODO: if it is a contextualized variable, do this on the element\r\n\t\t\t\t\tvar styleDefinition = styleDefinitions[key]\r\n\t\t\t\t\tif (styleDefinition) {\r\n\t\t\t\t\t\tstyleDefinition(rule, value, key)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!this.hasOwnProperty('_applyOnCreate')) {\r\n\t\t\t\tapplyOnCreate = getApplySet(this)\r\n\t\t\t}\r\n\t\t}*/\r\n\t\tvar element = doc.createElement(this.tagName)\r\n\t\tif (selector && selector.parent) {\r\n\t\t\tparent = selector.parent\r\n\t\t}\r\n\t\tif (parent) {\r\n\t\t\tpresumptiveParentMap.set(element, parent)\r\n\t\t}\r\n\t\tif (!(element instanceof this)) {\r\n\t\t\t// ideally we want to avoid this call, as it is expensive, but for classes that\r\n\t\t\t// don't register a tag name, we have to make sure the prototype chain is correct\r\n\t\t\tsetPrototypeOf(element, this.prototype)\r\n\t\t}\r\n\t\tif (element.constructor != this) {\r\n\t\t\telement.constructor = this // need to do this for hasOwn contextualization to work\r\n\t\t}\r\n\t\tif (arguments.length > 0) {\r\n\t\t\t// copy applyOnCreate when we have arguments\r\n\t\t\tvar ElementApplyOnCreate = applyOnCreate\r\n\t\t\tapplyOnCreate = {}\r\n\t\t\tfor (var key in ElementApplyOnCreate) {\r\n\t\t\t\tapplyOnCreate[key] = ElementApplyOnCreate[key]\r\n\t\t\t}\r\n\t\t\tvar i = 0\r\n\t\t\tif (typeof selector == 'string') {\r\n\t\t\t\ti++\r\n\t\t\t\tvar selectorMatch = selector.match(SELECTOR_REGEX)\r\n\t\t\t\tif (selectorMatch) {\r\n\t\t\t\t\tdo {\r\n\t\t\t\t\t\tvar operator = selectorMatch[1]\r\n\t\t\t\t\t\tvar name = selectorMatch[2]\r\n\t\t\t\t\t\tif (operator == '.') {\r\n\t\t\t\t\t\t\tif (applyOnCreate.className) {\r\n\t\t\t\t\t\t\t\tapplyOnCreate.className += ' ' + name\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tif (element.className) {\r\n\t\t\t\t\t\t\t\t    element.className += ' ' + name\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t    element.className = name\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tif (applyOnCreate.id) {\r\n\t\t\t\t\t\t\t\tapplyOnCreate.id = name\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// just skip right to the element\r\n\t\t\t\t\t\t\t\telement.id = name\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar remaining = selectorMatch[3]\r\n\t\t\t\t\t\tselectorMatch = remaining && remaining.match(SELECTOR_REGEX)\r\n\t\t\t\t\t} while (selectorMatch)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tapplyOnCreate.content = selector\r\n\t\t\t\t}\r\n\t\t\t} else if (selector && selector._item) {\r\n\t\t\t\t// this is kind of hack, to get the Item available before the properties, eventually we may want to\r\n\t\t\t\t// order static properties before variable binding applications, but for now.\r\n\t\t\t\telement._item = selector._item\r\n\t\t\t}\r\n\t\t\tfor (var l = arguments.length; i < l; i++) {\r\n\t\t\t\tvar argument = arguments[i]\r\n\t\t\t\tif (argument && typeof argument === 'object') {\r\n\t\t\t\t\tif (argument instanceof Array || argument.notifies) {\r\n\t\t\t\t\t\tapplyOnCreate.content = argument\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tfor (var key in argument) {\r\n\t\t\t\t\t\t\t// TODO: do deep merging of styles and classes, but not variables\r\n\t\t\t\t\t\t\tapplyOnCreate[key] = argument[key]\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (typeof argument === 'function' && argument.for) {\r\n\t\t\t\t\tapplyOnCreate.content = argument.for(element)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tapplyOnCreate.content = argument\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t// TODO: inline this\r\n\t\tapplyProperties(element, applyOnCreate)\r\n\t\tif (this.children) {\r\n\t\t\tlayoutChildren(element, this.children, element)\r\n\t\t}\r\n\t\t// always do this last, so it can be properly inserted inside the children\r\n\t\tif (applyOnCreate.content) {\r\n\t\t\tbuildContent(element, applyOnCreate.content, 'content', applyOnCreate)\r\n\t\t}\r\n\t\telement.createdCallback && element.createdCallback()\r\n\t\telement.created && element.created(applyOnCreate)\r\n\t\treturn element\r\n\t}\r\n\r\n\tvar slice = [].slice\r\n\tfunction append(parent){\r\n\t\treturn this.nodeType ?\r\n\t\t\tlayoutChildren(this, arguments, this) : // called as a method\r\n\t\t\tlayoutChildren(parent, slice.call(arguments, 1), parent) // called as a function\r\n\t}\r\n\r\n\tfunction prepend(parent){\r\n\t\treturn this.nodeType ?\r\n\t\t\tlayoutChildren(this, arguments, this, true) : // called as a method\r\n\t\t\tlayoutChildren(parent, slice.call(arguments, 1), parent, true) // called as a function\r\n\t}\r\n\r\n\tfunction registerTag(tagName) {\r\n\t\tthis.tagName = tagName\r\n\t\tif (doc.registerElement && this.prototype.constructor === this) {\r\n\t\t\tdoc.registerElement(tagName, this)\r\n\t\t}\r\n\t}\r\n\r\n\tvar Element = withProperties.call(typeof HTMLElement !== 'undefined' ? HTMLElement : function() {})\r\n\r\n\tElement.registerTag = registerTag\r\n\tElement.applyProperties = applyProperties\r\n\r\n\tElement.within = function(element){\r\n\t\t// find closest child\r\n\t}\r\n\r\n\tgenerate([\r\n\t\t'Video',\r\n\t\t'Source',\r\n\t\t'Media',\r\n\t\t'Audio',\r\n\t\t'UL',\r\n\t\t'Track',\r\n\t\t'Title',\r\n\t\t'TextArea',\r\n\t\t'Template',\r\n\t\t'TBody',\r\n\t\t'THead',\r\n\t\t'TFoot',\r\n\t\t'TR',\r\n\t\t'Table',\r\n\t\t'Col',\r\n\t\t'ColGroup',\r\n\t\t'TH',\r\n\t\t'TD',\r\n\t\t'Caption',\r\n\t\t'Style',\r\n\t\t'Span',\r\n\t\t'Shadow',\r\n\t\t'Select',\r\n\t\t'Script',\r\n\t\t'Quote',\r\n\t\t'Progress',\r\n\t\t'Pre',\r\n\t\t'Picture',\r\n\t\t'Param',\r\n\t\t'P',\r\n\t\t'Output',\r\n\t\t'Option',\r\n\t\t'Optgroup',\r\n\t\t'Object',\r\n\t\t'OL',\r\n\t\t'Ins',\r\n\t\t'Del',\r\n\t\t'Meter',\r\n\t\t'Meta',\r\n\t\t'Menu',\r\n\t\t'Map',\r\n\t\t'Link',\r\n\t\t'Legend',\r\n\t\t'Label',\r\n\t\t'LI',\r\n\t\t'KeyGen',\r\n\t\t'Input',\r\n\t\t'Image',\r\n\t\t'IFrame',\r\n\t\t'H1',\r\n\t\t'H2',\r\n\t\t'H3',\r\n\t\t'H4',\r\n\t\t'H5',\r\n\t\t'H6',\r\n\t\t'Hr',\r\n\t\t'FrameSet',\r\n\t\t'Frame',\r\n\t\t'Form',\r\n\t\t'Font',\r\n\t\t'Embed',\r\n\t\t'Article',\r\n\t\t'Aside',\r\n\t\t'Footer',\r\n\t\t'Figure',\r\n\t\t'FigCaption',\r\n\t\t'Header',\r\n\t\t'Main',\r\n\t\t'Mark',\r\n\t\t'MenuItem',\r\n\t\t'Nav',\r\n\t\t'Section',\r\n\t\t'Summary',\r\n\t\t'WBr',\r\n\t\t'Div',\r\n\t\t'Dialog',\r\n\t\t'Details',\r\n\t\t'DataList',\r\n\t\t'DL',\r\n\t\t'Canvas',\r\n\t\t'Button',\r\n\t\t'Base',\r\n\t\t'Br',\r\n\t\t'Area',\r\n\t\t'A'\r\n\t])\r\n\tgenerateInputs([\r\n\t\t'Checkbox',\r\n\t\t'Password',\r\n\t\t'Submit',\r\n\t\t'Radio',\r\n\t\t'Color',\r\n\t\t'Date',\r\n\t\t'DateTime',\r\n\t\t'Email',\r\n\t\t'Month',\r\n\t\t'Number',\r\n\t\t'Range',\r\n\t\t'Search',\r\n\t\t'Tel',\r\n\t\t'Time',\r\n\t\t'Url',\r\n\t\t'Week'])\r\n\r\n\tvar tags = {}\r\n\tfunction getConstructor(tagName) {\r\n\t\ttagName = tagName.toLowerCase()\r\n\t\treturn tags[tagName] ||\r\n\t\t\t(tags[tagName] =\r\n\t\t\t\tsetTag(withProperties.call(doc.createElement(tagName).constructor), tagName))\r\n\t}\r\n\r\n\tfunction setTag(Element, tagName) {\r\n\t\tElement.tagName = tagName\r\n\t\treturn Element\r\n\t}\r\n\tfunction generate(elements) {\r\n\t\telements.forEach(function(elementName) {\r\n\t\t\tvar ElementClass\r\n\t\t\tObject.defineProperty(Element, elementName, {\r\n\t\t\t\tget: function() {\r\n\t\t\t\t\treturn ElementClass || (ElementClass = getConstructor(elementName))\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t})\r\n\t}\r\n\tfunction generateInputs(elements) {\r\n\t\telements.forEach(function(inputType) {\r\n\t\t\tvar ElementClass\r\n\t\t\tObject.defineProperty(Element, inputType, {\r\n\t\t\t\tget: function() {\r\n\t\t\t\t\t// TODO: make all inputs extend from input generated from generate\r\n\t\t\t\t\treturn ElementClass || (ElementClass = setTag(withProperties.call(HTMLInputElement, {\r\n\t\t\t\t\t\ttype: inputType.toLowerCase()\r\n\t\t\t\t\t}), 'input'))\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\t// alias all the inputs with an Input suffix\r\n\t\t\tObject.defineProperty(Element, inputType + 'Input', {\r\n\t\t\t\tget: function() {\r\n\t\t\t\t\treturn this[inputType]\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t})\r\n\t}\r\n\r\n\tvar aliases = {\r\n\t\tAnchor: 'A',\r\n\t\tParagraph: 'P',\r\n\t\tTextarea: 'TextArea',\r\n\t\tDList: 'DL',\r\n\t\tUList: 'UL',\r\n\t\tOList: 'OL',\r\n\t\tListItem: 'LI',\r\n\t\tText: 'Input',\r\n\t\tTextInput: 'Input',\r\n\t\tTableRow: 'TR',\r\n\t\tTableCell: 'TD',\r\n\t\tTableHeaderCell: 'TH',\r\n\t\tTableHeader: 'THead',\r\n\t\tTableBody: 'TBody'\r\n\t}\r\n\tfor (var alias in aliases) {\r\n\t\t(function(alias, to) {\r\n\t\t\tObject.defineProperty(Element, alias, {\r\n\t\t\t\tget: function() {\r\n\t\t\t\t\treturn this[to]\r\n\t\t\t\t}\r\n\t\t\t})\t\t\t\r\n\t\t})(alias, aliases[alias])\r\n\t}\r\n\r\n\tElement.append = append\r\n\tElement.prepend = prepend\r\n\tElement.refresh = Renderer.refresh\r\n\tvar options = Element.options = {\r\n\t\tmoveLiveElementsEnabled: true,\r\n\t}\r\n\tElement.content = function(element){\r\n\t\t// container marker\r\n\t\treturn {\r\n\t\t\tisContentNode: true,\r\n\t\t\tcreate: element.create.bind(element)\r\n\t\t}\r\n\t}\r\n\t// TODO: unify this in lang\r\n\tElement.extend = function(Class, properties) {\r\n\t\tfunction ExtendedElement() {\r\n\t\t\treturn Class.apply(this, arguments)\r\n\t\t}\r\n\t\tsetPrototypeOf(ExtendedElement, Class)\r\n\t\tvar prototype = ExtendedElement.prototype = Object.create(Class.prototype)\r\n\t\tprototype.constructor = ExtendedElement\r\n\t\tObject.getOwnPropertyNames(properties).forEach(function(key) {\r\n\t\t\tvar descriptor = Object.getOwnPropertyDescriptor(properties, key)\r\n\t\t\tif (classHandlers[key]) {\r\n\t\t\t\tclassHandlers[key](ExtendedElement, descriptor.value)\r\n\t\t\t} else {\r\n\t\t\t\tObject.defineProperty(prototype, key, descriptor)\r\n\t\t\t}\r\n\t\t})\r\n\t\treturn ExtendedElement\r\n\t}\r\n\r\n\tfunction forTarget(target) {\r\n\t\treturn target.constructor.getForClass(target, this)\r\n\t}\r\n\r\n\tfunction hasOwn(From, Target, createInstance) {\r\n\t\tif (typeof Target === 'object' && Target.Class) {\r\n\t\t\treturn hasOwn(From, Target.Class, Target.createInstance)\r\n\t\t}\r\n\t\tif (Target instanceof Array) {\r\n\t\t\treturn Target.forEach(function(Target) {\r\n\t\t\t\thasOwn(From, Target)\r\n\t\t\t})\r\n\t\t}\r\n\t\tvar ownedClasses = From.ownedClasses || (From.ownedClasses = new WeakMap())\r\n\t\t// TODO: assign to super classes\r\n\t\townedClasses.set(Target, createInstance || function() {\r\n\t\t\treturn new Target()\r\n\t\t})\r\n\t\treturn From\r\n\t}\r\n\r\n\tvar globalInstances = {}\r\n\tfunction getForClass(element, Target) {\r\n\t\tvar createInstance\r\n\t\twhile (element && !(createInstance = element.constructor.ownedClasses && element.constructor.ownedClasses.get(Target))) {\r\n\t\t\telement = element.parentNode || presumptiveParentMap.get(element)\r\n\t\t}\r\n\t\tif (createInstance) {\r\n\t\t\tvar ownedInstances = element.ownedInstances || (element.ownedInstances = new WeakMap())\r\n\t\t\tvar instance = ownedInstances.get(Target)\r\n\t\t\tif (instance === undefined) {\r\n\t\t\t\townedInstances.set(Target, instance = createInstance(element))\r\n\t\t\t\tinstance.subject = element\r\n\t\t\t}\r\n\t\t\treturn instance\r\n\t\t}\r\n\t}\r\n\r\n\tfunction propertyForElement(key) {\r\n\t\t// we just need to establish one Variable class for each element, so we cache it\r\n\t\tThisElementVariable = this._Variable\r\n\t\tif (!ThisElementVariable) {\r\n\t\t\t// need our own branded variable class for this element class\r\n\t\t\tThisElementVariable = this._Variable = Variable()\r\n\r\n\t\t\thasOwn(this, ThisElementVariable, function(element) {\r\n\t\t\t\t// when we create the instance, immediately observe it\r\n\t\t\t\t// TODO: we might want to do this in init instead\r\n\t\t\t\tvar instance = new ThisElementVariable(element)\r\n\t\t\t\tinstance.observeObject()\r\n\t\t\t\treturn instance\r\n\t\t\t})\r\n\t\t}\r\n\t\t// now actually get the property class\r\n\t\treturn ThisElementVariable.property(key)\r\n\t}\r\n\r\n\tvar Item = Element.Item = Variable.Item\r\n\r\n\tfunction enterRenderer(Renderer, options/*, target*/) {\r\n\t\t// this will be used for optimized class-level variables\r\n\t\t/*if (target.started) { // TODO: Might want to pass in started as a parameter\r\n\t\t\t// this means that the updater has already been created, so we just need to add this instance\r\n\t\t\tRenderer.prototype.renderUpdate.call(options, element)\r\n\t\t} else {*/\r\n\t\tvar target = options.element\r\n\t\tvar updaters = target.updaters || (target.updaters = [])\r\n\t\tupdaters.push(new Renderer(options))\r\n\t\t//}\r\n\t}\r\n\r\n\tfunction cleanup(target) {\r\n\t\tvar updaters = target.updaters\r\n\t\tif (updaters) {\r\n\t\t\tfor (var i = 0, l = updaters.length; i < l; i++) {\r\n\t\t\t\tupdaters[i].stop()\r\n\t\t\t}\r\n\t\t\ttarget.needsRestart = true\r\n\t\t}\r\n\t}\r\n\tfunction restart(target) {\r\n\t\tvar updaters = target.updaters\r\n\t\tif (updaters) {\r\n\t\t\tfor (var i = 0, l = updaters.length; i < l; i++) {\r\n//\t\t\t\tupdaters[i].start()\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t// setup the mutation observer so we can be notified of attachments and removals\r\n\tfunction elementAttached(element) {\r\n\t\tvar Class = element.constructor\r\n\t\tif (Class.create) {\r\n/*\t\t\tif (Class.attachedInstances) {\r\n\t\t\t\tClass.attachedInstances.push(element)\r\n\t\t\t\tif (Class.attachedInstances.length === 1 && Class.needsRestart) {\r\n\t\t\t\t\trestart(Class)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tClass.attachedInstances = [element]\r\n\t\t\t}*/\r\n\t\t\tif (element.attached) {\r\n\t\t\t\telement.attached()\r\n\t\t\t}\r\n\t\t\tif (element.needsRestart) {\r\n\t\t\t\trestart(element)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfunction elementDetached(element) {\r\n\t\t/*var attachedInstances = element.constructor.attachedInstances\r\n\t\tif (attachedInstances) {\r\n\t\t\tvar index = attachedInstances.indexOf(element)\r\n\t\t\tif (index > -1) {\r\n\t\t\t\tattachedInstances.splice(index, 1)\r\n\t\t\t\tif (attachedInstances.length === 0) {\r\n\t\t\t\t\tcleanup(Class)\r\n\t\t\t\t}\r\n\t\t\t}*/\r\n\t\t\tif (element.detached) {\r\n\t\t\t\telement.detached()\r\n\t\t\t}\r\n\t\t\tcleanup(element)\r\n\t\t//}\r\n\t}\r\n\tif (typeof MutationObserver === 'function') {\r\n\t\tvar docBody = doc.body\r\n\t\tvar lifeStates = [{\r\n\t\t\tname: 'detached',\r\n\t\t\tnodes: 'removedNodes',\r\n\t\t\taction: elementDetached\r\n\t\t}, {\r\n\t\t\tname: 'attached',\r\n\t\t\tnodes: 'addedNodes',\r\n\t\t\taction: elementAttached\r\n\t\t}]\r\n\t\tfunction firstVisit(node, state) {\r\n\t\t\tif (state.name === 'attached') {\r\n\t\t\t\tif (node.__alkaliAttached__) {\r\n\t\t\t\t\treturn false\r\n\t\t\t\t} else {\r\n\t\t\t\t\tnode.__alkaliAttached__ = true\r\n\t\t\t\t\tstate.action(node)\r\n\t\t\t\t\treturn true\r\n\t\t\t\t}\r\n\t\t\t} else if (node.__alkaliAttached__) {\r\n\t\t\t\tif (docBody.contains(node)) {\r\n\t\t\t\t\t// detached event, but it is actually still attached (will get attached in a later mutation record)\r\n\t\t\t\t\t// so don't get through the detached/attached lifecycle\r\n\t\t\t\t\treturn false\r\n\t\t\t\t}\r\n\t\t\t\tnode.__alkaliAttached__ = false\r\n\t\t\t\tstate.action(node)\r\n\t\t\t}\r\n\t\t\treturn true\r\n\t\t}\r\n\t\tvar observer = new MutationObserver(function(mutations) {\r\n\t\t\tfor (var i = 0, il = mutations.length; i < il; i++) {\r\n\t\t\t\tvar mutation = mutations[i]\r\n\t\t\t\t// invoke action on element if we haven't already\r\n\t\t\t\tactionIteration:\r\n\t\t\t\tfor (var j = 0, jl = lifeStates.length; j < jl; j++) { // two steps, removed nodes and added nodes\r\n\t\t\t\t\tvar state = lifeStates[j]\r\n\t\t\t\t\tvar nodes = mutation[state.nodes]\r\n\t\t\t\t\t// iterate over node list\r\n\t\t\t\t\tnodeIteration:\r\n\t\t\t\t\tfor (var k = 0, kl = nodes.length; k < kl; k++) {\r\n\t\t\t\t\t\tvar baseNode = nodes[k]\r\n\t\t\t\t\t\tif (firstVisit(baseNode, state)) {\r\n\t\t\t\t\t\t\t// start traversal with child, if it exists\r\n\t\t\t\t\t\t\tvar currentNode = baseNode.firstChild\r\n\t\t\t\t\t\t\tif (currentNode) {\r\n\t\t\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\t\t\tvar nextNode\r\n\t\t\t\t\t\t\t\t\tif (currentNode.nodeType === 1 && firstVisit(currentNode, state)) {\r\n\t\t\t\t\t\t\t\t\t\t// depth-first search\r\n\t\t\t\t\t\t\t\t\t\tnextNode = currentNode.firstChild\r\n\t\t\t\t\t\t\t\t\t\tif (!nextNode) {\r\n\t\t\t\t\t\t\t\t\t\t\tnextNode = currentNode.nextSibling\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\tnextNode = currentNode.nextSibling\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tif (!nextNode) {\r\n\t\t\t\t\t\t\t\t\t\t// come back out to parents\r\n\t\t\t\t\t\t\t\t\t\t// TODO: try keeping a stack to make this faster\r\n\t\t\t\t\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\t\t\t\t\tcurrentNode = currentNode.parentNode\r\n\t\t\t\t\t\t\t\t\t\t\tif (currentNode === baseNode) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tcontinue nodeIteration\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t} while (!(nextNode = currentNode.nextSibling))\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tcurrentNode = nextNode\r\n\t\t\t\t\t\t\t\t} while (true)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// if (options.moveLiveElementsEnabled) {\r\n\t\t\t\t\t\t// TODO: any options that we can really do here?\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t\tobserver.observe(docBody, {\r\n\t\t\tchildList: true,\r\n\t\t\tsubtree: true\r\n\t\t})\r\n\t}\r\n\r\n\treturn Element\r\n})\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./Element.js\n ** module id = 1\n ** module chunks = 0\n **/","define(['./util/lang'], function (lang) {\r\n\tvar deny = {}\r\n\tvar noChange = {}\r\n\tvar WeakMap = lang.WeakMap\r\n\tvar setPrototypeOf = Object.setPrototypeOf || (function(base, proto) { base.__proto__ = proto})\r\n\tvar getPrototypeOf = Object.getPrototypeOf || (function(base) { return base.__proto__ })\r\n\t// update types\r\n\tvar ToParent = 2\r\n\tvar RequestChange = 3\r\n\t\r\n\tvar ToChild = Object.freeze({\r\n\t\ttype: 'refresh'\r\n\t})\r\n\tvar nextId = 1\r\n\tvar propertyListenersMap = new WeakMap(null, 'propertyListenersMap')\r\n\r\n\tvar CacheEntry = lang.compose(WeakMap, function() {\r\n\t},{\r\n\t\t_propertyChange: function(propertyName) {\r\n\t\t\tthis.variable._propertyChange(propertyName, contextFromCache(this))\r\n\t\t}\r\n\t})\r\n\tvar listenerId = 1\r\n\r\n\tfunction mergeSubject(context) {\r\n\t\tfor (var i = 1, l = arguments.length; i < l; i++) {\r\n\t\t\tvar nextContext = arguments[i]\r\n\t\t\tif (nextContext !== context && (!context || nextContext && context.contains && context.contains(nextContext))) {\r\n\t\t\t\tcontext = nextContext\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn context\r\n\t}\r\n\r\n\tfunction getMaterializedContextualInstance(variable, context) {\r\n\t\tvar subject = context && (context.distinctSubject || context.subject)\r\n\t\tif (typeof variable === 'function') {\r\n\t\t\treturn variable.for(subject)\r\n\t\t}\r\n\t\tvar contextMap = variable.contextMap\r\n\t\tif (context && contextMap) {\r\n\t\t\twhile(subject && !contextMap.has(subject)) {\r\n\t\t\t\tsubject = subject.parentNode\r\n\t\t\t}\r\n\t\t\tif (!subject) {\r\n\t\t\t\tsubject = defaultContext\r\n\t\t\t}\r\n\t\t\treturn contextMap.get(subject)\r\n\t\t}\r\n\t}\r\n\tfunction when(value, callback) {\r\n\t\tif (value && value.then) {\r\n\t\t\treturn value.then(callback)\r\n\t\t}\r\n\t\treturn callback(value)\r\n\t}\r\n\r\n\tfunction Context(subject){\r\n\t\tthis.subject = subject\r\n\t}\r\n\tfunction whenAll(inputs, callback){\r\n\t\tvar promiseInvolved\r\n\t\tvar needsContext\r\n\t\tfor (var i = 0, l = inputs.length; i < l; i++) {\r\n\t\t\tif (inputs[i] && inputs[i].then) {\r\n\t\t\t\tpromiseInvolved = true\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (promiseInvolved) {\r\n\t\t\treturn lang.whenAll(inputs, callback)\r\n\t\t}\r\n\t\treturn callback(inputs)\r\n\t}\r\n\r\n\tfunction registerListener(value, listener) {\r\n\t\tvar listeners = propertyListenersMap.get(value)\r\n\t\tvar id = listener.listenerId || (listener.listenerId = ('-' + listenerId++))\r\n\t\tif (listeners) {\r\n\t\t\tif (listeners[id] === undefined) {\r\n\t\t\t\tlisteners[id] = listeners.push(listener) - 1\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\tpropertyListenersMap.set(value, listeners = [listener])\r\n\t\t\tlisteners[id] = 0\r\n\t\t\tif (Variable.autoObserveObjects) {\r\n\t\t\t\tobserve(value)\r\n\t\t\t}\r\n\t\t}\r\n\t\tlistener.listeningToObject = value\r\n\t}\r\n\tfunction deregisterListener(listener) {\r\n\t\tif (listener.listeningToObject) {\r\n\t\t\tvar value = listener.listeningToObject\r\n\t\t\tlistener.listeningToObject = null\r\n\t\t\tvar listeners = propertyListenersMap.get(value)\r\n\t\t\tif (listeners) {\r\n\t\t\t\tvar index = listeners[listener.listenerId]\r\n\t\t\t\tif (index > -1) {\r\n\t\t\t\t\tlisteners.splice(index, 1)\r\n\t\t\t\t\tdelete listeners[listener.listenerId]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction RefreshEvent() {\r\n\t\tthis.visited = new Set()\r\n\t}\r\n\tRefreshEvent.prototype.type = 'refresh'\r\n\r\n\tfunction PropertyChangeEvent(key, childEvent, parent) {\r\n\t\tthis.key = key\r\n\t\tthis.childEvent = childEvent\r\n\t\tthis.parent = parent\r\n\t\tthis.visited = childEvent.visited\r\n\t}\r\n\tPropertyChangeEvent.prototype.type = 'update'\r\n\r\n\tfunction AddEvent(args) {\r\n\t\tthis.visited = new Set()\r\n\t\tfor (var key in args) {\r\n\t\t\tthis[key] = args[key]\r\n\t\t}\r\n\t}\r\n\tAddEvent.prototype.type = 'add'\r\n\tfunction DeleteEvent(args) {\r\n\t\tthis.visited = new Set()\r\n\t\tfor (var key in args) {\r\n\t\t\tthis[key] = args[key]\r\n\t\t}\r\n\t}\r\n\tDeleteEvent.prototype.type = 'delete'\r\n\r\n\r\n\tfunction Variable(value) {\r\n\t\tif (this instanceof Variable) {\r\n\t\t\t// new call, may eventually use new.target\r\n\t\t\tthis.value = typeof value === 'undefined' ? this.default : value\r\n\t\t} else {\r\n\t\t\treturn Variable.extend(value)\r\n\t\t}\r\n\t}\r\n\tvar VariablePrototype = Variable.prototype = {\r\n\t\tconstructor: Variable,\r\n\t\tvalueOf: function(context) {\r\n\t\t\tif (this.subject) {\r\n\t\t\t\tvar variable = this\r\n\t\t\t\tcontext = new Context(this.subject)\r\n\t\t\t}\r\n\t\t\treturn this.gotValue(this.getValue(context), context)\r\n\t\t},\r\n\t\tgetValue: function() {\r\n\t\t\treturn this.value\r\n\t\t},\r\n\t\tgotValue: function(value, context) {\r\n\t\t\tvar previousNotifyingValue = this.notifyingValue\r\n\t\t\tvar variable = this\r\n\t\t\tif (value && value.then) {\r\n\t\t\t\treturn when(value, function(value) {\r\n\t\t\t\t\treturn Variable.prototype.gotValue.call(variable, value, context)\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tif (previousNotifyingValue) {\r\n\t\t\t\tif (value === previousNotifyingValue) {\r\n\t\t\t\t\t// nothing changed, immediately return valueOf (or ownObject if we have it)\r\n\t\t\t\t\treturn variable.ownObject || value.valueOf(context)\r\n\t\t\t\t}\r\n\t\t\t\t// if there was a another value that we were dependent on before, stop listening to it\r\n\t\t\t\t// TODO: we may want to consider doing cleanup after the next rendering turn\r\n\t\t\t\tif (variable.dependents) {\r\n\t\t\t\t\tpreviousNotifyingValue.stopNotifies(variable)\r\n\t\t\t\t}\r\n\t\t\t\tvariable.notifyingValue = null\r\n\t\t\t}\r\n\t\t\tif (value && value.notifies) {\r\n\t\t\t\tif (variable.dependents) {\r\n\t\t\t\t\t\t// the value is another variable, start receiving notifications\r\n\t\t\t\t\tvalue.notifies(variable)\r\n\t\t\t\t}\r\n\t\t\t\tvariable.notifyingValue = value\r\n\t\t\t\tvalue = value.valueOf(context)\r\n\t\t\t\tif (variable.ownObject) {\r\n\t\t\t\t\tif (getPrototypeOf(variable.ownObject) !== value) {\r\n\t\t\t\t\t\tsetPrototypeOf(variable.ownObject, value)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvalue = variable.ownObject\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (value === undefined) {\r\n\t\t\t\tvalue = variable.default\r\n\t\t\t}\r\n\t\t\treturn value\r\n\t\t},\r\n\t\tisMap: function() {\r\n\t\t\treturn this.value instanceof Map\r\n\t\t},\r\n\t\tproperty: function(key) {\r\n\t\t\tvar isMap = this.isMap()\r\n\t\t\tvar properties = this._properties || (this._properties = isMap ? new Map() : {})\r\n\t\t\tvar propertyVariable = isMap ? properties.get(key) : properties[key]\r\n\t\t\tif (!propertyVariable) {\r\n\t\t\t\t// create the property variable\r\n\t\t\t\tpropertyVariable = new Property(this, key)\r\n\t\t\t\tif (isMap) {\r\n\t\t\t\t\tproperties.set(key, propertyVariable)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tproperties[key] = propertyVariable\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn propertyVariable\r\n\t\t},\r\n\t\tfor: function(subject) {\r\n\t\t\tif (subject && subject.target && !subject.constructor.getForClass) {\r\n\t\t\t\t// makes HTML events work\r\n\t\t\t\tsubject = subject.target\r\n\t\t\t}\r\n\t\t\tif (typeof this === 'function') {\r\n\t\t\t\t// this is a class, the subject should hopefully have an entry\r\n\t\t\t\tif (subject !== undefined) {\r\n\t\t\t\t\tvar instance\r\n\t\t\t\t\tif (subject.constructor.getForClass) {\r\n\t\t\t\t\t\t// if the subject has it is own means of retrieving an instance\r\n\t\t\t\t\t\tinstance = subject.constructor.getForClass(subject, this)\r\n\t\t\t\t\t\tif (instance && !instance.subject) {\r\n\t\t\t\t\t\t\tinstance.subject = subject\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (subject && typeof subject === 'object') {\r\n\t\t\t\t\t\t\t// a plain object, we use our own map to retrieve the instance (or create one)\r\n\t\t\t\t\t\t\tvar instanceMap = this.instanceMap || (this.instanceMap = new WeakMap())\r\n\t\t\t\t\t\t\tinstance = instanceMap.get(subject)\r\n\t\t\t\t\t\t\tif (!instance) {\r\n\t\t\t\t\t\t\t\tinstanceMap.set(subject, instance = new this(subject))\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// a primitive, just unconditionally create a new variable for it\r\n\t\t\t\t\t\t\tinstance = new this(subject)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// TODO: Do we have a global context that we set on defaultInstance?\r\n\t\t\t\t\treturn instance || this.defaultInstance\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn this.defaultInstance\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn new ContextualizedVariable(this, subject || defaultContext)\r\n\t\t},\r\n\t\tdistinctFor: function(subject) {\r\n\t\t\tif (typeof this === 'function') {\r\n\t\t\t\treturn this.for(subject)\r\n\t\t\t}\r\n\t\t\tvar map = this.contextMap || (this.contextMap = new WeakMap())\r\n\t\t\tif (map.has(subject)) {\r\n\t\t\t\treturn map.get(subject)\r\n\t\t\t}\r\n\t\t\tvar contextualizedVariable\r\n\t\t\tmap.set(subject, contextualizedVariable = new ContextualizedVariable(this, subject))\r\n\t\t\treturn contextualizedVariable\r\n\t\t},\r\n\t\t_propertyChange: function(propertyName, object, context, type) {\r\n\t\t\tif (this.onPropertyChange) {\r\n\t\t\t\tthis.onPropertyChange(propertyName, object, context)\r\n\t\t\t}\r\n\t\t\tthis.updated(new PropertyChangeEvent(propertyName, new RefreshEvent(), this), null, context)\r\n\t\t},\r\n\t\teachKey: function(callback) {\r\n\t\t\tfor (var i in this._properties) {\r\n\t\t\t\tcallback(i)\r\n\t\t\t}\r\n\t\t},\r\n\t\tapply: function(instance, args) {\r\n\t\t\treturn new Call(this, args)\r\n\t\t},\r\n\t\tcall: function(instance) {\r\n\t\t\treturn this.apply(instance, Array.prototype.slice.call(arguments, 1))\r\n\t\t},\r\n\t\tforDependencies: function(callback) {\r\n\t\t\tif (this.notifyingValue) {\r\n\t\t\t\tcallback(this.notifyingValue)\r\n\t\t\t}\r\n\t\t},\r\n\t\tinit: function() {\r\n\t\t\tif (this.subject) {\r\n\t\t\t\tthis.constructor.notifies(this)\r\n\t\t\t}\r\n\t\t\tvar variable = this\r\n\t\t\tthis.forDependencies(function(dependency) {\r\n\t\t\t\tdependency.notifies(variable)\r\n\t\t\t})\r\n\t\t\tif (this.listeningToObject === null) {\r\n\t\t\t\t// we were previously listening to an object, but it needs to be restored\r\n\t\t\t\t// calling valueOf will cause the listening object to be restored\r\n\t\t\t\tthis.valueOf()\r\n\t\t\t}\r\n\t\t},\r\n\t\tcleanup: function() {\r\n\t\t\tvar handles = this.handles\r\n\t\t\tif (handles) {\r\n\t\t\t\tfor (var i = 0; i < handles.length; i++) {\r\n\t\t\t\t\thandles[i].remove()\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.handles = null\r\n\t\t\tvar notifyingValue = this.notifyingValue\r\n\t\t\tif (notifyingValue) {\r\n\t\t\t\t// TODO: move this into the caching class\r\n\t\t\t\tthis.computedVariable = null\r\n\t\t\t}\r\n\t\t\tvar variable = this\r\n\t\t\tthis.forDependencies(function(dependency) {\r\n\t\t\t\tdependency.stopNotifies(variable)\r\n\t\t\t})\r\n\t\t\tif (this.context) {\r\n\t\t\t\tthis.constructor.stopNotifies(this)\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tupdateVersion: function(version) {\r\n\t\t\tthis.version = nextId++\r\n\t\t},\r\n\r\n\t\tgetVersion: function(context) {\r\n\t\t\treturn Math.max(this.version || 0, this.notifyingValue && this.notifyingValue.getVersion ? this.notifyingValue.getVersion(context) : 0)\r\n\t\t},\r\n\r\n\t\tgetSubject: function(selectVariable) {\r\n\t\t\treturn this.subject\r\n\t\t},\r\n\r\n\t\tgetUpdates: function(since) {\r\n\t\t\tvar updates = []\r\n\t\t\tvar nextUpdateMap = this.nextUpdateMap\r\n\t\t\tif (nextUpdateMap && since) {\r\n\t\t\t\twhile ((since = nextUpdateMap.get(since))) {\r\n\t\t\t\t\tif (since.type === 'refresh') {\r\n\t\t\t\t\t\t// if it was refresh, we can clear any prior entries\r\n\t\t\t\t\t\tupdates = []\r\n\t\t\t\t\t}\r\n\t\t\t\t\tupdates.push(since)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn updates\r\n\t\t},\r\n\r\n\t\tupdated: function(updateEvent, by, context) {\r\n\t\t\tif (!updateEvent) {\r\n\t\t\t\tupdateEvent = new RefreshEvent()\r\n\t\t\t}\r\n\t\t\tif (updateEvent.visited.has(this)){\r\n\t\t\t\t// if this event has already visited this variable, skip it\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tupdateEvent.visited.add(this)\r\n\t\t\tif (this.subject) {\r\n\t\t\t\tif (by === this.constructor) {\r\n\t\t\t\t\t// if we receive an update from the constructor, filter it\r\n\t\t\t\t\tif (!(!context || (context.distinctSubject || context.subject) === this.subject || (context.subject.contains && this.subject.nodeType && context.subject.contains(this.subject)))) {\r\n\t\t\t\t\t\treturn\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// if we receive an outside update, send it to the constructor\r\n\t\t\t\t\treturn this.constructor.updated(updateEvent, this, new Context(this.subject))\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tvar contextualInstance = getMaterializedContextualInstance(this, context)\r\n\t\t\tif (contextualInstance) {\r\n\t\t\t\tcontextualInstance.updated(updateEvent, this, context)\r\n\t\t\t}\r\n\t\t\tif (this.lastUpdate) {\r\n\t\t\t\tvar nextUpdateMap = this.nextUpdateMap\r\n\t\t\t\tif (!nextUpdateMap) {\r\n\t\t\t\t\tnextUpdateMap = this.nextUpdateMap = new WeakMap()\r\n\t\t\t\t}\r\n\t\t\t\tnextUpdateMap.set(this.lastUpdate, updateEvent)\r\n\t\t\t}\r\n\r\n\t\t\tthis.lastUpdate = updateEvent\r\n\t\t\tthis.updateVersion()\r\n\t\t\tvar value = this.value\r\n\r\n\t\t\tvar dependents = this.dependents\r\n\t\t\tif (dependents) {\r\n\t\t\t\t// make a copy, in case they change\r\n\t\t\t\tdependents = dependents.slice(0)\r\n\t\t\t\tfor (var i = 0, l = dependents.length; i < l; i++) {\r\n\t\t\t\t\ttry{\r\n\t\t\t\t\t\tvar dependent = dependents[i]\r\n\t\t\t\t\t\tif ((updateEvent instanceof PropertyChangeEvent) &&\r\n\t\t\t\t\t\t\t\t(dependent instanceof Property)) {\r\n\t\t\t\t\t\t\tif (dependent.key === updateEvent.key) {\r\n\t\t\t\t\t\t\t\tdependent.updated(updateEvent.childEvent, this, context)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tdependent.updated(updateEvent, this, context)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}catch(e) {\r\n\t\t\t\t\t\tconsole.error(e, e.stack, 'updating a variable')\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (updateEvent instanceof PropertyChangeEvent) {\r\n\t\t\t\tif (this.notifyingValue && this.fixed) {\r\n\t\t\t\t\tthis.notifyingValue.updated(updateEvent, this, context)\r\n\t\t\t\t}\r\n\t\t\t\tif (this.collection) {\r\n\t\t\t\t\tthis.collection.updated(updateEvent, this, context)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn updateEvent\r\n\t\t},\r\n\r\n\t\tinvalidate: function() {\r\n\t\t\t// for back-compatibility for now\r\n\t\t\tthis.updated()\r\n\t\t},\r\n\r\n\t\tnotifies: function(target) {\r\n\t\t\tvar dependents = this.dependents\r\n\t\t\tif (!dependents || !this.hasOwnProperty('dependents')) {\r\n\t\t\t\tthis.dependents = dependents = []\r\n\t\t\t\tthis.init()\r\n\t\t\t}\r\n\t\t\tdependents.push(target)\r\n\t\t\tvar variable = this\r\n\t\t\treturn {\r\n\t\t\t\tunsubscribe: function() {\r\n\t\t\t\t\tvariable.stopNotifies(target)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tsubscribe: function(listener) {\r\n\t\t\t// ES7 Observable (and baconjs) compatible API\r\n\t\t\tvar updated\r\n\t\t\tvar updateQueued\r\n\t\t\tvar variable = this\r\n\t\t\t// it is important to make sure you register for notifications before getting the value\r\n\t\t\tif (typeof listener === 'function') {\r\n\t\t\t\t// BaconJS compatible API\r\n\t\t\t\tvar variable = this\r\n\t\t\t\tvar event = {\r\n\t\t\t\t\tvalue: function() {\r\n\t\t\t\t\t\treturn variable.valueOf()\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tupdated = function() {\r\n\t\t\t\t\tupdateQueued = false\r\n\t\t\t\t\tlistener(event)\r\n\t\t\t\t}\r\n\t\t\t}\telse if (listener.next) {\r\n\t\t\t\t// Assuming ES7 Observable API. It is actually a streaming API, this pretty much violates all principles of reactivity, but we will support it\r\n\t\t\t\tupdated = function() {\r\n\t\t\t\t\tupdateQueued = false\r\n\t\t\t\t\tlistener.next(variable.valueOf())\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tthrow new Error('Subscribing to an invalid listener, the listener must be a function, or have an update or next method')\r\n\t\t\t}\r\n\r\n\t\t\tvar handle = this.notifies({\r\n\t\t\t\tupdated: function() {\r\n\t\t\t\t\tif (updateQueued) {\r\n\t\t\t\t\t\treturn\r\n\t\t\t\t\t}\r\n\t\t\t\t\tupdateQueued = true\r\n\t\t\t\t\tlang.nextTurn(updated)\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\tvar initialValue = this.valueOf()\r\n\t\t\tif (initialValue !== undefined) {\r\n\t\t\t\tupdated()\r\n\t\t\t}\r\n\t\t\treturn handle\r\n\t\t},\r\n\t\tstopNotifies: function(dependent) {\r\n\t\t\tvar dependents = this.dependents\r\n\t\t\tif (dependents) {\r\n\t\t\t\tfor (var i = 0; i < dependents.length; i++) {\r\n\t\t\t\t\tif (dependents[i] === dependent) {\r\n\t\t\t\t\t\tdependents.splice(i--, 1)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (dependents.length === 0) {\r\n\t\t\t\t\t// clear the dependents so it will be reinitialized if it has\r\n\t\t\t\t\t// dependents again\r\n\t\t\t\t\tthis.dependents = dependents = false\r\n\t\t\t\t\tthis.cleanup()\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tput: function(value, context) {\r\n\t\t\tvar variable = this\r\n\t\t\tif (this.ownObject) {\r\n\t\t\t\tthis.ownObject = false\r\n\t\t\t}\t\t\t\r\n\t\t\treturn when(this.getValue(context), function(oldValue) {\r\n\t\t\t\tif (oldValue === value) {\r\n\t\t\t\t\treturn noChange\r\n\t\t\t\t}\r\n\t\t\t\tif (variable.fixed &&\r\n\t\t\t\t\t\t// if it is set to fixed, we see we can put in the current variable\r\n\t\t\t\t\t\toldValue && oldValue.put) {\r\n\t\t\t\t\treturn oldValue.put(value)\r\n\t\t\t\t}\r\n\t\t\t\treturn when(variable.setValue(value, context), function(value) {\r\n\t\t\t\t\tvariable.updated(new RefreshEvent(), variable, context)\r\n\t\t\t\t})\r\n\t\t\t})\r\n\t\t},\r\n\t\tget: function(key) {\r\n\t\t\treturn when(this.valueOf(), function(object) {\r\n\t\t\t\tvar value = object && (typeof object.get === 'function' ? object.get(key) : object[key])\r\n\t\t\t\tif (value && value.notifies) {\r\n\t\t\t\t\t// nested variable situation, get underlying value\r\n\t\t\t\t\treturn value.valueOf()\r\n\t\t\t\t}\r\n\t\t\t\treturn value\r\n\t\t\t})\r\n\t\t},\r\n\t\tset: function(key, value) {\r\n\t\t\t// TODO: create an optimized route when the property doesn't exist yet\r\n\t\t\tthis.property(key).put(value)\r\n\t\t},\r\n\t\tundefine: function(key, context) {\r\n\t\t\tthis.set(key, undefined, context)\r\n\t\t},\r\n\t\tproxy: function(proxiedVariable) {\r\n\t\t\tvar thisVariable = this\r\n\t\t\tthis.fixed = true\r\n\t\t\treturn when(this.setValue(proxiedVariable), function(value) {\r\n\t\t\t\tthisVariable.updated(new RefreshEvent(), thisVariable)\r\n\t\t\t})\r\n\t\t},\r\n\t\tnext: function(value) {\r\n\t\t\t// for ES7 observable compatibility\r\n\t\t\tthis.put(value)\r\n\t\t},\r\n\t\terror: function(error) {\r\n\t\t\t// for ES7 observable compatibility\r\n\t\t\tvar dependents = this.dependents\r\n\t\t\tif (dependents) {\r\n\t\t\t\t// make a copy, in case they change\r\n\t\t\t\tdependents = dependents.slice(0)\r\n\t\t\t\tfor (var i = 0, l = dependents.length; i < l; i++) {\r\n\t\t\t\t\ttry{\r\n\t\t\t\t\t\tvar dependent = dependents[i]\r\n\t\t\t\t\t\t// skip notifying property dependents if we are headed up the parent chain\r\n\t\t\t\t\t\tdependent.error(error)\r\n\t\t\t\t\t}catch(e) {\r\n\t\t\t\t\t\tconsole.error(e, 'sending an error')\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tcomplete: function(value) {\r\n\t\t\t// for ES7 observable compatibility\r\n\t\t\tthis.put(value)\r\n\t\t},\r\n\t\tsetValue: function(value) {\r\n\t\t\tthis.value = value\r\n\t\t},\r\n\t\tonValue: function(listener) {\r\n\t\t\treturn this.subscribe(function(event) {\r\n\t\t\t\tlang.when(event.value(), function(value) {\r\n\t\t\t\t\tlistener(value)\r\n\t\t\t\t})\r\n\t\t\t})\r\n\t\t},\r\n\t\tforEach: function(callbackOrItemClass, callbackOrContext, context) {\r\n\t\t\t// iterate through current value of variable\r\n\t\t\tif (callbackOrItemClass.notifies) {\r\n\t\t\t\tvar collectionVariable = this\r\n\t\t\t\tthis.forEach(function(item) {\r\n\t\t\t\t\tvar itemVariable = callbackOrItemClass.for(item)\r\n\t\t\t\t\titemVariable.collection = collectionVariable\r\n\t\t\t\t\tcallbackOrContext.call(this, itemVariable)\r\n\t\t\t\t}, context)\r\n\t\t\t}\r\n\t\t\treturn when(this.valueOf(callbackOrContext), function(value) {\r\n\t\t\t\tif (value && value.forEach) {\r\n\t\t\t\t\tvalue.forEach(callbackOrItemClass)\r\n\t\t\t\t}else{\r\n\t\t\t\t\tfor (var i in value) {\r\n\t\t\t\t\t\tcallbackOrItemClass.call(value, value[i], i)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t},\r\n\r\n\t\tto: function (transformFunction, reverse) {\r\n\t\t\tif (typeof transformFunction !== 'function') {\r\n\t\t\t\tif (typeof transformFunction === 'object') {\r\n\t\t\t\t\tthis.to(transformFunction.forward, transformFunction.reverse)\r\n\t\t\t\t}\r\n\t\t\t\tthrow new Error('No function provided to transform')\r\n\t\t\t}\r\n\t\t\tif (reverse) {\r\n\t\t\t\ttransformFunction.reverse = function(value, args, context) {\r\n\t\t\t\t\t// for direct to, we can just use the first argument\r\n\t\t\t\t\treverse.call(this, args[0], context)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn new Call(transformFunction, [this])\r\n\t\t},\r\n\t\tget schema() {\r\n\t\t\t// default schema is the constructor\r\n\t\t\treturn this.notifyingValue ? this.notifyingValue.schema : this.constructor\r\n\t\t},\r\n\t\tset schema(schema) {\r\n\t\t\t// but allow it to be overriden\r\n\t\t\tObject.defineProperty(this, 'schema', {\r\n\t\t\t\tvalue: schema\r\n\t\t\t})\r\n\t\t},\r\n\t\tvalidate: function(target, schema) {\r\n\t\t\tif (this.notifyingValue) {\r\n\t\t\t\treturn this.notifyingValue.validate(target, schema)\r\n\t\t\t}\r\n\t\t\tif (schema.type && (schema.type !== typeof target)) {\r\n\t\t\t\treturn ['Target type of ' + typeof target + ' does not match schema type of ' + schema.type]\r\n\t\t\t}\r\n\t\t\tvar valid = []\r\n\t\t\tvalid.isValid = true\r\n\t\t\treturn valid\r\n\t\t},\r\n\r\n\t\tget validation() {\r\n\t\t\tvar validation = new Validating(this)\r\n\t\t\tObject.defineProperty(this, 'validation', {\r\n\t\t\t\tvalue: validation\r\n\t\t\t})\r\n\t\t\treturn validation\r\n\t\t},\r\n\t\tset validation(validation) {\r\n\t\t\t// but allow it to be overriden\r\n\t\t\tObject.defineProperty(this, 'validation', {\r\n\t\t\t\tvalue: validation\r\n\t\t\t})\r\n\t\t},\r\n\t\tgetId: function() {\r\n\t\t\treturn this.id || (this.id = nextId++)\r\n\t\t},\r\n\t\tobserveObject: function() {\r\n\t\t\tvar variable = this\r\n\t\t\treturn when(this.valueOf(), function(object) {\r\n\t\t\t\tvar listeners = propertyListenersMap.get(object)\r\n\t\t\t\tif (!listeners) {\r\n\t\t\t\t\tpropertyListenersMap.set(object, listeners = [])\r\n\t\t\t\t}\r\n\t\t\t\tif (listeners.observerCount) {\r\n\t\t\t\t\tlisteners.observerCount++\r\n\t\t\t\t}else{\r\n\t\t\t\t\tlisteners.observerCount = 1\r\n\t\t\t\t\tvar observer = listeners.observer = lang.observe(object, function(events) {\r\n\t\t\t\t\t\tfor (var i = 0, l = listeners.length; i < l; i++) {\r\n\t\t\t\t\t\t\tvar listener = listeners[i]\r\n\t\t\t\t\t\t\tfor (var j = 0, el = events.length; j < el; j++) {\r\n\t\t\t\t\t\t\t\tvar event = events[j]\r\n\t\t\t\t\t\t\t\tlistener._propertyChange(event.name, object)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t\tif (observer.addKey) {\r\n\t\t\t\t\t\tfor (var i = 0, l = listeners.length; i < l; i++) {\r\n\t\t\t\t\t\t\tvar listener = listeners[i]\r\n\t\t\t\t\t\t\tlistener.eachKey(function(key) {\r\n\t\t\t\t\t\t\t\tobserver.addKey(key)\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tregisterListener(object, variable)\r\n\t\t\t\treturn {\r\n\t\t\t\t\tremove: function() {\r\n\t\t\t\t\t\tderegisterListener(object, variable)\r\n\t\t\t\t\t\tif (!(--listeners.observerCount)) {\r\n\t\t\t\t\t\t\tlisteners.observer.remove()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t},\r\n\t\t\t\t\tdone: function() {\r\n\t\t\t\t\t\t// deliver changes\r\n\t\t\t\t\t\tlang.deliverChanges(observer)\r\n\t\t\t\t\t\tthis.remove()\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t},\r\n\t\t_willModify: function(context) {\r\n\t\t\t// an intent to modify, so we need to make sure we have our own copy\r\n\t\t\t// of an object when necessary\r\n\t\t\tif (this.fixed) {\r\n\t\t\t\tif (this.value && this.value._willModify) {\r\n\t\t\t\t\treturn this.value._willModify(context)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!this.ownObject && this.value && this.value.notifies) {\r\n\t\t\t\tvar variable = this\r\n\t\t\t\treturn when(this.valueOf(context), function(value) {\r\n\t\t\t\t\tif (value && typeof value === 'object') {\r\n\t\t\t\t\t\tif (value instanceof Array) {\r\n\t\t\t\t\t\t\tvariable.ownObject = value.slice(0)\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tvariable.ownObject = Object.create(value)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t},\r\n\t\tsplice: function(startingIndex, removalCount) {\r\n\t\t\tvar args = arguments\r\n\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\tvar results = array.splice.apply(array, args)\r\n\t\t\t\tremovedAt(this, results, startingIndex, removalCount, array.length)\r\n\t\t\t\tinsertedAt(this, [].slice.call(args, 2), startingIndex, array.length)\r\n\t\t\t\treturn results\r\n\t\t\t})\r\n\t\t},\r\n\t\tpush: function() {\r\n\t\t\tvar args = arguments\r\n\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\tvar results = array.push.apply(array, args)\r\n\t\t\t\tinsertedAt(this, args, array.length - args.length, array.length)\r\n\t\t\t\treturn results\r\n\t\t\t})\r\n\t\t},\r\n\t\tunshift: function() {\r\n\t\t\tvar args = arguments\r\n\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\tvar results = array.unshift.apply(array, args)\r\n\t\t\t\tinsertedAt(this, args, 0, array.length)\r\n\t\t\t\treturn results\r\n\t\t\t})\r\n\t\t},\r\n\t\tpop: function() {\r\n\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\tvar results = array.pop()\r\n\t\t\t\tremovedAt(this, [results], array.length, 1)\r\n\t\t\t\treturn results\r\n\t\t\t})\r\n\t\t},\r\n\t\tshift: function() {\r\n\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\tvar results = array.shift()\r\n\t\t\t\tremovedAt(this, [results], 0, 1, array.length)\r\n\t\t\t\treturn results\r\n\t\t\t})\r\n\t\t}\r\n\t}\r\n\r\n\tfunction arrayToModify(variable, callback) {\r\n\t\tvariable._willModify()\r\n\t\t// TODO: switch this to allow promises\r\n\t\twhen(variable.cachedValue || variable.valueOf(), function(array) {\r\n\t\t\tif (!array) {\r\n\t\t\t\tvariable.put(array = [])\r\n\t\t\t}\r\n\t\t\tvariable.updateVersion()\r\n\t\t\tvar results = callback.call(variable, array)\r\n\t\t\tvariable.cachedVersion = variable.version // update the cached version so it doesn't need to be recomputed\r\n\t\t\treturn results\r\n\t\t})\r\n\t}\r\n\r\n\tfunction insertedAt(variable, added, startingIndex, arrayLength) {\r\n\t\tvar addedCount = added.length\r\n\t\t// adjust the key positions of any index properties after splice\r\n\t\tif (addedCount > 0) {\r\n\t\t\tif (variable._properties) {\r\n\t\t\t\tvar arrayPosition\r\n\t\t\t\tfor (var i = arrayLength - addedCount; i > startingIndex;) {\r\n\t\t\t\t\tvar arrayPosition = variable._properties[--i]\r\n\t\t\t\t\tif (arrayPosition) {\r\n\t\t\t\t\t\tvariable._properties[i] = undefined\r\n\t\t\t\t\t\tarrayPosition.key += addedCount\r\n\t\t\t\t\t\tvariable._properties[arrayPosition.key] = arrayPosition\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// send out updates\r\n\t\t\tfor (var i = 0, l = added.length; i < l; i++) {\r\n\t\t\t\tvariable.updated(new AddEvent({\r\n\t\t\t\t\tvalue: added[i],\r\n\t\t\t\t\tindex: i + startingIndex,\r\n\t\t\t\t\tmodifier: variable\r\n\t\t\t\t}), variable)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction removedAt(variable, removed, startingIndex, removalCount, arrayLength) {\r\n\t\t// adjust the properties\r\n\t\tvar i = startingIndex + removalCount\r\n\t\tvar arrayPosition\r\n\t\tif (removalCount > 0) {\r\n\t\t\tif (variable._properties) {\r\n\t\t\t\tfor (var i = startingIndex + removalCount; i < arrayLength + removalCount; i++) {\r\n\t\t\t\t\tvar arrayPosition = variable._properties[i]\r\n\t\t\t\t\tif (arrayPosition) {\r\n\t\t\t\t\t\tvariable._properties[i] = undefined\r\n\t\t\t\t\t\tarrayPosition.key -= removalCount\r\n\t\t\t\t\t\tvariable._properties[arrayPosition.key] = arrayPosition\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// send out updates\r\n\t\t\tfor (var i = 0; i < removalCount; i++) {\r\n\t\t\t\tvariable.updated(new DeleteEvent({\r\n\t\t\t\t\tpreviousIndex: startingIndex,\r\n\t\t\t\t\toldValue: removed[i],\r\n\t\t\t\t\tmodifier: variable\r\n\t\t\t\t}), variable)\r\n\t\t\t}\r\n\t\t\tvariable.cachedVersion = variable.version // update the cached version so it doesn't need to be recomputed\r\n\t\t}\r\n\t}\r\n\r\n\tif (typeof Symbol !== 'undefined') {\r\n\t\tVariable.prototype[Symbol.iterator] = function() {\r\n\t\t\treturn this.valueOf()[Symbol.iterator]()\r\n\t\t}\r\n\t}\r\n\r\n\tVariable.VMap = lang.compose(Variable, function(value){\r\n\t\tthis.value = typeof value === 'undefined' ? this.default : value\r\n\t}, {\r\n\t\t// TODO: Move all the get and set functionality for maps out of Variable\r\n\t\tproperty: function(key) {\r\n\t\t\tvar properties = this._properties || (this._properties = new Map())\r\n\t\t\tvar propertyVariable = properties.get(key)\r\n\t\t\tif (!propertyVariable) {\r\n\t\t\t\t// create the property variable\r\n\t\t\t\tpropertyVariable = new Property(this, key)\r\n\t\t\t\tproperties.set(key, propertyVariable)\r\n\t\t\t}\r\n\t\t\treturn propertyVariable\r\n\t\t}\r\n\t})\r\n\r\n\tvar cacheNotFound = {}\r\n\tvar Caching = Variable.Caching = lang.compose(Variable, function(getValue, setValue) {\r\n\t\tif (getValue) {\r\n\t\t\tthis.getValue = getValue\r\n\t\t}\r\n\t\tif (setValue) {\r\n\t\t\tthis.setValue = setValue\r\n\t\t}\r\n\t}, {\r\n\t\tvalueOf: function(context) {\r\n\t\t\t// first check to see if we have the variable already computed\r\n\t\t\tif (this.cachedVersion === this.getVersion()) {\r\n\t\t\t\tif (this.contextMap) {\r\n\t\t\t\t\tvar contextualizedVariable = getMaterializedContextualInstance(this, context)\r\n\t\t\t\t\tif (contextualizedVariable) {\r\n\t\t\t\t\t\treturn contextualizedVariable.cachedValue\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn this.cachedValue\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar variable = this\r\n\r\n\t\t\tfunction withComputedValue(computedValue) {\r\n\t\t\t\tif (computedValue && computedValue.notifies && variable.dependents) {\r\n\t\t\t\t\tvariable.computedVariable = computedValue\r\n\t\t\t\t}\r\n\t\t\t\tcomputedValue = variable.gotValue(computedValue, watchedContext)\r\n\t\t\t\tvar contextualizedVariable\r\n\t\t\t\tif (watchedContext && watchedContext.distinctSubject) {\r\n\t\t\t\t\t(variable.contextMap || (variable.contextMap = new WeakMap()))\r\n\t\t\t\t\t\t.set(watchedContext.distinctSubject,\r\n\t\t\t\t\t\t\tcontextualizedVariable = new ContextualizedVariable(variable, watchedContext.distinctSubject))\r\n\t\t\t\t\tcontext.distinctSubject = mergeSubject(context.distinctSubject, watchedContext.distinctSubject)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcontextualizedVariable = variable\r\n\t\t\t\t}\r\n\t\t\t\tcontextualizedVariable.cachedVersion = newVersion\r\n\t\t\t\tcontextualizedVariable.cachedValue = computedValue\r\n\t\t\t\treturn computedValue\r\n\t\t\t}\r\n\r\n\t\t\tvar watchedContext\r\n\t\t\tif (context) {\r\n\t\t\t\twatchedContext = new Context(context.subject)\r\n\t\t\t}\r\n\t\t\tvar newVersion = this.getVersion()\r\n\t\t\tvar computedValue = this.getValue(watchedContext)\r\n\t\t\tif (computedValue && computedValue.then) {\r\n\t\t\t\treturn computedValue.then(withComputedValue)\r\n\t\t\t} else {\r\n\t\t\t\treturn withComputedValue(computedValue)\r\n\t\t\t}\r\n\t\t}\r\n\t})\r\n\r\n\tfunction GetCache() {\r\n\t}\r\n\r\n\tvar Property = lang.compose(Variable, function Property(parent, key) {\r\n\t\tthis.parent = parent\r\n\t\tthis.key = key\r\n\t},\r\n\t{\r\n\t\tforDependencies: function(callback) {\r\n\t\t\tVariable.prototype.forDependencies.call(this, callback)\r\n\t\t\tcallback(this.parent)\r\n\t\t},\r\n\t\tvalueOf: function(context) {\r\n\t\t\tvar key = this.key\r\n\t\t\tvar property = this\r\n\t\t\tvar object = this.parent.valueOf(context)\r\n\t\t\tfunction gotValueAndListen(object) {\r\n\t\t\t\tif (property.dependents) {\r\n\t\t\t\t\tvar listeners = propertyListenersMap.get(object)\r\n\t\t\t\t\tif (listeners && listeners.observer && listeners.observer.addKey) {\r\n\t\t\t\t\t\tlisteners.observer.addKey(key)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tvar value = property.gotValue(object == null ? undefined : typeof object.get === 'function' ? object.get(key) : object[key])\r\n\t\t\t\treturn value\r\n\t\t\t}\r\n\t\t\tif (object && object.then) {\r\n\t\t\t\treturn when(object, gotValueAndListen)\r\n\t\t\t}\r\n\t\t\treturn gotValueAndListen(object)\r\n\t\t},\r\n\t\tput: function(value, context) {\r\n\t\t\treturn this._changeValue(context, RequestChange, value)\r\n\t\t},\r\n\t\tparentUpdated: function(updateEvent, context) {\r\n\t\t\treturn Variable.prototype.updated.call(this, updateEvent, this.parent, context)\r\n\t\t},\r\n\t\tupdated: function(updateEvent, by, context) {\r\n\t\t\tif (updateEvent = Variable.prototype.updated.call(this, updateEvent, by, context)) {\r\n\t\t\t\tthis.parent.updated(new PropertyChangeEvent(this.key, updateEvent, this.parent), this, context)\r\n\t\t\t}\r\n\t\t},\r\n\t\t_changeValue: function(context, type, newValue) {\r\n\t\t\tvar key = this.key\r\n\t\t\tvar parent = this.parent\r\n\t\t\tvar variable = this\r\n\t\t\tparent._willModify(context)\r\n\t\t\treturn when(parent.valueOf(context), function(object) {\r\n\t\t\t\tif (object == null) {\r\n\t\t\t\t\t// nothing there yet, create an object to hold the new property\r\n\t\t\t\t\tvar response = parent.put(object = typeof key == 'number' ? [] : {}, context)\r\n\t\t\t\t}else if (typeof object != 'object') {\r\n\t\t\t\t\t// if the parent is not an object, we can't set anything (that will be retained)\r\n\t\t\t\t\treturn deny\r\n\t\t\t\t}\r\n\t\t\t\tif (type == RequestChange) {\r\n\t\t\t\t\tvar oldValue = typeof object.get === 'function' ? object.get(key) : object[key]\r\n\t\t\t\t\tif (oldValue === newValue) {\r\n\t\t\t\t\t\t// no actual change to make\r\n\t\t\t\t\t\treturn noChange\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (typeof object.set === 'function') {\r\n\t\t\t\t\t\tobject.set(key, newValue)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tobject[key] = newValue\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tvariable.updated(null, variable, context)\r\n\r\n\t\t\t\t// now notify any object listeners\r\n\t\t\t\tvar listeners = propertyListenersMap.get(object)\r\n\t\t\t\t// we need to do it before the other listeners, so we can update it before\r\n\t\t\t\t// we trigger a full clobbering of the object\r\n\t\t\t\tif (listeners) {\r\n\t\t\t\t\tlisteners = listeners.slice(0)\r\n\t\t\t\t\tfor (var i = 0, l = listeners.length; i < l; i++) {\r\n\t\t\t\t\t\tvar listener = listeners[i]\r\n\t\t\t\t\t\tif (listener !== parent) {\r\n\t\t\t\t\t\t\t// now go ahead and actually trigger the other listeners (but make sure we don't do the parent again)\r\n\t\t\t\t\t\t\tlistener._propertyChange(key, object, context, type)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t},\r\n\t\t_willModify: function() {\r\n\t\t\tthis.parent._willModify()\r\n\t\t\treturn Variable.prototype._willModify.call(this)\r\n\t\t},\r\n\t\tvalidate: function(target, schema) {\r\n\t\t\treturn this.parent.validate(target.valueOf(), schema)\r\n\t\t}\r\n\t})\r\n\tObject.defineProperty(Property.prototype, 'schema', {\r\n\t\tget: function() {\r\n\t\t\tvar parentSchemaProperties = this.parent.schema.properties\r\n\t\t\treturn parentSchemaProperties && parentSchemaProperties[this.key]\r\n\t\t},\r\n\t\tset: function(schema) {\r\n\t\t\t// have to repeat the override\r\n\t\t\tObject.defineProperty(this, 'schema', {\r\n\t\t\t\tvalue: schema\r\n\t\t\t})\r\n\t\t}\r\n\t})\r\n\tVariable.Property = Property\r\n\r\n\tvar Item = Variable.Item = lang.compose(Variable, function Item(value, content) {\r\n\t\tthis.value = value\r\n\t\tthis.collection = content\r\n\t}, {})\r\n\r\n\tvar Composite = Variable.Composite = lang.compose(Caching, function Composite(args) {\r\n\t\tthis.args = args\r\n\t}, {\r\n\t\tforDependencies: function(callback) {\r\n\t\t\t// depend on the args\r\n\t\t\tCaching.prototype.forDependencies.call(this, callback)\r\n\t\t\tvar args = this.args\r\n\t\t\tfor (var i = 0, l = args.length; i < l; i++) {\r\n\t\t\t\tvar arg = args[i]\r\n\t\t\t\tif (arg && arg.notifies) {\r\n\t\t\t\t\tcallback(arg)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tupdated: function(updateEvent, by, context) {\r\n\t\t\tvar args = this.args\r\n\t\t\tif (by !== this.notifyingValue && updateEvent && updateEvent.type !== 'refresh') {\r\n\t\t\t\t// using a painful search instead of indexOf, because args may be an arguments object\r\n\t\t\t\tfor (var i = 0, l = args.length; i < l; i++) {\r\n\t\t\t\t\tvar arg = args[i]\r\n\t\t\t\t\tif (arg === by) {\r\n\t\t\t\t\t\t// if one of the args was updated, we need to do a full refresh (we can't compute differential events without knowledge of how the mapping function works)\r\n\t\t\t\t\t\tupdateEvent = new RefreshEvent()\r\n\t\t\t\t\t\tcontinue\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn Caching.prototype.updated.call(this, updateEvent, by, context)\r\n\t\t},\r\n\r\n\t\tgetUpdates: function(since) {\r\n\t\t\t// this always issues updates, nothing incremental can flow through it\r\n\t\t\tif (!since || since.version < getVersion()) {\r\n\t\t\t\treturn [new RefreshEvent()]\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tgetVersion: function(context) {\r\n\t\t\tvar args = this.args\r\n\t\t\tvar version = Variable.prototype.getVersion.call(this, context)\r\n\t\t\tfor (var i = 0, l = args.length; i < l; i++) {\r\n\t\t\t\tvar arg = args[i]\r\n\t\t\t\tif (arg && arg.getVersion) {\r\n\t\t\t\t\tversion = Math.max(version, arg.getVersion(context))\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn version\r\n\t\t},\r\n\r\n\t\tgetValue: function(context) {\r\n\t\t\tvar results = []\r\n\t\t\tvar args = this.args\r\n\t\t\tfor (var i = 0, l = args.length; i < l; i++) {\r\n\t\t\t\tvar arg = args[i]\r\n\t\t\t\tresults[i] = arg && arg.valueOf(context)\r\n\t\t\t}\r\n\t\t\treturn whenAll(results, function(resolved) {\r\n\t\t\t\treturn resolved\r\n\t\t\t})\r\n\t\t}\r\n\t})\r\n\r\n\t// a call variable is the result of a call\r\n\tvar Call = lang.compose(Composite, function Call(functionVariable, args) {\r\n\t\tthis.functionVariable = functionVariable\r\n\t\tthis.args = args\r\n\t}, {\r\n\t\tfixed: true,\r\n\t\tforDependencies: function(callback) {\r\n\t\t\t// depend on the args\r\n\t\t\tComposite.prototype.forDependencies.call(this, callback)\r\n\t\t\tif (this.functionVariable.notifies) {\r\n\t\t\t\tcallback(this.functionVariable)\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tgetValue: function(context) {\r\n\t\t\tvar functionValue = this.functionVariable.valueOf(context)\r\n\t\t\tif (functionValue.then) {\r\n\t\t\t\tvar call = this\r\n\t\t\t\treturn functionValue.then(function(functionValue) {\r\n\t\t\t\t\treturn call.invoke(functionValue, call.args, context)\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\treturn this.invoke(functionValue, this.args, context)\r\n\t\t},\r\n\r\n\t\tgetVersion: function(context) {\r\n\t\t\t// TODO: shortcut if we are live and since equals this.lastUpdate\r\n\t\t\tvar argsVersion = Composite.prototype.getVersion.call(this, context)\r\n\t\t\tif (this.functionVariable.getVersion) {\r\n\t\t\t\treturn Math.max(argsVersion, this.functionVariable.getVersion(context))\r\n\t\t\t}\r\n\t\t\treturn argsVersion\r\n\t\t},\r\n\r\n\t\texecute: function(context) {\r\n\t\t\tvar call = this\r\n\t\t\treturn when(this.functionVariable.valueOf(context), function(functionValue) {\r\n\t\t\t\treturn call.invoke(functionValue, call.args, context, true)\r\n\t\t\t})\r\n\t\t},\r\n\r\n\t\tput: function(value, context) {\r\n\t\t\tvar call = this\r\n\t\t\treturn when(this.valueOf(context), function(originalValue) {\r\n\t\t\t\tif (originalValue === value) {\r\n\t\t\t\t\treturn noChange\r\n\t\t\t\t}\r\n\t\t\t\treturn when(call.functionVariable.valueOf(context), function(functionValue) {\r\n\t\t\t\t\treturn call.invoke(function() {\r\n\t\t\t\t\t\tif (functionValue.reverse) {\r\n\t\t\t\t\t\t\tfunctionValue.reverse.call(call, value, call.args, context)\r\n\t\t\t\t\t\t\treturn Variable.prototype.put.call(call, value, context)\r\n\t\t\t\t\t\t} else if (originalValue && originalValue.put) {\r\n\t\t\t\t\t\t\treturn originalValue.put(value)\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\treturn deny\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}, call.args, context)\r\n\t\t\t\t});\t\t\t\t\r\n\t\t\t})\r\n\t\t},\r\n\t\tinvoke: function(functionValue, args, context, observeArguments) {\r\n\t\t\tvar instance = this.functionVariable.parent\r\n\t\t\tif (functionValue.handlesContext) {\r\n\t\t\t\treturn functionValue.apply(instance, args, context)\r\n\t\t\t}else{\r\n\t\t\t\tvar results = []\r\n\t\t\t\tfor (var i = 0, l = args.length; i < l; i++) {\r\n\t\t\t\t\tvar arg = args[i]\r\n\t\t\t\t\tresults[i] = arg && arg.valueOf(context)\r\n\t\t\t\t}\r\n\t\t\t\tinstance = instance && instance.valueOf(context)\r\n\t\t\t\tif (functionValue.handlesPromises) {\r\n\t\t\t\t\treturn functionValue.apply(instance, results, context)\r\n\t\t\t\t}else{\r\n\t\t\t\t\t// include the instance in whenAll\r\n\t\t\t\t\tresults.push(instance)\r\n\t\t\t\t\t// wait for the values to be received\r\n\t\t\t\t\treturn whenAll(results, function(inputs) {\r\n\t\t\t\t\t\tif (observeArguments) {\r\n\t\t\t\t\t\t\tvar handles = []\r\n\t\t\t\t\t\t\tfor (var i = 0, l = inputs.length; i < l; i++) {\r\n\t\t\t\t\t\t\t\tvar input = inputs[i]\r\n\t\t\t\t\t\t\t\tif (input && typeof input === 'object') {\r\n\t\t\t\t\t\t\t\t\thandles.push(observe(input))\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tvar instance = inputs.pop()\r\n\t\t\t\t\t\t\ttry{\r\n\t\t\t\t\t\t\t\tvar result = functionValue.apply(instance, inputs, context)\r\n\t\t\t\t\t\t\t}finally{\r\n\t\t\t\t\t\t\t\twhen(result, function() {\r\n\t\t\t\t\t\t\t\t\tfor (var i = 0; i < l; i++) {\r\n\t\t\t\t\t\t\t\t\t\thandles[i].done()\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn result\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar instance = inputs.pop()\r\n\t\t\t\t\t\treturn functionValue.apply(instance, inputs, context)\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tsetReverse: function(reverse) {\r\n\t\t\tthis.functionVariable.valueOf().reverse = reverse\r\n\t\t\treturn this\r\n\t\t}\r\n\t})\r\n\tVariable.Call = Call\r\n\r\n\tvar ContextualizedVariable = lang.compose(Variable, function ContextualizedVariable(Source, subject) {\r\n\t\tthis.constructor = Source\r\n\t\tthis.subject = subject\r\n\t}, {\r\n\t\tvalueOf: function() {\r\n\t\t\treturn this.constructor.valueOf(new Context(this.subject))\r\n\t\t},\r\n\r\n\t\tput: function(value) {\r\n\t\t\treturn this.constructor.put(value, new Context(this.subject))\r\n\t\t},\r\n\t\tparentUpdated: function(event, context) {\r\n\t\t\t// if we receive an outside update, send it to the constructor\r\n\t\t\tthis.constructor.updated(event, this.parent, this.context)\r\n\t\t}\r\n\t})\r\n\r\n\r\n\tfunction iterateMethod(method) {\r\n\t\tVariable.prototype[method] = function() {\r\n\t\t\treturn new IterativeMethod(this, method, arguments)\r\n\t\t}\r\n\t}\r\n\r\n\titerateMethod('filter')\r\n\titerateMethod('map')\r\n\titerateMethod('reduce')\r\n\titerateMethod('reduceRight')\r\n\titerateMethod('some')\r\n\titerateMethod('every')\r\n\titerateMethod('slice')\r\n\t\r\n\tvar IterativeMethod = lang.compose(Composite, function(source, method, args) {\r\n\t\tthis.source = source\r\n\t\t// source.interestWithin = true\r\n\t\tthis.method = method\r\n\t\tthis.args = args\r\n\t}, {\r\n\t\tgetValue: function(context) {\r\n\t\t\tvar method = this.method\r\n\t\t\tvar args = this.args\r\n\t\t\tvar variable = this\r\n\t\t\treturn when(this.source.valueOf(context), function(array) {\r\n\t\t\t\tif (array && array.forEach) {\r\n\t\t\t\t\tif (variable.dependents) {\r\n\t\t\t\t\t\tvar contextualizedVariable\r\n\t\t\t\t\t\tif (context) {\r\n\t\t\t\t\t\t\tvar contextMap = variable.contextMap || (variable.contextMap = new WeakMap())\r\n\t\t\t\t\t\t\tif (contextMap.has(context.distinctSubject)) {\r\n\t\t\t\t\t\t\t\tcontextualizedVariable = contextMap.get(context.distinctSubject)\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tcontextMap.set(context.distinctSubject, contextualizedVariable = new ContextualizedVariable(variable, context.distinctSubject))\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tcontextualizedVariable = variable\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (method === 'map'){\r\n\t\t\t\t\t\t// fast path, and special behavior for map\r\n\t\t\t\t\t\treturn args[0](array)\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// if not an array convert to an array\r\n\t\t\t\t\tarray = [array]\r\n\t\t\t\t}\r\n\t\t\t\t// apply method\r\n\t\t\t\treturn array[method].apply(array, args)\r\n\t\t\t})\r\n\t\t},\r\n\t\tupdated: function(event, by, context) {\r\n\t\t\tif (!event || event.modifier === this || (event.modifier && event.modifier.constructor === this)) {\r\n\t\t\t\treturn Composite.prototype.updated.call(this, event, by, context)\r\n\t\t\t}\r\n\t\t\tvar propagatedEvent = event.type === 'refresh' ? event : // always propagate refreshes\r\n\t\t\t\tthis[this.method + 'Updated'] ? this[this.method + 'Updated'](event, context) : // if we have an updated handler, use it\r\n\t\t\t\tnew RefreshEvent() // else recompute the array method\r\n\t\t\t// TODO: make sure we normalize the event structure\r\n\t\t\tif (propagatedEvent) {\r\n\t\t\t\tComposite.prototype.updated.call(this, propagatedEvent, by, context)\r\n\t\t\t}\r\n\t\t},\r\n\t\tfilterUpdated: function(event, context) {\r\n\t\t\tvar contextualizedVariable = getMaterializedContextualInstance(this, context) || this\r\n\t\t\tif (event.type === 'delete') {\r\n\t\t\t\tvar index = contextualizedVariable.cachedValue.indexOf(event.oldValue)\r\n\t\t\t\tif (index > -1) {\r\n\t\t\t\t\tcontextualizedVariable.splice(index, 1)\r\n\t\t\t\t}\r\n\t\t\t} else if (event.type === 'add') {\r\n\t\t\t\tif ([event.value].filter(this.args[0]).length > 0) {\r\n\t\t\t\t\tcontextualizedVariable.push(event.value)\r\n\t\t\t\t}\r\n\t\t\t} else if (event.type === 'update') {\r\n\t\t\t\tvar object = event.parent.valueOf(context)\r\n\t\t\t\tvar index = contextualizedVariable.cachedValue.indexOf(object)\r\n\t\t\t\tvar matches = [object].filter(this.args[0]).length > 0\r\n\t\t\t\tif (index > -1) {\r\n\t\t\t\t\tif (matches) {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\ttype: 'updated',\r\n\t\t\t\t\t\t\tobject: object,\r\n\t\t\t\t\t\t\tindex: index\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tcontextualizedVariable.splice(index, 1)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\telse {\r\n\t\t\t\t\tif (matches) {\r\n\t\t\t\t\t\tcontextualizedVariable.push(object)\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// else nothing mactches\r\n\t\t\t\t}\r\n\t\t\t\treturn\r\n\t\t\t} else {\r\n\t\t\t\treturn event\r\n\t\t\t}\r\n\t\t},\r\n\t\tmapUpdated: function(event, context) {\r\n\t\t\tvar contextualizedVariable = getMaterializedContextualInstance(this, context) || this\r\n\t\t\tif (event.type === 'delete') {\r\n\t\t\t\tcontextualizedVariable.splice(event.previousIndex, 1)\r\n\t\t\t} else if (event.type === 'add') {\r\n\t\t\t\tcontextualizedVariable.push(this.args[0].call(this.args[1], event.value))\r\n\t\t\t} else if (event.type === 'update') {\r\n\t\t\t\tvar object = event.parent.valueOf(context)\r\n\t\t\t\tvar array = contextualizedVariable.cachedValue\r\n\t\t\t\tif (array && array.map) {\r\n\t\t\t\t\tvar index = array.indexOf(object)\r\n\t\t\t\t\tvar matches = [object].filter(this.args[0]).length > 0\r\n\t\t\t\t\tcontextualizedVariable.splice(index, 1, this.args[0].call(this.args[1], event.value))\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn event\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\treturn event\r\n\t\t\t}\r\n\t\t},\r\n\t\t// TODO: Create specialized updated handlers for faster recomputation of other array derivatives\r\n\t\tforDependencies: function(callback) {\r\n\t\t\t// depend on the args\r\n\t\t\tComposite.prototype.forDependencies.call(this, callback)\r\n\t\t\tcallback(this.source)\r\n\t\t},\r\n\t\tgetVersion: function(context) {\r\n\t\t\treturn Math.max(Composite.prototype.getVersion.call(this, context), this.source.getVersion(context))\r\n\t\t}\t\t\r\n\t})\r\n\r\n\r\n\tvar getValue\r\n\tvar GeneratorVariable = Variable.GeneratorVariable = lang.compose(Variable.Composite, function ReactiveGenerator(generator){\r\n\t\tthis.generator = generator\r\n\t\tthis.args = []\r\n\t}, {\r\n\t\tgetValue: getValue = function(context, resuming) {\r\n\t\t\tvar lastValue\r\n\t\t\tvar i\r\n\t\t\tvar generatorIterator\r\n\t\t\tvar isThrowing\r\n\t\t\tif (resuming) {\r\n\t\t\t\t// resuming from a promise\r\n\t\t\t\tgeneratorIterator = resuming.iterator\r\n\t\t\t\ti = resuming.i\r\n\t\t\t\tlastValue = resuming.value\r\n\t\t\t\tisThrowing = resuming.isThrowing\r\n\t\t\t} else {\r\n\t\t\t\t// a fresh start\r\n\t\t\t\ti = 0\r\n\t\t\t\tgeneratorIterator = this.generator()\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar args = this.args\r\n\t\t\tdo {\r\n\t\t\t\tvar stepReturn = generatorIterator[isThrowing ? 'throw' : 'next'](lastValue)\r\n\t\t\t\tif (stepReturn.done) {\r\n\t\t\t\t\treturn stepReturn.value\r\n\t\t\t\t}\r\n\t\t\t\tvar nextVariable = stepReturn.value\r\n\t\t\t\t// compare with the arguments from the last\r\n\t\t\t\t// execution to see if they are the same\r\n\t\t\t\tif (args[i] !== nextVariable) {\r\n\t\t\t\t\tif (args[i]) {\r\n\t\t\t\t\t\targs[i].stopNotifies(this)\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// subscribe if it is a variable\r\n\t\t\t\t\tif (nextVariable && nextVariable.notifies) {\r\n\t\t\t\t\t\tnextVariable.notifies(this)\r\n\t\t\t\t\t\tthis.args[i] = nextVariable\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.args[i] = null\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\ti++\r\n\t\t\t\tlastValue = nextVariable && nextVariable.valueOf(context)\r\n\t\t\t\tif (lastValue && lastValue.then) {\r\n\t\t\t\t\t// if it is a promise, we will wait on it\r\n\t\t\t\t\tvar variable = this\r\n\t\t\t\t\t// and return the promise so that the getValue caller can wait on this\r\n\t\t\t\t\treturn lastValue.then(function(value) {\r\n\t\t\t\t\t\treturn getValue.call(variable, context, {\r\n\t\t\t\t\t\t\ti: i,\r\n\t\t\t\t\t\t\titerator: generatorIterator,\r\n\t\t\t\t\t\t\tvalue: value\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}, function(error) {\r\n\t\t\t\t\t\treturn getValue.call(variable, context, {\r\n\t\t\t\t\t\t\ti: i,\r\n\t\t\t\t\t\t\titerator: generatorIterator,\r\n\t\t\t\t\t\t\tvalue: error,\r\n\t\t\t\t\t\t\tisThrowing: true\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t} while(true)\r\n\t\t}\r\n\t})\r\n\r\n\tvar Validating = lang.compose(Caching, function(target) {\r\n\t\tthis.target = target\r\n\t}, {\r\n\t\tforDependencies: function(callback) {\r\n\t\t\tCaching.prototype.forDependencies.call(this, callback)\r\n\t\t\tcallback(this.target)\r\n\t\t},\r\n\t\tgetVersion: function(context) {\r\n\t\t\treturn Math.max(Variable.prototype.getVersion.call(this, context), this.target.getVersion(context))\r\n\t\t},\r\n\t\tgetValue: function(context) {\r\n\t\t\tvar target = this.target\r\n\t\t\treturn target.validate(target, target.schema)\r\n\t\t}\r\n\t})\r\n\r\n\tfunction validate(target) {\r\n\t\tvar schemaForObject = schema(target)\r\n\t\treturn new Validating(target, schemaForObject)\r\n\t}\r\n\tVariable.VArray = Variable\r\n\tVariable.deny = deny\r\n\tVariable.noChange = noChange\r\n\tfunction addFlag(name) {\r\n\t\tVariable[name] = function(functionValue) {\r\n\t\t\tfunctionValue[name] = true\r\n\t\t}\r\n\t}\r\n\taddFlag(Variable, 'handlesContext')\r\n\taddFlag(Variable, 'handlesPromises')\r\n\r\n\tfunction objectUpdated(object) {\r\n\t\t// simply notifies any subscribers to an object, that it has changed\r\n\t\tvar listeners = propertyListenersMap.get(object)\r\n\t\tif (listeners) {\r\n\t\t\tfor (var i = 0, l = listeners.length; i < l; i++) {\r\n\t\t\t\tlisteners[i]._propertyChange(null, object)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction all(array) {\r\n\t\t// This is intended to mirror Promise.all. It actually takes\r\n\t\t// an iterable, but for now we are just looking for array-like\r\n\t\tif (array.length > -1) {\r\n\t\t\treturn new Composite(array)\r\n\t\t}\r\n\t\tif (arguments.length > 1) {\r\n\t\t\t// support multiple arguments as an array\r\n\t\t\treturn new Composite(arguments)\r\n\t\t}\r\n\t\tif (typeof array === 'object') {\r\n\t\t\t// allow an object as a hash to be mapped\r\n\t\t\tvar keyMapping = []\r\n\t\t\tvar valueArray = []\r\n\t\t\tfor (var key in array) {\r\n\t\t\t\tkeyMapping.push(key)\r\n\t\t\t\tvalueArray.push(array[key])\r\n\t\t\t}\r\n\t\t\treturn new Variable(function(results) {\r\n\t\t\t\tvar resultObject = {}\r\n\t\t\t\tfor (var i = 0; i < results.length; i++) {\r\n\t\t\t\t\tresultObject[keyMapping[i]] = results[i]\r\n\t\t\t\t}\r\n\t\t\t\treturn resultObject\r\n\t\t\t}).apply(null, valueArray)\r\n\t\t}\r\n\t\tthrow new TypeError('Variable.all requires an array')\r\n\t}\r\n\r\n\tfunction hasOwn(Target, createForInstance) {\r\n\t\tvar ownedClasses = this.ownedClasses || (this.ownedClasses = new WeakMap())\r\n\t\t// TODO: assign to super classes\r\n\t\tvar Class = this\r\n\t\townedClasses.set(Target, createForInstance || function() { return new Target() })\r\n\t\treturn this\r\n\t}\r\n\tfunction getForClass(subject, Target) {\r\n\t\tvar createInstance = subject.constructor.ownedClasses && subject.constructor.ownedClasses.get(Target)\r\n\t\tif (createInstance) {\r\n\t\t\tvar ownedInstances = subject.ownedInstances || (subject.ownedInstances = new WeakMap())\r\n\t\t\tvar instance = ownedInstances.get(Target)\r\n\t\t\tif (!instance) {\r\n\t\t\t\townedInstances.set(Target, instance = createInstance(subject))\r\n\t\t\t\tinstance.subject = subject\r\n\t\t\t}\r\n\t\t\treturn instance\r\n\t\t}\r\n\t}\r\n\tfunction generalizeClass() {\r\n\t\tvar prototype = this.prototype\r\n\t\tvar prototypeNames = Object.getOwnPropertyNames(prototype)\r\n\t\tfor(var i = 0, l = prototypeNames.length; i < l; i++) {\r\n\t\t\tvar name = prototypeNames[i]\r\n\t\t\tObject.defineProperty(this, name, getGeneralizedDescriptor(Object.getOwnPropertyDescriptor(prototype, name), name, this))\r\n\t\t}\r\n\t}\r\n\tfunction getGeneralizedDescriptor(descriptor, name, Class) {\r\n\t\tif (typeof descriptor.value === 'function') {\r\n\t\t\treturn {\r\n\t\t\t\tvalue: generalizeMethod(Class, name)\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\treturn descriptor\r\n\t\t}\r\n\t}\r\n\tfunction generalizeMethod(Class, name) {\r\n\t\t// I think we can just rely on `this`, but we could use the argument:\r\n\t\t// function(possibleEvent) {\r\n\t\t// \tvar target = possibleEvent && possibleEvent.target\r\n\t\tvar method = Class[name] = function() {\r\n\t\t\tvar instance = Class.for(this)\r\n\t\t\treturn instance[name].apply(instance, arguments)\r\n\t\t}\r\n\t\tmethod.for = function(context) {\r\n\t\t\tvar instance = Class.for(context)\r\n\t\t\treturn function() {\r\n\t\t\t\treturn instance[name].apply(instance, arguments)\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn method\r\n\t}\r\n\r\n\tvar defaultContext = {\r\n\t\tname: 'Default context',\r\n\t\tdescription: 'This object is the default context for classes, corresponding to a singleton instance of that class',\r\n\t\tconstructor: {\r\n\t\t\tgetForClass: function(subject, Class) {\r\n\t\t\t\treturn Class.defaultInstance\r\n\t\t\t}\r\n\t\t},\r\n\t\tcontains: function() {\r\n\t\t\treturn true // contains everything\r\n\t\t}\r\n\t}\r\n\tfunction instanceForContext(Class, context) {\r\n\t\tif (!context) {\r\n\t\t\tthrow new TypeError('Accessing a generalized class without context to resolve to an instance, call for(context) (where context is an element or related variable instance) on your variable first')\r\n\t\t}\r\n\t\tvar instance = context.subject.constructor.getForClass && context.subject.constructor.getForClass(context.subject, Class) || Class.defaultInstance\r\n\t\tcontext.distinctSubject = mergeSubject(context.distinctSubject, instance.subject)\r\n\t\treturn instance\r\n\t}\r\n\t// a variable inheritance change goes through its own prototype, so classes/constructor\r\n\t// can be used as variables as well\r\n\tfor (var key in VariablePrototype) {\r\n\t\tObject.defineProperty(Variable, key, Object.getOwnPropertyDescriptor(VariablePrototype, key))\r\n\t}\r\n\tVariable.valueOf = function(context) {\r\n\t\t// contextualized getValue\r\n\t\treturn instanceForContext(this, context).valueOf()\r\n\t}\r\n\tVariable.setValue = function(value, context) {\r\n\t\t// contextualized setValue\r\n\t\treturn instanceForContext(this, context).put(value)\r\n\t}\r\n\tVariable.getForClass = getForClass\r\n\tVariable.generalize = generalizeClass\r\n\tVariable.call = Function.prototype.call // restore these\r\n\tVariable.apply = Function.prototype.apply\r\n\tVariable.extend = function(properties) {\r\n\t\t// TODO: handle arguments\r\n\t\tvar Base = this\r\n\t\tfunction ExtendedVariable() {\r\n\t\t\tif (this instanceof ExtendedVariable) {\r\n\t\t\t\treturn Base.apply(this, arguments)\r\n\t\t\t} else {\r\n\t\t\t\treturn ExtendedVariable.extend(properties)\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar prototype = ExtendedVariable.prototype = Object.create(this.prototype)\r\n\t\tExtendedVariable.prototype.constructor = ExtendedVariable\r\n\t\tsetPrototypeOf(ExtendedVariable, this)\r\n\t\tfor (var key in properties) {\r\n\t\t\tvar descriptor = Object.getOwnPropertyDescriptor(properties, key)\r\n\t\t\tObject.defineProperty(prototype, key, descriptor)\r\n\t\t\tObject.defineProperty(ExtendedVariable, key, getGeneralizedDescriptor(descriptor, key, ExtendedVariable))\r\n\t\t}\r\n\t\tif (properties && properties.hasOwn) {\r\n\t\t\thasOwn.call(ExtendedVariable, properties.hasOwn)\r\n\t\t}\r\n\t\treturn ExtendedVariable\r\n\t}\r\n\tObject.defineProperty(Variable, 'defaultInstance', {\r\n\t\tget: function() {\r\n\t\t\treturn this.hasOwnProperty('_defaultInstance') ?\r\n\t\t\t\tthis._defaultInstance : (\r\n\t\t\t\t\tthis._defaultInstance = new this(),\r\n\t\t\t\t\tthis._defaultInstance.subject = defaultContext,\r\n\t\t\t\t\tthis._defaultInstance)\r\n\t\t}\r\n\t})\r\n\tVariable.hasOwn = hasOwn\r\n\tVariable.all = all\r\n\tVariable.objectUpdated = objectUpdated\r\n\tVariable.observe = function() {\r\n\t\tthrow new Error('Use variable.observeObject() instead')\r\n\t}\r\n\r\n\treturn Variable\r\n})\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./Variable.js\n ** module id = 2\n ** module chunks = 0\n **/","define([], function () {\r\n\tvar getPrototypeOf = Object.getPrototypeOf || (function(base) { return base.__proto__ })\r\n\tvar setPrototypeOf = Object.setPrototypeOf || (function(base, proto) { base.__proto__ = proto})\r\n\tvar hasFeatures = {\r\n\t\trequestAnimationFrame: typeof requestAnimationFrame != 'undefined',\r\n\t\tdefineProperty: Object.defineProperty && (function() {\r\n\t\t\ttry{\r\n\t\t\t\tObject.defineProperty({}, 't', {})\r\n\t\t\t\treturn true\r\n\t\t\t}catch(e) {\r\n\t\t\t}\r\n\t\t})(),\r\n\t\tpromise: typeof Promise !== 'undefined',\r\n\t\tMutationObserver: typeof MutationObserver !== 'undefined',\r\n\t\t'WeakMap': typeof WeakMap === 'function'\r\n\t}\r\n\tfunction has(feature) {\r\n\t\treturn hasFeatures[feature]\r\n\t}\r\n\t// This is an polyfill for Object.observe with just enough functionality\r\n\t// for what Variables need\r\n\t// An observe function, with polyfile\r\n\tvar observe =\r\n\t\thas('defineProperty') ? \r\n\t\tfunction observe(target, listener) {\r\n\t\t\t/*for(var i in target) {\r\n\t\t\t\taddKey(i)\r\n\t\t\t}*/\r\n\t\t\tlistener.addKey = addKey\r\n\t\t\tlistener.remove = function() {\r\n\t\t\t\tlistener = null\r\n\t\t\t}\r\n\t\t\treturn listener\r\n\t\t\tfunction addKey(key) {\r\n\t\t\t\tvar keyFlag = 'key' + key\r\n\t\t\t\tif(this[keyFlag]) {\r\n\t\t\t\t\treturn\r\n\t\t\t\t}else{\r\n\t\t\t\t\tthis[keyFlag] = true\r\n\t\t\t\t}\r\n\t\t\t\tvar currentValue = target[key]\r\n\t\t\t\tvar targetAncestor = target\r\n\t\t\t\tvar descriptor\r\n\t\t\t\tdo {\r\n\t\t\t\t\tdescriptor = Object.getOwnPropertyDescriptor(targetAncestor, key)\r\n\t\t\t\t} while(!descriptor && (targetAncestor = getPrototypeOf(targetAncestor)))\r\n\r\n\t\t\t\tif(descriptor && descriptor.set) {\r\n\t\t\t\t\tvar previousSet = descriptor.set\r\n\t\t\t\t\tvar previousGet = descriptor.get\r\n\t\t\t\t\tObject.defineProperty(target, key, {\r\n\t\t\t\t\t\tget: function() {\r\n\t\t\t\t\t\t\treturn (currentValue = previousGet.call(this))\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tset: function(value) {\r\n\t\t\t\t\t\t\tpreviousSet.call(this, value)\r\n\t\t\t\t\t\t\tif(currentValue !== value) {\r\n\t\t\t\t\t\t\t\tcurrentValue = value\r\n\t\t\t\t\t\t\t\tif(listener) {\r\n\t\t\t\t\t\t\t\t\tlistener([{target: this, name: key}])\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tenumerable: descriptor.enumerable\r\n\t\t\t\t\t})\r\n\t\t\t\t}else{\r\n\t\t\t\t\tObject.defineProperty(target, key, {\r\n\t\t\t\t\t\tget: function() {\r\n\t\t\t\t\t\t\treturn currentValue\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tset: function(value) {\r\n\t\t\t\t\t\t\tif(currentValue !== value) {\r\n\t\t\t\t\t\t\t\tcurrentValue = value\r\n\t\t\t\t\t\t\t\tif(listener) {\r\n\t\t\t\t\t\t\t\t\tlistener([{target: this, name: key}])\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tenumerable: !descriptor || descriptor.enumerable\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} :\r\n\t\t// and finally a polling-based solution, for the really old browsers\r\n\t\tfunction(target, listener) {\r\n\t\t\tif(!timerStarted) {\r\n\t\t\t\ttimerStarted = true\r\n\t\t\t\tsetInterval(function() {\r\n\t\t\t\t\tfor(var i = 0, l = watchedObjects.length; i < l; i++) {\r\n\t\t\t\t\t\tdiff(watchedCopies[i], watchedObjects[i], listeners[i])\r\n\t\t\t\t\t}\r\n\t\t\t\t}, 20)\r\n\t\t\t}\r\n\t\t\tvar copy = {}\r\n\t\t\tfor(var i in target) {\r\n\t\t\t\tif(target.hasOwnProperty(i)) {\r\n\t\t\t\t\tcopy[i] = target[i]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\twatchedObjects.push(target)\r\n\t\t\twatchedCopies.push(copy)\r\n\t\t\tlisteners.push(listener)\r\n\t\t}\r\n\tvar queuedListeners\r\n\tfunction queue(listener, object, name) {\r\n\t\tif(queuedListeners) {\r\n\t\t\tif(queuedListeners.indexOf(listener) === -1) {\r\n\t\t\t\tqueuedListeners.push(listener)\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\tqueuedListeners = [listener]\r\n\t\t\tlang.nextTurn(function() {\r\n\t\t\t\tqueuedListeners.forEach(function(listener) {\r\n\t\t\t\t\tvar events = []\r\n\t\t\t\t\tlistener.properties.forEach(function(property) {\r\n\t\t\t\t\t\tevents.push({target: listener.object, name: property})\r\n\t\t\t\t\t})\r\n\t\t\t\t\tlistener(events)\r\n\t\t\t\t\tlistener.object = null\r\n\t\t\t\t\tlistener.properties = null\r\n\t\t\t\t})\r\n\t\t\t\tqueuedListeners = null\r\n\t\t\t}, 0)\r\n\t\t}\r\n\t\tlistener.object = object\r\n\t\tvar properties = listener.properties || (listener.properties = [])\r\n\t\tif(properties.indexOf(name) === -1) {\r\n\t\t\tproperties.push(name)\r\n\t\t}\r\n\t}\r\n\tvar unobserve = has('observe') ? Object.unobserve :\r\n\t\tfunction(target, listener) {\r\n\t\t\tif(listener.remove) {\r\n\t\t\t\tlistener.remove()\r\n\t\t\t}\r\n\t\t\tfor(var i = 0, l = watchedObjects.length; i < l; i++) {\r\n\t\t\t\tif(watchedObjects[i] === target && listeners[i] === listener) {\r\n\t\t\t\t\twatchedObjects.splice(i, 1)\r\n\t\t\t\t\twatchedCopies.splice(i, 1)\r\n\t\t\t\t\tlisteners.splice(i, 1)\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\tvar watchedObjects = []\r\n\tvar watchedCopies = []\r\n\tvar listeners = []\r\n\tvar timerStarted = false\r\n\tfunction diff(previous, current, callback) {\r\n\t\t// TODO: keep an array of properties for each watch for faster iteration\r\n\t\tvar queued\r\n\t\tfor(var i in previous) {\r\n\t\t\tif(previous.hasOwnProperty(i) && previous[i] !== current[i]) {\r\n\t\t\t\t// a property has changed\r\n\t\t\t\tprevious[i] = current[i]\r\n\t\t\t\t(queued || (queued = [])).push({name: i})\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor(var i in current) {\r\n\t\t\tif(current.hasOwnProperty(i) && !previous.hasOwnProperty(i)) {\r\n\t\t\t\t// a property has been added\r\n\t\t\t\tprevious[i] = current[i]\r\n\t\t\t\t(queued || (queued = [])).push({name: i})\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(queued) {\r\n\t\t\tcallback(queued)\r\n\t\t}\r\n\t}\r\n\r\n\tvar id = 1\r\n\t// a function that returns a function, to stop JSON serialization of an\r\n\t// object\r\n\tfunction toJSONHidden() {\r\n\t\treturn toJSONHidden\r\n\t}\r\n\t// An object that will be hidden from JSON serialization\r\n\tvar Hidden = function () {\r\n\t}\r\n\tHidden.prototype.toJSON = toJSONHidden\r\n\r\n\tvar lang = {\r\n\t\trequestAnimationFrame: has('requestAnimationFrame') ? requestAnimationFrame :\r\n\t\t\t(function() {\r\n\t\t\t\tvar toRender = []\r\n\t\t\t\tvar queued = false\r\n\t\t\t\tfunction processAnimationFrame() {\r\n\t\t\t\t\tfor (var i = 0; i < toRender.length; i++) {\r\n\t\t\t\t\t\ttoRender[i]()\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttoRender = []\r\n\t\t\t\t\tqueued = false\r\n\t\t\t\t}\r\n\t\t\t\tfunction requestAnimationFrame(renderer) {\r\n\t\t\t\t \tif (!queued) {\r\n\t\t\t\t\t\tsetTimeout(processAnimationFrame)\r\n\t\t\t\t\t\tqueued = true\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttoRender.push(renderer)\r\n\t\t\t\t}\r\n\t\t\t\treturn requestAnimationFrame\r\n\t\t\t})(),\r\n\t\tPromise: has('promise') ? Promise : (function() {\r\n\t\t\tfunction Promise(execute) {\r\n\t\t\t\tvar isResolved, resolution, errorResolution\r\n\t\t\t\tvar queue = 0\r\n\t\t\t\tfunction resolve(value) {\r\n\t\t\t\t\t// resolve function\r\n\t\t\t\t\tif(value && value.then) {\r\n\t\t\t\t\t\t// received a promise, wait for it\r\n\t\t\t\t\t\tvalue.then(resolve, reject)\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tresolution = value\r\n\t\t\t\t\t\tfinished()\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tfunction reject(error) {\r\n\t\t\t\t\t// reject function\r\n\t\t\t\t\terrorResolution = error\r\n\t\t\t\t\tfinished()\r\n\t\t\t\t}\r\n\t\t\t\texecute(resolve, reject)\r\n\t\t\t\tfunction finished() {\r\n\t\t\t\t\tisResolved = true\r\n\t\t\t\t\tfor(var i = 0, l = queue.length; i < l; i++) {\r\n\t\t\t\t\t\tqueue[i]()\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// clean out the memory\r\n\t\t\t\t\tqueue = 0\r\n\t\t\t\t}\r\n\t\t\t\treturn {\r\n\t\t\t\t\tthen: function(callback, errback) {\r\n\t\t\t\t\t\treturn new Promise(function(resolve, reject) {\r\n\t\t\t\t\t\t\tfunction handle() {\r\n\t\t\t\t\t\t\t\t// promise fulfilled, call the appropriate callback\r\n\t\t\t\t\t\t\t\ttry{\r\n\t\t\t\t\t\t\t\t\tif(errorResolution && !errback) {\r\n\t\t\t\t\t\t\t\t\t\t// errors without a handler flow through\r\n\t\t\t\t\t\t\t\t\t\treject(errorResolution)\r\n\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t// resolve to the callback's result\r\n\t\t\t\t\t\t\t\t\t\tresolve(errorResolution ?\r\n\t\t\t\t\t\t\t\t\t\t\terrback(errorResolution) :\r\n\t\t\t\t\t\t\t\t\t\t\tcallback ?\r\n\t\t\t\t\t\t\t\t\t\t\t\tcallback(resolution) : resolution)\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}catch(newError) {\r\n\t\t\t\t\t\t\t\t\t// caught an error, reject the returned promise\r\n\t\t\t\t\t\t\t\t\treject(newError)\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif(isResolved) {\r\n\t\t\t\t\t\t\t\t// already resolved, immediately handle\r\n\t\t\t\t\t\t\t\thandle()\r\n\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t(queue || (queue = [])).push(handle)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn Promise\r\n\t\t}()),\r\n\r\n\t\tWeakMap: has('WeakMap') ? WeakMap :\r\n\t \tfunction (values, name) {\r\n\t \t\tvar mapProperty = '__' + (name || '') + id++\r\n\t \t\treturn has('defineProperty') ?\r\n\t \t\t{\r\n\t \t\t\tget: function (key) {\r\n\t \t\t\t\treturn key[mapProperty]\r\n\t \t\t\t},\r\n\t \t\t\tset: function (key, value) {\r\n\t \t\t\t\tObject.defineProperty(key, mapProperty, {\r\n\t \t\t\t\t\tvalue: value,\r\n\t \t\t\t\t\tenumerable: false\r\n\t \t\t\t\t})\r\n\t \t\t\t}\r\n\t \t\t} :\r\n\t \t\t{\r\n\t \t\t\tget: function (key) {\r\n\t \t\t\t\tvar intermediary = key[mapProperty]\r\n\t \t\t\t\treturn intermediary && intermediary.value\r\n\t \t\t\t},\r\n\t \t\t\tset: function (key, value) {\r\n\t \t\t\t\t// we use an intermediary that is hidden from JSON serialization, at least\r\n\t \t\t\t\tvar intermediary = key[mapProperty] || (key[mapProperty] = new Hidden())\r\n\t \t\t\t\tintermediary.value = value\r\n\t \t\t\t}\r\n\t \t\t}\r\n\t \t},\r\n\r\n\t\tobserve: observe,\r\n\t\tunobserve: unobserve,\r\n\t\twhen: function(value, callback, errorHandler) {\r\n\t\t\treturn value && value.then ?\r\n\t\t\t\t(value.then(callback, errorHandler) || value) : callback(value)\r\n\t\t},\r\n\t\twhenAll: function(inputs, callback) {\r\n\t\t\tvar promiseInvolved\r\n\t\t\tfor(var i = 0, l = inputs.length; i < l; i++) {\r\n\t\t\t\tif(inputs[i] && inputs[i].then) {\r\n\t\t\t\t\tpromiseInvolved = true\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(promiseInvolved) {\r\n\t\t\t\t// we have asynch inputs, do lazy loading\r\n\t\t\t\treturn {\r\n\t\t\t\t\tthen: function(onResolve, onError) {\r\n\t\t\t\t\t\tvar remaining = 1\r\n\t\t\t\t\t\tvar result\r\n\t\t\t\t\t\tvar readyInputs = []\r\n\t\t\t\t\t\tvar lastPromiseResult\r\n\t\t\t\t\t\tfor(var i = 0; i < inputs.length; i++) {\r\n\t\t\t\t\t\t\tvar input = inputs[i]\r\n\t\t\t\t\t\t\tremaining++\r\n\t\t\t\t\t\t\tif(input && input.then) {\r\n\t\t\t\t\t\t\t\t(function(i, previousPromiseResult) {\r\n\t\t\t\t\t\t\t\t\tlastPromiseResult = input.then(function(value) {\r\n\t\t\t\t\t\t\t\t\t\treadyInputs[i] = value\r\n\t\t\t\t\t\t\t\t\t\tonEach()\r\n\t\t\t\t\t\t\t\t\t\tif(!remaining) {\r\n\t\t\t\t\t\t\t\t\t\t\treturn result\r\n\t\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t\treturn previousPromiseResult\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}, onError)\r\n\t\t\t\t\t\t\t\t})(i, lastPromiseResult)\r\n\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\treadyInputs[i] = input\r\n\t\t\t\t\t\t\t\tonEach()\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tonEach()\r\n\t\t\t\t\t\tfunction onEach() {\r\n\t\t\t\t\t\t\tremaining--\r\n\t\t\t\t\t\t\tif(!remaining) {\r\n\t\t\t\t\t\t\t\tresult = onResolve(callback(readyInputs))\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn lastPromiseResult\r\n\t\t\t\t\t},\r\n\t\t\t\t\tinputs: inputs\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// just sync inputs\r\n\t\t\treturn callback(inputs)\r\n\r\n\t\t},\r\n\t\tcompose: function(Base, constructor, properties) {\r\n\t\t\tvar prototype = constructor.prototype = Object.create(Base.prototype)\r\n\t\t\tsetPrototypeOf(constructor, Base)\r\n\t\t\tfor(var i in properties) {\r\n\t\t\t\tprototype[i] = properties[i]\r\n\t\t\t}\r\n\t\t\tprototype.constructor = constructor\r\n\t\t\treturn constructor\r\n\t\t},\r\n\t\tnextTurn: has('MutationObserver') ?\r\n\t\t\tfunction (callback) {\r\n\t\t\t\t// promises don't resolve consistently on the next micro turn (Edge doesn't do it right),\r\n\t\t\t\t// so use mutation observer\r\n\t\t\t\t// TODO: make a faster mode that doesn't recreate each time\r\n\t\t\t\tvar div = document.createElement('div')\r\n\t\t\t\tvar observer = new MutationObserver(callback)\r\n\t\t\t\tobserver.observe(div, {\r\n\t\t\t\t\tattributes: true\r\n\t\t\t\t})\r\n\t\t\t\tdiv.setAttribute('a', id++)\r\n\t\t\t} :\r\n\t\t\tfunction (callback) {\r\n\t\t\t\t// TODO: we can do better for other, older browsers\r\n\t\t\t\tsetTimeout(callback, 0)\r\n\t\t\t},\r\n\t\tcopy: Object.assign || function(target, source) {\r\n\t\t\tfor(var i in source) {\r\n\t\t\t\ttarget[i] = source[i]\r\n\t\t\t}\r\n\t\t\treturn target\r\n\t\t}\r\n\t}\r\n\treturn lang\r\n})\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./util/lang.js\n ** module id = 3\n ** module chunks = 0\n **/","define(['./util/lang'], function (lang, Variable) {\r\n\tvar doc = typeof document !== 'undefined' && document\r\n\tvar invalidatedElements\r\n\tvar queued\r\n\tvar toRender = []\r\n\tvar nextId = 1\r\n\tvar requestAnimationFrame = lang.requestAnimationFrame\r\n\r\n\tfunction Context(subject){\r\n\t\tthis.subject = subject\r\n\t}\r\n\r\n\tfunction Renderer(options) {\r\n\t\tvar variable = options.variable\r\n\r\n\t\tthis.variable = variable\r\n\t\tthis.elements = []\r\n\t\tif (options) {\r\n\t\t\tif (options.selector) {\r\n\t\t\t\tthis.selector = options.selector\r\n\t\t\t}\r\n\t\t\tif (options.elements) {\r\n\t\t\t\tthis.elements = options.elements\r\n\t\t\t\tthis.element = this.elements[0]\r\n\t\t\t}\r\n\t\t\tif (options.element) {\r\n\t\t\t\tthis.element = options.element\r\n\t\t\t\tthis.elements.push(options.element)\r\n\t\t\t}\r\n\t\t\tfor(var i = 0, l = this.elements.length; i < l; i++) {\r\n\t\t\t\t(this.elements[i].alkaliRenderers || (this.elements[i].alkaliRenderers = [])).push(this)\r\n\t\t\t}\r\n\t\t\tif (options.update) {\r\n\t\t\t\tthis.updateRendering = options.update\r\n\t\t\t}\r\n\t\t\tif (options.shouldRender) {\r\n\t\t\t\tthis.shouldRender = options.shouldRender\r\n\t\t\t}\r\n\t\t\tif (options.renderUpdate) {\r\n\t\t\t\tthis.renderUpdate = options.renderUpdate\r\n\t\t\t}\r\n\t\t\tif (options.alwaysUpdate) {\r\n\t\t\t\tthis.alwaysUpdate = options.alwaysUpdate\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (variable.updated) {\r\n\t\t\t// if it has update, we don't need to instantiate a closure\r\n\t\t\tvariable.notifies(this)\r\n\t\t} else {\r\n\t\t\t// baconjs-esqe API\r\n\t\t\tvar renderer = this\r\n\t\t\tvariable.subscribe(function (event) {\r\n\t\t\t\t// replace the variable with an object\r\n\t\t\t\t// that returns the value from the event\r\n\t\t\t\trenderer.variable = {\r\n\t\t\t\t\tvalueOf: function () {\r\n\t\t\t\t\t\treturn event.value()\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\trenderer.updated()\r\n\t\t\t})\r\n\t\t}\r\n\t\tif(options && options.updateOnStart !== false){\r\n\t\t\tthis.updateRendering(true)\r\n\t\t}\r\n\t}\r\n\tRenderer.prototype = {\r\n\t\tconstructor: Renderer,\r\n\t\tupdateRendering: function () {\r\n\t\t\tthrow new Error ('updateRendering must be implemented by sub class of Renderer')\r\n\t\t},\r\n\t\tupdated: function (updateEvent, by, context) {\r\n\t\t\tif (!this.invalidated) {\r\n\t\t\t\tif (!context || this.contextMatches(context)) {\r\n\t\t\t\t\t// do this only once, until we render again\r\n\t\t\t\t\tthis.invalidated = true\r\n\t\t\t\t\tvar renderer = this\r\n\t\t\t\t\trequestAnimationFrame(function(){\r\n\t\t\t\t\t\tinvalidatedElements = null\r\n\t\t\t\t\t\trenderer.updateRendering(renderer.alwaysUpdate)\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tcontextMatches: function(context) {\r\n\t\t\treturn true\r\n\t\t\treturn context == this.elements ||\r\n\t\t\t\t// if context is any element in this.elements - perhaps return only the specific matching elements?\r\n\t\t\t\t(this.elements.indexOf(context) != -1) ||\r\n\t\t\t  // (context is an array and any/all elements are contained in this.elements) ||\r\n\t\t\t\t// context contains() any of this.elements\r\n\t\t\t\t(function(elements) {\r\n\t\t\t\t\tfor(var i = 0, l = elements.length; i < l; i++) {\r\n\t\t\t\t\t\tif (context.contains(elements[i])) return true\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn false\r\n\t\t\t\t})(this.elements)\r\n\t\t},\r\n\t\tinvalidateElement: function(element) {\r\n\t\t\tif(!invalidatedElements){\r\n\t\t\t\tinvalidatedElements = new WeakMap(null, 'invalidated')\r\n\t\t\t\t// TODO: if this is not a real weak map, we don't want to GC it, or it will leak\r\n\t\t\t}\r\n\t\t\tvar invalidatedParts = invalidatedElements.get(element)\r\n\t\t\tinvalidatedElements.set(element, invalidatedParts = {})\r\n\t\t\tif (!invalidatedParts[id]) {\r\n\t\t\t\tinvalidatedParts[id] = true\r\n\t\t\t}\r\n\t\t\tif (!queued) {\r\n\t\t\t\tlang.queueTask(processQueue)\r\n\t\t\t\tqueued = true\r\n\t\t\t}\r\n\t\t\tvar renderer = this\r\n\t\t\ttoRender.push(function(){\r\n\t\t\t\trenderer.invalidated = false\r\n\t\t\t\trenderer.updateElement(element)\r\n\t\t\t})\r\n\t\t},\r\n\t\tgetId: function(){\r\n\t\t\treturn this.id || (this.id = nextId++)\r\n\t\t},\r\n\t\tstop: function() {\r\n\t\t\tthis.variable.stopNotifies(this)\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction ElementRenderer(options) {\r\n\t\tRenderer.call(this, options)\r\n\t}\r\n\tElementRenderer.prototype = Object.create(Renderer.prototype)\r\n\tElementRenderer.prototype.shouldRender = function (element) {\r\n\t\treturn document.body.contains(element)\r\n\t}\r\n\tElementRenderer.prototype.getSubject = function () {\r\n\t\treturn this.element || this.elements[0]\r\n\t}\r\n\tElementRenderer.prototype.updateRendering = function (always, element) {\r\n\t\tvar elements = this.elements || (element && [element]) || []\r\n\t\tif(!elements.length){\r\n\t\t\tif(this.selector){\r\n\t\t\t\telements = document.querySelectorAll(this.selector)\r\n\t\t\t}else{\r\n\t\t\t\tthrow new Error('No element or selector was provided to the Renderer')\r\n\t\t\t}\r\n\t\t\treturn\r\n\t\t}\r\n\t\tfor(var i = 0, l = elements.length; i < l; i++){\r\n\t\t\tif(always || this.shouldRender(elements[i])){\r\n\t\t\t\t// it is connected\r\n\t\t\t\tthis.updateElement(elements[i])\r\n\t\t\t}else{\r\n\t\t\t\tvar id = this.getId()\r\n\t\t\t\tvar renderers = elements[i].renderersOnShow\r\n\t\t\t\tif(!renderers){\r\n\t\t\t\t\trenderers = elements[i].renderersOnShow = []\r\n\t\t\t\t\telements[i].className += ' needs-rerendering'\r\n\t\t\t\t}\r\n\t\t\t\tif (!renderers[id]) {\r\n\t\t\t\t\trenderers[id] = this\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tElementRenderer.prototype.addElement = function (element) {\r\n\t\tif (this.selector) {\r\n\t\t\telement.renderersOnShow = [this]\r\n\t\t} else {\r\n\t\t\tthis.elements.push(element)\r\n\t\t}\r\n\t\t// and immediately do an update\r\n\t\tthis.updateElement(element)\r\n\t}\r\n\tElementRenderer.prototype.updateElement = function(element) {\r\n\t\tthis.invalidated = false\r\n\t\ttry {\r\n\t\t\t// TODO: might make something cheaper than for(element) for setting context?\r\n\t\t\tvar value = !this.omitValueOf && this.variable.valueOf(new Context(element))\r\n\t\t} catch (error) {\r\n\t\t\telement.appendChild(document.createTextNode(error))\r\n\t\t}\r\n\t\tif(value !== undefined || this.started){\r\n\t\t\tthis.started = true\r\n\t\t\tif(value && value.then){\r\n\t\t\t\tif(this.renderLoading){\r\n\t\t\t\t\tthis.renderLoading(value, element)\r\n\t\t\t\t}\r\n\t\t\t\tvar renderer = this\r\n\t\t\t\tvalue.then(function (value) {\r\n\t\t\t\t\trenderer.renderUpdate(value, element)\r\n\t\t\t\t})\r\n\t\t\t}else{\r\n\t\t\t\tthis.renderUpdate(value, element)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tElementRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\tthrow new Error('renderUpdate(newValue) must be implemented')\r\n\t}\r\n\tRenderer.Renderer = Renderer\r\n\tRenderer.ElementRenderer = ElementRenderer\r\n\r\n\tfunction AttributeRenderer(options) {\r\n\t\tif(options.name){\r\n\t\t\tthis.name = options.name\r\n\t\t}\r\n\t\tElementRenderer.apply(this, arguments)\r\n\t}\r\n\tAttributeRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\tAttributeRenderer.prototype.type = 'AttributeRenderer'\r\n\tAttributeRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\telement.setAttribute(this.name, newValue)\r\n\t}\r\n\tRenderer.AttributeRenderer = AttributeRenderer\r\n\r\n\tfunction PropertyRenderer(options) {\r\n\t\tif (options.name) {\r\n\t\t\tthis.name = options.name\r\n\t\t}\r\n\t\tElementRenderer.apply(this, arguments)\r\n\t}\r\n\tPropertyRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\tPropertyRenderer.prototype.type = 'PropertyRenderer'\r\n\tPropertyRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\telement[this.name] = newValue\r\n\t}\r\n\tRenderer.PropertyRenderer = PropertyRenderer\r\n\r\n\tfunction InputPropertyRenderer(options) {\r\n\t\tif (options.element && options.element.tagName === 'SELECT' && options.name === 'value') {\r\n\t\t\t// use the deferred value assignment for <select>\r\n\t\t\tthis.renderUpdate = this.renderSelectValueUpdate\r\n\t\t}\r\n\t\tPropertyRenderer.apply(this, arguments)\r\n\t}\r\n\tInputPropertyRenderer.prototype = Object.create(PropertyRenderer.prototype)\r\n\tInputPropertyRenderer.prototype.type = 'InputPropertyRenderer'\r\n\tInputPropertyRenderer.prototype.renderUpdate = function(newValue, element) {\r\n\t\tif (element.type === 'number') {\r\n\t\t\tif (isNaN(newValue)) {\r\n\t\t\t\tnewValue = ''\r\n\t\t\t}\r\n\t\t}\r\n\t\telement[this.name] = newValue\r\n\t}\r\n\tInputPropertyRenderer.prototype.renderSelectValueUpdate = function (newValue, element) {\r\n\t\telement.value = newValue\r\n\t\tif (element.value != newValue && !element.value) {\r\n\t\t\t// if we didn't successfully set the value of a <select>, we may need to wait until the children are constructed\r\n\t\t\telement.eventualValue = newValue\r\n\t\t\tlang.nextTurn(function() {\r\n\t\t\t\tif (element.eventualValue) {\r\n\t\t\t\t\telement.value = element.eventualValue\r\n\t\t\t\t\telement.eventualValue = undefined\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t} else {\r\n\t\t\telement.eventualValue = undefined\r\n\t\t}\r\n\t}\r\n\tRenderer.InputPropertyRenderer = InputPropertyRenderer\r\n\r\n\tfunction StyleRenderer(options) {\r\n\t\tif(options.name){\r\n\t\t\tthis.name = options.name\r\n\t\t}\r\n\t\tElementRenderer.apply(this, arguments)\r\n\t}\r\n\tStyleRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\tStyleRenderer.prototype.type = 'StyleRenderer'\r\n\tStyleRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\telement.style[this.name] = newValue\r\n\t}\r\n\tRenderer.StyleRenderer = StyleRenderer\r\n\r\n\tfunction ContentRenderer(options) {\r\n\t\tElementRenderer.apply(this, arguments)\r\n\t}\r\n\tContentRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\tContentRenderer.prototype.type = 'ContentRenderer'\r\n\tContentRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\telement.innerHTML = ''\r\n\t\tif (newValue === undefined){\r\n\t\t\tnewValue = ''\r\n\t\t}\r\n\t\telement.appendChild(document.createTextNode(newValue))\r\n\t}\r\n\tRenderer.ContentRenderer = ContentRenderer\r\n\r\n\tfunction TextRenderer(options) {\r\n\t\tthis.position = options.position\r\n\t\tthis.textNode = options.textNode\r\n\t\tElementRenderer.apply(this, arguments)\r\n\t}\r\n\tTextRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\tTextRenderer.prototype.type = 'TextRenderer'\r\n\tTextRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\tif (newValue == null){\r\n\t\t\tnewValue = ''\r\n\t\t} else if (newValue.nodeType) {\r\n\t\t\tif (this.textNode && this.textNode.parentNode == element) {\r\n\t\t\t\t// text node is attached, we can replace it with the node\r\n\t\t\t\telement.replaceChild(newValue, this.textNode)\r\n\t\t\t} else {\r\n\t\t\t\telement.appendChild(newValue)\r\n\t\t\t}\r\n\t\t\tthis.textNode = newValue\r\n\t\t\treturn\r\n\t\t}\r\n\t\t(this.textNode || element.childNodes[this.position]).nodeValue = newValue\r\n\t}\r\n\tRenderer.TextRenderer = TextRenderer\r\n\r\n\tfunction ListRenderer(options) {\r\n\t\tif (options.each) {\r\n\t\t\tthis.each = options.each\r\n\t\t}\r\n\t\tElementRenderer.apply(this, arguments)\r\n\t}\r\n\tListRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\tListRenderer.prototype.updated = function (updateEvent, context) {\r\n\t\t(this.updates || (this.updates = [])).push(updateEvent)\r\n\t\tElementRenderer.prototype.updated.call(this, updateEvent, context)\r\n\t}\r\n\tListRenderer.prototype.type = 'ListRenderer'\r\n\tListRenderer.prototype.omitValueOf = true\r\n\tListRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\tvar container\r\n\t\tvar each = this.each\r\n\t\tvar thisElement = this.elements[0]\r\n\t\tvar renderer = this\r\n\t\tif (!this.builtList) {\r\n\t\t\tthis.builtList = true\r\n\t\t\tcontainer = document.createDocumentFragment()\r\n\t\t\tvar childElements = this.childElements = []\r\n\t\t\tthis.variable.for(thisElement).forEach(function(item) {\r\n\t\t\t\teachItem(item)\r\n\t\t\t})\r\n\t\t\tthis.element.appendChild(container)\r\n\t\t} else {\r\n\t\t\tvar childElements = this.childElements\r\n\t\t\tvar updates = this.updates\r\n\t\t\tcontainer = this.element\r\n\t\t\tupdates.forEach(function(update) {\r\n\t\t\t\tif (update.type === 'refresh') {\r\n\t\t\t\t\trenderer.builtList = false\r\n\t\t\t\t\tfor (var i = 0, l = childElements.length; i < l; i++) {\r\n\t\t\t\t\t\tthisElement.removeChild(childElements[i])\r\n\t\t\t\t\t}\r\n\t\t\t\t\trenderer.renderUpdate()\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (update.previousIndex > -1) {\r\n\t\t\t\t\t\tthisElement.removeChild(childElements[update.previousIndex])\r\n\t\t\t\t\t\tchildElements.splice(update.previousIndex, 1)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (update.index > -1) {\r\n\t\t\t\t\t\tvar nextChild = childElements[update.index] || null\r\n\t\t\t\t\t\teachItem(update.value, update.index, nextChild)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\tthis.updates = [] // clear the updates\r\n\t\t}\r\n\t\tfunction eachItem(item, index, nextChild) {\r\n\t\t\tvar childElement\r\n\t\t\tif (each.create) {\r\n\t\t\t\tchildElement = each.create({parent: thisElement, _item: item}) // TODO: make a faster object here potentially\r\n\t\t\t} else {\r\n\t\t\t\tchildElement = each(item, thisElement)\r\n\t\t\t}\r\n\t\t\tif (nextChild) {\r\n\t\t\t\tcontainer.insertBefore(childElement, nextChild)\r\n\t\t\t\tchildElements.splice(index, 0, childElement)\r\n\t\t\t} else {\r\n\t\t\t\tcontainer.appendChild(childElement)\r\n\t\t\t\tchildElements.push(childElement)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tRenderer.ListRenderer = ListRenderer\r\n\r\n\tRenderer.onShowElement = function(shownElement){\r\n\t\trequestAnimationFrame(function(){\r\n\t\t\tinvalidatedElements = null\r\n\t\t\tvar elements = [].slice.call(shownElement.getElementsByClassName('needs-rerendering'))\r\n\t\t\tif (shownElement.className.indexOf('needs-rerendering') > 0){\r\n\t\t\t\tvar includingTop = [shownElement]\r\n\t\t\t\tincludingTop.push.apply(includingTop, elements)\r\n\t\t\t\telements = includingTop\r\n\t\t\t}\r\n\t\t\tfor (var i = 0, l = elements.length; i < l; i++){\r\n\t\t\t\tvar element = elements[i]\r\n\t\t\t\tvar renderers = element.renderersOnShow\r\n\t\t\t\tif(renderers){\r\n\t\t\t\t\telement.renderersOnShow = null\r\n\t\t\t\t\t// remove needs-rerendering class\r\n\t\t\t\t\telement.className = element.className.replace(/\\s?needs\\-rerendering\\s?/g, '')\r\n\t\t\t\t\tfor (var id in renderers) {\r\n\t\t\t\t\t\tvar renderer = renderers[id]\r\n\t\t\t\t\t\trenderer.updateElement(element)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n\r\n\tfunction onElementRemoval(element){\r\n\t\t// cleanup element renderers\r\n\t\tif(element.alkaliRenderers){\r\n\t\t\tvar renderers = element.alkaliRenderers\r\n\t\t\tfor(var i = 0; i < renderers.length; i++){\r\n\t\t\t\tvar renderer = renderers[i]\r\n\t\t\t\trenderer.variable.stopNotifies(renderer)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tRenderer.onElementRemoval = function(element, onlyChildren){\r\n\t\tif(!onlyChildren){\r\n\t\t\tonElementRemoval(element)\r\n\t\t}\r\n\t\tvar children = element.getElementsByTagName('*')\r\n\t\tfor(var i = 0, l = children.length; i < l; i++){\r\n\t\t\tvar child = children[i]\r\n\t\t\tif(child.alkaliRenderers){\r\n\t\t\t\tonElementRemoval(child)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn Renderer\r\n})\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./Renderer.js\n ** module id = 4\n ** module chunks = 0\n **/","define(['./util/lang', './Variable', './operators'], function (lang, Variable, operators) {\r\n\r\n\tfunction react(generator, options) {\r\n    if (typeof generator !== 'function') {\r\n      throw new Error('react() must be called with a generator. You need to use the babel-plugin-transform-alkali plugin if you want to use reactive expressions')\r\n    }\r\n\t\tif (options && options.reverse) {\r\n\t\t\tgenerator.reverse = options.reverse\r\n\t\t}\r\n\t\treturn new Variable.GeneratorVariable(generator)\r\n\t}\r\n  Object.assign(react, operators)\r\n  react.from = function(value) {\r\n    if (value && value.notifies) {\r\n      return value\r\n    }\r\n    return new Variable(value)\r\n  }\r\n  react.prop = function(object, property) {\r\n    if (object) {\r\n      var value = object[property]\r\n      if (value !== undefined || !object.property) {\r\n        return value\r\n      } else {\r\n        return object.property(property)\r\n      }\r\n    }\r\n    return object\r\n  }\r\n  react.cond = function(test, consequent, alternate) {\r\n    return operators.if(test, operators.choose(consequent, alternate))\r\n  }\r\n  react.fcall = function(target, args) {\r\n    return new Variable.Call(target, args)\r\n  }\r\n  react.mcall = function(target, key, args) {\r\n    return new Variable.Call(target[key].bind(target), args)\r\n  }\r\n\treturn react\r\n})\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./react.js\n ** module id = 5\n ** module chunks = 0\n **/","define(['./Variable'], function (Variable) {\r\n\tvar deny = Variable.deny;\r\n\tvar operatingFunctions = {};\r\n\tvar operators = {};\r\n\tfunction getOperatingFunction(expression){\r\n\t\t// jshint evil: true\r\n\t\treturn operatingFunctions[expression] ||\r\n\t\t\t(operatingFunctions[expression] =\r\n\t\t\t\tnew Function('a', 'b', 'deny', 'return ' + expression));\r\n\t}\r\n\tfunction operator(operator, name, precedence, forward, reverseA, reverseB){\r\n\t\t// defines the standard operators\r\n\t\tvar reverse = function(output, inputs){\r\n\t\t\tvar a = inputs[0],\r\n\t\t\t\tb = inputs[1];\r\n\t\t\tif(a && a.put){\r\n\t\t\t\tvar result = reverseA(output, b && b.valueOf());\r\n\t\t\t\tif(result !== deny){\r\n\t\t\t\t\ta.put(result);\r\n\t\t\t\t}\r\n\t\t\t}else if(b && b.put){\r\n\t\t\t\tb.put(reverseB(output, a && a.valueOf()));\r\n\t\t\t}else{\r\n\t\t\t\treturn deny;\r\n\t\t\t}\r\n\t\t};\r\n\t\t// define a function that can lazily ensure the operating function\r\n\t\t// is available\r\n\t\tvar operatorHandler = {\r\n\t\t\tapply: function(instance, args){\r\n\t\t\t\tforward = getOperatingFunction(forward);\r\n\t\t\t\treverseA = reverseA && getOperatingFunction(reverseA);\r\n\t\t\t\treverseB = reverseB && getOperatingFunction(reverseB);\r\n\t\t\t\tforward.reverse = reverse;\r\n\t\t\t\toperators[operator] = operatorHandler = new Variable(forward);\r\n\r\n\t\t\t\taddFlags(operatorHandler);\r\n\t\t\t\targs = Array.prototype.slice.call(args);\r\n\t\t\t\targs.push(deny)\r\n\t\t\t\treturn operatorHandler.apply(instance, args);\r\n\t\t\t}\r\n\t\t};\r\n\t\tfunction addFlags(operatorHandler){\r\n\t\t\toperatorHandler.precedence = precedence;\r\n\t\t\toperatorHandler.infix = reverseB !== false;\r\n\t\t}\r\n\t\taddFlags(operatorHandler);\r\n\t\toperators[operator] = operatorHandler;\r\n\t\toperators[name] = function() {\r\n\t\t\treturn operatorHandler.apply(null, arguments)\r\n\t\t}\r\n\t}\r\n\t// using order precedence from:\r\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence\r\n\toperator('+', 'add', 6, 'a+b', 'a-b', 'a-b');\r\n\toperator('-', 'subtract', 6, 'a-b', 'a+b', 'b-a');\r\n\toperator('*', 'multiply', 5, 'a*b', 'a/b', 'a/b');\r\n\toperator('/', 'divide', 5, 'a/b', 'a*b', 'b/a');\r\n//\toperator('^', 7, 'a^b', 'a^(-b)', 'Math.log(a)/Math.log(b)');\r\n\toperator('?', 'if', 16, 'b[a?0:1]', 'a===b[0]||(a===b[1]?false:deny)', '[a,b]');\r\n\toperator(':', 'choose', 15, '[a,b]', 'a[0]?a[1]:deny', 'a[1]');\r\n\toperator('!', 'not', 4, '!a', '!a', false);\r\n\toperator('%', 'remainder', 5, 'a%b');\r\n\toperator('>', 'greater', 8, 'a>b');\r\n\toperator('>=', 'greaterOrEqual', 8, 'a>=b');\r\n\toperator('<', 'less', 8, 'a<b');\r\n\toperator('<=', 'lessOrEqual', 8, 'a<=b');\r\n\toperator('==', 'equal', 9, 'a===b');\r\n\toperator('&', 'and', 8, 'a&&b');\r\n\toperator('|', 'or', 8, 'a||b');\r\n\toperator('round', 'round', 8, 'Math.round(a*Math.pow(10,b||1))/Math.pow(10,b||1)', 'a', 'a');\r\n\treturn operators;\r\n})\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./operators.js\n ** module id = 6\n ** module chunks = 0\n **/","define(['./util/lang', './Variable'], function (lang, Variable) {\r\n\r\n\tfunction deepCopy(source, target, derivativeMap) {\r\n\t\tif (source && typeof source == 'object') {\r\n\t\t\tif (source instanceof Array) {\r\n\t\t\t\ttarget = [] // always create a new array for array targets\r\n\t\t\t\tfor(var i = 0, l = source.length; i < l; i++) {\r\n\t\t\t\t\ttarget[i] = deepCopy(source[i], null, derivativeMap)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (!target || typeof target !== 'object') {\r\n\t\t\t\t\ttarget = derivativeMap && derivativeMap.get(source)\r\n\t\t\t\t\tif (!target) {\r\n\t\t\t\t\t\ttarget = {}\r\n\t\t\t\t\t\tderivativeMap && derivativeMap.set(source, target)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tfor (var i in source) {\r\n\t\t\t\t\ttarget[i] = deepCopy(source[i], target[i], derivativeMap)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn target\r\n\t\t}\r\n\t\treturn source\r\n\t}\r\n\r\n\tvar Copy = lang.compose(Variable, function(copiedFrom) {\r\n\t\t// this is the variable that we derive from\r\n\t\tthis.copiedFrom = copiedFrom\r\n\t\tthis.derivativeMap = new lang.WeakMap(null, 'derivative')\r\n\t\tthis.isDirty = new Variable(false)\r\n\t}, {\r\n\t\tvalueOf: function(context) {\r\n\t\t\tif(this.state) {\r\n\t\t\t\tthis.state = null\r\n\t\t\t}\r\n\t\t\tvar value = this.copiedFrom.valueOf(context)\r\n\t\t\tif(value && typeof value == 'object') {\r\n\t\t\t\tvar derivative = this.derivativeMap.get(value)\r\n\t\t\t\tif (derivative == null) {\r\n\t\t\t\t\tthis.derivativeMap.set(value, derivative = deepCopy(value, undefined, this.derivativeMap))\r\n\t\t\t\t\tthis.setValue(derivative, context)\r\n\t\t\t\t}\r\n\t\t\t\treturn derivative\r\n\t\t\t}\r\n\t\t\tvar thisValue = this.getValue(context)\r\n\t\t\tif(thisValue === undefined) {\r\n\t\t\t\treturn value\r\n\t\t\t}\r\n\t\t\treturn thisValue\r\n\t\t},\r\n\t\tgetCopyOf: function(value) {\r\n\t\t\tvar derivative = this.derivativeMap.get(value)\r\n\t\t\tif (derivative == null) {\r\n\t\t\t\tthis.derivativeMap.set(value, derivative = deepCopy(value, undefined, this.derivativeMap))\r\n\t\t\t}\r\n\t\t\treturn derivative\r\n\t\t},\r\n\t\tsave: function() {\r\n\t\t\t// copy back to the original object\r\n\t\t\tvar original = this.copiedFrom.valueOf()\r\n\t\t\tvar newCopiedFrom = deepCopy(this.valueOf(), original)\r\n\t\t\tif (original !== newCopiedFrom) {\r\n\t\t\t\t// if we have replaced it with a new object/value, put it\r\n\t\t\t\tthis.copiedFrom.put && this.copiedFrom.put(newCopiedFrom)\r\n\t\t\t} else {\r\n\t\t\t\t// else we have modified an existing object, but we still need to notify\r\n\t\t\t\tif (this.copiedFrom.notifies && this.copiedFrom.updated) { // copiedFrom doesn't have to be a variable, it can be a plain object\r\n\t\t\t\t\tthis.copiedFrom.updated()\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.isDirty.put(false)\r\n\t\t\tthis.onSave && this.onSave()\r\n\t\t},\r\n\t\trevert: function() {\r\n\t\t\tvar original = this.copiedFrom.valueOf()\r\n\t\t\tthis.put(deepCopy(original, this.derivativeMap.get(original), this.derivativeMap))\r\n\t\t\tthis.isDirty.put(false)\r\n\t\t},\r\n\t\tupdated: function() {\r\n\t\t\tthis.isDirty.put(true)\r\n\t\t\treturn Variable.prototype.updated.apply(this, arguments)\r\n\t\t}\r\n\t})\r\n\treturn Copy\r\n})\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./Copy.js\n ** module id = 7\n ** module chunks = 0\n **/"],"sourceRoot":""}